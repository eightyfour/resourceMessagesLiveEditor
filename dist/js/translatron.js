(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

/**
 * Error constants
 *
 * @type {{PROJECT_NOT_EXISTS: number, INVALID_URL: number, NO_PERMISSION: number}}
 */
module.exports = {
  PROJECT_NOT_EXISTS: 'PROJECT_NOT_EXISTS',
  VALIDATION: 'VALIDATION',
  NO_PERMISSION: 'NO_PERMISSION'
};

},{}],2:[function(require,module,exports){
'use strict';

var C = {
    FILE_MANAGER: {
        FILE_TYPES: {
            IMAGE: 'image',
            FILE: 'file'
        },
        ENCODING: {
            image: 'base64',
            file: 'utf8'
        }
    },
    SESSION: {
        renewal_interval_in_ms: 1000 * 15
    }
};

module.exports = C;

},{}],3:[function(require,module,exports){
'use strict';

/**
 * TODO fade out when maxLengthOfMessages exceeded looks not so nice
 * @param id
 * @return {Object}
 * @constructor
 */
var toast = new function Toast(id) {
    var DELAY = 4000,
        opacityFadeSteps = 0.04,
        maxLengthOfMessages = 4,
        toastNode = document.getElementById(id),
        isReadyForStartAgain = true,
        newMessage = true,
        initToast = function initToast() {
        var rootNode = document.getElementsByTagName('body')[0];
        toastNode = document.createElement('div');
        toastNode.id = id;
        toastNode.style.cssText = "position:fixed;z-index:999;top:4.5em;right:2em;border-radius:5px;color:#fff;font-size:1.2em;font-weight:bold;background-color:rgba(63,143,251,0.9);padding: 1em 0.5em; box-sizing: border-box; max-width: 50%; text-align: center; word-wrap: break-word; break-word: break-all;";
        rootNode.appendChild(toastNode);
    },
        toast = {
        fadeOut: function fadeOut(_node, _done) {
            var node = _node;
            var done = _done;
            var opacity = 1;
            (function decrementOpacity() {
                if (opacity > opacityFadeSteps) {
                    opacity = opacity - opacityFadeSteps;
                    node.style.opacity = opacity;
                    setTimeout(function () {
                        decrementOpacity();
                    }, 40);
                } else {
                    console.log('PARENT NODE:');
                    console.log(node);
                    console.log(node.parentNode);
                    if (node.parentNode != null) {
                        node.parentNode.removeChild(node);
                    }
                    done();
                }
            })();
        },
        showMessage: function showMessage(msg) {
            if (!toastNode) {
                initToast();
            }
            toastNode.style.opacity = 1;
            var p = document.createElement('p');
            p.style.cssText = "padding:0px 10px";
            p.innerHTML = msg;
            toastNode.insertBefore(p, toastNode.firstChild);
            (function fadeOutToMuchMessages() {
                if (toastNode.childNodes.length > maxLengthOfMessages) {
                    toast.fadeOut(toastNode.children[toastNode.children.length - 1], function () {
                        fadeOutToMuchMessages();
                    });
                }
            })();
            var timeOut = DELAY;
            newMessage = true;
            function fadeOut(_fc) {
                var fc = _fc;
                var opacity = toastNode.style.opacity;
                if (opacity > opacityFadeSteps) {
                    if (newMessage) {
                        // resetMessage
                        newMessage = false;
                        timeOut = DELAY;
                        toastNode.style.opacity = 1;
                    } else {
                        opacity = opacity - opacityFadeSteps;
                        toastNode.style.opacity = opacity;
                        timeOut = 40;
                    }
                    // start timer
                    setTimeout(function () {
                        fadeOut(fc);
                    }, timeOut);
                } else {
                    while (toastNode.firstChild) {
                        toastNode.removeChild(toastNode.firstChild);
                    }
                    toastNode.style.opacity = 0;
                    // callback
                    fc(true);
                }
            }
            if (isReadyForStartAgain) {
                isReadyForStartAgain = false;
                timeOut = DELAY;
                fadeOut(function (_b) {
                    isReadyForStartAgain = true;
                });
            }
        }
    };
    return toast;
}('toast');

if (typeof module != "undefined") {
    console.log('exports');
    module.exports = toast;
} else {
    console.log('asign to global scope');
    window.toast = toast;
}

},{}],4:[function(require,module,exports){
'use strict';

/**
 * controller for the image uplaoder view - calls the server to upload a image and notifier the ui event handler
 * @type {{}}
 */
var canny = require('canny'),
    JMBFUploader = canny.JMBFUploader,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;
/**
 * Call this for each file - will call a call back with the server answer
 * @param file
 */
function sendFile(file, directCallback) {
    var uri = '/uploadJMBFFile?projectId=' + projectInfo.id + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        var data;
        if (xhr.readyState == 4 && xhr.status == 200) {
            // Handle response.
            data = JSON.parse(xhr.responseText);
            directCallback && directCallback(data); // handle response.
            // {file: "//sub/sub1/sub1_blue_coke.jpg", name: "sub1_blue_coke.jpg", type: "image/jpg"}
            console.log(data);
            uiEvents.callUievent('JMBFFileUploaded', projectInfo.id, uploadId, data.name);
        } else if (xhr.readyState == 4 && xhr.status === 406) {
            toast.showMessage('Upload failure. The file language is not supported');
        }
    };
    fd.append('myFile', file);
    // Initiate a multipart/form-data upload
    xhr.send(fd);
}

/**
 * Save data in member variable used by further upload operations
 * @param data: Project data
 */
function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showJMBFUploader: function showJMBFUploader(id) {
        displayManager.show('JMBFUploaderView');
    }
});

JMBFUploader.onUpload(function (file) {
    // TODO additional to the upload id we need the project ID
    console.log('uploadController:upload id: file:', uploadId, file);
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":23,"canny":52}],5:[function(require,module,exports){
'use strict';

var canny = require('canny'),
    JsonImport = canny.JsonImport,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;

function sendFile(file) {
    var uri = '/importJSON?projectId=' + projectInfo.id + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            var data = JSON.parse(xhr.responseText);
            if (xhr.status == 200) {
                // data.name does not exist - and is also not used, is it ?
                uiEvents.callUievent('jsonImported', projectInfo.id, uploadId, data.name);
            } else if (xhr.status === 406) {
                toast.showMessage('Upload failure. There is an error:<br />' + data.msg);
            }
        }
    };
    fd.append('myFile', file);
    xhr.send(fd);
}

function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showJSONImport: function showJSONImport(id) {
        displayManager.show('JSONImportView');
    }
});

JsonImport.onUpload(function (file) {
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":23,"canny":52}],6:[function(require,module,exports){
'use strict';

var async = require('canny/mod/async'),
    auth = require('canny').auth;

auth.onLogout(function () {
    async.doAjax({
        path: '/logout',
        onSuccess: function onSuccess(response) {
            location.reload();
        }
    });
});

module.exports = {};

},{"canny":52,"canny/mod/async":53}],7:[function(require,module,exports){
'use strict';

var breadcrumb = require('../uiModules/breadcrumb'),
    canny = require('canny'),
    trade = require('../trade'),
    uiEvents = require('../uiEventManager');

canny.add('breadcrumb', breadcrumb);

breadcrumb.onClick(function (directoryId) {
    trade.getDirectory(directoryId, function (err) {
        if (err !== false) {
            // TODO call the
            uiEvents.callUievent('showOverviewPage');
        } else {
            console.log('breadcrumbController:getDirectory can not load project for directory name:', directoryId);
        }
    });
});

module.exports = {
    setPath: function setPath(url) {
        var path = '/';
        if (url === '/') return breadcrumb.updateFolders([{ id: '/', name: '' }]);

        breadcrumb.updateFolders(url.split('/').map(function (folder) {
            path = path[path.length - 1] !== '/' ? path + '/' + folder : path + folder;
            return {
                id: path, name: folder
            };
        }));
    },
    getDirectory: function getDirectory(data) {
        console.log('breadcrumbController:parentDirectories', data.parentDirectories);
        breadcrumb.updateFolders(data.parentDirectories);
    }
};

},{"../trade":22,"../uiEventManager":23,"../uiModules/breadcrumb":28,"canny":52}],8:[function(require,module,exports){
'use strict';

var createNewProject = require('canny').createNewProject,
    displayManager = require('canny').displayManager,
    trade = require('../trade');

var currentDirectory;

createNewProject.onCreateNewProject(function (projectName) {
    trade.createNewProject(projectName, currentDirectory);
    displayManager.hide('createNewProjectView');
});

createNewProject.onCreateNewDirectoy(function (directoryName) {
    trade.createNewDirectory(directoryName, currentDirectory);
    displayManager.hide('createNewDirectoryView');
});

module.exports = {
    // TODO introduce new event: onDirectoryChanged - because a "getDirectory" event does not really explain what's
    // happening here
    getDirectory: function getDirectory(data) {
        currentDirectory = data.currentDirectory;
    }
};

},{"../trade":22,"canny":52}],9:[function(require,module,exports){
'use strict';

var anchorMenu = require('canny').anchorMenu,
    translationViewConfig = require('../uiModules/translationView').config,
    uiEvents = require('../uiEventManager');

/**
 * Nice approach but the order is different from the DOM.
 * TODO It would be better to read the elements from the DOM
 *  1. it's easier to reinitialize if a key is renamed or created new (Y)
 *  2. the order will be same as in the DOM (Y)
 *  con: we need to wait until the DOM is rendered - otherwise elements will be missing
 *
 *  We need:
 *  * DOM render success event (the translationView controller has to throw it) (so far the controller is added after the translationController it looks like that this is not an issue)
 *  * an a if anchor is clicked (in view) event ; then also focus the correct menu right element
 *  * the right menu element interact only as scroll overview - not as anchor helper as it is right now
 *
 * @param keys
 */

anchorMenu.onSelect(function (id) {
    var dom = document.getElementById(translationViewConfig.rowPrefix + id);
    if (dom) {
        var bodyRect = document.body.getBoundingClientRect(),
            elemRect = dom.getBoundingClientRect(),
            offset = elemRect.top - bodyRect.top;
        window.scrollTo(0, offset - 60);
        uiEvents.callUievent('anchorFocus', '#' + id);
    }
});

uiEvents.addUiEventListener({
    anchorFocus: function anchorFocus(id) {
        anchorMenu.focusElement(id.replace('#', ''));
    }
});

module.exports = {
    renameCategory: function renameCategory(oldName, newName) {
        anchorMenu.renderMenu();
    },
    removeCategory: function removeCategory(categoryName) {
        anchorMenu.renderMenu();
    },
    renameKey: function renameKey(oldKey, newKey) {
        anchorMenu.renderMenu();
    },
    removeKey: function removeKey(key) {
        anchorMenu.renderMenu();
    },
    onCreateKey: function onCreateKey() {
        anchorMenu.renderMenu();
    },
    onKeyCloned: function onKeyCloned(projectId, data) {
        anchorMenu.renderMenu();
    },
    /**
     * Will be called with the complete JSON object from a specific project
     * @param projectData
     */
    onLoadProject: function onLoadProject(projectData) {
        anchorMenu.renderMenu();
    },
    onNewProjectCreated: function onNewProjectCreated() {
        anchorMenu.renderMenu();
    }
};

},{"../uiEventManager":23,"../uiModules/translationView":41,"canny":52}],10:[function(require,module,exports){
'use strict';

var whisker = require('canny/mod/whisker');
var canny = require('canny');
var displayManager = canny.displayManager;
var trade = require('../trade');
var ERRORS = require('../../../ERRORS');

var inputNodes = {
    name: undefined,
    url: undefined
    // whisker callback for rendering the ui module
};var renderUi = void 0;
// save the actual loaded project config - needed for comparision
var project = void 0;

function noReturn(node) {
    node.addEventListener('keypress', function (e) {
        var key = e.keyCode || e.which;
        if (key === 13) e.returnValue = false;
        return true;
    });
    return node;
}

function noSpaces(node) {
    node.addEventListener('keypress', function (e) {
        var key = e.keyCode || e.which;
        if (key === 32) e.returnValue = false;
        return true;
    });
    return node;
}

function trimSlashes(url) {

    while (/\/\//.test(url)) {
        url = url.replace('//', '/');
    } // remove last slash if there is one
    if (url.length > 1 && url[url.length - 1] === '/') url = url.slice(0, -1);

    return url;
}

function removeSpaces(s) {
    while (/ /.test(s)) {
        s = s.replace(' ', '_');
    }return s;
}

function _submit() {
    trade.moveProject({
        id: project.id,
        url: removeSpaces(trimSlashes(inputNodes.url.value || ui.url)),
        name: inputNodes.name.value || ui.name
    }, function (err, _ref) {
        var id = _ref.id,
            name = _ref.name,
            url = _ref.url;

        if (err) {
            displayManager.hide('moveProject');
            if (ERRORS[err.error]) {
                toast.showMessage('Changing ' + inputNodes.name.value + ' failed: ' + err.message);
                toast.showMessage(err.error);
            } else {
                toast.showMessage('Failure ' + inputNodes.name.value + ' failed: ' + err.message);
                toast.showMessage('ERROR UNKNOWN');
            }
        } else {
            displayManager.hide('moveProject');
            // show/reload actual directory
            trade.getDirectory(url);
            if (project.url !== url) toast.showMessage('Change project location successfully to ' + url);
            if (project.name !== name) toast.showMessage('Rename project successfully to ' + name);
        }
    });
}

var ui = {
    inputName: function inputName(n) {
        return inputNodes.name = noReturn(n);
    },
    inputUrl: function inputUrl(n) {
        return inputNodes.url = noReturn(noSpaces(n));
    },
    submit: function submit(n) {
        return n.addEventListener('click', function () {
            return _submit();
        });
    },
    cancel: function cancel(n) {
        return n.addEventListener('click', function () {
            return displayManager.hide('moveProject');
        });
    },
    name: '',
    url: '',
    id: '',
    projectLink: ''
};

canny.add('moveProject', {
    add: function add(node) {
        whisker.add(node, function (fc) {
            renderUi = fc;
            renderUi(ui);
        });
    }
});

module.exports = {
    show: function show(_ref2) {
        var id = _ref2.id,
            url = _ref2.url,
            name = _ref2.name;


        project = { id: id, url: url, name: name };

        renderUi({
            id: id,
            url: url,
            name: name,
            projectLink: '/' + id + '.prj'
        });
        displayManager.show('moveProject');
    }
};

},{"../../../ERRORS":1,"../trade":22,"canny":52,"canny/mod/whisker":56}],11:[function(require,module,exports){
'use strict';

var canny = require('canny');

/**
 * just the implementation of the callbacks
 */

/**
 * Apply project description data to dom elements
 * @param data: Project configuration data
 */
function applyProjectData(data, project) {
    if (project.hasOwnProperty('name')) {
        // project specific config
        canny.texts.setTexts({ projectName: project.name });
    }

    // FIXME: Categories should not be named "__description" as they would override the project description
    if (data.hasOwnProperty('keyDescriptions')) {
        // project specific config - if property is present
        canny.texts.setTexts({
            projectDescription: data.keyDescriptions['__description'] ? data.keyDescriptions['__description'] : ''
        });
    }
}

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData,
    onNewDirectoryCreated: function onNewDirectoryCreated(data) {
        canny.texts.setTexts({
            projectName: data.directoryId
        });
    }
};

},{"canny":52}],12:[function(require,module,exports){
'use strict';

var canny = require('canny'),
    domOpts = require('dom-opts'),
    trade = require('../trade.js'),
    events = require('../events.js'),
    uiEvents = require('../uiEventManager.js'),
    keyValueCounter = {
    projectMap: {},
    getCountObj: function getCountObj() {
        return {
            keyMap: {}, // just collect all unique keys for getting total number of existing keys
            langMap: {} // save for each language all "valid" keys
        };
    }
},
    projectConfig = {},
    projectInfo = {},
    availableLanguages = [];

canny.projectMainNavigation.onLanguageSelect(function (obj) {
    var eventName;
    if (obj.isActive) {
        eventName = obj.isInactive ? 'deActivateLanguage' : 'activateLanguage';
        uiEvents.callUievent(eventName, obj.language);
    } else {
        uiEvents.callUievent('addLanguage', obj.language);
    }
    console.log('Click on language', obj);
});

(function () {
    var editorModeEnabled = false;

    canny.projectMainNavigation.onEnableEditorMode(function () {
        console.log('projectMainNavigationController:onEnableEditorMode show JSON format in new tab.');
        uiEvents.callUievent('enableEditorMode', !editorModeEnabled);
    });
    //maybe someone else calls this too
    uiEvents.addUiEventListener({
        enableEditorMode: function enableEditorMode(enabled) {
            editorModeEnabled = enabled;
        }
    });
})();

(function () {
    var wordCountEnabled = false;

    canny.projectMainNavigation.onToggleWordCount(function () {
        wordCountEnabled = !wordCountEnabled;
        uiEvents.callUievent('toggleWordCount', wordCountEnabled);
    });
})();

canny.projectMainNavigation.onShowJSON(function () {
    console.log('projectMainNavigationController:onShowJSON show JSON format in new tab.');
    window.open('/' + projectInfo.id + '.json?category=true', '_blank' // <- This is what makes it open in a new window.
    );
});

canny.projectMainNavigation.onShowJMBFUploader(function () {
    console.log('projectMainNavigationController:onShowJMBFUploader show message bundle uploader');
    uiEvents.callUievent('showJMBFUploader');
});

canny.projectMainNavigation.onShowJSONImport(function () {
    console.log('projectMainNavigationController:onShowJSONImport show JSON import overlay');
    uiEvents.callUievent('showJSONImport');
});

canny.projectMainNavigation.onShowJMBF(function () {
    console.log('projectMainNavigationController:onShowJMBF show JMBF format in new tab.');

    var lang = window.prompt('Enter a language code. E.g.: ' + function () {
        var existingLanguages = [];
        Object.keys(projectConfig.keys).forEach(function (lang) {
            if (Object.keys(projectConfig.keys[lang]).length > 0) {
                existingLanguages.push(lang);
            }
        });
        return existingLanguages;
    }().join(', '));

    if (lang !== null) {
        window.open('/' + projectInfo.id + '.properties' + (lang !== '' ? '?lang=' + lang : ''), '_blank' // <- This is what makes it open in a new window.
        );
    }
});

/**
 * server event listener
 */
events.addServerListener('newProjectWasCreated', function (projectName) {
    toast.showMessage('A new project with name: "' + projectName + '" was created.');
});
/**
 * server event listener
 */
events.addServerListener('keyUpdated', function (projectId, language, keyName, keyValue) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (projectId === currentProjectId) {
    //    var projectName = projectId.substring(projectId.lastIndexOf('/') + 1);
    //    updateKeyToProjectMap(projectName, language, keyName, keyValue);
    //    console.log('projectMainNavigationController:updateKey', projectId, language, keyName, keyValue);
    //}
});
/**
 * server event listener
 */
events.addServerListener('keyDeleted', function (bundleName, obj) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (bundleName === projectConfig.project) {
    //    console.log('projectMainNavigationController:keyRenamed', bundleName, obj);
    //    // TODO update the statistics...
    //}
});

/**
 *
 * @param projectName
 * @param lang
 * @param key
 * @param value
 */
function saveKeyToProjectMap(projectName, lang, key, value) {

    // just collect all keys (only the unique keys are relevant)
    if (keyValueCounter.projectMap[projectName] === undefined) {
        console.log('projectMainNavigationController:saveKeyToProjectMap project name not exists:', projectName);
        keyValueCounter.projectMap[projectName] = keyValueCounter.getCountObj();
    }

    keyValueCounter.projectMap[projectName].keyMap[key] = true;
    if (keyValueCounter.projectMap[projectName].langMap[lang] === undefined) {
        keyValueCounter.projectMap[projectName].langMap[lang] = {};
    }
    // only save the keys as object if it is a valid key otherwise delete it
    if (value) {
        keyValueCounter.projectMap[projectName].langMap[lang][key] = true;
    } else if (keyValueCounter.projectMap[projectName].langMap[lang][key]) {
        // if this key exists than remove it
        delete keyValueCounter.projectMap[projectName].langMap[lang][key];
    }
}

// TODO should use projectId, not projectName
function updateKeyToProjectMap(projectName, lang, key, value) {
    saveKeyToProjectMap(projectName, lang, key, value);
    canny.projectMainNavigation.setNumberOfTranslatedLanguageKey(Object.keys(keyValueCounter.projectMap[projectName].langMap[lang]).length, lang);
    canny.projectMainNavigation.setNumberOfTranslationMaxKeys(Object.keys(keyValueCounter.projectMap[projectName].keyMap).length);
}

// register listener function to the ui events
uiEvents.addUiEventListener({
    /**
     * the internal updateKey event - the server will not trigger the updateKey for the own client
     */
    updateKey: function updateKey(projectName, lang, key, value) {
        console.log('projectMainNavigationController:updateKey', projectName, lang, key, value);
        updateKeyToProjectMap(projectName, lang, key, value);
    },
    projectSelected: function projectSelected(projectId) {
        console.log('projectMainNavigationController:projectSelected Click on project', projectId);
        trade.loadProject(projectId, function (error) {
            if (error === false) console.error('projectMainNavigationController:loadProject fails for projectId:', projectId);
        });
    },
    activateLanguage: function activateLanguage(lang) {
        canny.projectMainNavigation.activateLang(lang);
    },
    deActivateLanguage: function deActivateLanguage(lang) {
        canny.projectMainNavigation.deActivateLang(lang);
    },
    addLanguage: function addLanguage(lang) {
        canny.projectMainNavigation.activateLang(lang);
    }
});

function computeTotalTranslationProgree(translations) {
    var totalProgress = {};
    Object.keys(translations).forEach(function (lang) {
        Object.keys(translations[lang]).forEach(function (key) {
            totalProgress[key] = undefined;
        });
    });
    return Object.keys(totalProgress).length;
}

function computeTranslationProgress(translations) {
    var progressByLanguage = {};
    Object.keys(translations).forEach(function (lang) {
        progressByLanguage[lang] = Object.keys(translations[lang]).length;
    });
    return progressByLanguage;
}

/**
 * Callback implementation of the onLoadProject & onNewProjectCreated
 * @param projectData (see project JSON file)
 */
function applyProjectData(data, project) {
    projectConfig = data;
    projectInfo = project;

    canny.projectMainNavigation.setAvailableLanguages(data.availableLanguages);

    canny.projectMainNavigation.setActivatedProjectLanguages(computeTotalTranslationProgree(data.keys), computeTranslationProgress(data.keys));

    Object.keys(data.keys).forEach(function (lang) {
        if (Object.keys(data.keys[lang]).length > 0 && availableLanguages.indexOf(lang) !== -1) {

            Object.keys(data.keys[lang]).forEach(function (key) {
                saveKeyToProjectMap(data.project, lang, key, data.keys[lang][key]);
            });

            if (keyValueCounter.projectMap[data.project].langMap[lang]) {
                console.log('projectMainNavigationController:onLoadProject ', keyValueCounter.projectMap[data.project].langMap[lang]);
                console.log('projectMainNavigationController:onLoadProject maxKeys are', Object.keys(keyValueCounter.projectMap[data.project].keyMap).length);
                //canny.projectMainNavigation.setNumberOfTranslationMaxKeys(Object.keys(keyValueCounter.projectMap[projectData.project].keyMap).length);
                //canny.projectMainNavigation.setNumberOfTranslatedLanguageKey(Object.keys(keyValueCounter.projectMap[projectData.project].langMap[lang]).length, lang);
                // TODO refactor this and make one call ;)
                canny.projectMainNavigation.activateLang(lang);
                canny.projectMainNavigation.deActivateLang(lang);
            } else {
                console.log('projectMainNavigationController:onLoadProject get language without any keys for locale:', lang);
            }
        }
    });

    // reset or reinitialize or initialize the key value counter (otherwise the counter can't detect deleted keys. E.g. from the editor mode)
    keyValueCounter.projectMap[data.project] = keyValueCounter.getCountObj();
    // show default language as selected language in menu
    // TODO check who decides to show which language as default - and then call this event from there
    uiEvents.callUievent('activateLanguage', data.defaultLanguage);
}

/**
 * the implementation of the callbacks
 */
module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../events.js":18,"../trade.js":22,"../uiEventManager.js":23,"canny":52,"dom-opts":65}],13:[function(require,module,exports){
'use strict';

var projectOverview = require('canny').projectOverview,
    displayManager = require('canny').displayManager,
    trade = require('../trade.js'),
    uiEvents = require('../uiEventManager.js'),
    toast = require('../Toast.js'),
    events = require('../events.js');

var moveProject = require('./moveProjectComponent');

var projectOverviewController = function () {

    var currentParentDirectory, currentDirectory,
    /**
     * Maps project names to projects IDs
     */
    projects,
    /**
     * Maps directory names to directory IDs
     */
    directories;

    uiEvents.addUiEventListener({
        showOverviewPage: function showOverviewPage() {
            displayManager.show('projectsOverview');
        }
    });

    projectOverview.onParentDirectorySelected(function () {
        if (currentParentDirectory !== currentDirectory) {
            trade.getDirectory(currentParentDirectory);
        } else {
            console.log('No parent directory');
        }
    });

    projectOverview.onProjectSelected(function (projectName) {
        uiEvents.callUievent('projectSelected', projects[projectName].id);
    });

    projectOverview.onDirectorySelected(function (directoryName) {
        var directoryId = directories[directoryName];
        trade.getDirectory(directoryId, function () {
            console.log('projectOverviewController:can not load project for directory name:', directoryId);
        });
    });

    projectOverview.onCreateProjectPressed(function () {
        displayManager.show('createNewProjectView');
    });

    projectOverview.onCreateDirectoryPressed(function () {
        displayManager.show('createNewDirectoryView');
    });

    projectOverview.onDeleteFolderPressed(function (dirName) {
        trade.deleteFolder(dirName, currentDirectory, function (err, dirName) {
            var toastMessage;
            if (!err) {
                projectOverview.deleteProjectListNode(dirName);
                toastMessage = 'Folder "' + dirName + '" has been deleted.';
            } else {
                toastMessage = 'There was an error: "' + err.message + '"';
            }
            toast.showMessage(toastMessage);
        });
    });

    projectOverview.onMoveDirectoryPressed(function (projectName) {
        return moveProject.show(projects[projectName]);
    });

    projectOverview.onDeleteProjectPressed(function (projectName) {
        trade.deleteProject(projects[projectName].id, function (err, project) {
            var toastMessage;
            if (!err) {
                projectOverview.deleteProjectListNode(project.name);
                toastMessage = 'Project "' + project.name + '" has been deleted.';
            } else {
                toastMessage = 'There was an error: "' + err.message + '"';
            }
            toast.showMessage(toastMessage);
        });
    });

    events.addServerListener('newDirectoryCreated', function (directoryId) {
        var lastDirSepIdx = directoryId.lastIndexOf('/');
        var parentDirectory = directoryId.substring(0, lastDirSepIdx + 1);
        if (parentDirectory === currentParentDirectory) {
            var directoryName = directoryId.substring(lastDirSepIdx + 1);
            directories[directoryName] = directoryId;
            // TODO show message only if projectOverview is currently visible - but canny.flowcontrol currently does not
            // have anything to find out which view is the active one
            toast.showMessage('A new directory "' + directoryName + '" has been created by another user.');
            projectOverview.setProjectsAndDirectories(Object.keys(projects), Object.keys(directories));
        }
    });

    return {
        /**
         * Callback from the server which handles a fresh directory/projects list
         *
         * @param {{currentDirectory:string, dirs:[{name, id}], parentDirectories:[{name, id}], parentDirectory:string, projects:[{name, id}] }} data - an object with 2 properties "projects" and "directories", each listing project/directory names.
         */
        getDirectory: function getDirectory(data) {
            console.log('ProjectOverviewController.getDirectory: ', data);
            if (data === false) {
                console.error("Server call failed");
            } else if (data.hasOwnProperty('projects') && data.hasOwnProperty('dirs')) {

                projects = {};
                data.projects.forEach(function (entry) {
                    projects[entry.name] = entry;
                });

                directories = {};
                data.dirs.forEach(function (entry) {
                    directories[entry.name] = entry.id;
                });

                projectOverview.setProjectsAndDirectories(Object.keys(projects), Object.keys(directories));
                currentParentDirectory = data.parentDirectory;
                currentDirectory = data.currentDirectory;
            } else {
                console.warn('Data rcvd from server is missing expected properties ("projects", "dirs")');
            }
        },
        onNewDirectoryCreated: function onNewDirectoryCreated(data) {
            displayManager.show('projectsOverview');
            trade.getDirectory(data.directoryId, function () {
                console.log('projectOverviewController.onNewDirectoryCreated: trade callback');
            });
        }
    };
}();

module.exports = projectOverviewController;

},{"../Toast.js":3,"../events.js":18,"../trade.js":22,"../uiEventManager.js":23,"./moveProjectComponent":10,"canny":52}],14:[function(require,module,exports){
'use strict';

var textEditor = require('canny').textEditor,
    trade = require('../trade.js'),
    toast = require('../Toast.js'),
    events = require('../events.js'),
    currentProjectId;
/**
 * returns the language or false
 * @param fileName
 * @returns {*}
 */
function getLanguageFromFileName(fileName) {
    var reg = /messages_(.*)\..*./g.exec(fileName);
    if (reg && reg.length === 2) {
        return reg[1];
    }
    return false;
}

/**
 * handle the change project description event in the view
 */
textEditor.onChange(function (id, value, fc) {
    console.log('textEditorController:onChange', value);
    if (currentProjectId) {
        if (!id) {
            // TODO to keep backward functionality this is the "main" project description - will be changed in future
            id = '__description';
        }
        // TODO remove the tv_ from the id
        trade.saveProjectDescription(currentProjectId, id, value, function (success) {
            if (success) {
                fc(true);
                toast.showMessage('Project description changed for project ' + currentProjectId);
            } else {
                fc(false);
            }
        });
    }
});
/**
 * just the implementation of the callbacks
 *
 */
module.exports = {
    onLoadProject: function onLoadProject(data, _ref) {
        var id = _ref.id,
            name = _ref.name,
            url = _ref.url;

        if (id) currentProjectId = id;
    }
};

},{"../Toast.js":3,"../events.js":18,"../trade.js":22,"canny":52}],15:[function(require,module,exports){
'use strict';

var canny = require("canny"),
    translationView = require('../uiModules/translationView'),
    translationViewImageUpload = require('../uiModules/translationViewImageUpload'),
    wordCounter = require('../util/wordCounter'),
    domOpts = require('dom-opts'),
    uiEvents = require('../uiEventManager.js'),
    events = require('../events.js'),
    trade = require('../trade.js'),
    url = require('../util/url'),
    sortByKey = function sortByKey(a, b) {
    if (a.key < b.key) {
        return -1;
    }
    if (a.key > b.key) {
        return 1;
    }
    return 0;
},
    projectConfig,
    projectInfo,
    availableLanguages = [],

/**
 * An object (used as a set datastructure here) holding all existing keys of the project (no matter for how many
 * languages it is used). It is needed when adding a new language, see the function for addLanguage which is added
 * to uiEvents.
 * @type {{}}
 */
existingKeys = {};

translationViewImageUpload.onUploadButton(function (id) {
    uiEvents.callUievent('showFileUpload', id);
});

translationViewImageUpload.onDeleteButton(function (id) {
    if (confirm('Delete the image for category » ' + id + ' « forever?')) {
        trade.removeImage(projectInfo.id, id);
    }
});

translationView.onCategoryClicked(function (id) {
    uiEvents.callUievent('anchorFocus', '#' + id);
});
/**
 * Setup the UI events and manage the logic for them.
 *
 * TODO replace bundle with locale and refactor the calls from translationView
 */
translationView.onSaveKey(function (key, lang, value) {

    // TODO: Count words and tell word count label to update

    console.log('translationViewController:onSaveValue', [].slice.call(arguments));
    trade.saveKey(projectInfo.id, lang || projectConfig.defaultLanguage, {
        key: key,
        value: value || undefined
    }, function (projectId, language, key, value) {
        var catId;

        if (projectId === projectInfo.id) {
            // prevent applying the callback if project has been changed in the meantime
            catId = key.split('_')[0];
            existingKeys[key] = undefined; // save the key
            projectConfig.keys[lang][key] = value;
            translationView.printBundleTemplate([{
                key: key,
                value: value || ''
            }], language, availableLanguages, function () {
                updateCategoryWordCount(catId, language);
            });

            toast.showMessage('Auto save: "' + key + '" (success)');

            translationView.sendSuccess(key, 'value_');
            // TODO not sure if this is needed
            uiEvents.callUievent('updateKey', projectId, language, key, value);
        }
    });
});

/**
 * Setup the UI events and manage the logic for them.
 *
 * TODO replace bundle with locale and refactor the calls from translationView
 */
translationView.onCreateKey(function (key, lang, value) {
    console.log('translationViewController:onSaveValue', [].slice.call(arguments));
    trade.createKey(projectInfo.id, lang || projectConfig.defaultLanguage, {
        key: key,
        value: value || undefined
    }, function (projectId, language, key, value) {
        var catId = key.split('_')[0];
        if (projectId === projectInfo.id) {
            // prevent applying the callback if project has been changed in the meantime
            existingKeys[key] = undefined; // save the key
            projectConfig.keys[language] = projectConfig.keys[language] ? projectConfig.keys[language] : {};
            projectConfig.keys[language][key] = value;
            translationView.printBundleTemplate([{
                key: key,
                value: value || '',
                words: 0
            }], language, availableLanguages, function () {
                updateCategoryWordCount(catId, language);
            });
            toast.showMessage('Auto save: "' + key + '" (success)');

            translationView.sendSuccess(key, 'value_');
            // TODO not sure if this is needed
            uiEvents.callUievent('updateKey', projectId, language, key, value);
        }
    });
});

translationView.onCloneKey(function (keyId, keyName, fromCategory, toCategory) {
    trade.cloneKey(projectInfo.id, {
        id: keyId,
        key: keyName,
        sourceCategory: fromCategory,
        targetCategory: toCategory
    }, function (err, projectId, data) {
        var texts;
        if (projectId === projectInfo.id) {
            existingKeys[data.key] = undefined;
            texts = data.values;
            for (var lang in texts) {
                if (texts.hasOwnProperty(lang)) {
                    projectConfig.keys[lang][data.key] = texts[lang];
                    translationView.printBundleTemplate([{
                        key: data.key,
                        value: texts[lang] || ''
                    }], lang, availableLanguages, function () {
                        updateCategoryWordCount(toCategory, lang);
                    });
                }
            }
            canny.translationViewDescription.addDescriptions(data.keyDescriptions);
        }
    });
});

/**
 * Read the from param as default language otherwise take it from the project.json
 * @param config
 */
function saveProjectConfig(config, project) {
    var idx,

    // the from parameter can overwrite the default language (legacy)
    defaultLanguage = domOpts.params.from ? domOpts.params.from : config.defaultLanguage;
    projectConfig = config;
    projectInfo = project;

    // Set ${ defaultLanguage } as default in case a project was just created (i.e. does not contain any keys yet)
    // TODO: Better create / add check of object to functional helper object instead ?
    availableLanguages = Object.keys(projectConfig.keys).length === 0 && JSON.stringify(projectConfig.keys) === JSON.stringify({}) ? [defaultLanguage] : Object.keys(projectConfig.keys);

    idx = availableLanguages.indexOf(defaultLanguage);

    if (idx !== -1 && idx !== 0) {
        // move default to the begin of the list (this defines the order how the translation languages are shown)
        availableLanguages.splice(0, 0, availableLanguages.splice(idx, 1)[0]);
    }
}

///**
// * TODO replace bundle with locale and refactor the calls from translationView
// * TODO this code is not called!?
// */
//translationView.onAddNewKey(function (lang, key, value, cb) {
//    console.log('translationViewController:onAddNewKey', [].slice.call(arguments));
//    alert('huhu');
//    trade.sendResource({
//        bundle: projectConfig.project,
//        locale: lang
//    }, {
//        key: key,
//        value: value
//    }, function (key) {
//        cb(key)
//    });
//});

translationView.onCreateNewProject(function (prjName, obj) {
    trade.createNewProject(prjName, obj);
});

translationView.onRemoveCategory(function (obj) {
    console.log('translationViewController:onRemoveCategory', obj, projectInfo.id);
    trade.removeCategory(projectInfo.id, obj.category);
});

translationView.onRenameCategory(function (obj) {
    console.log('translationViewController:onRenameCategory', obj, projectInfo.id);
    trade.renameCategory(projectInfo.id, obj.oldName, obj.newName);
});

translationView.onRenameKey(function (obj) {
    console.log('translationViewController:onRenameKey', obj, projectInfo.id);
    trade.renameKey(projectInfo.id, {
        newKey: obj.newKey,
        oldKey: obj.oldKey
    });
});

translationView.onRemoveKey(function (obj) {
    console.log('translationViewController:onRemoveKey', obj, projectInfo.id);
    trade.removeKey(projectInfo.id, obj.key, function (key) {
        var catName = key.split('_')[0];
        for (var lang in projectConfig.keys) {
            if (projectConfig.keys.hasOwnProperty(lang)) {
                delete projectConfig.keys[lang][key];
                updateCategoryWordCount(catName, lang);
            }
        }
    });
});

// register listener function to the ui events
uiEvents.addUiEventListener({
    activateLanguage: function activateLanguage(lang) {
        //        translationViewHeader.showLang(lang);
        translationView.showLang(lang);
    },
    deActivateLanguage: function deActivateLanguage(lang) {
        //        translationViewHeader.hideLang(lang);
        translationView.hideLang(lang);
    },
    toggleWordCount: function toggleWordCount(active) {
        translationView.toggleWordCount(active);
    },
    // TODO  don't trigger it twice for the same language
    addLanguage: function addLanguage(lang) {
        availableLanguages.push(lang);
        projectConfig.keys[lang] = {};
        translationView.addLanguage(Object.keys(existingKeys), lang);
        //        translationViewHeader.showLang(lang);
        translationView.showLang(lang);
    },
    enableEditorMode: function enableEditorMode(enabled) {
        translationView.enableEditorMode(enabled);
    },
    fileUploaded: function fileUploaded(projectId, key, url) {
        canny.translationViewImageUpload.appendImage(key, url);
    },
    JMBFFileUploaded: function JMBFFileUploaded(projectId) {
        trade.loadProject(projectId, function (error) {
            if (error === false) console.error('translationViewController:loadProject fails for projectId:', projectInfo.id);
        });
    },
    jsonImported: function jsonImported(projectId) {
        trade.loadProject(projectId, function (error) {
            if (error === false) {
                console.warn('Project with id ' + projectId + ' could not be loaded.');
                console.error(error.toString());
            }
        });
    }
});

/**
 * server event listener
 */
events.addServerListener('keyUpdated', function () {
    // TODO more client changes are coming, we'll finish the code below then
    //if (projectId === projectConfig.projectId) {
    //    existingKeys[keyName] = undefined; // save the key // what's happening here?
    //    var data = {};
    //    data[keyName] = keyValue;
    //    translationView.printBundleTemplate([data], language, availableLanguages, projectConfig.project);
    //}
});

/**
 * server event listener
 * all users will be notified of changes
 */
events.addServerListener('onKeyCloned', function () {
    console.log('events.listener::onKeyCloned' + [].slice.call(arguments));
});

/**
 * server event listener
 */
events.addServerListener('keyDeleted', function (bundleName, obj) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (bundleName === projectConfig.project) {
    //    console.log('translationViewController:keyRenamed', bundleName, obj);
    //    toast.showMessage('Key deleted!' + obj.key);
    //    translationView.markKeyAsRemoved(obj.key);
    //}
});

events.addServerListener('categoryDeleted', function (bundleName, obj) {
    console.log('events.listener::categoryDeleted' + [].slice.call(arguments));
});

events.addServerListener('categoryRenamed', function (bundleName, obj) {
    console.log('events.listener::categoryRenamed' + [].slice.call(arguments));
});

/**
 * server event listener
 */
events.addServerListener('imageRemoved', function (bundleName, categoryName) {
    if (bundleName === projectInfo.id) {
        toast.showMessage('Image removed for category: ' + categoryName);
        translationView.removeImage(categoryName);
    }
});

/**
 * Get word count for given category and language
 * @param category
 * @param lang
 * @returns Number
 */
function countWordsInCategory(category, lang) {
    var wordCount = 0;
    Object.keys(projectConfig.keys[lang]).forEach(function (key) {
        if (key.split('_')[0] === category) {
            wordCount += wordCounter.countWordsInString(projectConfig.keys[lang][key]);
        }
    });
    return wordCount;
}

/**
 * Update overall word-count view for category language
 * @param catId
 * @param lang
 */
function updateCategoryWordCount(catId, lang) {
    translationView.updateCategoryWordCount({
        id: catId,
        language: lang,
        words: countWordsInCategory(catId, lang)
    });
}

/**
 * Filter category names by iterating through project keys
 * @param keys
 * @returns Array
 */
function getCategoriesByKeys(keys) {
    var currentCatName,
        defaultKeys,
        categories = [];
    for (var lang in keys) {
        if (keys.hasOwnProperty(lang)) {
            defaultKeys = keys[lang];
            for (var key in defaultKeys) {
                if (defaultKeys.hasOwnProperty(key)) {
                    currentCatName = key.split('_')[0];
                    if (categories.indexOf(currentCatName) === -1) {
                        categories.push(currentCatName);
                    }
                }
            }
        }
    }
    return categories;
}

/**
 * Removes category related keys from "session" data - stored in projectConfig.keys
 * (member var declared on top of this file)
 * Invoked by category was removed
 * @param category
 */
function removeCategoryData(category) {
    Object.keys(projectConfig.keys).forEach(function (lang) {
        var langData = projectConfig.keys[lang];
        Object.keys(langData).forEach(function (key) {
            if (key.split('_')[0] === category) {
                delete langData[key];
            }
        });
    });
}

function handleNewProjectConfig(newProjectConfig, project) {
    // project specific config
    console.log('translationViewController get new config', newProjectConfig);
    // n.b. nothing is saved here - "saving" only happens as in "store in our data structure"
    saveProjectConfig(newProjectConfig, project);
    // before there was a check do not clear the view if the actual project is the same.
    // The problem is if you remove a key in the editor view than the translation view can't
    // detect this.
    translationView.clearView();
    canny.flowControl.show('resourceBundle');
}

function renderProject(projectData, project, cb) {
    var categories = getCategoriesByKeys(projectData.keys);

    handleNewProjectConfig(projectData, project);

    Object.keys(projectData.keys).forEach(function (lang) {
        var sorted,
            datas = [];
        Object.keys(projectData.keys[lang]).forEach(function (key) {
            datas.push({
                key: key,
                value: projectData.keys[lang][key]
            });
        });
        sorted = datas.sort(sortByKey);

        sorted.forEach(function (data) {
            existingKeys[data.key] = undefined;
        });

        // TODO projectConfig.project will be removed if the trade call moved to this controller
        translationView.printBundleTemplate(sorted, lang, availableLanguages, cb || function () {});

        categories.forEach(function (category) {
            updateCategoryWordCount(category, lang);
        });
    });
}

module.exports = {
    renameCategory: function renameCategory(oldName, newName) {
        toast.showMessage('Renamed category ' + oldName + ' to ' + newName + '!');
        translationView.renameCategory(oldName, newName, availableLanguages);
    },
    removeCategory: function removeCategory(catName) {
        toast.showMessage('Removed category ' + catName + '!');
        removeCategoryData(catName);
        translationView.removeCategory(catName);
    },
    /**
     * is called if the user rename key request was successful
     * @param newKey
     * @param oldKey
     */
    renameKey: function renameKey(oldKey, newKey) {
        if (oldKey) {
            toast.showMessage('Key renamed successful! From ' + oldKey + ' to ' + newKey);
            translationView.renameKey(oldKey, newKey, availableLanguages);
        } else {
            toast.showMessage('Key renamed failed!');
        }
    },
    removeKey: function removeKey(key) {
        toast.showMessage('Key removed successful!', key);
        translationView.removeKey(key);
    },
    imageRemoved: function imageRemoved(categoryName) {
        toast.showMessage('Image removed for category: ' + categoryName);
        translationView.removeImage(categoryName);
    },
    /**
     * Will be called with the complete JSON object from a specific project
     * @param projectData
     */
    onLoadProject: function onLoadProject(projectData, project) {
        var anchor = url.hasAnchor() ? url.getAnchor().replace('#', '') : false;
        renderProject(projectData, project, function (viewId) {
            if (anchor) {
                if (viewId === anchor) {
                    var dom = document.getElementById(translationView.config.rowPrefix + viewId);
                    // do the element exists?
                    if (dom) {
                        uiEvents.callUievent('anchorFocus', url.getAnchor());
                        setTimeout(function () {
                            var bodyRect = document.body.getBoundingClientRect(),
                                elemRect = dom.getBoundingClientRect(),
                                offset = elemRect.top - bodyRect.top;
                            window.scrollTo(0, offset);
                        }, 1000);
                    }
                }
            }
        });
        // add the descriptions
        canny.translationViewDescription.addDescriptions(projectData.keyDescriptions);
        Object.keys(projectData.images).forEach(function (key) {
            // images without a slash at front are old image upload - this is only to be backward compatible
            var url = projectData.images[key][0] === '/' ? projectData.images[key] : '/' + project.id + '/' + projectData.images[key];
            canny.translationViewImageUpload.appendImage(key, url);
        });
    },
    onNewProjectCreated: function onNewProjectCreated(projectData, project) {
        renderProject(projectData, project);
    }
};

},{"../events.js":18,"../trade.js":22,"../uiEventManager.js":23,"../uiModules/translationView":41,"../uiModules/translationViewImageUpload":43,"../util/url":46,"../util/wordCounter":47,"canny":52,"dom-opts":65}],16:[function(require,module,exports){
'use strict';

/**
 * controller for the image uplaoder view - calls the server to upload a image and notifier the ui event handler
 * @type {{}}
 */
var canny = require('canny'),
    upload = canny.upload,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;
/**
 * Call this for each file - will call a call back with the server answer
 * @param file
 */
function sendFile(file, directCallback) {
    var uri = '/uploadFile?projectId=' + projectInfo.id + '&key=' + uploadId + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        var data;
        if (xhr.readyState == 4 && xhr.status == 200) {
            // Handle response.
            data = JSON.parse(xhr.responseText);
            directCallback && directCallback(data); // handle response.
            // {file: "//sub/sub1/sub1_blue_coke.jpg", name: "sub1_blue_coke.jpg", type: "image/jpg"}
            console.log(data);
            uiEvents.callUievent('fileUploaded', projectInfo.id, uploadId, data.file);
        }
    };
    fd.append('myFile', file);
    // Initiate a multipart/form-data upload
    xhr.send(fd);
}

/**
 * Save data in member variable used by further upload operations
 * @param data: Project data
 */
function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showFileUpload: function showFileUpload(id) {
        uploadId = id;
        displayManager.show('uploadView');
    }
});

upload.onUpload(function (file) {
    // TODO additional to the upload id we need the project ID
    console.log('uploadController:upload id: file:', uploadId, file);
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":23,"canny":52}],17:[function(require,module,exports){
'use strict';

var trade = require('../trade'),
    uiEvents = require('../uiEventManager'),
    url = require('../util/url');
/**
 * TODO handle the browser back and next button and load the correct view
 */
function processAjaxData(response, urlPath) {
    document.title = response.pageTitle;
    window.history.pushState({
        "html": response.html,
        "pageTitle": response.pageTitle,
        id: response.id,
        isProject: response.isProject
    }, "", urlPath + url.getAnchor());
}

/**
 * Manipulate browser history / location with given project data
 * @param data: Project related data
 */
function applyProjectData(data, project) {
    // add the project path to the URL
    if (project.name) {
        processAjaxData({
            pageTitle: project.id,
            html: '',
            id: project.id,
            isProject: true
            // to persists the links we save the id in URL - it's not human readable but links will work forever
        }, '/' + project.id + '.prj');
    }
}

uiEvents.addUiEventListener({
    anchorFocus: function anchorFocus(id) {
        // set the anchor to the URL
        window.history.pushState(null, null, id);
    }
});

window.onpopstate = function (e) {
    //    console.log('onpopstate', e.state.id);
    if (e.state) {
        if (e.state.isProject) {
            trade.loadProject(e.state.id, function (err) {
                if (err === false) console.error('urlManipulator:loadProject fails for projectId:', e.state.id);
            });
        } else {
            trade.getDirectory(e.state.id, function (err) {
                if (err !== false) {
                    // TODO call the
                    uiEvents.callUievent('showOverviewPage');
                } else {
                    console.log('urlManipulator:getDirectory can not load project for directory name:', e.state.id);
                }
            });
        }
    }
};

/**
 * TODO there is a problem with activating the project view or the overview page...
 *
 * just the implementation of the callbacks
 *
 */
module.exports = {
    onLoadProject: applyProjectData,
    onNewProjectCreated: applyProjectData,
    getDirectory: function getDirectory(data) {
        processAjaxData({
            pageTitle: 'translatron overview',
            html: '',
            id: data.currentDirectory,
            isProject: false
        }, data.currentDirectory);
    }
};

},{"../trade":22,"../uiEventManager":23,"../util/url":46}],18:[function(require,module,exports){
'use strict';

/**
 * Created by eightyfour.
 *
 * All server events. Multiple clients can register on each event
 * and will be notified if method is called from server.
 *
 * TODO RENAME FILE
 * TODO to what? :)
 * What about "externalChangeNotifications"?
 *
 * TBD why don't we integrate this one with ui events? that would cut down on the number of components we have and we "only" (?)
 * have to do some sensible renaming of events, like renaming all events handled here by adding "external" or similar
 * (e.g. "keyUpdated" becomes "keyUpdatedExternally").
 */
var events = function () {
    "use strict";

    var eventQueue = {},
        callQueue = function callQueue(name, args) {
        console.log('got notification for ', name, 'with payload', args);
        if (eventQueue.hasOwnProperty(name)) {
            eventQueue[name].map(function (fc) {
                fc.apply(null, args);
            });
        }
    };
    return {
        serverEvents: {
            // TBD can be removed?
            sendFile: function sendFile() {
                callQueue('sendFile', [].slice.call(arguments));
            },
            // TBD can be removed?
            sendPathList: function sendPathList() {
                callQueue('sendPathList', [].slice.call(arguments));
            },
            keyUpdated: function keyUpdated(projectId, language, keyName, keyValue) {
                callQueue('keyUpdated', [projectId, language, keyName, keyValue]);
            },
            onKeyCloned: function onKeyCloned(projectId, data) {
                callQueue('onKeyCloned', [projectId, data]);
            },
            keyRenamed: function keyRenamed(projectId, oldKeyName, newKeyName) {
                callQueue('keyRenamed', [projectId, oldKeyName, newKeyName]);
            },
            /**
             * @param bundleObj {locale: string, bundle: string}
             * @param data {oldKey:string, newKey: string}
             */
            keyDeleted: function keyDeleted(projectId, keyName) {
                callQueue('keyDeleted', [projectId, keyName]);
            },
            imageRemoved: function imageRemoved(projectId, categoryName) {
                callQueue('imageRemoved', [projectId, categoryName]);
            },
            newProjectWasCreated: function newProjectWasCreated(projectId) {
                callQueue('newProjectWasCreated', [projectId]);
            },
            categoryRenamed: function categoryRenamed(projectId, oldName, newName) {
                callQueue('categoryRenamed', [projectId, oldName, newName]);
            },
            categoryDeleted: function categoryDeleted(projectId, catName) {
                callQueue('categoryDeleted', [projectId, catName]);
            },
            newDirectoryCreated: function newDirectoryCreated(directoryId) {
                callQueue('newDirectoryCreated', [directoryId]);
            },
            projectDescriptionUpdated: function projectDescriptionUpdated(projectId, id, description) {
                callQueue('projectDescriptionUpdated', [projectId, id, description]);
            }
        },
        addServerListener: function addServerListener(name, cb) {
            if (eventQueue.hasOwnProperty(name)) {
                eventQueue[name].push(cb);
            } else {
                eventQueue[name] = [cb];
            }
        }
    };
}();

module.exports = events;

},{}],19:[function(require,module,exports){
'use strict';

var C = require('./CONST');
var connectionLost = require('./uiModules/connectionLost');

/**
 * Refresh the user session and detects if the user is not authenticated anymore
 * useful for:
 *  * session keep alive
 *  * detect if the user is not authenticated anymore
 *  * detects server shut down
 */
module.exports = function handleSessionTimeOut() {
    var connectionLostUi = connectionLost({
        onReload: function onReload() {
            return location.reload();
        },
        onClose: function onClose() {
            return connectionLostUi.destroy();
        }
    });
    var interval = setInterval(function () {
        fetch(location.protocol + '//' + location.host + '/touchSession', {
            credentials: "same-origin"
        }).then(function (d) {
            if (d.status === 401) {
                clearInterval(interval);
                // whoops server has no authentication anymore...
                connectionLostUi.render('AUTH');
            }
        }).catch(function (e) {
            clearInterval(interval);
            connectionLostUi.render('SERVER_DOWN', 'Maybe a server restart happens. Please try to login again in few minutes');
        });
    }, C.SESSION.renewal_interval_in_ms);
};

},{"./CONST":2,"./uiModules/connectionLost":30}],20:[function(require,module,exports){
'use strict';

/*global domOpts */
/*jslint browser: true */
var unicode = require('./unicode.js');
var toast = require('./Toast.js');
var canny = require('canny');
var trade = require('./trade.js');
var handleSessionTimeOut = require('./handleSessionTimeOut');
var breadCrumbController = require('./controller/breadcrumbController.js');

window.domOpts = window.domOpts || require('dom-opts');
// made it public - just for development
window.canny = canny;

canny.add('repeat', require('canny/mod/repeat'));
canny.add('whisker', require('canny/mod/whisker'));
canny.add('async', require('canny/mod/async'));
canny.add('flowControl', require('canny/mod/flowControl')('flowControl'));
canny.add('displayManager', require('./uiModules/displayManager.js'));
canny.add('textEditor', require('./textEditor.js'));
canny.add('cookieManager', require('canny-cookieManager-lib'));

canny.add('texts', require('./uiModules/texts.js'));
canny.add('auth', require('./uiModules/auth.js'));
canny.add('projectMainNavigation', require('./uiModules/projectMainNavigation.js'));
canny.add('translationView', require('./uiModules/translationView.js'));
canny.add('translationViewImageUpload', require('./uiModules/translationViewImageUpload.js'));
//canny.add('translationViewHeader',  require('./uiModules/translationViewHeader.js'));
canny.add('imageViewer', require('./uiModules/imageViewer.js'));
canny.add('projectOverview', require('./uiModules/projectOverview.js'));
canny.add('createNewProject', require('./uiModules/createNewProject.js'));
canny.add('menuRight', require('./uiModules/menuRight.js'));
canny.add('anchorMenu', require('./uiModules/anchorMenu.js'));

canny.add('translationViewDescription', require('./uiModules/translationViewDescription.js'));
canny.add('upload', require('./uiModules/upload.js'));
canny.add('JMBFUploader', require('./uiModules/JMBFUploader.js'));
canny.add('JsonImport', require('./uiModules/JsonImport.js'));

trade.addController(require('./controller/projectMainNavigationController.js'));
trade.addController(require('./controller/pageHeaderController.js'));
trade.addController(require('./controller/translationViewController.js'));
trade.addController(require('./controller/textEditorController.js'));
trade.addController(require('./controller/urlManipulator.js'));
trade.addController(require('./controller/projectOverviewController.js'));
trade.addController(require('./controller/createNewProjectController.js'));
trade.addController(breadCrumbController);
trade.addController(require('./controller/authController.js'));
trade.addController(require('./controller/menuRightController.js'));
trade.addController(require('./controller/uploadController.js'));
trade.addController(require('./controller/JMBFUploaderController.js'));
trade.addController(require('./controller/JsonImportController.js'));

canny.ready(function () {
    "use strict";
    // create websocket connection via trade

    trade.initialize(function (userObject, sessionsEnabled) {

        if (userObject === null) {
            alert('A fatal error happens while loading the view');
            location.reload();
            return;
        }
        canny.texts.setTexts({ userName: userObject.name });

        if (userObject.isAdmin) {
            document.body.classList.add('isAdmin');
        }

        if (sessionsEnabled) {
            // trigger a "session keep alive" and detects if the user is not authenticated anymore or the server is down
            handleSessionTimeOut();
        }
    });
});

window.canny = canny;
window.domOpts = require('dom-opts');
window.unicode = unicode;
window.toast = toast;

// QUESTION: can it happen that the above call to trade.initialize (in canny.ready) finishes earlier than the next lines?
// i.e. the callback for trade.ready will never be executed? if yes: why not pass the callback already to trade.initialize?
trade.ready(function () {
    'use strict';

    var prj = function getProjectNameAndPathFromURL() {
        var split = location.pathname.split('/');
        var path = location.pathname;
        var prjName = void 0;

        if (/\.prj/.test(split[split.length - 1])) {
            // remove .prj extension and first slash
            prjName = path.replace('.prj', '').replace('/', '');
            path = split.slice(0, -1).join('/');
        }

        if (path[0] !== '/') {
            path = '/' + path;
        }

        return {
            path: path,
            projectId: prjName
        };
    }();

    // QUESTION: since this is working on the URL the application was loaded with and this URL can be either a directory URL
    // or a project URL: why can't we decide first what we actually have in the URL and then either call getDirectory
    // or loadProject? ANSWER: depends. if the URL points to a directory, we only have to do the getDirectory call.
    // if the URL is a project, two calls have to be made: one loadProject call and one extra getDirectory call for the
    // parent of the project (mainly for navigation component which needs to know the siblings of the project). But: take
    // care that this extra getDirectory must *not* change the state of the breadcrumb trail (that one should still show
    // the selected project)


    if (prj.projectId) {
        // this is the initial call to trigger a project load - you will get
        // the project.json and all translations
        trade.loadProject(prj.projectId, function (err, data, project) {
            // callback is only called if an error occurs
            if (err !== null) {
                toast.showMessage('Loading project \'' + prj.projectId + '\' failed - project doesn\'t exists');
                console.error('translationViewController:loadProject fails for projectId:', prj.projectId);
            } else {
                // required for the breadcrumb
                breadCrumbController.setPath(project.url);
            }
        });
    } else {
        trade.getDirectory(prj.path, function (obj) {});
    }
});

},{"./Toast.js":3,"./controller/JMBFUploaderController.js":4,"./controller/JsonImportController.js":5,"./controller/authController.js":6,"./controller/breadcrumbController.js":7,"./controller/createNewProjectController.js":8,"./controller/menuRightController.js":9,"./controller/pageHeaderController.js":11,"./controller/projectMainNavigationController.js":12,"./controller/projectOverviewController.js":13,"./controller/textEditorController.js":14,"./controller/translationViewController.js":15,"./controller/uploadController.js":16,"./controller/urlManipulator.js":17,"./handleSessionTimeOut":19,"./textEditor.js":21,"./trade.js":22,"./uiModules/JMBFUploader.js":24,"./uiModules/JsonImport.js":25,"./uiModules/anchorMenu.js":26,"./uiModules/auth.js":27,"./uiModules/createNewProject.js":31,"./uiModules/displayManager.js":32,"./uiModules/imageViewer.js":34,"./uiModules/menuRight.js":36,"./uiModules/projectMainNavigation.js":38,"./uiModules/projectOverview.js":39,"./uiModules/texts.js":40,"./uiModules/translationView.js":41,"./uiModules/translationViewDescription.js":42,"./uiModules/translationViewImageUpload.js":43,"./uiModules/upload.js":44,"./unicode.js":45,"canny":52,"canny-cookieManager-lib":51,"canny/mod/async":53,"canny/mod/flowControl":54,"canny/mod/repeat":55,"canny/mod/whisker":56,"dom-opts":65}],21:[function(require,module,exports){
'use strict';

/**
 * textEditor
 */
(function () {
    "use strict";

    var textEditor = function () {

        var texts = {
            originText: 'Double click to edit this text',
            editBtn: 'Edit',
            cancelBtn: 'Cancel',
            changeBtn: 'Save changes'
        },
            onChangeAllList = [];

        function findClosestAncestorWithId(element) {
            while ((element = element.parentElement) && !element.id) {}
            return element;
        }

        function callChangeList(id, value, fc) {
            onChangeAllList.forEach(function (cb) {
                return cb(id, value, fc);
            });
        }

        function editWithTextarea(node, buttonWrap, obj) {
            var open = false,
                divWrapper = document.createElement('div'),
                button = document.createElement('div'),
                cancelButton = document.createElement('div'),
                area = document.createElement('textarea'),
                jsTextN;

            if (obj && obj.hasOwnProperty('placeholder')) {
                area.setAttribute('placeholder', obj.placeholder);
            }

            function close() {
                node.classList.add('textEditor-hide');
                open = false;
            }

            function edit() {
                if (!open) {
                    jsTextN = node.querySelector('.js-text');
                    open = true;
                    area.value = jsTextN.innerHTML;
                    setTimeout(function () {
                        node.classList.remove('textEditor-hide');
                    }, 100);
                }
            }

            // set classes
            cancelButton.className = 'textEditor-button textEditor-button-cancel octicon octicon-x';
            button.className = 'textEditor-button textEditor-button-change octicon octicon-check';
            area.className = 'textEditor-area';
            divWrapper.className = 'textEditor-wrap-area';
            node.classList.add('textEditor-hide');

            // register listeners
            cancelButton.addEventListener('click', close);
            button.addEventListener('click', function () {
                var val = area.value,
                    id = findClosestAncestorWithId(this).id,
                    ret = callChangeList(id, val, function (success) {
                    if (success) {
                        jsTextN.innerHTML = val;
                        close();
                    } else {
                        console.warn('textEditor:toTextareaNode text not accepted! Ignore changes.');
                    }
                });
            });
            node.addEventListener('dblclick', edit);

            // set titles
            node.setAttribute('title', texts.originText);
            cancelButton.setAttribute('title', texts.cancelBtn);
            button.setAttribute('title', texts.changeBtn);

            // append to wrapper div
            divWrapper.appendChild(area);
            buttonWrap.appendChild(cancelButton);
            buttonWrap.appendChild(button);

            // append to parent
            node.appendChild(divWrapper);

            // return click function
            return function () {
                if (!open) {
                    // show input
                    edit();
                } else {
                    // show text
                    close();
                }
            };
        }

        return {
            /**
             * Register a function to a specific editor.
             * If the function returns undefined than the editor expect that the passed callback
             * is called with true or false. If the method returns true the text will change.
             * If the method returns false the text is not changed.
             *
             * @param id
             * @param fc <- is called with (textValue, callbackFunction) can return undefined, false and true
             */
            onChange: function onChange(fc) {
                onChangeAllList.push(fc);
            },
            /**
             *
             * @param node
             * @param id
             */
            add: function add(node, obj) {
                var buttonWrap = document.createElement('div'),
                    editIconButton = document.createElement('div');
                buttonWrap.className = 'textEditor-buttonWrap';
                editIconButton.className = 'textEditor-button textEditor-button-edit octicon octicon-pencil';
                editIconButton.addEventListener('click', editWithTextarea(node, buttonWrap, obj));
                editIconButton.setAttribute('title', texts.editBtn);
                // append editIconButton to parent
                node.classList.add('textEditor-main-wrap');
                buttonWrap.appendChild(editIconButton);
                node.appendChild(buttonWrap);
            }
        };
    }();

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = textEditor;
    } else {
        canny.add('textEditor', textEditor);
    }
})();

},{}],22:[function(require,module,exports){
'use strict';

/*jslint browser: true */
/**
 * handle the connection between server and client
 */
var canny = require('canny');
var events = require('./events.js');
var shoe = require('shoe');
var dnode = require('dnode');
var connectionLost = require('./uiModules/connectionLost/index.js');

window.domOpts = window.domOpts || require('dom-opts');

/**
 * Some of the callbacks are handled via the registered controller - addController method.
 */
var trade = function () {
    "use strict";
    // ready queue call registered call backs when trade is ready

    var cbs = [],
        server,
        registeredController = [],

    // this flag should be true if there is a stable server connection
    hasServerConnection = false,
        tryToReconnect = false,
        connectionLostUi = connectionLost({
        onReload: function onReload() {
            return location.reload();
        },
        onReconnect: function onReconnect() {
            tryToReconnect = true;
            connectionLostUi.showProgress();
            stream = shoe('/trade');
            createConnection(function (userObject, sessionsEnabled) {
                if (userObject === null) {
                    // this is the case when the session ends on server side
                    connectionLostUi.render('RECONNECT_FAIL');
                } else {
                    connectionLostUi.destroy();
                    tryToReconnect = false;
                }
            });
        },
        onClose: function onClose() {
            connectionLostUi.destroy();
        }
    });
    var stream = shoe('/trade');
    var d = void 0;

    function init(s, fc) {
        server = s;

        if (server.setUserRights) {
            server.setUserRights(canny.cookieManager.forSessionCookie('translatron_session').getValues(), fc);
        } else {
            fc({ name: 'Logout', isAdmin: true }, false);
        }

        server.attachClientCallbacks(events.serverEvents);
        // call ready queue
        cbs.map(function (cb) {
            cb && cb();
            return null;
        });
    }

    function createConnection(fc) {
        d = dnode();
        d.on('remote', function (server) {
            hasServerConnection = true;
            init(server, fc);
        });
        d.on('fail', function (err) {
            console.log(err);
            hasServerConnection = false;
            connectionLostUi.render('CONNECTION_FAIL');
        });
        d.on('error', function (err) {
            console.log(err);
            // something happens
            // e.g. a UI update throws an exception
            hasServerConnection = false;
            connectionLostUi.render('EXCEPTION', err.name);
        });
        d.on('end', function (err) {
            // this is called if the connection is closes from server
            hasServerConnection = false;
            console.error('trade:end', err);
            // the setTimeout is for avoid flickering if page reload via e.g. F5
            if (tryToReconnect) connectionLostUi.render('RECONNECT_FAIL');else setTimeout(function () {
                return connectionLostUi.render('CONNECTION_END');
            }, 1000);
        });
        d.pipe(stream).pipe(d);
    }
    /**
     * Check if connection is available - otherwise send view error
     * @returns {boolean}
     */
    function isConnected() {
        if (hasServerConnection) return true;
        connectionLostUi.render('RECONNECT');
        return false;
    }

    /**
     *
     * @param functionName the function to call
     * @param args an array of parameters which are passed to the function
     */
    function callController(functionName, args) {
        registeredController.forEach(function (controller) {
            if (controller.hasOwnProperty(functionName)) {
                try {
                    console.log('controller:', functionName);
                    controller[functionName].apply(null, args);
                } catch (e) {
                    connectionLostUi.render('FATAL', e.message);
                    console.error(e);
                }
            }
        });
    }

    return {
        initialize: function initialize(fc) {
            createConnection(fc);
        },
        addController: function addController(obj) {
            registeredController.push(obj);
        },
        /**
         * Load the whole project files with all required data (project specific json)
         * @param {string} projectId
         * @param {function} cb
         */
        loadProject: function loadProject(projectId, cb) {
            server.loadProject(projectId, function (data, _ref) {
                var id = _ref.id,
                    name = _ref.name,
                    url = _ref.url;

                if (data) {
                    // overwrite project id
                    data.projectId = id;
                    data.project = name;
                    callController('onLoadProject', [data, { id: id, name: name, url: url }]);
                    cb && cb(null, data, { id: id, name: name, url: url });
                } else {
                    // callback a error so the caller has the control about error handling
                    // TODO refactor code and make use of error object instead of false - and pass empty object to other args instead of nothing
                    cb && cb(false);
                }
            });
        },
        /**
         * actually same as saveKey but the internal controller call is different
         * @param projectId
         * @param language
         * @param keyAndValue
         * @param cb
         */
        createKey: function createKey(projectId, language, keyAndValue, cb) {
            if (isConnected()) server.saveKey(projectId, language, keyAndValue, function (err, key, value) {
                // TODO handle error case
                if (!err) {
                    cb(projectId, language, key, value);
                    callController('onCreateKey', [projectId, language, key, value]);
                }
            });
        },
        /**
         *
         * @param projectId
         * @param {{id :string, sourceCategory:string, targetCategory:string}} keyAndValue
         * @param cb
         */
        cloneKey: function cloneKey(projectId, keyAndValue, cb) {
            if (isConnected()) server.cloneKey(projectId, keyAndValue, function (err, projectId, data) {
                cb(err, projectId, data);
                callController('onKeyCloned', [projectId, data]);
            });
        },
        /**
         * Save changes to a key's value. Change will be broadcast to other clients.
         * @param {string} projectId
         * @param {string} language
         * @param {{key:string, value:string}} keyAndValue
         * @param {function} cb - callback to execute after saving
         */
        saveKey: function saveKey(projectId, language, keyAndValue, cb) {
            if (isConnected()) server.saveKey(projectId, language, keyAndValue, function (err, key, value) {
                // TODO handle error case
                if (!err) {
                    cb(projectId, language, key, value);
                }
            });
        },
        /**
         *
         * @param {string} projectName
         * @param currentDirId if of the directory in which the new project will be created
         */
        createNewProject: function createNewProject(projectName, currentDirId) {
            if (isConnected()) server.createNewProject(currentDirId, projectName, {}, function (err, projectData, project) {
                // TODO handle error case
                if (!err) {
                    callController('onNewProjectCreated', [projectData, project]);
                }
            });
        },
        /**
         *
         * @param {string} directoryName
         * @param {string} currentDirectory
         */
        createNewDirectory: function createNewDirectory(directoryName, currentDirectory) {
            if (isConnected()) server.createNewDirectory(directoryName, currentDirectory, function (err, directoryData) {
                // TODO handle error case
                if (!err) {
                    callController('onNewDirectoryCreated', [directoryData]);
                }
            });
        },
        /**
         * Renames a category.
         * @param {string} projectId
         * @param {string} oldName
         * @param {string} newName
         */
        renameCategory: function renameCategory(projectId, oldName, newName) {
            if (isConnected()) server.renameCategory(projectId, oldName, newName, function (err, oldName, newName) {
                if (!err) {
                    callController('renameCategory', [oldName, newName]);
                }
            });
        },
        /**
         * Removes a category with all it's child keys.
         * @param {string} projectId
         * @param {string} catName
         */
        removeCategory: function removeCategory(projectId, catName) {
            if (isConnected()) server.removeCategory(projectId, catName, function (err, catName) {
                if (!err) {
                    callController('removeCategory', [catName]);
                }
            });
        },
        /**
         * Renames a key for all languages
         * @param {string} projectId
         * @param {{newKey: string, oldKey: string}} obj
         */
        renameKey: function renameKey(projectId, obj) {
            if (isConnected()) server.renameKey(projectId, {
                newKey: obj.newKey,
                oldKey: obj.oldKey
            }, function (err, oldKey, newKey) {
                if (!err) {
                    callController('renameKey', [oldKey, newKey]);
                } else {
                    callController('renameKey', [false]);
                }
            });
        },
        /**
         * Removes a key for all languages.
         * @param {string} projectId
         * @param {string} keyName
         * @param {function} cb
         */
        removeKey: function removeKey(projectId, keyName, cb) {
            if (isConnected()) server.removeKey(projectId, keyName, function (err, keyName) {
                if (!err) {
                    cb(keyName);
                    callController('removeKey', [keyName]);
                }
            });
        },
        /**
         *
         * @param {string} projectId
         * @param {string} categoryName
         */
        removeImage: function removeImage(projectId, categoryName) {
            if (isConnected()) server.removeImage(projectId, categoryName, function (err, categoryName) {
                if (!err) {
                    callController('imageRemoved', [categoryName]);
                } else {
                    toast.showMessage(err.message);
                }
            });
        },
        /**
         *
         * Get the contents of the directory.
         *
         * @param dir the selected directory.
         * @param cb {projects:[String]:dirs:[String]}
         */
        getDirectory: function getDirectory(dir, cb) {
            if (isConnected()) server.getDirectory(dir, function (err, args) {
                if (err !== null) {
                    toast.showMessage('Internal server error! Please report this message to a developer: ' + err.message);
                    console.error(err.message);
                    return;
                }
                // only call the controller if not false
                cb && cb(args);
                if (args !== false) {
                    callController('getDirectory', [args]);
                }
            });
        },
        /**
         * save the project description
         * @param projectId
         * @param id
         * @param description
         * @param callback
         */
        saveProjectDescription: function saveProjectDescription(projectId, id, description, callback) {
            if (isConnected()) server.saveProjectDescription(projectId, id, description, function (err) {
                if (!err) {
                    callback && callback(true);
                    callController('savedProjectDescription', []);
                } else {
                    callback && callback(false);
                }
            });
        },
        /**
         * Move a project. Can be used for:
         *  * move project
         *  * rename project
         *
         * @param {string} id
         * @param {string} url - the new URL (optional)
         * @param {string} name - the new name (optional)
         * @param {function} cb - callback will be called
         */
        moveProject: function moveProject(_ref2, cb) {
            var id = _ref2.id,
                url = _ref2.url,
                name = _ref2.name;

            if (isConnected()) {
                server.moveProject({ id: id, url: url, name: name }, function (err, project) {
                    cb(err, project || {});
                });
            }
        },
        /**
         * TODO summarize projectName + currentDirId to one projectId
         * Delete a project.
         * @param projectName
         * @param currentDirId - @deprecated
         * @param callback
         */
        deleteProject: function deleteProject(id, cb) {
            if (isConnected()) {
                server.deleteProject(id, function (err, project) {
                    if (!err) {
                        // TODO change to: prjName
                        cb && cb(null, project);
                        callController('projectDeleted', [project]);
                    } else {
                        cb && cb(err);
                    }
                });
            }
        },
        /**
         * Delete a project.
         * @param dirName
         * @param currentDirId
         * @param callback
         */
        deleteFolder: function deleteFolder(dirName, currentDirId, callback) {
            if (isConnected()) server.deleteFolder(currentDirId, dirName, function (err, dirName) {
                if (!err) {
                    callback && callback(null, dirName);
                    callController('folderDeleted', [dirName]);
                } else {
                    callback && callback(err);
                }
            });
        },
        // Not really tested
        ready: function ready(cb) {
            if (server) {
                cb();
            } else {
                cbs.push(cb);
            }
        }
    };
}();

module.exports = trade;

},{"./events.js":18,"./uiModules/connectionLost/index.js":30,"canny":52,"dnode":63,"dom-opts":65,"shoe":80}],23:[function(require,module,exports){
"use strict";

var uiEvent = function () {
    var eventQueues = {
        activateLanguage: [],
        deActivateLanguage: [],
        addLanguage: [],
        showExportDialog: [],
        projectSelected: [],
        showOverviewPage: [],
        updateKey: [],
        anchorFocus: [],
        enableEditorMode: [],
        toggleWordCount: [],
        showFileUpload: [],
        showJMBFUploader: [],
        showJSONImport: [],
        JMBFFileUploaded: [],
        jsonImported: [],
        fileUploaded: []
    };
    return {
        addUiEventListener: function addUiEventListener(obj) {
            Object.keys(obj).forEach(function (key) {
                if (eventQueues.hasOwnProperty(key)) {
                    eventQueues[key].push(obj[key]);
                }
            });
        },
        callUievent: function callUievent(eventName, args) {
            var argsList = [].slice.call(arguments, 1, arguments.length);
            if (eventQueues.hasOwnProperty(eventName)) {
                eventQueues[eventName].forEach(function (fc) {
                    fc.apply(null, argsList);
                });
            }
        }
    };
}();

module.exports = uiEvent;

},{}],24:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    console.log('c-upload:trigger upload');
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],25:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],26:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * anchorMenu
 *
 * TODO show the actual frame:
 *  * detect which dome categories in dom are in view and add a classes to the menu ul category.
 *      * the expected effect will be look like a frame which categories are in view
 *      * first-child border-top last-child border bottom and the rest border left and right will give a frame effect
 *
 *  do it for all c-anchorMenu-parent element which could be found in view
 *
 * The anchor menu shows all elements which have the class c-anchorMenu-parent as parent and searches for children
 * with class c-anchorMenu-child. It renders a ul li list and registered a click call to throw a click event with the id.
 *
 * @type {exports}
 */
var util = require('../util/url'),
    translationViewConfig = require('./translationView').config,
    rootNode,
    parentNodeList = [],
    _onSelect = function onSelect() {},
    shrinkOffsetForViewDetection = 100,
    highlightTopMostKey = function () {

    var highlightedItem;

    /**
     * check if node is aligned top most in the browser view
     * @param obj
     */
    return function () {

        var firstOpenCategory = rootNode.querySelector('li.c-inView'),
            currentMainViewCategoryNode,
            currentMainViewCategoryChildNodes,
            mainViewTopMostKeyNode;

        if (!firstOpenCategory) {
            return;
        }

        // Reset previous highlighted item
        if (highlightedItem) {
            highlightedItem.classList.remove('c-key-highlight');
        }

        // Highlight topmost item
        currentMainViewCategoryNode = document.body.querySelector('#' + translationViewConfig.rowPrefix + firstOpenCategory.attributes.data.nodeValue.replace('anchor_', ''));
        if (currentMainViewCategoryNode) {
            currentMainViewCategoryChildNodes = currentMainViewCategoryNode.querySelectorAll('.c-anchorMenu-child');
            mainViewTopMostKeyNode = getFirstElementInViewport(currentMainViewCategoryChildNodes);
        } else {
            console.error('anchorMenu:Can\'t find the category node with id', translationViewConfig.rowPrefix + firstOpenCategory.attributes.data.nodeValue.replace('anchor_', ''));
        }

        if (mainViewTopMostKeyNode) {
            highlightedItem = rootNode.querySelector('[data=anchor_' + mainViewTopMostKeyNode.id.replace(translationViewConfig.rowPrefix, '') + ']');
            if (highlightedItem) {
                highlightedItem.classList.add('c-key-highlight');
            }
        }
    };
}();

function _focusElement(id, elem) {
    var dom;
    // handle the active class from menu
    [].slice.call(rootNode.querySelectorAll('.c-active')).forEach(function (n) {
        n.classList.remove('c-active');
    });
    elem.classList.add('c-active');
    elem.parentNode.parentNode.classList.add('c-active');
    // handle the common dom active class
    [].slice.call(document.querySelectorAll('.c-anchorMenu-focus')).forEach(function (n) {
        n.classList.remove('c-anchorMenu-focus');
    });
    dom = document.getElementById(translationViewConfig.rowPrefix + id);
    if (dom) {
        dom.classList.add('c-anchorMenu-focus');
    } else {
        console.log('anchorMenu:focusElement can\'t find element for a anchor', id);
    }
}
/**
 *
 * @param items [{id : string, children : [string]}]
 */
function addItems(root, items) {
    var ul = document.createElement('ul'),
        anchor = util.getAnchor();
    root.appendChild(ul);
    items.forEach(function (catObj) {
        var li = document.createElement('li'),
            span = document.createElement('span');
        // TODO check with log
        if ((typeof catObj === 'undefined' ? 'undefined' : _typeof(catObj)) !== 'object') {
            console.error('anchorMenu:category needs to be an object', catObj);
        }
        span.appendChild(document.createTextNode(catObj.id));
        li.appendChild(span);
        li.setAttribute('data', 'anchor_' + catObj.id);
        span.addEventListener('click', function () {
            _onSelect(catObj.id);
            _focusElement(catObj.id, li);
        });

        if (catObj.children) {
            addItems(li, catObj.children);
        }
        ul.appendChild(li);
        if ('#' + catObj.id === anchor) {
            _focusElement(catObj.id, li);
        }
    });
}

/**
 * check is the node is in the view
 * @param node
 */
function isNodeInView(node) {
    var yOffset = window.scrollY || window.pageYOffset,
        w = {
        top: yOffset,
        bottom: yOffset + window.innerHeight
    },
        bodyRect = document.body.getBoundingClientRect(),
        elemRect = node.getBoundingClientRect(),
        offset = elemRect.top - bodyRect.top + shrinkOffsetForViewDetection,
        nodeHeight = offset + node.offsetHeight - shrinkOffsetForViewDetection * 2;
    return offset > w.top && offset < w.bottom || // is top frame in view
    nodeHeight > w.top && nodeHeight < w.bottom || // is bottom frame in view
    offset < w.top && nodeHeight > w.bottom; // is top frame above view and bottom frame below view
}

function cutCategories(val) {
    var split = val.split('_');
    if (split.length > 1) {
        split.splice(0, 1);
    }
    return {
        id: val,
        value: split.join('_')
    };
}

function expandCategoriesInView() {
    parentNodeList.forEach(function (obj) {
        var li = rootNode.querySelector('[data=anchor_' + obj.id + ']');
        if (isNodeInView(obj.node)) {
            li.classList.add('c-inView');
        } else {
            li.classList.remove('c-inView');
        }
    });
}

function getFirstElementInViewport(nodes) {
    var keyNode,
        pageScrollOffset = document.body.scrollTop || document.documentElement && document.documentElement.scrollTop,
        i = nodes.length,
        nodeMargin;

    while (i--) {
        keyNode = nodes[i];
        nodeMargin = parseInt(window.getComputedStyle(keyNode, null).marginBottom, 10);
        if (getPageOffsetForElement(keyNode) - nodeMargin * 2 <= pageScrollOffset) {
            return keyNode;
        }
    }

    // Return first key node for current active category
    return nodes[0];
}

function getPageOffsetForElement(elem) {
    var bodyRect = document.body.getBoundingClientRect(),
        elemRect = elem.getBoundingClientRect();
    return elemRect.top - bodyRect.top;
}

module.exports = {
    focusElement: function focusElement(id) {
        var li = rootNode.querySelector('[data=anchor_' + id + ']');
        if (li) {
            _focusElement(id, li);
        }
    },
    onSelect: function onSelect(fc) {
        _onSelect = fc;
    },
    renderMenu: function renderMenu() {
        var catObj = [];
        // clear parent node list
        parentNodeList = [];

        [].slice.call(document.querySelectorAll('.c-anchorMenu-parent')).forEach(function (parent) {
            var id = parent.getAttribute('id'),
                children = [];
            if (id) {
                id = id.replace(translationViewConfig.rowPrefix, '');
                // collect parents
                parentNodeList.push({ node: parent, id: id });

                [].slice.call(parent.querySelectorAll('.c-anchorMenu-child')).forEach(function (child) {
                    var id = child.getAttribute('id');
                    if (id) {
                        children.push(cutCategories(id.replace(translationViewConfig.rowPrefix, '')));
                    }
                });
                catObj.push({ id: id, children: children });
            }
        });
        [].slice.call(rootNode.children).forEach(function (child) {
            child.parentNode.removeChild(child);
        });
        addItems(rootNode, catObj);
        rootNode.children[0].style.height = window.innerHeight - 125 + 'px';

        // time delayed trigger the init view
        setTimeout(function () {
            expandCategoriesInView();
            highlightTopMostKey();
        }, 1000);
    },
    add: function add(node, attr) {
        rootNode = node;
    },
    ready: function ready() {
        window.addEventListener('scroll', function (e) {
            expandCategoriesInView();
            highlightTopMostKey();
        });
        window.addEventListener('resize', function () {
            if (rootNode.children[0]) {
                rootNode.children[0].style.height = window.innerHeight - 125 + 'px';
            }
        });
        // init the menu with a time delay
        setTimeout(function () {
            expandCategoriesInView();
            highlightTopMostKey();
        }, 1500);
    }
};

},{"../util/url":46,"./translationView":41}],27:[function(require,module,exports){
'use strict';

var _onLogout = function onLogout() {
    console.log('auth:onLogout is not handled');
},
    brain = {
    logoutButton: function logoutButton(node) {
        node.addEventListener('click', _onLogout);
    }
};

module.exports = {
    onLogout: function onLogout(fc) {
        _onLogout = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr](node);
        }
    }
};

},{}],28:[function(require,module,exports){
'use strict';

var repeatFcPointer,
    _onClick = function onClick(item) {
    console.warn('breadcrumb:click handler not registered', item);
};

module.exports = {
    onClick: function onClick(fc) {
        _onClick = fc;
    },
    add: function add(node, attr) {},
    /**
     *
     * @param parentDirectories [String]
     */
    updateFolders: function updateFolders(parentDirectories) {
        repeatFcPointer(parentDirectories.map(function (item) {
            return { name: item.name, onClick: function onClick() {
                    _onClick(item.id);
                } };
        }));
    },
    /**
     * for canny repeat to get
     */
    registerCannyRepeat: function registerCannyRepeat(fc) {
        repeatFcPointer = fc;
    }
};

},{}],29:[function(require,module,exports){
module.exports = "<div class=\"connectionLost\">\n  <section>\n    <i class=\"octicon octicon-plug\"></i>\n    <h2>{{item.title}}</h2>\n    <div class=\"errorCode\"><p>Error code: <strong>{{item.errorCode}}</strong><span class=\"errorMessage\" wk-bind=\"item.errorMessage\"></span></p></div>\n    <div class=\"button-section\">\n      <button class=\"reconnect\" wk-bind=\"item.reconnect\" title=\"Try to reconnect your changes will be overwritten\">reconnect</button>\n      <button class=\"close\" wk-bind=\"item.close\" title=\"You can close this view to rescure you changes manually\">close</button>\n      <button class=\"reload\" wk-bind=\"item.reload\" title=\"If you do a page reload all your unsaved changes will be lost\">reload page</button>\n    </div>\n  </section>\n  <div class=\"progressUi\"></div>\n</div>";

},{}],30:[function(require,module,exports){
'use strict';

var whisker = require('canny/mod/whisker');
var template = require('./index.html');
var TEXTS = function TEXTS(code) {
    switch (code) {
        case 'EXCEPTION':
            return 'wow... not good - please report this problem to a developer';
        case 'FATAL':
            return 'dammed... this should not happen - please consult dev of trust';
        case 'AUTH':
            return 'Session timeout please login again';
        case 'RECONNECT_FAIL':
            return 'can\'t create a connection';
        default:
            return 'whooops... server connection lost';
    }
};
/**
 *
 * @param onReload
 * @param onReconnect
 * @returns {{render: (function(string)), destroy: (function())}}
 */
module.exports = function (_ref) {
    var onReload = _ref.onReload,
        onReconnect = _ref.onReconnect,
        onClose = _ref.onClose;

    // saves the active node
    var ui = void 0;

    function _render(_ref2) {
        var errorCode = _ref2.errorCode,
            _errorMessage = _ref2.errorMessage;

        if (ui) ui.remove();
        var d = document.createElement('div');
        d.innerHTML = template;
        whisker.add(d.children[0], {
            reconnect: function reconnect(n) {
                if (errorCode === 'RECONNECT_FAIL' || errorCode === 'FATAL' || errorCode === 'AUTH' || errorCode === 'SERVER_DOWN' || errorCode === 'EXCEPTION') return false;
                n.addEventListener('click', onReconnect);
            },
            close: function close(n) {
                return n.addEventListener('click', onClose);
            },
            reload: function reload(n) {
                return n.addEventListener('click', onReload);
            },
            errorCode: errorCode,
            title: TEXTS(errorCode),
            errorMessage: function errorMessage(n) {
                if (_errorMessage) {
                    n.innerHTML = ' ' + _errorMessage;
                } else return false;
            }
        });
        document.body.appendChild(ui = d.children[0]);
    }

    return {
        /**
         * Show the module
         * @param {string} err - error code to print on the view
         */
        render: function render(err, msg) {
            return _render({ errorCode: err, errorMessage: msg });
        },
        /**
         * Remove the module from ui
         */
        destroy: function destroy() {
            ui.remove();
            ui = undefined;
        },
        /**
         * indicates that the view is busy
         */
        showProgress: function showProgress() {
            ui.classList.add('progress');
        }
    };
};

},{"./index.html":29,"canny/mod/whisker":56}],31:[function(require,module,exports){
'use strict';

var _onCreateNewProject = function onCreateNewProject() {
    console.warn('createNewProject.onCreateNewProject not set');
},
    onCreateNewDirectory = function onCreateNewDirectory() {
    console.warn('createNewProject.onCreateNewDirectory not set');
};

var projectNameInputNode, directoryNameInputNode;

function noSpaces(node) {
    node.addEventListener('keypress', function (e) {
        var key = e.keyCode || e.which;
        if (key === 32) e.returnValue = false;
        return true;
    });
    return node;
}

function isValidProjectName(projectName) {
    return projectName.length > 0 && projectName.search('\\.|,| ') === -1 ? true : false;
}

function isValidDirectoryName(directoryName) {
    // TBD more forbidden characters?
    return directoryName.length > 0 && directoryName.search('/') === -1 ? true : false;
}

module.exports = {
    add: function add(node, attribute) {
        switch (attribute) {
            case 'createNewProjectInputProject':
                projectNameInputNode = node;
                break;
            case 'newDirectoryNameInput':
                directoryNameInputNode = noSpaces(node);
                break;
            case 'createNewProjectSubmit':
                node.addEventListener('click', function () {
                    var projectName = projectNameInputNode.value;
                    if (isValidProjectName(projectName)) {
                        _onCreateNewProject(projectName);
                    } else {
                        projectNameInputNode.classList.add('error');
                    }
                });
                break;
            case 'createNewDirectorySubmit':
                node.addEventListener('click', function () {
                    var directoryName = directoryNameInputNode.value;
                    if (isValidDirectoryName(directoryName)) {
                        onCreateNewDirectory(directoryName);
                    } else {
                        directoryNameInputNode.classList.add('error');
                    }
                });
                break;
            case 'cancel':
                node.addEventListener('click', function () {
                    canny.displayManager.hide(this.dataset.view);
                });
                break;
        }
    },
    /**
     * Pass in listener for execution of creating new project.
     * @param func
     */
    onCreateNewProject: function onCreateNewProject(func) {
        _onCreateNewProject = func;
    },
    /**
     * Pass in listener for execution of creating a new directory.
     * @param func
     */
    onCreateNewDirectoy: function onCreateNewDirectoy(func) {
        onCreateNewDirectory = func;
    }
};

},{}],32:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Overlay = require('./overlay'),
    displayManager = function displayManager() {

	var mainController = canny.flowControl,
	    overlayController = canny.flowControl.createNewInstance('overlays'),
	    children = {
		overlay: {
			ids: [],
			controller: overlayController,
			add: function add(node, id) {

				var overlay = new Overlay(node, id);
				overlay.onClick(function () {
					setDisplayStateById(id, false);
				});

				this.controller.add(overlay.node, {
					'view': overlay.id
				});
				this.ids.push(overlay.id);
			}
		},
		view: {
			ids: [],
			controller: mainController,
			add: function add(node, id) {
				this.controller.add(node, {
					'view': id
				});
				this.ids.push(id);
			}
		}
	};

	function setDisplayStateById(id, show) {
		Object.keys(children).map(function (type) {
			var pool = children[type],
			    ids = pool.ids,
			    currentId;

			for (var i = 0; i < ids.length; i++) {
				currentId = ids[i];
				if (id === currentId) {
					if (show) {
						pool.controller.show(currentId);
					} else if (pool.controller.mod[id]) {
						pool.controller.mod[id].forEach(function (obj) {
							obj.hide();
						});
					}
					break;
				}
			}
		});
	}

	return {
		add: function add(node, descriptor) {
			var keys, key;
			if ((typeof descriptor === 'undefined' ? 'undefined' : _typeof(descriptor)) === 'object') {
				keys = Object.keys(descriptor);
				for (var i = 0; i < keys.length; i++) {
					key = keys[i];
					if (children.hasOwnProperty(key)) {
						children[key].add(node, descriptor[key]);
					}
				}
			} else {
				console.warn('Parameter to add child to displayManager is not valid: ' + descriptor);
			}
		},
		show: function show(id) {
			setDisplayStateById(id, true);
		},
		hide: function hide(id) {
			setDisplayStateById(id, false);
		}

	};
};

module.exports = displayManager;

},{"./overlay":37}],33:[function(require,module,exports){
'use strict';

/**
 * handles all texts
 */
var domOpts = require('dom-opts'),
    flagMap = {
    da: 'dk',
    de: 'de',
    fr: 'fr',
    nl: 'nl',
    en: 'us',
    en_GB: 'gb',
    sv: 'se',
    es: 'es'
};

function getLang(lang) {
    var flagLang = lang;
    if (flagMap.hasOwnProperty(lang)) {
        flagLang = flagMap[lang];
    }
    return flagLang;
}

module.exports = {
    getFlag: function getFlag(lang) {
        return domOpts.createElement('span', null, 'flag-icon flag-icon-' + getLang(lang));
    },
    getFlagClasses: function getFlagClasses(lang) {
        return ['flag-icon', 'flag-icon-' + getLang(lang)];
    }
};

},{"dom-opts":65}],34:[function(require,module,exports){
'use strict';

/*global ace */
/*jslint browser: true */
var events = require('../events.js');
var C = require('../CONST.js');

window.domOpts = window.domOpts || require('dom-opts');

var imageViewer = function () {
    "use strict";

    var nodeToAppend,
        init = false,
        config = {
        idPrefix: 'imageViewer_'
    },
        setupContainerCSS = function setupContainerCSS(node, css) {
        for (var prop in css) {
            node.style[prop] = css[prop];
        }
    },
        settings = {
        maxWidth: 300,
        maxHeight: 300
    },
        fc = {
        hideImageViewer: function hideImageViewer() {
            var pres = nodeToAppend.domChildTags('img');

            if (pres.length > 0) {
                // there are other open images
                pres.forEach(function (e) {
                    e.domAddClass('hidden');
                });
            }
        },
        showImage: function showImage(obj) {
            var img,
                id = config.idPrefix + obj.id,
                actualImg = document.getElementById(id);

            if (actualImg !== null) {
                actualImg.domRemoveClass('hidden');
            } else {
                img = new Image();
                img.onload = function () {
                    console.log('DONE IMAGE');
                };
                img.src = "data:image/png;base64," + obj.data;
                setupContainerCSS(img, {
                    maxWidth: '100%',
                    maxHeight: '100%'
                });
                img.setAttribute('id', id);
                img.domAppendTo(nodeToAppend);
            }
        }
    };

    events.addServerListener('sendFile', function (obj) {
        if (init) {
            fc.hideImageViewer();

            if (obj.fileType === C.FILE_MANAGER.FILE_TYPES.IMAGE) {
                fc.showImage(obj);
            }
        }
    });

    return {
        add: function add(node, attr) {
            init = true;
            nodeToAppend = node;
            nodeToAppend.setAttribute('id', 'imageViewer');

            setupContainerCSS(nodeToAppend, {
                width: settings.maxWidth + 'px',
                height: settings.maxHeight + 'px'
            });
        },
        setup: function setup(config) {
            var obj;
            for (obj in config) {
                settings[obj] = config[obj];
            }
        }
    };
}();

module.exports = imageViewer;

},{"../CONST.js":2,"../events.js":18,"dom-opts":65}],35:[function(require,module,exports){
'use strict';

function addEdit(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button edit octicon octicon-pencil');
    div.addEventListener('click', function (event) {
        node.classList.add('c-edit');
        fc(event);
    });
    div.setAttribute('title', 'edit');
    node.appendChild(div);
}
function addCancel(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button cancel octicon octicon-x');
    div.addEventListener('click', function (event) {
        node.classList.remove('c-edit');
        fc(event);
    });
    div.setAttribute('title', 'cancel');
    node.appendChild(div);
}

function addSave(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button save octicon octicon-check');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'save changes');
    node.appendChild(div);
}

function addClone(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button save octicon octicon-file-symlink-file');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'move key into other category');
    node.appendChild(div);
}

function addDelete(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button delete octicon octicon-trashcan');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'remove this key');
    node.appendChild(div);
}

function closeEditorView(keyInputNode) {
    var editorPanelNode = keyInputNode.parentNode.querySelector('.inputEditManager.wrap');
    if (editorPanelNode) {
        editorPanelNode.classList.remove('c-edit');
    }
}

module.exports = {
    /**
     * each key input node hast
     * @param keyInputNode
     */
    closeEditView: function closeEditView(keyInputNode) {
        if (keyInputNode) {
            closeEditorView(keyInputNode);
        }
    },
    addEditorPanel: function addEditorPanel(keyNode, listeners) {
        var containerNode = domOpts.createElement('div', null, 'inputEditManager wrap');

        if (listeners.hasOwnProperty('onEdit')) {
            addEdit(containerNode, listeners.onEdit);
        }
        if (listeners.hasOwnProperty('onDelete')) {
            addDelete(containerNode, listeners.onDelete);
        }
        if (listeners.hasOwnProperty('onSave')) {
            addSave(containerNode, listeners.onSave);
        }
        if (listeners.hasOwnProperty('onClone')) {
            addClone(containerNode, listeners.onClone);
        }
        if (listeners.hasOwnProperty('onCancel')) {
            addCancel(containerNode, listeners.onCancel);
        }

        containerNode.domAppendTo(keyNode);

        return containerNode;
    },
    removePanel: function removePanel(node) {
        node.querySelector('.inputEditManager.wrap').domRemove();
    }
};

},{}],36:[function(require,module,exports){
'use strict';

var rootNode;

module.exports = {
    show: function show() {
        rootNode.classList.add('c-show');
    },
    hide: function hide() {
        rootNode.classList.remove('c-show');
    },
    add: function add(node, attr) {
        if (attr === 'button') {
            node.addEventListener('click', function () {
                if (rootNode.classList.contains('c-show')) {
                    rootNode.classList.remove('c-show');
                } else {
                    rootNode.classList.add('c-show');
                }
            });
        } else {
            rootNode = node;
        }
    }
};

},{}],37:[function(require,module,exports){
'use strict';

module.exports = function Overlay(node, id) {

	var id = id,
	    node = node,
	    clickHandler = function clickHandler() {
		console.warn('Click listener not attached for overlay with id: ' + id);
	};

	node.classList.add('displayManager-overlay');
	node.addEventListener('click', function (e) {
		if (node === e.target) {
			clickHandler();
		}
	});

	return {
		id: id,
		node: node,
		onClick: function onClick(cb) {
			clickHandler = cb;
		}
	};
};

},{}],38:[function(require,module,exports){
'use strict';

/*global */
/*jslint browser: true*/

var canny = require('canny'),
    flag = require('./flag'),
    texts = require('./texts');

/**
 * E.g.: canny-mod="flowControl" canny-var="{'view' : 'viewToShow'}"
 *
 * you can activate a initial view with a anchor in the URL e.g.: yourdomain.html#viewToShow
 * Or pass a comma separated module list for activate more module #viewToShow,otherView
 *
 * TODO made it possible to summarize views with one identifier.
 * Instead of call: gdom.flowControl.show('view1', 'view2', 'view3') call gdom.flowControl.show('view').
 */
var projectMainNavigation = function () {
    "use strict";

    var mainNode,
        selectLanguageQueue = [],
        onShowJSONQueue = [],
        onEnableEditorModeQueue = [],
        onToggleWordCountQueue = [],
        onShowJMBFQueue = [],
        onShowJMBFUploaderQueue = [],
        onShowJSONImportQueue = [],
        bundleName = window.domOpts.params.bundle,
        modViews = {
        main: function main(node) {
            mainNode = node;
        },
        menuToggleButton: function menuToggleButton(node) {
            new svgIcon(node, {
                hamburgerCross: {
                    url: '/dist/animatedSVG/svg/hamburger.svg',
                    animation: [{
                        el: 'path:nth-child(1)',
                        animProperties: {
                            from: { val: '{"path" : "m 5.0916789,20.818994 53.8166421,0"}' },
                            to: { val: '{"path" : "M 12.972944,50.936147 51.027056,12.882035"}' }
                        }
                    }, {
                        el: 'path:nth-child(2)',
                        animProperties: {
                            from: { val: '{"transform" : "s1 1", "opacity" : 1}', before: '{"transform" : "s0 0"}' },
                            to: { val: '{"opacity" : 0}' }
                        }
                    }, {
                        el: 'path:nth-child(3)',
                        animProperties: {
                            from: { val: '{"path" : "m 5.0916788,42.95698 53.8166422,0"}' },
                            to: { val: '{"path" : "M 12.972944,12.882035 51.027056,50.936147"}' }
                        }
                    }]
                }
            }, {
                easing: mina.elastic, speed: 1200, size: { w: '4em', h: '3em' }
            });
            node.addEventListener('click', function () {
                if (mainNode.classList.contains('c-open')) {
                    mainNode.classList.remove('c-open');
                } else {
                    mainNode.classList.add('c-open');
                }
            });
        },
        showResourceBundleEditor: function showResourceBundleEditor(node) {
            // reload the page because the files are not synced
            node.setAttribute('href', '#');
            node.addEventListener('click', function () {
                location.reload();
            });
        },
        showMessageBundleFormat: function showMessageBundleFormat(node) {
            node.addEventListener('click', function () {
                onShowJMBFQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJSONBundle: function showJSONBundle(node) {
            node.addEventListener('click', function () {
                onShowJSONQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJMBFUploader: function showJMBFUploader(node) {
            node.addEventListener('click', function () {
                onShowJMBFUploaderQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJSONImport: function showJSONImport(node) {
            node.addEventListener('click', function () {
                onShowJSONImportQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        enableEditorMode: function enableEditorMode(node) {
            node.addEventListener('click', function () {
                onEnableEditorModeQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        toggleWordCount: function toggleWordCount(node) {
            node.addEventListener('click', function () {
                onToggleWordCountQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        from: function from(node) {
            this.from.node = node;
        },
        to: function to(node) {
            this.to.node = node;
        }
    };

    /**
     *
     * @param locales []
     * @param node
     */
    function setLocale(locales, node) {
        var ul = node.querySelector('.languages'),
            li,
            languageNameNode,
            progressNode,
            flagIC;
        if (ul) {
            // remove all existing children first
            [].slice.call(ul.querySelectorAll('li')).forEach(function (elem) {
                ul.removeChild(elem);
            });
        } else {
            ul = window.domOpts.createElement('ul', null, 'navigationMenu languages');
        }
        locales.forEach(function (key) {
            var numOfTransKeys = window.domOpts.createElement('span', null, 'numOfTransKeys'),
                maxKeyNode = window.domOpts.createElement('span', null, 'maxKey');
            li = window.domOpts.createElement('li');
            languageNameNode = window.domOpts.createElement('span');
            progressNode = window.domOpts.createElement('span', null, 'progress');
            numOfTransKeys.appendChild(document.createTextNode('-'));
            numOfTransKeys.domAppendTo(progressNode);
            progressNode.appendChild(document.createTextNode('/'));
            maxKeyNode.appendChild(document.createTextNode('-'));
            maxKeyNode.domAppendTo(progressNode);

            li.classList.add('lang');
            li.classList.add(key);

            li.addEventListener('click', function () {
                var isInactive = true,
                    isActive = this.classList.contains('c-active');

                if (isActive) {
                    this.classList.toggle('c-inactive');
                    isInactive = this.classList.contains('c-inactive');
                } else {
                    // has no state
                }

                selectLanguageQueue.forEach(function (fc) {
                    fc({
                        isActive: isActive,
                        isInactive: isInactive,
                        project: bundleName,
                        language: key
                    });
                });
            });

            languageNameNode.innerHTML = texts.getLanguageNames(key);
            languageNameNode.className = 'langName';
            languageNameNode.domAppendTo(li);
            progressNode.domAppendTo(li);
            flagIC = flag.getFlag(key);
            flagIC.classList.add('icon', 'octicon', 'octicon-plus');
            flagIC.domAppendTo(li);
            li.domAppendTo(ul);
        });
        ul.domAppendTo(node);
    }

    /**
     * update all language max keys for all languages
     * @param keys
     * @param node
     */
    function updateMaxKeys(keys, node) {
        [].slice.call(node.querySelectorAll('.languages .lang')).forEach(function (langNode) {
            langNode.querySelector('.maxKey').innerHTML = keys;
        });
    }

    /**
     * update a specific language
     * @param key
     * @param lang
     * @param node
     */
    function updateNumberOfLangKeys(key, lang, node) {
        console.log('projectMainNavigation:updateNumberOfLangKeys', key, lang);
        node.querySelector('.languages .lang.' + lang + ' .numOfTransKeys').innerHTML = key;
    }

    return {
        setNumberOfTranslationMaxKeys: function setNumberOfTranslationMaxKeys(maxKeys) {
            updateMaxKeys(maxKeys, modViews.from.node);
        },
        setNumberOfTranslatedLanguageKey: function setNumberOfTranslatedLanguageKey(numberOfKeys, lang) {
            updateNumberOfLangKeys(numberOfKeys, lang, modViews.from.node);
        },
        onLanguageSelect: function onLanguageSelect(fc) {
            selectLanguageQueue.push(fc);
        },
        onShowJSON: function onShowJSON(fc) {
            onShowJSONQueue.push(fc);
        },
        onShowJMBF: function onShowJMBF(fc) {
            onShowJMBFQueue.push(fc);
        },
        onShowJMBFUploader: function onShowJMBFUploader(fc) {
            onShowJMBFUploaderQueue.push(fc);
        },
        onShowJSONImport: function onShowJSONImport(fc) {
            onShowJSONImportQueue.push(fc);
        },
        onEnableEditorMode: function onEnableEditorMode(fc) {
            onEnableEditorModeQueue.push(fc);
        },
        onToggleWordCount: function onToggleWordCount(fc) {
            onToggleWordCountQueue.push(fc);
        },
        activateLang: function activateLang(lang) {
            var node = mainNode.querySelector('li.' + lang);
            node.classList.remove('c-inactive');
            node.classList.add('c-active');
        },
        deActivateLang: function deActivateLang(lang) {
            var node = mainNode.querySelector('li.' + lang);
            node.classList.add('c-inactive');
        },
        /**
         * Apply the current project's number to the flags: activate flag where translations exist and show number of
         * translated keys.
         * @param keysTotal the total number of keys
         * @param translatedKeysPerLang the number of translated keys per language
         */
        setActivatedProjectLanguages: function setActivatedProjectLanguages(keysTotal, translatedKeysPerLang) {
            [].slice.call(mainNode.querySelectorAll('li')).forEach(function (node) {
                var progressNode = node.querySelector('.progress');
                node.classList.remove('c-active');
                if (progressNode) {
                    progressNode.children[0].innerHTML = "-";
                    progressNode.children[1].innerHTML = "-";
                }
            });

            Object.keys(translatedKeysPerLang).forEach(function (key) {
                [].slice.call(mainNode.querySelectorAll('li.' + key)).forEach(function (node) {
                    var progressNode = node.querySelector('.progress');
                    node.classList.add('c-active');
                    if (progressNode) {
                        progressNode.children[0].innerHTML = translatedKeysPerLang[key];
                        progressNode.children[1].innerHTML = keysTotal;
                    }
                });
            });
        },
        setAvailableLanguages: function setAvailableLanguages(languages) {
            setLocale(languages, modViews.from.node);
        },
        ready: function ready() {
            console.log('nav-controller ready event');
        },
        add: function add(node, attr) {
            // part of api
            if (modViews.hasOwnProperty(attr)) {
                modViews[attr](node);
            } else {
                console.log('LINK NOT IMPLEMENTED');
            }
        }
    };
}();

module.exports = projectMainNavigation;

},{"./flag":33,"./texts":40,"canny":52}],39:[function(require,module,exports){
'use strict';

var projectOverview = function () {
    'use strict';

    var componentRootNode,
        renderProjectsAndDirectoriesList,
        _onCreateProjectPressed = function onCreateProjectPressed() {
        console.warn('projectOverview.onCreateProjectPressed not set');
    },
        _onParentDirectorySelected = function onParentDirectorySelected() {
        console.warn('projectOverview.onParentDirectorySelected not set');
    },
        _onProjectSelected = function onProjectSelected() {
        console.warn('projectOverview.onProjectSelected not set');
    },
        _onDeleteProjectPressed = function onDeleteProjectPressed() {
        console.warn('projectOverview.onDeleteProjectPressed not set');
    },
        onMovedProjectPressed = function onMovedProjectPressed() {
        console.warn('projectOverview.onMovedProjectPressed not set');
    },
        _onDeleteFolderPressed = function onDeleteFolderPressed() {
        console.warn('projectOverview.onDeleteFolderPressed not set');
    },
        _onDirectorySelected = function onDirectorySelected() {
        console.warn('projectOverview.onDirectorySelected not set');
    },
        _onCreateDirectoryPressed = function onCreateDirectoryPressed() {
        console.warn('projectOverview.onCreateDirectoryPressed not set');
    },
        editModeEnabled = false;

    return {
        /**
         * Called from canny when registering components. The only component which we expect to be registered is
         * "projectOverviewContainer" (the root node of the component).
         * @param node
         * @param vars
         */
        add: function add(node, attr) {
            if (componentRootNode === undefined) {
                componentRootNode = node;
            } else {
                console.warn('projectOverview:add multiple views detected - it should be registered only ones in the DOM!');
            }
        },
        /**
         * Called from canny on documentReady event.
         */
        ready: function ready() {

            var createProjectButtonNode = componentRootNode.querySelector('.js-createProjectButton');
            if (!createProjectButtonNode) {
                console.error('No child node with class "createProjectButton found inside "projectOverviewContainer"');
            } else {
                createProjectButtonNode.addEventListener('click', function (event) {
                    _onCreateProjectPressed();
                });
            }

            var createFolderButtonNode = componentRootNode.querySelector('.js-createFolderButton');
            if (!createFolderButtonNode) {
                console.error('No child node with class "createFolderButton found inside "projectOverviewContainer"');
            } else {
                createFolderButtonNode.addEventListener('click', function (event) {
                    _onCreateDirectoryPressed();
                });
            }

            var toggleEditModeButtonNode = componentRootNode.querySelector('.js-toggleEditModeButton');
            if (!toggleEditModeButtonNode) {
                console.error('No child node with class "createFolderButton found inside "projectOverviewContainer"');
            } else {
                toggleEditModeButtonNode.addEventListener('click', function (event) {
                    editModeEnabled = !editModeEnabled;
                    componentRootNode.classList.toggle('editMode-enabled', editModeEnabled);
                    toggleEditModeButtonNode.classList.toggle('active', editModeEnabled);
                });
            }

            var selectParentDirectoryButton = componentRootNode.querySelector('.js-selectParentDirectoryButton');
            if (!selectParentDirectoryButton) {
                console.error('No child node with class "selectParentDirectoryButton" found inside "projectOverviewContainer"');
            } else {
                selectParentDirectoryButton.addEventListener('click', function (event) {
                    _onParentDirectorySelected();
                });
            }
        },
        /**
         * Inform the ui module about the new current set of directories and projects to list. This will also trigger
         * a new rendering of the projects list with the new content.
         * @param projectNames
         * @param directoryNames
         */
        setProjectsAndDirectories: function setProjectsAndDirectories(projectNames, directoryNames) {
            var projectsAndDirectories = [];

            if (!projectNames || !directoryNames) {
                return;
            } else if (!renderProjectsAndDirectoriesList) {
                console.error('renderProjectsAndDirectoriesList function has not been set, new list cannot be shown');
                return;
            }

            console.log('got projects', projectNames);
            console.log('got directories', directoryNames);

            projectNames.forEach(function (projectName) {
                projectsAndDirectories.push({
                    name: projectName,
                    dir: false,
                    openProjectListItem: function openProjectListItem() {
                        console.log('project selected:', projectName);
                        if (_onProjectSelected) {
                            _onProjectSelected(projectName);
                        }
                    },
                    deleteProjectListItem: function deleteProjectListItem() {
                        var deletionConfirmed = window.confirm('Really delete project ' + projectName + '?');
                        if (_onDeleteProjectPressed && deletionConfirmed) {
                            _onDeleteProjectPressed(projectName);
                        }
                    },
                    moveProject: function moveProject() {
                        onMovedProjectPressed(projectName);
                    }
                });
            });
            directoryNames.forEach(function (directoryName) {
                projectsAndDirectories.push({
                    name: directoryName,
                    dir: true,
                    openProjectListItem: function openProjectListItem() {
                        console.log('directory selected:', directoryName);
                        if (_onDirectorySelected) {
                            _onDirectorySelected(directoryName);
                        }
                    },
                    deleteProjectListItem: function deleteProjectListItem() {
                        var deletionConfirmed = window.confirm('Really delete folder ' + directoryName + '?');
                        if (_onDeleteFolderPressed && deletionConfirmed) {
                            _onDeleteFolderPressed(directoryName);
                        }
                    }
                });
            });

            renderProjectsAndDirectoriesList(projectsAndDirectories);
        },
        /**
         * For canny-repeat registered on the projects list, provide the function for rendering the list.
         * @param func a function which will set the list of projects and directories.
         */
        setRenderProjectsAndDirectoriesListFunction: function setRenderProjectsAndDirectoriesListFunction(func) {
            renderProjectsAndDirectoriesList = func;
        },
        deleteProjectListNode: function deleteProjectListNode(itemName) {
            var node = componentRootNode.querySelector('tr[data-listItem=' + itemName + ']');
            if (node && node.parentNode) {
                node.parentNode.removeChild(node);
            }
        },
        /**
         * Register a listener callback which will react to "to parent directory" event.
         * @param listener
         */
        onParentDirectorySelected: function onParentDirectorySelected(listener) {
            _onParentDirectorySelected = listener;
        },
        /**
         * Register a listener callback which will react to clicks on a project. The callback function should expect
         * one parameter which is the project name.
         * @param listener
         */
        onProjectSelected: function onProjectSelected(listener) {
            _onProjectSelected = listener;
        },
        /**
         * Register a listener callback which will react to clicks on a directory. The callback function should expect
         * one parameter which is the directory name.
         * @param listener
         */
        onDirectorySelected: function onDirectorySelected(listener) {
            _onDirectorySelected = listener;
        },
        onCreateProjectPressed: function onCreateProjectPressed(func) {
            _onCreateProjectPressed = func;
        },
        onDeleteProjectPressed: function onDeleteProjectPressed(func) {
            _onDeleteProjectPressed = func;
        },
        onDeleteFolderPressed: function onDeleteFolderPressed(func) {
            _onDeleteFolderPressed = func;
        },
        onCreateDirectoryPressed: function onCreateDirectoryPressed(func) {
            _onCreateDirectoryPressed = func;
        },
        onMoveDirectoryPressed: function onMoveDirectoryPressed(func) {
            onMovedProjectPressed = func;
        }
    };
}();

module.exports = projectOverview;

},{}],40:[function(require,module,exports){
'use strict';

/**
 * handles all texts
 */
var texts = function () {
    'use strict';

    var node,
        languageNames = {
        da: 'Danmark',
        de: 'Deutschland',
        fr: 'France',
        nl: 'Nederland',
        en: 'United States (Default)',
        en_GB: 'United Kingdom',
        sv: 'Sverige',
        es: 'Espanol'
    },
        texts = {
        changeTexts: function changeTexts() {},
        data: {
            projectName: '',
            projectDescription: ''
        }
    };

    return {
        getLanguageNames: function getLanguageNames(key) {
            return languageNames[key];
        },
        setTexts: function setTexts(data) {
            texts.changeTexts('msg', data);
        },
        getTexts: function getTexts(fc) {
            console.log('texts:yes text is triggered');
            texts.changeTexts = fc;
            texts.changeTexts('msg', texts.data);
        },
        add: function add(elem, attr) {
            node = elem;
        },
        ready: function ready() {
            console.log('texts ready!');
        }
    };
}();

module.exports = texts;

},{}],41:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var flag = require('./flag.js'),
    inputEditManager = require('./inputEditManager.js'),
    wordCounter = require('../util/wordCounter'),
    displayManager = require('canny').displayManager,
    conf = {
    rowPrefix: "tv_",
    inputPrefix: "keyValue_",
    inputTransPrefix: "trans_"
},
    catPrefix = 'tv_';
/**
 * Rename all DOM id attributes from old to new key
 * @param oldKey
 * @param newKey
 */
function renameDOMIds(oldKey, newKey, availableLanguages) {
    Object.keys(conf).forEach(function (prop) {
        var node;
        if (prop === 'inputTransPrefix') {
            availableLanguages.forEach(function (lang) {
                node = document.getElementById(getLanguageTextId(oldKey, lang));
                if (node) {
                    node.setAttribute('id', getLanguageTextId(newKey, lang));
                } else {
                    console.error('translationView:renameIds can not find dom node for id', getLanguageTextId(newKey, lang));
                }
            });
        } else {
            node = document.getElementById(conf[prop] + oldKey);
            if (node) {
                node.setAttribute('id', conf[prop] + newKey);
            } else {
                console.error('translationView:renameIds can not find dom node for id', conf[prop] + oldKey, 'property:', prop);
            }
        }
    });
}

function textAreaKeyPressListener(e) {
    var key = e.keyCode || e.which;
    // TODO allow enter - it's useful for formatting a text - but it's a mess for all other
    if (key === 13) {
        e.returnValue = false;
    }
    return true;
}

function keyKeyPressListener(e) {
    var key = e.keyCode || e.which;
    if (key === 32) {
        e.returnValue = false;
    }
    return true;
}

function validateNewKey(string) {
    return string.length > 0 && string.search('\\.|,| ') === -1 ? true : false;
}

function getLanguageTextId(key, lang) {
    return conf.inputTransPrefix + [key, lang].join('_');
}

function getWordCountText(count) {
    return 'Words: ' + count;
}

/**
 * Count only letters
 * @param value
 */
function getCharacterCount(value) {
    while (/{.*?}/.test(value)) {
        value = value.replace(/{.*?}/, '');
    }return [].concat(_toConsumableArray(value)).filter(function (char) {
        return (/[a-zA-z]/.test(char)
        );
    }).length;
}

function getWordCountHeadline(category) {
    return 'Overall words in ' + category;
}

function createWordCountForLanguage(lang) {
    var countWrapper = domOpts.createElement('div', null, 'data js_' + lang),
        flagClass = flag.getFlagClasses(lang).pop(),
        wordCountLabel = domOpts.createElement('span', null, 'wordCountLabel '.concat(flagClass));
    wordCountLabel.innerHTML = getWordCountText(0);
    countWrapper.appendChild(wordCountLabel);
    return countWrapper;
}

/**
 * handle the translation overview
 * TODO refactor base.connection
 */
var translationView = function () {
    'use strict';

    /**
     * TODO remove project name - only the controller needs to know this
     *
     * @param {HTMLElement} node
     * @param {string} key - @deprecated
     * @param {string} lang
     * @param {string} text
     *
     * @class
     */

    function SaveOnLeave(node, key, lang, text) {
        var textList = [text],
            textIdx = 0;

        /**
         *
         * @param {HTMLElement} node
         * @returns {string} the key id
         */
        function getIdFromRow(node) {
            return node.parentNode.parentNode.parentNode.getAttribute('id').replace(conf.rowPrefix, '');
        }

        node.addEventListener('change', function (e) {
            console.log("Old: " + textList[textIdx]);
            var newValue = this.value;
            if (textList[textIdx] !== newValue) {
                textList.push(newValue);
                textIdx++;
            }
            console.log(textList);
            _onSaveKey && _onSaveKey(getIdFromRow(node), lang, newValue);
        });
    }

    /**
     * Clean up the attached event listeners and removes them from the node.
     * It removes the 'change' and 'keypress' event from all textArea's and input fields and
     * set it to "read only"
     *
     * @param {HTMLElement} rowNode
     */
    function removeEventListenersFromRow(rowNode) {
        [].slice.call(rowNode.querySelectorAll('textarea')).forEach(function (tarea) {
            tarea.removeEventListener('change', false);
            tarea.setAttribute('readonly', 'true');
        });

        [].slice.call(rowNode.querySelectorAll('input')).forEach(function (input) {
            input.removeEventListener('keypress', false);
            input.setAttribute('readonly', 'true');
        });
    }

    /**
     *
     * @param {HTMLElement} catNodeToInsert
     * @param {Array<HTMLElement>} catNodes
     */
    function insertCategory(catNodeToInsert, catNodes) {
        var catToAppendID = catNodeToInsert.id.toLowerCase(),
            shownCatNode,
            shownCatID;

        for (var i = 0; i < catNodes.length; i++) {
            shownCatNode = catNodes[i];
            shownCatID = catNodes[i].id.toLowerCase();
            if (catToAppendID < shownCatID) {
                rootNode.insertBefore(catNodeToInsert, shownCatNode);
                break;
            }
        }

        if (catNodes.length === 0 || catToAppendID > shownCatID) {
            rootNode.appendChild(catNodeToInsert);
        }
    }

    var rootNode,
        // main node all content are added to here
    renderTextFc,
        selectors = {
        root: "resourceBundleTable",
        debug: "debugIncomming",
        tpl: {
            tableBody: 'tableBody'
        }
    },

    // QUESTION: are these real queues?
    onQueues = {
        addNewKey: [],
        createNewProject: [],
        removeKey: [],
        renameKey: [],
        categoryClicked: [],
        removeCategory: [],
        renameCategory: []
    },
        ui = {
        css: {
            sendSuccess: 'sendSuccess',
            updateKey: 'updateKey'
        },
        /**
         *
         * @param key
         * @param inputPrefix
         */
        sendSuccess: function sendSuccess(key, inputPrefix) {
            var node1 = document.getElementById(conf.rowPrefix + key),
                node2 = document.getElementById(inputPrefix + key);
            if (node1) {
                ui.removeStateClasses(node1).classList.remove(ui.css.sendSuccess);
                setTimeout(function () {
                    ui.removeStateClasses(node1).classList.add(ui.css.sendSuccess);
                }, 100);
            }
            if (node2) {
                ui.removeStateClasses(node2).classList.remove(ui.css.sendSuccess);
                setTimeout(function () {
                    ui.removeStateClasses(node2).classList.add(ui.css.sendSuccess);
                }, 100);
            }
        },
        updateInputFields: function updateInputFields(key, inputPrefix) {
            console.error('translationView:updateInputFields', 'is this still in use????????????????????????????????????');
            debugger;
            var node = document.getElementById(inputPrefix + key);
            if (node) {
                ui.removeStateClasses(node).domAddClass(ui.css.updateKey);
            }
        },
        removeStateClasses: function removeStateClasses(node) {
            var cssState,
                classes = '';
            if (!node) {
                return;
            }
            // TODO refactor Object.keys()
            for (cssState in ui.css) {
                classes += cssState + ' ';
            }
            node.domRemoveClass(classes);
            return node;
        }
    },

    /**
     * Callback (registered from controller) to be called when changes to a key must be saved
     */
    _onSaveKey = function onSaveKey() {
        console.warn('translationView:onSaveKey not initialized');
    },
        _onCreateKey = function onCreateKey() {
        console.warn('translationView:onCreateKey not initialized');
    },
        _onCloneKey = function onCloneKey() {
        console.warn('translationView:onCloneKey not initialized');
    },
        brain = {
        cloneKeyOverlay: {
            init: function init(node) {
                this.node = node;
            },
            setData: function setData(data) {
                this.data = data;
                renderTextFc('cloneKeyOverlayText', {
                    keyName: data.keyName,
                    categoryName: data.contextName
                });
            },
            getData: function getData() {
                return this.data;
            }
        },
        cloneKeyInputCategory: {
            init: function init(node) {
                this.node = node;
            }
        },
        cloneKeyButtonSubmit: {
            init: function init(node) {
                node.addEventListener('click', function () {
                    if (brain.cloneKeyInputCategory.node.value.length === 0) {
                        brain.cloneKeyInputCategory.node.classList.add('error');
                        return;
                    }
                    var data = brain.cloneKeyOverlay.getData();
                    _onCloneKey(data.key, data.keyName, data.contextName, brain.cloneKeyInputCategory.node.value);
                });
            }
        },
        createNewProjectInputProject: {
            init: function init(node) {
                this.node = node;
            }
        },
        createNewProjectProjectDescription: {
            init: function init(node) {
                this.node = node;
            }
        },
        createNewProjectSubmit: function () {
            var node;
            return {
                init: function init(elem) {
                    node = elem;
                    node.addEventListener('click', function () {
                        var projectValue = brain.createNewProjectInputProject.node.value;

                        if (validateNewKey(projectValue)) {
                            // TODO read description field
                            onQueues.createNewProject.forEach(function (fc) {
                                fc(projectValue, {
                                    description: brain.createNewProjectProjectDescription.node.value
                                });
                            });
                            // TODO check if closed is needed?
                            displayManager.hide('createNewProjectView');
                        } else {
                            // TODO replace with classes
                            brain.createNewProjectInputProject.node.style.backgroundColor = '#ff4444';
                        }
                    });
                }
            };
        }(),
        projectShow: {
            init: function init(node) {
                node.addEventListener('click', function () {
                    displayManager.show('translationViewProjectCategoryKey');
                });
            }
        },
        projectInputCategory: {
            init: function init(node) {
                this.node = node;
            }
        },
        projectInputKey: {
            init: function init(node) {
                this.node = node;
            }
        },
        cancel: function () {
            return {
                init: function init(node) {
                    node.addEventListener('click', function () {
                        canny.displayManager.hide(this.dataset.view);
                    });
                }
            };
        }(),
        projectSubmit: function () {
            var node;
            return {
                init: function init(elem) {
                    node = elem;
                    node.addEventListener('click', function () {
                        var categoryKey = brain.projectInputCategory.node.value,
                            key = brain.projectInputKey.node.value,
                            newKey;

                        if (validateNewKey(categoryKey) && validateNewKey(key)) {
                            // TODO default language
                            newKey = categoryKey + '_' + key;
                            _onCreateKey(newKey);
                        } else {
                            // TODO replace with classes
                            brain.projectInputCategory.node.classList.add('error');
                            brain.projectInputKey.node.classList.add('error');
                        }
                    });
                }
            };
        }()
    },
        fc = {
        /**
         *
         * @returns {{rowPrefix: string, inputPrefix: string, inputTransPrefix: string}}
         */
        get config() {
            return conf;
        },
        enableEditorMode: function enableEditorMode(enable) {
            if (enable) {
                rootNode.classList.add('c-enableEditorMode');
            } else {
                rootNode.classList.remove('c-enableEditorMode');
            }
        },
        toggleWordCount: function toggleWordCount(enable) {
            rootNode.classList.toggle('c-wordCountEnabled', enable);
        },
        sendSuccess: ui.sendSuccess,
        add: function add(node, attr) {
            if (attr === 'main') {
                rootNode = node;
            } else if (brain.hasOwnProperty(attr)) {
                brain[attr].init(node);
            }
        },
        getViewKeyObject: function getViewKeyObject(obj) {
            var newKey,
                contextName = null,
                delimiter = '_';
            if (/\./.test(obj.key)) {
                delimiter = '.';
            }

            newKey = obj.key.split(delimiter);

            if (newKey.length > 1) {
                // use slice if we need the complete key in the view
                contextName = newKey.splice(0, 1)[0];
            }
            return {
                id: obj.key, // deprecated
                key: obj.key,
                contextName: contextName,
                keyName: newKey.join(delimiter),
                value: obj.value
            };
        },
        isBundleEqual: function isBundleEqual(bundle1, bundle2) {
            if (bundle1.bundle === bundle2.bundle && bundle1.locale === bundle2.locale) {
                return true;
            }
            return false;
        },
        getBundleNameFrom: function getBundleNameFrom() {

            return {
                bundle: domOpts.params.bundle || 'messages',
                locale: this.getFromParam()
            };
        },
        getFromParam: function getFromParam() {
            return domOpts.params.from || 'de';
        },
        getBundleNameTo: function getBundleNameTo() {

            return {
                bundle: domOpts.params.bundle || 'messages',
                locale: domOpts.params.to || null
            };
        },
        getBundleName: function getBundleName(locale) {
            var bundle = domOpts.params.bundle || 'messages';
            return bundle + '_' + locale;
        },
        /**
         * Render the i18n input field for keys from a single language. The row header (i.e. the actual key field) is
         * rendered, too if it does not exist yet.
         * @param bundles {key: string, data: string}
         * @param actualLanguage
         * @param availableProjectLanguages
         * @param projectName
         */
        printBundleTemplate: function printBundleTemplate(bundles, actualLanguage, availableProjectLanguages, cb) {
            var keyObj,
                projectNode,
                shownCategories = [].slice.call(rootNode.querySelectorAll('.categoryNode'));
            /**
             * Setup header and handle the category
             *
             * @param {string} contextName
             * @returns {HTMLElement}
             */
            function prepareCategoryNode(contextName, languages) {
                var categoryNode = document.getElementById(conf.rowPrefix + contextName);
                if (!categoryNode) {
                    categoryNode = document.querySelector('#templates .categoryNode').cloneNode(true);
                    categoryNode.classList.add('c-anchorMenu-parent');
                    var categoryName = contextName;
                    var categoryNodeId = categoryName;
                    categoryNode.setAttribute('id', conf.rowPrefix + categoryNodeId);
                    if (categoryName) {
                        var wrapper = categoryNode.querySelector('.headlineWrapper'),
                            h2 = categoryNode.querySelector('h2');
                        // TODO make a span for it
                        h2.appendChild(function () {
                            var span = document.createElement('span');
                            span.appendChild(document.createTextNode(categoryName));
                            span.className = 'keyName';
                            return span;
                        }());
                        h2.addEventListener('click', function (event) {
                            onQueues.categoryClicked.forEach(function (fc) {
                                fc(categoryNodeId);
                            });
                        });

                        var editPanel = inputEditManager.addEditorPanel(categoryNode, {
                            onEdit: function onEdit(event) {
                                event.stopImmediatePropagation();
                                keyInputNode.removeAttribute('disabled');
                                contextName = keyInputNode.value;
                                keyInputNode.focus();
                            },
                            onCancel: function onCancel(event) {
                                event.stopImmediatePropagation();
                                keyInputNode.setAttribute('disabled', 'true');
                                keyInputNode.value = contextName;
                            },
                            onSave: function onSave(event) {
                                event.stopImmediatePropagation();
                                onQueues.renameCategory.forEach(function (fc) {
                                    fc({
                                        oldName: contextName,
                                        newName: keyInputNode.value
                                    });
                                });
                            },
                            onDelete: function onDelete(event) {
                                event.stopImmediatePropagation();
                                var yes = window.confirm('Delete this category?\nAll keys within with will be lost.');
                                if (yes) {
                                    onQueues.removeCategory.forEach(function (fc) {
                                        fc({
                                            category: categoryName
                                        });
                                    });
                                }
                            }
                        });
                        wrapper.appendChild(editPanel);

                        var keyInputNode = domOpts.createElement('input', conf.rowPrefix + categoryName + '_input', 'categoryField');
                        keyInputNode.setAttribute('disabled', 'true');
                        keyInputNode.addEventListener('click', function (event) {
                            event.stopImmediatePropagation();
                        });
                        keyInputNode.addEventListener('keypress', keyKeyPressListener);
                        h2.appendChild(keyInputNode);
                        keyInputNode.value = categoryName;

                        // add the description functionality
                        var catDescNode = categoryNode.querySelector('.js-cat-description');
                        var span = document.createElement('span');
                        span.className = 'js-text';
                        catDescNode.appendChild(span);
                        if (catDescNode) {
                            canny.textEditor.add(catDescNode, {
                                id: categoryName,
                                placeholder: 'Add here the category description'
                            });
                            canny.translationViewImageUpload.add(categoryNode.querySelector('.js-imageUpload-editButton'), categoryName);
                        }
                        // add add key input field and button
                        var keyNameInput = categoryNode.querySelector('.addNewKeyrow input');
                        keyNameInput.setAttribute('category', categoryName);
                        keyNameInput.addEventListener('keypress', keyKeyPressListener);
                        categoryNode.querySelector('label').innerText = categoryName + "_";
                        var button = categoryNode.querySelector('button');
                        button.addEventListener('click', function () {
                            if (validateNewKey(keyNameInput.value)) {
                                var newKey = keyNameInput.getAttribute('category') + '_' + keyNameInput.value;
                                // TODO refactor this - server should add the key for all available languages - or pass default lang
                                _onCreateKey(newKey, actualLanguage);
                            } else {
                                button.style.color = '#ff0000';
                                keyNameInput.style.backgroundColor = "#ff4444";
                            }
                        });
                    }

                    // add overall word count for each language of a category
                    var overallWordsWrapper = categoryNode.querySelector('.overallWordCountWrapper'),
                        overallHeadline = overallWordsWrapper.querySelector('.overallWordsHeadline'),
                        countersWrapper = overallWordsWrapper.querySelector('.translationContainer');
                    overallHeadline.innerHTML = getWordCountHeadline(categoryName);
                    languages.forEach(function (lang) {
                        countersWrapper.appendChild(createWordCountForLanguage(lang));
                    });
                }
                return categoryNode;
            };

            bundles.forEach(function (data) {
                keyObj = fc.getViewKeyObject(data);
                // TODO which who calc the cate...
                projectNode = prepareCategoryNode(keyObj.contextName, availableProjectLanguages);
                insertCategory(projectNode, shownCategories);
                fc.addRowWithLanguages(projectNode, keyObj, actualLanguage, availableProjectLanguages);
                cb(projectNode.getAttribute('id').replace(conf.rowPrefix, ''));
                cb(keyObj.key);
            });
        },
        /**
         * Update the word count for a given category
         * @param data
         */
        updateCategoryWordCount: function updateCategoryWordCount(data) {
            var label = document.querySelector('#' + conf.rowPrefix + data.id + ' .overallWordCountWrapper .js_' + data.language + ' .wordCountLabel');
            if (label) {
                label.innerHTML = getWordCountText(data.words);
            }
        },
        /**
         * creates a key field
         *
         * @param node
         * @param data
         */
        addKeyField: function addKeyField(node, data) {
            var keyInputNode = document.getElementById(conf.inputPrefix + data.key),
                keyNode;
            if (!keyInputNode) {
                keyInputNode = domOpts.createElement('input', conf.inputPrefix + data.key, 'keyField');
                keyNode = domOpts.createElement('div', null, 'data key octicon octicon-key');
                keyInputNode.setAttribute('disabled', 'true');
                inputEditManager.addEditorPanel(keyNode, {
                    onDelete: function onDelete() {
                        var yes = window.confirm('Delete this key?\nThis key with all translations will removed.');
                        if (yes) {
                            onQueues.removeKey.forEach(function (fc) {
                                fc({
                                    key: data.key
                                });
                            });
                        }
                    },
                    onEdit: function onEdit() {
                        keyInputNode.removeAttribute('disabled');
                        // save actual key for restoring if cancel
                        data.keyName = keyInputNode.value;
                        // get the key: take id attribute and remove the value from it
                        data.key = keyInputNode.getAttribute('id').replace(conf.inputPrefix, '');
                        data.contextName = data.key.split('_')[0];
                        keyInputNode.focus();
                    },
                    onCancel: function onCancel() {
                        keyInputNode.setAttribute('disabled', 'true');
                        keyInputNode.value = data.keyName;
                    },
                    onSave: function onSave() {
                        console.log('translationView:addKeyField save new key');
                        var value = data.contextName ? data.contextName + '_' + keyInputNode.value : keyInputNode.value;
                        if (keyInputNode.value != '' && value != data.key) {
                            onQueues.renameKey.forEach(function (fc) {
                                fc({
                                    newKey: value,
                                    oldKey: data.key
                                });
                            });
                        }
                    },
                    onClone: function onClone() {
                        brain.cloneKeyOverlay.setData(data);
                        displayManager.show('translationViewCloneKey');
                    }
                });
                // register the input key listener to capture wrong character
                keyInputNode.addEventListener('keypress', keyKeyPressListener);
                keyNode.appendChild(function () {
                    var span = document.createElement('span');
                    span.appendChild(document.createTextNode(data.keyName));
                    span.className = 'keyName';
                    return span;
                }());

                keyNode.appendChild(keyInputNode);
                node.insertBefore(keyNode, node.children[0]);
                keyInputNode.value = data.keyName;
            }
        },
        /**
         * Call this to update/create a language field
         * @param node
         * @param key
         * @param value
         * @param lang
         * @param wordCount
         */
        addLanguageField: function addLanguageField(node, key, value, lang, wordCount) {

            var textNode = document.getElementById(getLanguageTextId(key, lang)),
                dataNode,
                wordCountNode,
                charCountNode,
                textInformationNode;

            if (!textNode) {
                textNode = domOpts.createElement('textarea', getLanguageTextId(key, lang), 'textField');
                dataNode = domOpts.createElement('div', null, 'data tpl js_' + lang);
                textInformationNode = domOpts.createElement('div', null, 'textInformation');
                wordCountNode = domOpts.createElement('span', null, 'textInformation-wordCountLabel');
                charCountNode = domOpts.createElement('span', null, 'textInformation-charCountLabel');
                wordCountNode.innerHTML = getWordCountText(0);

                textInformationNode.appendChild(flag.getFlag(lang));
                textInformationNode.appendChild(wordCountNode);
                textInformationNode.appendChild(charCountNode);

                textNode.addEventListener('keyup', function () {
                    charCountNode.innerHTML = getCharacterCount(this.value);
                    wordCountNode.innerHTML = getWordCountText(wordCounter.countWordsInString(this.value));
                });

                textNode.addEventListener('keypress', textAreaKeyPressListener);
                textNode.setAttribute('type', 'text');

                new SaveOnLeave(textNode, key, lang, value);

                dataNode.appendChild(textNode);
                dataNode.appendChild(textInformationNode);

                node.appendChild(dataNode);
            } else {
                wordCountNode = textNode.parentElement.querySelector('.textInformation-wordCountLabel');
                charCountNode = textNode.parentElement.querySelector('.textInformation-charCountLabel');
            }

            if (value || value === '') {
                textNode.value = value ? unicode.encode(value) : '';
                wordCountNode.innerHTML = getWordCountText(wordCounter.countWordsInString(value));
                charCountNode.innerHTML = getCharacterCount(value);
            }
        },
        /**
         * creates a row
         * @param {HTMLElement} node
         * @param {string} key
         * @returns {HTMLElement} the existing row or in case if not exists a new created row
         */
        getRow: function getRow(node, key) {
            // try to get the row
            var row = document.getElementById(conf.rowPrefix + key),
                translationContainer = row !== null ? row.querySelector('.translationContainer') : document.createElement('div');

            translationContainer.className = "translationContainer";

            // if there is a row but it is marked as removed than removed it
            if (row && row.classList.contains('c-removed')) {
                row.domRemove();
                row = undefined;
            }
            // create a row if the row is not exists
            if (!row) {
                row = domOpts.createElement('div', conf.rowPrefix + key, 'row c-row c-anchorMenu-child');
                // add the description functionality
                var catDescNode = document.createElement('div');
                var span = document.createElement('span');
                span.className = 'js-text';
                catDescNode.appendChild(span);
                catDescNode.className = 'js-row-description';
                row.appendChild(catDescNode);
                canny.textEditor.add(catDescNode, { id: key, placeholder: 'Add here the key description' });

                // add the translation area field container
                row.appendChild(translationContainer);
                node.querySelector('.keysWrapper').appendChild(row);
            }
            return row;
        },
        addRowWithLanguages: function addRowWithLanguages(node, data, actualLanguage, allProjectLanguages) {
            var row = fc.getRow(node, data.key);

            fc.addKeyField(row, data);

            allProjectLanguages.forEach(function (lang) {
                fc.addLanguageField(row.querySelector('.translationContainer'), data.key, actualLanguage === lang ? data.value : null, lang);
            });
        },
        addLanguage: function addLanguage(keys, lang) {
            var row,
                categories = [],
                currentCategory;
            keys.forEach(function (key) {
                row = document.getElementById(conf.rowPrefix + key);
                if (row) {
                    fc.addLanguageField(row.querySelector('.translationContainer'), key, null, lang, 0);

                    currentCategory = key.split('_')[0];
                    if (categories.indexOf(currentCategory) === -1) {
                        categories.push(currentCategory);
                    }
                } else {
                    console.log('translationView:addLanguage found key which is not available in view:', key);
                }
            });

            categories.forEach(function (category) {
                var overallWordCount = document.querySelector('#' + conf.rowPrefix + category + ' .overallWordCountWrapper .translationContainer');
                overallWordCount.appendChild(createWordCountForLanguage(lang));
            });
        },
        clearView: function clearView() {
            // just reset all for now
            // TODO do it better ;)
            [].slice.call(rootNode.children).forEach(function (child) {
                rootNode.removeChild(child);
            });
        },
        showLang: function showLang(lang) {
            // show the lang tab
            rootNode.classList.remove('c-hide_' + lang);
        },
        /**
         * remove a category
         * TODO it's not called if own user renames a category
         */
        renameCategory: function renameCategory(oldName, newName, availableProjectLanguages) {
            var categoryNode = document.getElementById(conf.rowPrefix + oldName),
                rows = categoryNode.querySelectorAll('.c-row'),
                headline = categoryNode.querySelector('h2'),
                addKeyNode = categoryNode.querySelector('.addNewKeyrow');

            categoryNode.id = conf.rowPrefix + newName;

            headline.querySelector('.keyName').childNodes[0].nodeValue = newName;

            addKeyNode.querySelector('label').innerHTML = newName + '_';
            addKeyNode.querySelector('input').setAttribute('category', newName);

            [].slice.call(rows).forEach(function (row) {
                var id = row.id.replace(conf.rowPrefix, ''),
                    splitName = id.split('_'),
                    newKeyName;

                splitName.shift();
                newKeyName = newName + '_' + splitName.join('_');
                if (id !== '') {
                    renameDOMIds(id, newKeyName, availableProjectLanguages);
                } else {
                    console.error('translationView:renameCategory should not hav an empty id', row);
                }
            });
            inputEditManager.closeEditView(headline);
            headline.querySelector('.categoryField').setAttribute('disabled', 'true');
        },
        /**
         * remove a category
         */
        removeCategory: function removeCategory(cat) {
            var row = document.getElementById(conf.rowPrefix + cat);
            if (row) {
                row.domRemove();
            }
        },
        /**
         * show a key as deleted
         * @param key
         */
        markKeyAsRemoved: function markKeyAsRemoved(key) {
            var row = document.getElementById(conf.rowPrefix + key),
                removeIc;
            if (row && !row.classList.contains('c-removed')) {
                row.classList.add('c-removed');
                removeIc = domOpts.createElement('div', null, 'remove-button octicon octicon-x');
                removeIc.addEventListener('click', function () {
                    row.domRemove();
                });
                removeIc.domAppendTo(row);
                removeEventListenersFromRow(row);
                inputEditManager.removePanel(row);
            } else {
                console.error('translationView:markkeyAsRemoved no node found for key', key, row);
            }
        },
        /**
         * remove a key
         */
        removeKey: function removeKey(key) {
            var row = document.getElementById(conf.rowPrefix + key);
            if (row) {
                row.domRemove();
            }
        },
        /**
         * rename a key
         *
         * @param oldKey
         * @param newKey
         * @param availableProjectLanguages []
         */
        renameKey: function renameKey(oldKey, newKey, availableProjectLanguages) {
            var keyInputNode = document.getElementById(conf.inputPrefix + oldKey),
                keyName;

            if (keyInputNode) {
                keyName = fc.getViewKeyObject({ key: newKey }).keyName;
                renameDOMIds(oldKey, newKey, availableProjectLanguages);
                keyInputNode.value = keyName;
                // close the edit view
                inputEditManager.closeEditView(keyInputNode);
                // disabled the input field
                keyInputNode.setAttribute('disabled', 'true');
                keyInputNode.parentNode.querySelector('.keyName').childNodes[0].nodeValue = keyName;
            }
        },
        removeImage: function removeImage(categoryName) {
            var imageBox = rootNode.querySelector('#' + conf.rowPrefix + categoryName + ' .imageUpload-imageBox');
            while (imageBox.firstChild) {
                imageBox.removeChild(imageBox.firstChild);
            }
            imageBox.classList.remove('c-show');
        },
        hideLang: function hideLang(lang) {
            rootNode.classList.add('c-hide_' + lang);
        },
        onCreateNewProject: function onCreateNewProject(cb) {
            onQueues.createNewProject.push(cb);
        },
        onCategoryClicked: function onCategoryClicked(cb) {
            onQueues.categoryClicked.push(cb);
        },
        onAddNewKey: function onAddNewKey(cb) {
            onQueues.addNewKey.push(cb);
        },
        onRenameKey: function onRenameKey(cb) {
            onQueues.renameKey.push(cb);
        },
        onRemoveKey: function onRemoveKey(cb) {
            onQueues.removeKey.push(cb);
        },
        onRemoveCategory: function onRemoveCategory(cb) {
            onQueues.removeCategory.push(cb);
        },
        onRenameCategory: function onRenameCategory(cb) {
            onQueues.renameCategory.push(cb);
        },
        /**
         * Set logic for handling saving changes to a key.
         * @param func
         */
        onSaveKey: function onSaveKey(func) {
            _onSaveKey = func;
        },
        /**
         * Set logic for handling saving changes to a key.
         * @param func
         */
        onCreateKey: function onCreateKey(func) {
            _onCreateKey = func;
        },
        onCloneKey: function onCloneKey(func) {
            _onCloneKey = func;
        },
        registerWhisker: function registerWhisker(fc) {
            renderTextFc = fc;
        }
    };
    return fc;
}();

module.exports = translationView;

},{"../util/wordCounter":47,"./flag.js":33,"./inputEditManager.js":35,"canny":52}],42:[function(require,module,exports){
'use strict';

var node;
module.exports = {
    add: function add(elem, attr) {
        node = elem;
    },
    addDescriptions: function addDescriptions(keyDescriptions) {
        Object.keys(keyDescriptions).forEach(function (key) {
            var parent = document.getElementById(key),
                child;
            if (parent) {
                child = parent.querySelector('.js-text');
                if (child) {
                    child.innerHTML = keyDescriptions[key];
                }
            }
        });
    }
};

},{}],43:[function(require,module,exports){
'use strict';

/**
 * is for the translation view to add the image upload button and show the images
 */
var rootNode,
    _onUploadButton = function onUploadButton() {
    console.warn('translationViewImageUpload::onUploadButton() not implemented.');
},
    _onDeleteButton = function onDeleteButton() {
    console.warn('translationViewImageUpload::onDeleteButton() not implemented.');
};

function uploadButton(id) {
    var node = document.createElement('div');
    node.className = 'upload-btn octicon octicon-cloud-upload';
    node.addEventListener('click', function () {
        _onUploadButton(id);
    });
    node.setAttribute('title', 'upload a image file');
    return node;
}

function editPanel(id) {
    var deleteBtn = document.createElement('div'),
        editBtn = document.createElement('div'),
        cancelBtn = document.createElement('div'),
        panelWrap = document.createElement('div');

    panelWrap.className = 'imageUpload-imageBox-editPanel';
    editBtn.className = 'edit-btn octicon octicon-pencil';
    editBtn.addEventListener('click', function () {
        panelWrap.classList.add('c-edit');
    });
    cancelBtn.className = 'cancel-btn octicon octicon-x';
    cancelBtn.addEventListener('click', function () {
        panelWrap.classList.remove('c-edit');
    });
    deleteBtn.className = 'delete-btn octicon octicon-trashcan';
    deleteBtn.addEventListener('click', function () {
        _onDeleteButton(id);
    });

    deleteBtn.setAttribute('title', 'remove image');
    cancelBtn.setAttribute('title', 'cancel');
    editBtn.setAttribute('title', 'edit');

    panelWrap.appendChild(editBtn);
    panelWrap.appendChild(cancelBtn);
    panelWrap.appendChild(deleteBtn);
    return panelWrap;
}

function getImage(file) {
    var img = new Image();
    img.src = file;
    img.addEventListener('click', function () {
        var win = window.open(file, '_blank');
        win.focus();
    });
    return img;
}

function addImageContent(id, img) {
    var node = document.createElement('div'),
        resizeAble = document.createElement('div');
    resizeAble.className = 'imageUpload-imageBox-resizeable';
    node.className = 'imageUpload-imageBox-content';
    resizeAble.appendChild(img);
    node.appendChild(resizeAble);
    node.appendChild(editPanel(id));
    return node;
}

module.exports = {
    onUploadButton: function onUploadButton(fc) {
        _onUploadButton = fc;
    },
    onDeleteButton: function onDeleteButton(fc) {
        _onDeleteButton = fc;
    },
    add: function add(node, attr) {
        node.appendChild(uploadButton(attr));
    },
    appendImage: function appendImage(id, url) {
        var dom = document.getElementById('tv_' + id),
            imgContainer;
        if (dom) {
            imgContainer = dom.querySelector('.js-imageUpload-box');
            if (imgContainer) {
                [].slice.call(imgContainer.children).forEach(function (n) {
                    n.remove();
                });
                imgContainer.classList.add('c-show');
                imgContainer.appendChild(addImageContent(id, getImage('/images' + url)));
            }
        }
    }
};

},{}],44:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    console.log('c-upload:trigger upload');
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],45:[function(require,module,exports){
'use strict';

var unicode = function () {

    String.prototype.getEachChar = function (cb) {
        var newString = this;
        for (var i = 0; i < newString.length; i++) {
            newString[i] = cb(newString[i]);
        }
        return newString.toString();
    };
    var reg = new RegExp('\\\\u([0-9a-fA-F]{4})', "g");
    return {
        encode: function encode(string) {
            if (!string) {
                return '';
            }
            var newstring = string.replace(reg, function (match, submatch) {
                return String.fromCharCode(parseInt(submatch, 16));
            });
            return newstring;
        },
        decode: function decode(string) {
            return string.getEachChar(function (c) {
                for (var i = 0; i < table.length; i++) {
                    if (table[i] == c) {
                        console.log('found:' + table[i]);
                        return table[i];
                    }
                }
                return c;
            });
        }

    };
}();

module.exports = unicode;

var table = ['\xC0', '\xC1', '\xC2', '\xC3', '\xC4', '\xC5', '\xC6', '\xC7', '\xC8', '\xC9', '\xCA', '\xCB', '\xCC', '\xCD', '\xCE', '\xCF', '\xD0', '\xD1', '\xD2', '\xD3', '\xD4', '\xD5', '\xD6', '\xD8', '\xD9', '\xDA', '\xDB', '\xDC', '\xDD', '\xDE', '\xDF', '\xE0', '\xE1', '\xE2', '\xE3', '\xE4', '\xE5', '\xE6', '\xE7', '\xE8', '\xE9', '\xEA', '\xEB', '\xEC', '\xED', '\xEE', '\xEF', '\xF0', '\xF1', '\xF2', '\xF3', '\xF4', '\xF5', '\xF6', '\xF8', '\xF9', '\xFA', '\xFB', '\xFC', '\xFD', '\xFE', '\xFF'];

},{}],46:[function(require,module,exports){
'use strict';

function getAnchor() {
    var href = location.href;
    if (/#/.test(href)) {
        return '#' + location.href.replace(/.*#/, '');
    }
    return '';
}

module.exports = {
    getAnchor: getAnchor,
    hasAnchor: function hasAnchor() {
        return getAnchor() !== '';
    }
};

},{}],47:[function(require,module,exports){
'use strict';

var regExPunc = new RegExp(/[\.,\s!;?:\"]+/gi);

/**
 * Count amount of words in a given String
 * @param str
 * @returns Number
 */
module.exports.countWordsInString = function countWordsInString(str) {
    if (str) {
        return str.replace(regExPunc, ' ').trim().split(' ').length;
    }
    return 0;
};

},{}],48:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],49:[function(require,module,exports){

},{}],50:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":48,"ieee754":67}],51:[function(require,module,exports){
/*global base.cookieHandler, canny */

(function () {
    var DEFAULT_LIFETIME_AS_DAYS = 365 * 5,
        DEFAULT_PATH = '/';

    var cookieManager = {};

    /**
     * A cookie manager for handling cookies where the cookie value is a JSON-stringified object.
     *
     * For creating a session cookie (i.e. deleted when browser closes), add a null-valued domain property to
     * cookieAttributes.
     *
     * @param cookieName
     * @param cookieAttributes: an optional object where the properties are attributes of the cookie - expireDays,
     * domain, path (if any of those is left out defaults will be used).
     * @returns {{cookieName, store: store, storeAll: storeAll, getValue: getValue, getValues: getValues}}
     * @constructor
     */
    var CookieManager = function(cookieName, cookieAttributes) {

        var lifetimeAsDays = (function() {
            if (cookieAttributes && cookieAttributes.expireDays) {
                return cookieAttributes.expireDays;
            } else if (cookieAttributes && cookieAttributes.expireDays === null) {
                return null;
            } else {
                return DEFAULT_LIFETIME_AS_DAYS;
            }
        })();
        var domain = cookieAttributes && cookieAttributes.domain ?
            cookieAttributes.domain : cookieManager.computeCookieDomain(document.location.hostname, false);
        var path = cookieAttributes && cookieAttributes.path ?
            cookieAttributes.path : DEFAULT_PATH;

        function getCookieValues(cookieName) {
            var i, currentName, currentValue, decodedValue,
                allCookies = window.document.cookie.split(";"),
                cookieValue = {};
            for (i = 0; i < allCookies.length; i++) {
                currentName = allCookies[i].substr(0, allCookies[i].indexOf("="));
                currentName = currentName.replace(/^\s+|\s+$/g, "");
                if (currentName === cookieName) {
                    currentValue = allCookies[i].substr(allCookies[i].indexOf("=") + 1);
                    try {
                      cookieValue = JSON.parse(decodeURIComponent(currentValue));
                    } catch (err) {
                      cookieValue = decodeURIComponent(currentValue);
                    }

                }
            }
            return cookieValue;
        }

        function computeNewExpiryDateString() {
            var expiryDate = new Date();
            expiryDate.setDate(expiryDate.getDate() + lifetimeAsDays);
            return expiryDate.toUTCString();
        }

        /**
         * Update the *full* value of the cookie, incl. writing all other cookie attributes according to
         * configuration of cookie manager.
         * @param cookieValue an object where each own property is an entry in the cookie value.
         */
        function updateCookie(cookieValue) {
            var cookieParts = [
                cookieName + '=' + encodeURIComponent(JSON.stringify(cookieValue)),
                'path=' + path,
                'domain=' + domain
            ];
            if (lifetimeAsDays) {
                cookieParts.push('expires=' + computeNewExpiryDateString());
            }

            window.document.cookie = cookieParts.join(';');
        }

        /**
         * Merge new values into existing/old values.
         * @param newCookieValues an object holding all new cookie value entries (entries may already exist
         * in existingCookieValues)
         * @param existingCookieValues an object holding all existing cookie value entries.
         * @returns {*}
         */
        function mergeNewIntoOldValues(newCookieValues, existingCookieValues) {
            Object.keys(newCookieValues).forEach(function (key) {
                existingCookieValues[key] = newCookieValues[key];
            });
            return existingCookieValues;
        }

        function updateCookieValues(cookieValues) {
            var oldCookieValue = getCookieValues(cookieName);
            if (Object.keys(oldCookieValue).length === 0) {
                updateCookie(cookieValues);
            } else {
                updateCookie(mergeNewIntoOldValues(cookieValues, oldCookieValue));
            }
        }

        function isValidCookieValueEntries(entries) {
            return typeof entries === 'object' && Object.prototype.toString.call( entries ) !== '[object Array]';
        }

        return {
            get cookieName() { return cookieName; },
            /**
             *
             * @param key a key (String)
             * @param value a value, can be any type of object (incl. nested). value can be a JSON string but will
             *     *not*  be parsed.
             */
            store : function(key, value) {
                var newValue = {};
                newValue[key] = value;
                updateCookieValues(newValue);
            },
            /**
             *
             * @param entries an object where all own properties will be added to the cookie value (rules for values
             * from store function apply here as well). Existing entries will be overwritten. No object encoded as
             * Json string accepted, no Arrays either.
             */
            storeAll : function(entries) {
                if (!isValidCookieValueEntries(entries)) {
                    throw new TypeError('cookieManager.storeAll accepts only objects (incl. no arrays), parameter was "'
                        + entries + '"');
                }
                updateCookieValues(entries);
            },
            /**
             * Get the value of a single entry from the cookie.
             * @param key
             * @returns {*}
             */
            getValue : function(key) {
                return getCookieValues(cookieName)[key];
            },
            /**
             * Get all entries (as an object) from the cookie.
             * @returns {*}
             */
            getValues : function() {
                return getCookieValues(cookieName);
            }
            // if needed, add remove(key) and removeAll(keys) functions to the api
        };
    };

    /**
     * Factory function which produces a cookie manager for the given cookie name and config.
     * @param cookieName
     * @param cookieAttributes: see constructor documentation
     * @returns {CookieManager}
     */
    cookieManager.forCookie = function(cookieName, cookieAttributes) {
        return new CookieManager(cookieName, cookieAttributes);
    };

    /**
     *
     * @param cookieName the name of the cookie
     * @param cookieAttributes attributes of the cookie (but note that expires attributes cannot be overwritten, it will
     * be added to that object)
     * @returns {CookieManager}
     */
    cookieManager.forSessionCookie = function(cookieName, cookieAttributes) {
        cookieAttributes = cookieAttributes || {};
        cookieAttributes['expireDays'] = null;
        return new CookieManager(cookieName, cookieAttributes);
    };

    /**
     * Convenience factory function which produces a cookie manager for the standard GD cookie.
     * @param cookieAttributes: see constructor documentation
     * @returns {CookieManager}
     */
    cookieManager.forGDStandardCookie = function () {
        // TODO what is the name of the standard cookie?
        return new CookieManager('GD');
    };

    /**
     * Extracts the cookie domain from the given hostname.
     * @param hostname
     * @param includeSubDomains if true all subdomains will be omitted
     */
    cookieManager.computeCookieDomain = function(hostname, includeSubDomains) {
        if (hostname.indexOf('gameduell') !== -1 && !includeSubDomains) {
            var hostnameParts = hostname.split('.');
            for (var i = 0; i < hostnameParts.length; i++) {
                if (hostnameParts[i] === "gameduell") {
                    // some infos about the leading dot:
                    // http://stackoverflow.com/questions/9618217/what-does-the-dot-prefix-in-the-cookie-domain-mean
                    // tl;dr: an obsolete RFC defined that a domain with a leading dot would mean "allow for
                    // subdomains, too" IE8/9 are still affected. Others should just disregard the dot (as per newer
                    // RFC)
                    return '.' + hostnameParts.splice(i).join('.');
                }
            }
        }

        return hostname;
    };

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = cookieManager;
    } else {
        canny.add('cookieManager', cookieManager);
    }

}());

},{}],52:[function(require,module,exports){
/*global */
/*jslint browser: true*/
/**
 *
 * E.g.:
 *  canny-mod="moduleObj" canny-var="{'propertyKey':'value'}"
 *  canny-mod="moduleString" canny-var="button"
 *
 * Instead of canny-var you can use the module name to avoid conflicts like:
 * E.g.: canny-mod="mod1 mod2" canny-mod1={'foo':'123456', 'bar':'654321'} canny-mod2="mod2Property"
 *
 * ---------------------------------------------------------------------------- eightyfour
 */
(function (global) {
    "use strict";
    var canny = (function () {
        var readyQueue = [],
            readyQueueInit = false,
            moduleQueue = []; // save modules to call the ready method once

        /**
         * Find the single quotes and replace them with double quotes except string which
         * are part of the property string.
         *
         * @param string
         * @returns {string}
         */
        function escapeStringForJSON(string) {
            var s = string
                .replace(/\{\s*\'/g,'{"').replace(/\'\s*\}/g,'"}')
                .replace(/:\s*\'/g,':"').replace(/\'\s*:/g,'":')
                .replace(/,\s*\'/g,',"').replace(/\'\s*,/g,'",')
                .replace(/\[\s*\'/g,'["').replace(/\'\s*\]/g,'"]');
            return s;
        }

        function escapeStringForJSONArray(string) {
            var s = string
                .replace(/,\s*\'/g,',"').replace(/\'\s*,/g,'",')
                .replace(/\[\s*\'/g,'["').replace(/\'\s*\]/g,'"]');
            return s;
        }

        function callMethodQueue(queue) {
            (function reduce() {
                var fc = queue.pop();
                if (fc) {
                    fc();
                    reduce();
                } else {
                    queue = [];
                }
            }());
        }

        function parseNode(node, name, cb) {
            var that = this, gdModuleChildren = [].slice.call(node.querySelectorAll('[' + name + '-mod]')), prepareReadyQueue = {};

            gdModuleChildren.forEach(function (node) {
                var attribute = node.getAttribute(name + '-mod'), attr, viewPart, attributes, cannyVar;

                attributes = attribute.split(' ');

                attributes.forEach(function (moduleName) {
                    if (that[moduleName]) {
                        if (node.getAttribute(name + '-mod')) {
                            if (node.getAttribute(name + '-' + moduleName)) {
                                cannyVar = node.getAttribute(name + '-' + moduleName);
                            } else {
                                cannyVar = node.getAttribute(name + '-var');
                            }
                            if (cannyVar) {
                                // simple JSON test
                                if (/\{\s*\'|\".*:.*\}/.test(cannyVar)) {
                                    attr = escapeStringForJSON(cannyVar);
                                    // could be a JSON
                                    try {
                                        viewPart = JSON.parse(attr);
                                    } catch (ex) {
                                        console.error("canny can't parse passed JSON for module: " + moduleName, node);
                                    }
                                } else if (/\[\s*\'|\".*\'|\"\]/.test(cannyVar)) {
                                    attr = escapeStringForJSONArray(cannyVar);
                                    try {
                                        viewPart = JSON.parse(attr);
                                    } catch (ex) {
                                        console.error("canny can't parse passed JSON for module: " + moduleName, node);
                                    }
                                } else {
                                    viewPart = cannyVar;
                                }
                            }
                        }
                        // has module a ready function than save it for calling
                        if (that[moduleName].hasOwnProperty('ready')) {
                            // TODO or call it immediately?
                            prepareReadyQueue[moduleName] = that[moduleName].ready;
                        }
                        if (that.hasOwnProperty(moduleName)) {
                            that[moduleName].add(node, viewPart);
                        }
                    } else {
                        console.warn('canny parse: module with name ´' + moduleName + '´ is not registered');
                    }
                });
            });
            // add ready callback to moduleQueue
            Object.keys(prepareReadyQueue).forEach(function (name) {
                moduleQueue.push(prepareReadyQueue[name]);
            });
            cb && cb();
        }

        document.addEventListener('DOMContentLoaded', function cannyDomLoad() {
            document.removeEventListener('DOMContentLoaded', cannyDomLoad);

            parseNode.apply(canny, [document, 'canny']);

            callMethodQueue(moduleQueue);
            // call registered ready functions
            readyQueueInit = true;
            callMethodQueue(readyQueue);
        }, false);

        return {
            add : function (name, module) {
                var moduleApi = module;
                if (!this.hasOwnProperty(name)) {
                    if (typeof module === 'function') {
                        moduleApi = module(this); // initialize the module with the actual canny instance
                    }
                    this[name] = moduleApi;
                } else {
                    console.error('canny: Try to register module with name ' + name + ' twice');
                }
            },
            ready : function (fc) {
                if (!readyQueueInit) {
                    readyQueue.push(fc);
                } else {
                    fc();
                }
            },
            cannyParse : function (node, name, cb) {
                // TODO needs a callback
                if (typeof name === 'function') {
                    cb = name;
                    name = "canny";
                }
                parseNode.apply(this || canny, [node, name || 'canny', function () {
                    callMethodQueue(moduleQueue);
                    cb && cb();
                }]);
            }
        };
    }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) { module.exports = canny; } else {global.canny = canny; }
}(this));
},{}],53:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * Required: 'canny' in global scope
 *
 * E.g.:
 * canny.async.load(URL, function (src) {
 *     node.innerHTML = src;
 *     // trigger canny parse to register canny on our new modules
 *     canny.cannyParse(node, function () {
 *         console.log('CANNY PARSE DONE');
 *     });
 * });
 *
 * Alternative you can just use loadHTML (scripts will automatically added and parsed by canny):
 * canny.async.loadHTML(node, {url : URL}, function () {
 *     console.log('kodos_load READY');
 * });
 *
 * Or directly as canny module:
 * <div canny-mod="async" canny-var="{'url':'/you/HTML/file.html'}"></div>
 *
 * TODO solve dependency problem to canny.
 *
 */
(function () {
    'use strict';
    var async = (function () {
        var filesToLoad = [],
            pushLoadCBs = [],
            ready = false;

        /**
         *
         * @param script
         * @param mediaURL
         * @param cb
         */
        function appendScript(script, mediaURL, cb) {
            var node = document.createElement('script'),
                src = script.getAttribute('src');
            // handle mediaURL and all relative script are loaded from the media URL string
            if (mediaURL && src[0] !== '/') {
                if (mediaURL[mediaURL.length - 1] !== '/') {
                    mediaURL += '/';
                }
                src = mediaURL + src;
            }
            node.type = "text/javascript";
            node.async = true;
            node.setAttribute('src', src);
            node.addEventListener('load', cb, false);
            node.addEventListener('error', cb, true);
            document.head.appendChild(node);
        }

        /**
         *
         * @param scripts
         * @param mediaURL
         * @param cb
         */
        function appendScriptsToHead(scripts, mediaURL, cb) {
            var script, i, includesScripts = false,
                scriptCounter = (function () {
                    var count = 0;
                    return {
                        up : function () {count++; },
                        ready : function () {
                            count--;
                            if (count <= 0) {
                                cb();
                            }
                        }
                    };
                }());

            for (i = 0; i < scripts.length; i++) {
                script = scripts[i];
                if (script.getAttribute('src')) {
                    includesScripts = true;
                    scriptCounter.up();
                    appendScript(script, mediaURL, scriptCounter.ready);
                } else {
                    console.warn('async: found inline script tag!!!');
                }
            }

            if (scripts.length === 0 || includesScripts === false) {
                cb();
            }

        }

        /**
         * Parse the complete given DOM and prefix all relative href URL's with the given URL
         * All URL's are handled as relative if there starts not with a / or http:// or https://
         * TODO add support for URL's with a ./ or ../ and so on
         *
         * @param node parent element
         * @param mediaURL mediaPath to another server
         */
        function handleLinks(node, mediaURL) {
            Array.prototype.slice.call(node.querySelectorAll('link')).forEach(function (link) {
                var href = link.getAttribute('href');
                if (link.getAttribute('type') === 'text/css' && 
                        href !== undefined && 
                        href[0] !== '/' &&
                        !/^http:\/\/.*/.test(href) &&
                        !/^https:\/\/.*/.test(href)) {
                    if (mediaURL[mediaURL.length - 1] !== '/') {
                        mediaURL += '/';
                    }
                    href = mediaURL + href;
                    link.setAttribute('href', href);
                }
            })
        }

        /**
         *
         * @param node
         * @param attr {{url:string, mediaURL: string}}
         * @param cb
         */
        function loadHTML(node, attr, cb) {
            var template = document.createElement('template'),
                div = ('content' in template ? template : document.implementation.createHTMLDocument('main').body),
                body,
                scripts,
                // only parse if html and scripts are loaded (scripts has callbacks because there are needs to loaded asynchronous)
                handleCannyParse = (function (cb) {
                    var waitForScripts = true,
                        waitForHTML = true,
                        triggger = function () {
                            if (!waitForScripts && !waitForHTML) {
                                canny.cannyParse(node, cb); // init only canny own modules
                            }
                        };
                    return {
                        scriptReady : function () {
                            waitForScripts = false;
                            triggger();
                        },
                        htmlReady : function () {
                            waitForHTML = false;
                            triggger();
                        }
                    };
                }(function () {
                    cb(attr);
                }));

            load(attr.url, function (src) {
                var childs;
                if (src) {
                    div.innerHTML = src;
                    // if it is a template we need the content
                    body = 'content' in div ? div.content : div;
                    scripts = body.querySelectorAll('script');
                    childs = [].slice.call(body.childNodes);
                    appendScriptsToHead(scripts, attr.mediaURL, handleCannyParse.scriptReady);

                    if (attr.mediaURL) {
                        handleLinks(body, attr.mediaURL);
                    }
                    childs.forEach(function (child) {
                        if (!(child.tagName === 'SCRIPT' && child.getAttribute('src'))) {
                            node.appendChild(child);
                        }
                    });
                    handleCannyParse.htmlReady();
                } else {
                    console.warn('async: Loading async HTML failed');
                }
            });
        }
        /**
         * simple wrapper to load HTML files with GET
         * @param path
         * @param cb
         */
        function load(path, cb) {
            doAjax({
                method: 'GET',
                path: path,
                onSuccess: function (response) {
                    cb(response.responseText);
                }
            });
        }
        /**
         *
         * @param params {{
         *   noCache:boolean,
         *   method:string|POST(default),
         *   data:object|string,
         *   path:string,
         *   async:boolean|true(default),
         *   onRequest:function (will be called with the xmlHTTPRequest object quite close before the send method is called),
         *   onFailure:function,
         *   onSuccess:function,
         *   contentType:string|Content-Type(default),
         *   mimeType:string|text plain(default)
         * }}
         */
         function doAjax(params) {
            var call = new XMLHttpRequest();
            var url = params.path;
            if (params.method === 'GET' && typeof params.data === 'object') {
                for (var attr in params.data) {
                    url = url + ((/\?/).test(url) ? "&" : "?") + attr + "=" + params.data[attr];
                }
            }
            if (params.noCache) {
                url = url + ((/\?/).test(url) ? "&" : "?") + "ts=" + (new Date()).getTime();
            }
            params.method = params.method || 'POST';
            call.open(params.method, url, params.async !== false);

            if (params.onSuccess) {
                call.addEventListener("load", function (s) {
                    params.onSuccess(s.target);
                });
            }

            if (params.onFailure) {
                call.addEventListener("error", function (s) {
                    params.onFailure(s.target);
                });
            }

            call.setRequestHeader(params.contentType || "Content-Type", params.mimeType || "text/plain");

            // allow the caller to do some extra stuff on the request object
            if (params.onRequest && typeof params.onRequest === 'function') {
                params.onRequest(call);
            }

            if (params.method === 'POST') {
                call.send(params.data);
            } else {
                call.send(null);
            }
        }

        return {
            /**
             * add a callback. So you will be notified when files are loaded asynchronous.
             * You will be called only once except your return true then async will keep
             * your callback in the notifier list and you will be informed for each async request.
             *
             * The async module will call each callback with the actual attr. So you have the control
             * how often you will be notified.
             *
             * Might be changed in the future version of async:
             * Currently this is only executed for canny modules which are loaded from the DOM directly.
             *
             * @param fc
             */
            pushLoadCB : function (fc) {
                pushLoadCBs.push(fc);
            },
            /**
             * Do a simple ajax call.
             *
             * @param params {{
             *   noCache:boolean,
             *   method:string|POST(default),
             *   data:object,string,
             *   async:boolean|true(default),
             *   path:string,
             *   onRequest:function (will be called with the xmlHTTPRequest object quite close before the send method is called),
             *   onFailure:function,
             *   onSuccess:function,
             *   contentType:string|Content-Type(default),
             *   mimeType:string|text plain(default)
             * }}
             */
            doAjax: doAjax,
            /**
             *
             * @param node
             * @param attr {{
             *  url:string,
             *  mediaURL:string
             * }}
             * @param cb
             */
            loadHTML : loadHTML,
            /**
             * Deprecated: use loadHTML instead
             * @param path
             * @param cb
             */
            load: function () {
                console.warn('async:load function load is deprecated. Use loadHTML instead');
                load.apply(null, arguments);
            },
            /**
             * canny's add method
             *
             * @param node
             * @param attr
             */
            add: function (node, attr) {    // part of api
                // TODO implement logic for loading it directly from html
                if (attr.hasOwnProperty('url')) {
                    if (!ready) {
                        filesToLoad.push({
                            node: node,
                            attr: attr
                        });
                    } else {
                        loadHTML(node, attr);
                    }
                }
            },
            ready: function () {
                var obj, cbCount = filesToLoad.length;
                while (filesToLoad.length > 0) {
                    obj = filesToLoad.splice(0, 1)[0];
                    loadHTML(obj.node, obj.attr, function (attr) {
                        var keepPushCB = [], tmpCb;
                        cbCount--;
                        while (pushLoadCBs.length > 0) {
                            tmpCb = pushLoadCBs.splice(0, 1)[0];
                            if (tmpCb(attr) === true) {
                                keepPushCB.push(tmpCb);
                            }
                        }
                        pushLoadCBs = keepPushCB;
                    });
                }
            }
        };
    }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = async;
    } else {
        canny.add('async', async);
    }

}());
},{}],54:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * E.g.: canny-mod="flowControl" canny-var="{'view' : 'viewName'}"
 *
 * you can activate a initial view with a anchor in the URL e.g.: yourdomain.html#viewToShow
 * Or pass a comma separated module list for activate more module #viewToShow,otherView.
 *
 * TODO made it possible to summarize views with one identifier.
 * Instead of call: canny.flowControl.show('view1', 'view2', 'view3') call canny.flowControl.show('view').
 *
 * TODO add a hide method that just hide the specific element.
 *
 * TODO handle the fade in and out via CSS classes - and use transitions for it
 */
(function () {
    "use strict";

    /**
     * wraps transitionend event vendor implementation
     */
    function onTransitionEndOnce(node, cb) {
        var event = (function () {
                if (node.style.webkitTransition !== undefined) {
                    return 'webkitTransitionEnd';
                } else if (node.style.transition !== undefined) {
                    return 'transitionend';
                }
            }()),
            listener = function(e) {
                e.target.removeEventListener(e.type, listener);
                cb(e);
            };
        if (event) {
            node.addEventListener(event, listener, false);
        } else {
            cb();
        }
    }

    var flowControlInstance = function (fcInstanceName) {
            var instanceName = fcInstanceName,
                // flag to save if the initial queue is already initialized or not
                showInitialViewComplete = false,
                onShowInitialViewComplete = [],
                modViews = {}, // saves module views
                getViewAnchor = function () {
                    var hash = location.hash || null,
                        rx = new RegExp('[^a-zA-Z-_,]', 'g'),
                        hashSub;

                    if (hash) {
                        hashSub = hash.substr(1);
                        if (hashSub.search(rx) > -1) {
                            hashSub = hashSub.substring(0, hashSub.search(rx));
                        }
                        return hashSub.split(',');
                    }

                    return hash;
                },
                getAllModuleChildrens = function (cNode) {
                    // TODO test selector if we have more than one module in canny-mod
                    var children = cNode.querySelectorAll('[canny-mod*=' + instanceName + ']'),
                        fc_childNodes = {};
//                            if (cNode.hasChildNodes()) {
//                                [].slice.call(cNode.children).forEach(findChildren);
//                            }
                    [].slice.call(children).forEach(function (mod) {
                        var attrValue, view;
                        // TODO read attributes should be a part of canny functionality
                        attrValue = mod.getAttribute('canny-var').split("\'").join('\"');
                        if (/:/.test(attrValue)) {
                            // could be a JSON
                            view = JSON.parse(attrValue).view;
                        } else {
                            view = attrValue;
                        }
                        fc_childNodes[view] = mod;
                    });
                    return fc_childNodes;
                },
                /**
                 * Each flowControl node will end up in a flowControlModule.
                 *
                 * @param node
                 * @param attr
                 * @returns {{hasChildrenWithName: hasChildrenWithName, getViewName: getViewName, show: show, hide: hide, fadeOut: fadeOut, getNode: getNode, fadeIn: fadeIn}}
                 */
                flowControlModule = function (node, attr) {
                    var flowControlChildNodes = {},
                        async = false,
                        parentViews = fc.getParentNode(attr.view);
                    // saves all children in a object
                    flowControlChildNodes = getAllModuleChildrens(node);
//                    console.log('flowControlChildNodes:', flowControlChildNodes);
                    return {
                        hasChildrenWithName : function (viewName) {
                            return flowControlChildNodes.hasOwnProperty(viewName);
                        },
                        getViewName : function () {
                            return attr.view;
                        },
                        display : function () {
                            // don't call parents
                            // don't fade in
                            node.style.display = '';
                        },
                        show : function (cb) {
                            if (parentViews) {
                                parentViews.forEach(function (fc_module) {
//                                console.log('parentViews', fc_module.getViewName());
                                    fc_module.display();
                                });
                            }
                            if (!async && attr.hasOwnProperty('async')) {
                                canny.async.loadHTML(node, {url : attr.async}, function () {
                                    if (attr.whisker) {
                                        if (canny.whisker !== undefined) {
                                            canny.whisker.add(node, attr.whisker);
                                        } else {
                                            console.error("flowControl:try execute whisker but no whisker module is registered on canny.")
                                        }
                                    }
                                    node.style.display = '';
                                    cb();
                                });
                                async = true;
                            } else {
                                node.style.display = '';
                                cb && cb();
                            }
                        },
                        hide : function () {
                            node.style.display = 'none';
                        },
                        fadeOut : function (cb) {
                            fc.fadeOut(node, cb || function () {});
                        },
                        getNode : function () {
                            return node;
                        },
                        fadeIn : function (cb) {
                            if (parentViews) {
                                parentViews.forEach(function (fc_module) {
//                                console.log('parentViews', fc_module.getViewName());
                                    fc_module.display();
                                });
                            }
                            if (!async && attr.hasOwnProperty('async')) {
                                canny.async.loadHTML(node, {url : attr.async}, function () {
                                    if (attr.whisker) {
                                        if (canny.whisker !== undefined) {
                                            canny.whisker.add(node, attr.whisker);
                                        } else {
                                            console.error("flowControl:try execute whisker but no whisker module is registered on canny.");
                                        }
                                    }
                                    fc.fadeIn(node,  cb || function () {});
                                });
                                async = true;
                            } else {
                                fc.fadeIn(node,  cb || function () {});
                            }
                        }
                    };

                },
                showInitialView = getViewAnchor(),
                fc = {
                    // get all parent modules from the given viewName
                    getParentNode : function (viewName) {
                        var queue = Object.keys(modViews), l, i, parents = [];
                        l = queue.length;
                        for (i = 0; i < l; i++) {
                            // TODO
                            if (viewName !== queue[i] && modViews[queue[i]][0].hasChildrenWithName(viewName)) {
                                parents.push(modViews[queue[i]][0]);
                            }
                        }
                        return parents.length === 0 ? null : parents;
                    },
                    // passes a view list and complete the list with all parent node names
                    addParents : function (views) {
                        var extViews = views, i, l, pNode,
                            pushExtViews = function (name) {
                                if (extViews.indexOf(name) === -1) {
                                    extViews.push(name);
                                }
                            },
                            addParentView = function (viewName) {
                                // TODO call ends always with null - viewName is top parent
                                var pViewName = fc.getParentNode(viewName);
//                            console.log('viewName: ' + viewName, 'pViewName ' + pViewName );
                                if (pViewName) {
                                    pViewName.forEach(function (fc_module) {
                                        // TODO while has parent add it to the extViews
                                        pushExtViews(fc_module.getViewName());
                                        addParentView(fc_module.getViewName());
                                    });
                                }
                            };
                        l = views.length;
                        for (i = 0; i < l; i++) {
                            pNode = fc.getParentNode(views[i]);
                            if (pNode) {
                                pNode.forEach(function (fc_module) {
                                    pushExtViews(fc_module.getViewName());
                                    // so far we have parents do it recursive
                                    // TODO not needed each parent will do it by own -
                                    addParentView(fc_module.getViewName());
                                });
                            }
                        }
                        return extViews;
                    },
                    fadeOut : function (node, cb) {

                        if(node.style.display === 'none') {
                            cb();
                        } else {
                            node.classList.add('c-flowControl');
                            node.classList.add('fade-out');

                            setTimeout(function () {
                                node.style.display = 'none';
                                node.classList.remove('c-flowControl');
                                node.classList.remove('fade-out');
                                cb();
                            }, 300);
                        }

                    },
                    fadeIn : function (node, cb) {
                        // TODO: fade in does not work properly
                        node.style.display = '';
                        node.classList.add('c-flowControl');
                        node.classList.add('fade-in');

                        setTimeout(function() {
                            node.classList.remove('c-flowControl');
                            node.classList.remove('fade-in');
                            cb();

                            // trigger reflow to fix the black boxes issue FTTWO-1249
                            // TODO: check if this can be avoided or
                            var box = document.querySelector('.t-centerBox-content');
                            if (box) {
                                box.style.opacity = 0.99;
                                setTimeout(function() {
                                    box.style.opacity = 1;
                                }, 50);
                            }
                        }, 300);
                    }
                },
                ext = {
                    /**
                     *
                     * @param node
                     * @param innerNode
                     * @returns {{remove: remove}}
                     */
                    progress : function (node, innerNode) {
                        var newNode = document.createElement('div'), centerNode = document.createElement('div'), txtNode;
                        node.style.position = 'relative';
                        newNode.style.opacity = '0.6';
                        newNode.style.backgroundColor = '#666';
                        newNode.style.position = 'absolute';
                        newNode.style.top = 0;
                        newNode.style.left = 0;
                        newNode.style.width = node.offsetWidth + 'px';
                        newNode.style.height = node.offsetHeight + 'px';
                        newNode.style.borderRadius = window.getComputedStyle(node, null).borderRadius;

                        centerNode.style.position = 'absolute';
                        centerNode.style.top = (node.offsetHeight / 2) - 30 + 'px';
                        centerNode.style.width = node.offsetWidth + 'px';
                        centerNode.style.textAlign = 'center';

                        if (innerNode) {
                            centerNode.appendChild(innerNode);
                        }
                        node.appendChild(newNode);
                        node.appendChild(centerNode);
                        return {
                            remove : function (delay, cb) {
                                setTimeout(function () {
                                    node.removeChild(newNode);
                                    node.removeChild(centerNode);
                                    cb && cb();
                                }, delay || 0);
                            },
                            fadeOut : function (delay, cb) {
                                setTimeout(function () {
                                    fc.fadeOut(newNode, function () {
                                        node.removeChild(newNode);
                                        node.removeChild(centerNode);
                                        cb && cb();
                                    });
                                }, delay || 0);
                            }
                        };
                    }
                },
                /**
                 *
                 * @type {{mod: {}, createNewInstance: createNewInstance, ready: ready, add: add, show: show, fadeIn: fadeIn, showImmediately: showImmediately, overlay: overlay}}
                 */
                api = {
                    mod : modViews, // part of api
                    /**
                     * this method could be used to create new instances of flowControl (only needed if you
                     * load this script directly without require)
                     * @param name (unique module name)
                     **/
                    createNewInstance : function (name) {
                        return flowControl(name);
                    },
                    ready : function () {
                        var modNames = Object.keys(modViews),
                            callInitialViewCompleteQueue = true,
                            l = modNames.length,
                            i;
                        if (showInitialView && l > 0) {
                            // check if showInitialView contains a registered module
                            for (i = 0; i < l; i++) {
                                // check for existing name in showInitialView
                                if (showInitialView.indexOf(modNames[i]) !== -1) {
                                    showInitialView.push(function () {
                                        onShowInitialViewComplete.forEach(function(fc) {
                                            showInitialViewComplete = true;
                                            fc();
                                        });
                                    });
                                    callInitialViewCompleteQueue = false;
                                    api.showImmediately.apply(null, showInitialView);
                                    break;
                                }
                            }
                        }

                        if (callInitialViewCompleteQueue) {
                            onShowInitialViewComplete.forEach(function(fc) {
                                showInitialViewComplete = true;
                                fc();
                            });
                        }
                    },
                    /**
                     * Calls the given function after loading all initial views.
                     *
                     * @param fc
                     */
                    onShowInitialViewComplete : function(fc) {
                        // make sure that the passed function will be called also after initialisation
                        if (!showInitialViewComplete) {
                            onShowInitialViewComplete.push(fc);
                        } else {
                            fc();
                        }
                    },
                    /**
                     *
                     * @param node
                     * @param attr {{view:(identifier),}}
                     */
                    add : function (node, attr) {    // part of api
                        if (!modViews[attr.view]) {
                            modViews[attr.view] = [];
                        }
                        modViews[attr.view].push(flowControlModule(node, attr));
                    },
                    /**
                     * @deprecated will handle showImmediately in near future
                     */
                    show : function () {
                        api.fadeIn.apply(this, arguments);
                    },
                    /**
                     * @param name (arguments list of views to show)
                     */
                    fadeIn : function (name) {
                        var showMods = [].slice.call(arguments),
                            queue = Object.keys(modViews),
                            queueCount = 0,// = queue.length,
                            fadeIn = function () {
                                showMods.forEach(function (module) {
                                    if (modViews.hasOwnProperty(module)) {
                                        modViews[module].forEach(function (obj) {
                                            obj.fadeIn(function () {
                                                // TODO remove
//                                                console.log('FADE IN DONE');
                                                // TODO count callbacks and handle it ?
                                            });
                                        });
                                    }
                                });
                                // if last param is function than handle it as callback
                                if (typeof showMods[showMods.length - 1] === 'function') {
                                    showMods[showMods.length - 1]();
                                }
                            };
                        showMods = fc.addParents(showMods);
                        queue.forEach(function (view) {
                            queueCount += modViews[view].length;
                        });
                        // iterate over all registered modules
                        queue.forEach(function (view) {
                            // iterate over all instances of the same view
                            modViews[view].forEach(function (obj) {
                                // hide all (except incoming and parents) TODO but only the parents of the module
                                if (showMods.indexOf(view) === -1) {
                                    obj.fadeOut(function () {
                                        queueCount--;
                                        if (queueCount <= 0) {
                                            fadeIn();
                                        }
                                    });
                                } else {
                                    queueCount--;
                                    if (queueCount <= 0) {
                                        fadeIn();
                                    }
                                }
                            });
                        });
                    },
                    /**
                     * @deprecated use show instead
                     * @param name
                     */
                    showImmediately : function () {    // module specific
                        var showMods = [].slice.call(arguments),
                            queue = Object.keys(modViews),
                            countCb = (function () {
                                var cb, length = 0;
                                // if last param is function than handle it as callback
                                if (typeof showMods[showMods.length - 1] === 'function') {
                                    cb = showMods[showMods.length - 1];
                                }
                                return {
                                    countUp : function (num) {
                                        length += num;
                                    },
                                    reduce : function () {
                                        length--;
                                        if (cb && length <= 0) {
                                            cb();
                                        }
                                    }
                                };
                            }()),
                            show = function () {
                                showMods.forEach(function (module) {
                                    if (modViews.hasOwnProperty(module)) {
                                        countCb.countUp(modViews[module].length);
                                        modViews[module].forEach(function (obj) {
                                            obj.show(countCb.reduce);
                                        });
                                    }
                                });
                            };
                        showMods = fc.addParents(showMods);
                        // hide all (except incoming)
                        queue.forEach(function (view) {
                            modViews[view].forEach(function (obj) {
                                if (showMods.indexOf(obj) === -1) {
                                    obj.hide();
                                }
                            });
                        });
                        show();
                    },
                    overlay : function (name) {
                        var node;
                        // it's own module?
                        if (modViews.hasOwnProperty(name)) {
                            node = modViews[name].getNode();
                        } else {
                            node = document.getElementById(name);
                        }

                        return {
                            by : function (name, text) {
                                return ext[name](node, text);
                            }
                        };
                    }
                };
            return api;
        },
        flowControl = (function () {
            var instances = {};
            return function (name) {
                var instance,
                    def = name || 'flowControl';
                if (instances.hasOwnProperty(def)) {
                    instance = instances[def];
                } else {
                    instances[def] = flowControlInstance(def);
                    instance = instances[def];
                }
                return instance;
            };
        }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) { module.exports = flowControl; } else {canny.add('flowControl', flowControl('flowControl')); }

}());
},{}],55:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * repeat
 *
 * E.g.
 *  <div canny-mod="repeat" canny-var="{'for':'item', 'in':'path.to.list'}">
 *     <p>DATA: {{item}})</p>
 *  </div>
 *  or:
 *  <div canny-mod="repeat" canny-var="{'for':'objectItem', 'in':'path.to.object'}">
 *     <p>DATA FOO: {{objectItem.foo}})</p>
 *     <p>DATA BAR: {{objectItem.bar}})</p>
 *  </div>
 *
 * for:
 * is the name of the iterating item to have access from the DOM.
 *
 * in:
 * is the source where repeat can find the array.
 * It accepts functions, array, and objects pointer
 * - object: keep in mind that object has no specific sorting
 * - array:
 * - function: repeat will call it with the following parameter:
 *  * function which needs to be called with the object or list
 *  * ...
 *
 *  TODO: add example to get data direct from
 *   * a list of function
 *   * a object which contain functions
 *
 */
(function () {
    'use strict';

    var openChar = '{',
        endChar  = '}',
        ESCAPE_RE = /[-.*+?^${}()|[\]\/\\]/g,
        repeat = (function () {
            var BINDING_RE = getRegex();

            /**
             *  Parse a piece of text, return an array of tokens
             *  TODO refactor method
             *  @param text
             *  @return [{key:String, html:boolean}]
             */
            function parse(text) {
                if (!BINDING_RE.test(text)) {return null; }
                var m, i, token, match, tokens = [], orig = {text: text, idx : 0}, textObject;
                /* jshint boss: true */
                while (m = text.match(BINDING_RE)) {
                    i = m.index;
                    token = {concat : true};
                    if (i > 0) {
                        if (orig.idx === 0) {
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                            orig.idx += i;
                        } else {
                            orig.idx += i;
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                        }
                        tokens.push(textObject);
                    }
                    orig.idx += i;
                    token.key = m[1].trim();
                    match = m[0];
                    token.html =
                        match.charAt(2) === openChar &&
                        match.charAt(match.length - 3) === endChar;
                    tokens.push(token);
                    text = text.slice(i + m[0].length);
                }
                if (text.length) {
                    tokens.push({value : text, text : true, concat: true});
                }
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             * @return tokens [{key:String, node:DOM node, html: boolean}]
             */
            function compileTextNode(node, dataObj, itemName) {
                var tokens = parse(node.nodeValue),
                    obj = dataObj,
                    el, token, i, l, tmp, tokenObjectProperty, val;
                if (!tokens || obj === undefined) {return; }

                for (i = 0, l = tokens.length; i < l; i++) {
                    token = tokens[i];
                    if (typeof token === 'object' && token.hasOwnProperty('key')) {
                        tmp = token.key.split('.');

                        if (tmp.length > 0 && tmp[0] === itemName) {

                            if (tmp[0] !== itemName) {
                                // TODO implement error handling if key doesn't match with itemName
                                console.error('repeat:compileTextNode hups something is wrong which needs to be fixed!!! Token with name', token.key, 'doesn\'t match with scope name: ', itemName , ' Repeat will continue but be carefully this "bug" will be removed in next version of repeat!!!');
                            }

                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                val = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                val = obj;
                            }
                        } else {
                            // just a string?
                            val = obj;
                        }
                        if (typeof val === 'string' || typeof val === 'number') {
                            el = document.createTextNode(val);
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'boolean') {
                            el = document.createTextNode(val.toString());
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'function') {
                            el = document.createTextNode(val(node.parentNode));
                            node.parentNode.insertBefore(el, node);
                        } else if (tmp[0] === itemName) {
                            // property is not exists but it is the same scope
                            el = document.createTextNode('');
                            node.parentNode.insertBefore(el, node);
                        } else {
                            // restore the token... looks like is not mine
                            el = document.createTextNode('{{' + token.key + '}}');
                            node.parentNode.insertBefore(el, node);
                        }
                        token.node = el;
                    } else {
                        el = document.createTextNode(token.value);
                        // just normal string put back to view
                        node.parentNode.insertBefore(el, node);
                    }
                }
                node.parentNode.removeChild(node);
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             */
            function compileElement (node, dataObj, itemName) {
                // recursively compile childNodes
                if (node.hasChildNodes()) {
                    [].slice.call(node.childNodes).forEach(function (child) {
                        compile(child, dataObj, itemName);
                    });
                }
            }
            /**
             * Compile a DOM node (recursive)
             * @param node
             * @param dataObj
             * @param itemName
             * @returns {*}
             */
            function compile(node, dataObj, itemName) {
                var nodeType = node.nodeType;
                if (nodeType === 1 && node.tagName !== 'SCRIPT') { // a normal node
                    compileElement(node, dataObj, itemName);
                } else if (nodeType === 3) {
                    compileTextNode(node, dataObj, itemName);
                }

                return node;
            }

            /**
             * helper function to do the read variable from string magic.
             * The cb will called with the property value - in case of undefined the variable does not exists
             * @param node
             * @param attributeName
             * @param cb
             */
            function getLoopValueFromAttribute(node, obj, itemName, attributeName, cb) {
                var tmp = node.getAttribute(attributeName).split('.'), tokenObjectProperty;
                if (tmp.length > 0 && tmp[0] === itemName) {
                    tokenObjectProperty = tmp.slice(1).join('.');
                    cb(getGlobalCall(tokenObjectProperty, obj));
                } else {
                    // TODO handle this correctly
                    console.error('repeat:getLoopValueFromAttribute has problems');
                }
            }

            /**
             * register click events
             * 
             * @deprecated use rp-bind attribute
             * 
             * @param clone
             * @param item
             * @param itemName
             */
            function handleEvents(clone, obj, itemName) {
                var onClick = 'on-click';
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' + onClick + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, onClick, function (val) {
                        if (typeof val === 'function') {
                            node.addEventListener('click', val);
                        } else {
                            console.log('repeat:can not register click listener without a function', node);
                        }
                    });
                });
            }

            /**
             * register rp-bind handler
             * 
             * With help of this the if and if-not and onClick attribute is deprecated - you can just pass a function 
             * pointer to rp-bind and do all the required logic by your own.
             * 
             * If you return false then the node will be removed from the DOM
             *
             * @param clone
             * @param obj
             * @param itemName
             */
            function handleRPBindAttribute(clone, obj, itemName) {
                var attrName = 'rp-bind';
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' + attrName + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attrName, function (val) {
                        if (typeof val === 'function') {
                            if (val(node) === false) {
                                // remove node if function returns false
                               node.parentNode.removeChild(node); 
                            }
                        } else {
                            console.error('repeat:can not register control function without a function pointer', node);
                        }
                    });
                });
            }

            /**
             * Replaces expressions for all tag attributes
             *
             * @param clone
             * @param obj
             * @param itemName (currently not in used but needs to be checked)
             */
            function handleAttributes(containerNode, obj, itemName) {
                var returnTokens = [];
                (function searchForExpressions(children) {
                    [].slice.call(children).forEach(function (node) {
                        var i, attr, rTokens;
                        if (node.children.length > 0) {
                            // do it recursive for all children
                            searchForExpressions(node.children);
                        }
                        // loop through each attribute
                        for (i = 0; i < node.attributes.length; i++) {
                            attr = node.attributes[i];
                            if (/\{\{/.test(attr.textContent)) {
                                if (attr.name) {
                                    rTokens = (function () {
                                        var token = parse(attr.textContent),
                                            endData = [], tmpToken, j, tmpTokenSplit, value;
                                        for (j = 0; j < token.length; j++) {
                                            tmpToken = token[j];
                                            // if token not itemName skipp all
                                            if (tmpToken.key !== undefined && tmpToken.key.split('.')[0] === itemName) {
                                                // save the attribute
                                                tmpToken.attr = attr;
                                                if (/\./.test(tmpToken.key)) {
                                                    tmpTokenSplit = tmpToken.key.split('.').slice(1).join('.');
                                                } else {
                                                    tmpTokenSplit = tmpToken.key;
                                                }
                                                if (typeof obj === 'object') {
                                                    tmpToken.value = getGlobalCall(tmpTokenSplit, obj);
                                                    if (typeof tmpToken.value === 'function') {
                                                        value = tmpToken.value();
                                                    } else {
                                                        value = tmpToken.value;
                                                    }
                                                } else if (typeof obj === 'string') {
                                                    value = obj;
                                                } else if (typeof obj === 'function') {
                                                    value = obj(node);
                                                }

                                            } else if (tmpToken.hasOwnProperty('key')) {
                                                // restore the expression - might be another whisker instance will
                                                // needs this
                                                value = '{{' + tmpToken.key + '}}';
                                            } else {
                                                value = tmpToken.value;
                                            }
                                            endData.push({value : value, concat : tmpToken.concat});
                                        }
                                        attr.textContent = endData.map(function (d) {
                                            return d.concat ? d.value : ' ' + d.value;
                                        }).join('');
                                        return token;
                                    }());
                                    returnTokens = returnTokens.concat(rTokens);
                                }
                            }
                        }
                    });
                }(containerNode.children));
                return returnTokens;
            }

            /**
             * handle the if conditions if and if-not
             * 
             * @deprecated use rp-bind attribute
             * 
             * @param clone
             * @param obj
             * @param itemName
             */
            function handleIfCondition(clone, obj, itemName) {
                var attributeName_if = 'if',
                    attributeName_if_not = 'if-not';

                function checkIf(val, node) {
                    if (!val) {
                        node.parentNode.removeChild(node);
                    }
                }
                function checkIfNot(val, node) {
                    if (val) {
                        node.parentNode.removeChild(node);
                    }
                }
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' +attributeName_if + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attributeName_if, function (val) {checkIf(val, node);});
                });

                [].slice.call(clone.querySelectorAll('[' +attributeName_if_not + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attributeName_if_not, function (val) {checkIfNot(val, node);});
                });
            }

            /**
             * Looped through the collection and do the logic for each clone instance.
             * Actually it supports only collection - no objects.
             * @param node
             * @param itemName
             * @param collection
             * @param template
             */
            function registerTemplate(node, itemName, collection, template) {
                var mainFrag;
                if (typeof collection === 'object') {
                    if (Object.prototype.toString.call(collection) === '[object Array]') {
                        // it is an array
                        mainFrag = document.createDocumentFragment();
                        collection.forEach(function (item) {
                            // item could be an object or just a property like a
                            // string (in case of it is direct a list of strings)
                            template.forEach(function (childTpl) {
                                // TODO works also with fragment but then the qunit test fails
                                // - there is a problem with the phantomjs
//                                var fragment = document.createDocumentFragment();
                                var fragment = document.createElement('div');
                                fragment.appendChild(childTpl.cloneNode(true));
                                
                                handleIfCondition(fragment, item, itemName);
                                // if conditions can remove elements from clone - it's important that this is executed first
                                if (fragment.children && fragment.children.length === 1) {
                                    handleRPBindAttribute(fragment, item, itemName);
                                }
                                // rp-bind attribute can also remove elements so need to check again if node exists
                                if (fragment.children && fragment.children.length === 1) {
                                    handleEvents(fragment, item, itemName);
                                    handleAttributes(fragment, item, itemName);
                                    // replace texts:
                                    mainFrag.appendChild(compile(fragment.children[0], item, itemName));
                                } else {
                                   // console.log('repeat:element has been removed from DOM');
                                }
                            });
                        });
                        node.appendChild(mainFrag);
                    } else {
                        // it is an object
                        console.error('repeat detect object but object currently not supported');
                        // what render? - property name or value? - Both?
                    }
                } else {
                    console.error('repeat:registerTemplate detect none acceptable data argument', collection);
                }
            }

            /**
             * Create a new repeat instance and do the "magic".
             * @param node
             * @param scopeName
             * @param data {[], function}
             */
            function execRepeat(node, scopeName, data) {
                var template = [];
                [].slice.call(node.children).forEach(function (child) {
                    template.push(node.removeChild(child));
                });

                if (typeof data === 'function') {
                    data(function (name, data) {
                        if (data) {
                            scopeName = name;
                        } else {
                            data = name;
                        }
                        // better would be a update children but this is much effort to detect
                        [].slice.call(node.children).forEach(function (child) {
                            node.removeChild(child);
                        });
                        registerTemplate(node, scopeName, data, template);
                    });
                } else {
                    registerTemplate(node, scopeName, data, template)
                }
            }

            return {
                /**
                 * the attribute requires:
                 *  for: name of the iterator
                 *  in: pointer to: function, array or object
                 *
                 * @param node
                 * @param attr {{for:string,in:string}}
                 */
                add : function (node, attr) {
                    var inPointer;
                    if (typeof attr === 'object' && attr.in && attr.for) {
                        if (typeof attr.in === 'string') {
                            // TODO replace window with this and also other instances could use the magic as closure
                            inPointer = getGlobalCall(attr.in, window);
                        } else {
                            inPointer = attr.in;
                        }
                        execRepeat(node, attr.for || 'item', inPointer);
                    } else if (Object.prototype.toString.call(attr) === '[object Array]') {
                        execRepeat(node, 'item', attr);
                    } else if (typeof attr === 'function') {
                        execRepeat(node, 'item', attr);
                    } else if (typeof attr === 'string') {
                        inPointer = getGlobalCall(attr, window);
                        execRepeat(node, 'item', inPointer);
                    } else {
                        console.warn('repeat:add none acceptable attributes', attr);
                    }
                }
            };
        }());

    function escapeRegex(str) {
        return str.replace(ESCAPE_RE, '\\$&');
    }

    function getRegex() {
        var open = escapeRegex(openChar),
            end  = escapeRegex(endChar);
        return new RegExp(open + open + open + '?(.+?)' + end + '?' + end + end);
    }

    /**
     * Read a property from a given string and object.
     * Returns the founded property pointer or undefined.
     * @param value
     * @param obj
     * @returns {*} or undefined
     */
    function getGlobalCall (value, obj) {
        var split = value.split('.'),
            rec = function (cur) {
                if (obj[cur] !== undefined) {
                    obj = obj[cur];
                    rec(split.shift());
                } else if (cur === value ) {
                    obj = undefined;
                }
            };
        rec(split.shift());
        return obj;
    }

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = repeat;
    } else {
        canny.add('repeat', repeat);
    }

}());

},{}],56:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/
/**
 *
 * E.g. {{whisker}}:
 *  <div canny-mod="whisker" canny-var="{'bind':'scope','to':{'message':'My text'}}">
 *     <p>DATA: {{scope.message}})</p>
 *  </div>
 *  Or just pass the function pointer the default scope is 'scope'.
 *  <div canny-mod="whisker" canny-var="mymodule.functionPointer">
 *     <p>DATA: {{scope.message}})</p>
 *  </div>
 *
 */
(function () {
    "use strict";

    var openChar = '{',
        endChar  = '}',
        ESCAPE_RE = /[-.*+?^${}()|[\]\/\\]/g,
        whisker = (function () {
            var BINDING_RE = getRegex();
            /**
             *  Parse a piece of text, return an array of tokens
             *  TODO refactor method
             *  @param text
             *  @return [{key:String, html:boolean}]
             */
            function parse(text) {
                if (!BINDING_RE.test(text)) {return null; }
                var m, i, token, match, tokens = [], orig = {text: text, idx : 0}, textObject;
                /* jshint boss: true */
                while (m = text.match(BINDING_RE)) {
                    i = m.index;
                    token = {concat : true};
                    if (i > 0) {
                        if (orig.idx === 0) {
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                            orig.idx += i;
                        } else {
                            orig.idx += i;
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                        }
                        tokens.push(textObject);
                    }
                    orig.idx += i;
                    token.key = m[1].trim();
                    match = m[0];
                    token.html =
                        match.charAt(2) === openChar &&
                        match.charAt(match.length - 3) === endChar;
                    tokens.push(token);
                    text = text.slice(i + m[0].length);
                }
                if (text.length) {
                    tokens.push({value : text, text : true, concat: true});
                }
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             * @return tokens [{key:String, node:DOM node, html: boolean}]
             */
            function compileTextNode(node, dataObj, itemName) {
                var tokens = parse(node.nodeValue),
                    obj = dataObj,
                    el, token, i, l, tmp, tokenObjectProperty, val, valUnknown;
                if (!tokens || obj === undefined || typeof obj === 'string') {return; }

                for (i = 0, l = tokens.length; i < l; i++) {
                    token = tokens[i];

                    if (typeof token === 'object' && token.hasOwnProperty('key')) {
                        tmp = token.key.split('.');
                        if (tmp.length > 0 && tmp[0] === itemName) {
                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                valUnknown = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                valUnknown = obj;
                            }
                        } else {
                            // just a string?
                            valUnknown = obj;
                        }

                        if (typeof valUnknown === 'function') {
                            val = valUnknown(node);
                        } else {
                            val = valUnknown;
                        }

                        if (typeof val === 'string' || typeof val === 'number') {
                            el = document.createTextNode(val);
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'boolean') {
                            el = document.createTextNode(val.toString());
                            node.parentNode.insertBefore(el, node);
                        } else if (val instanceof HTMLElement) {
                            el = val;
                            node.parentNode.insertBefore(el, node);
                        } else if (tmp[0] === itemName) {
                            // property is not exists but it is the same scope
                            el = document.createTextNode('');
                            node.parentNode.insertBefore(el, node);
                        } else {
                            // restore the token... looks like is not mine
                            el = document.createTextNode('{{' + token.key + '}}');
                            node.parentNode.insertBefore(el, node);
                        }
                        token.node = el;
                    } else {
                        el = document.createTextNode(token.value);
                        // just normal string put back to view
                        node.parentNode.insertBefore(el, node);
                    }
                }
                node.parentNode.removeChild(node);
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             */
            function compileElement (node, dataObj, itemName) {
                var tokens = [],
                    token;
                // recursively compile childNodes
                if (node.hasChildNodes()) {
                    [].slice.call(node.childNodes).forEach(function (child) {
                        token = compile(child, dataObj, itemName);
                        if (token) {
                            tokens = tokens.concat(token);
                        }
                    });
                }
                return tokens.length > 0 ? tokens : undefined;
            }


            /**
             * helper function to do the read variable from string magic.
             * The cb will called with the property value - in case of undefined the variable does not exists
             * 
             * @param node
             * @param obj
             * @param itemName
             * @param attributeName
             * 
             * @return {function} | false if it is not a function or not available 
             */
            function getWkBindValue(node, obj, itemName, attributeName) {
                var tmp = node.getAttribute(attributeName).split('.'), tokenObjectProperty;
                if (tmp.length > 0 && tmp[0] === itemName) {
                    tokenObjectProperty = tmp.slice(1).join('.');
                    return getGlobalCall(tokenObjectProperty, obj) || false;
                }
                return false;
            }

            /**
             * register rp-bind handler
             *
             * With help of this the if and if-not and onClick attribute is deprecated - you can just pass a function pointer to rp-bind and
             * do all the required logic by your own.
             *
             * If you return false then the node will be removed from the DOM
             *
             * @param node
             * @param obj
             * @param scopeName
             */
            function handleWKBindAttribute(node, obj, scopeName) {

                function parseChildAttribute(child, data, scopeName) {
                    var attrName = 'wk-bind',
                        key = child.getAttribute('wk-bind'),
                        token,
                        fc = getWkBindValue(child, data, scopeName, attrName);
                    if (fc) {
                        (function (fc) {
                            var shadow,
                                hidden = false;
                            if (typeof fc === 'function') {
                                shadow = document.createElement('div');
                                shadow.style.display = 'none';
                                if (fc(child) === false) {
                                    // remove node if function returns false
                                    child = child.parentNode.replaceChild(shadow, child);
                                    hidden = true;
                                }
                                token = {
                                    hidden : hidden,
                                    node : child,
                                    shadowNode : shadow,
                                    isWkBindToken : true,
                                    // check if key is needed because it has the wkBind function pointer
                                    key : child.getAttribute('wk-bind')
                                }

                            } else {
                                console.error('whisker:can not register control function without a function pointer', child);
                            }
                        }(fc));
                    } else {
                        // valid in case of there is a different scope variable or
                    }
                    return token;
                }

                var attrName = 'wk-bind',
                    tokens = [];
                // check children of clone
                [].slice.call(node.querySelectorAll('[' + attrName + ']')).forEach(function (child) {
                    var tmpToken = parseChildAttribute(child, obj, scopeName);
                    if (tmpToken) {
                        tokens.push(tmpToken);
                    }
                });
                return tokens
            }

            /**
             *  Compile a DOM node (recursive)
             * @param node
             * @param dataObj
             * @param itemName
             * @returns {*}
             */
            function compile(node, dataObj, itemName) {
                var nodeType = node.nodeType,
                    tokens = [],
                    token;
                if (nodeType === 1 && node.tagName !== 'SCRIPT') { // a normal node
                    token = compileElement(node, dataObj, itemName);
                    if (token) {
                        tokens = tokens.concat(token);
                    }
                } else if (nodeType === 3) {
                    token = compileTextNode(node, dataObj, itemName);
                    if (token) {
                        tokens = tokens.concat(token);
                    }
                }
                return tokens.length > 0 ? tokens : undefined;
            }

            /**
             * Replaces expressions for all tag attributes
             *
             * loop though all children and check if a attribute has a expressions inside
             *
             * @param containerNode
             * @param obj
             * @param itemName
             * @return returnTokens [{key:String, attr: node attribute reference, html: boolean}]
             */
            function handleAttributes(containerNode, obj, itemName) {
                var returnTokens = [];
                (function searchForExpressions(children) {
                    [].slice.call(children).forEach(function (node) {
                        var i, attr, rTokens;
                        if (node.children.length > 0) {
                            // do it recursive for all children
                            searchForExpressions(node.children);
                        }
                        // loop through each attribute
                        for (i = 0; i < node.attributes.length; i++) {
                            attr = node.attributes[i];
                            if (/\{\{/.test(attr.textContent)) {
                                if (attr.name) {
                                    rTokens = (function () {
                                        var token = parse(attr.textContent),
                                            endData = [], tmpToken, j, tmpTokenSplit, value, tmpValue;
                                        for (j = 0; j < token.length; j++) {
                                            tmpToken = token[j];
                                            // if token not itemName skipp all
                                            if (tmpToken.key !== undefined && tmpToken.key.split('.')[0] === itemName) {
                                                // save the attribute
                                                tmpToken.attr = attr;
                                                if (/\./.test(tmpToken.key)) {
                                                    tmpTokenSplit = tmpToken.key.split('.').slice(1).join('.');
                                                } else {
                                                    tmpTokenSplit = tmpToken.key;
                                                }
                                                if (typeof obj === 'object') {
                                                    tmpValue = getGlobalCall(tmpTokenSplit, obj);
                                                    if (typeof tmpValue === 'function') {
                                                        tmpToken.value = tmpValue(node);
                                                        tmpToken.node = node;
                                                    } else {
                                                        tmpToken.value = tmpValue;
                                                    }
                                                    value = tmpToken.value;
                                                } else if (typeof obj === 'string') {
                                                    value = obj;
                                                } else if (typeof obj === 'function') {
                                                    value = obj(node);
                                                }

                                            } else if (tmpToken.hasOwnProperty('key')) {
                                                // restore the expression - might be another whisker instance will
                                                // needs this
                                                value = '{{' + tmpToken.key + '}}';
                                            } else {
                                                value = tmpToken.value;
                                            }
                                            endData.push({value : value, concat : tmpToken.concat});
                                        }
                                        attr.textContent = endData.map(function (d) {
                                            return d.concat ? d.value : ' ' + d.value;
                                        }).join('');
                                        return token;
                                    }());
                                    returnTokens = returnTokens.concat(rTokens);
                                }
                            }
                        }
                    });
                }(containerNode.children));
                return returnTokens;
            }

            /**
             * do the magic for attributes or text nodes
             * 
             * TODO: bug if property doesn't exists in first execution it want work anymore for attributes and wk-bind
             *  See: whiskerSpecs.js > dynamicallyChangeDataWithInitialMissingProperties
             *
             * @param node
             * @param scopeName
             * @param data
             */
            function fillData(node, scopeName, data) {
                var tokens = [];
                if (typeof data === 'object') {
                    // handleEvents(node, data, scopeName);
                    tokens = tokens.concat(handleAttributes(node, data, scopeName));
                    // make sure that the compiler also updates the hidden element
                    tokens = tokens.concat(compile(node, data, scopeName));

                    tokens = tokens.concat(handleWKBindAttribute(node, data, scopeName));

                    // replace texts:
                    return tokens;
                } else {
                    console.error('whisker:handleAttributes detect none acceptable data argument', data);
                }
            }

            /**
             * helper function for updateData to update the DOM Elements
             * @param token
             * @param domElement DOMElement
             */
            function updateDOMElement(token, domElement) {
                token.node.parentNode.insertBefore(domElement, token.node);
                token.node.parentNode.removeChild(token.node);
                token.node = domElement;
            }
            /**
             * helper function for updateData to update the text nodes
             * @param token
             * @param val
             */
            function updateText(token, val) {
                var textNode;
                if (token.node instanceof HTMLElement) {
                    // convert back to textNode
                    textNode = document.createTextNode('');
                    token.node.parentNode.insertBefore(textNode, token.node);
                    token.node.parentNode.removeChild(token.node);
                    token.node = textNode;
                }
                if (typeof val === 'string' || typeof val === 'number') {
                    token.node.nodeValue = val;
                } else if (typeof val === 'boolean') {
                    // TODO test
                    token.node.nodeValue = val.toString();
                }
            }

            /**
             * helper function for updateData to update the attributes for a node
             * @param token
             * @param value
             */
            function updateAttributes(token, value) {
                var val;
                if (typeof value === 'function') {
                    val = value(token.node);
                } else {
                    val = value;
                }
                if (typeof val === 'string' || typeof val === 'number') {
                    var replaceText = token.attr.textContent;
                    if (replaceText) {
                        token.attr.textContent = replaceText.replace(token.value, val);
                    } else {
                        token.attr.textContent = replaceText + val;
                    }
                    token.value = val;
                } else if (typeof val === 'boolean') {
                    // TODO test (makes no sense for an attribute but needs to be handled correctly (think about what to do in this case)
                    token.node.nodeValue = val.toString();
                }
            }
            /**
             *
             * Call this to update the existing data's
             *
             * TODO test also boolean and function
             *
             * @param tokenObjList [{key : "scopeName.property", node}]
             * @param scopeName
             * @param obj
             */
            function updateData(tokenObjList, scopeName, obj) {
                tokenObjList.forEach(function (token) {
                    if (token && token.hasOwnProperty('key')) {
                        var tmp = token.key.split('.'), tokenObjectProperty, val;
                        if (tmp.length > 0 && tmp[0] === scopeName) {
                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                val = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                val = obj;
                            }

                            if (val !== undefined) {
                                if (token.hasOwnProperty('attr')) {
                                    // handle attribute
                                    updateAttributes(token, val);
                                } else if (token.isWkBindToken) {
                                    (function () {
                                        var removeMeIfImFalse;
                                        if (val) {
                                            removeMeIfImFalse = val(token.node);
                                        }
                                        if (removeMeIfImFalse === false && token.hidden === false) {
                                            // remove node
                                            token.hidden = true;
                                            token.node.parentNode.replaceChild(token.shadowNode, token.node);
                                        } else if (removeMeIfImFalse !== false && token.hidden) {
                                            token.hidden = false;
                                            token.shadowNode.parentNode.replaceChild(token.node, token.shadowNode);
                                            // restore node
                                        }
                                    }());
                                } else {
                                    (function () {
                                        // a return result could also be a HTMLElement
                                        var res = typeof val === 'function' ? val(token.node) : val;
                                        if (res instanceof HTMLElement) {
                                            updateDOMElement(token, res);
                                        } else {
                                            updateText(token, res);
                                        }
                                    }(val))
                                }
                            }
                        }
                    }
                });
            }

            /**
             * TODO description
             * Create a new whisker instance and do the "magic".
             * @param node
             * @param scopeName
             * @param data
             */
            function exec(node, data, scopeName) {
                var currentScope = scopeName || 'item',
                    keyValueholder = {};
                if (typeof data === 'function') {
                    data(function (scope, data) {
                        var renderScope;
                        if (data !== undefined) {
                            renderScope = currentScope = scope || currentScope;
                        } else {
                            data = scope;
                            // otherwise use the scope from the initialisation
                            renderScope = currentScope;
                        }
                        if (keyValueholder.hasOwnProperty(renderScope)) {
                            updateData(keyValueholder[renderScope], renderScope, data);
                        } else {
                            keyValueholder[renderScope] = fillData(node, renderScope, data);
                        }
                    });
                } else {
                    fillData(node, currentScope, data)
                }
            }

            return {
                add : function (node, attr) {
                    var inPointer;
                    if (typeof attr === 'object') {
                        if (attr.to && attr.bind) {
                            if (typeof attr.to === 'string') {
                                // TODO replace window with this and also other instances could use the magic as closure
                                inPointer = getGlobalCall(attr.to, window);
                            } else {
                                inPointer = attr.to;
                            }
                        } else {
                            inPointer = attr;
                        }
                        exec(node, inPointer, attr.bind || 'item');
                    } else if (typeof attr === 'string') {
                        inPointer = getGlobalCall(attr, window);
                        if (typeof inPointer === 'function') {
                            exec(node, inPointer);
                        } else {
                            console.warn('whisker:add none acceptable attributes', attr);
                        }
                    } else {
                        exec(node, attr);
                    }
                }
            };
        }());

    function escapeRegex(str) {
        return str.replace(ESCAPE_RE, '\\$&');
    }

    function getRegex() {
        var open = escapeRegex(openChar),
            end  = escapeRegex(endChar);
        return new RegExp(open + open + open + '?(.+?)' + end + '?' + end + end);
    }

    /**
     * Read a property from a given string and object.
     * Returns the founded property pointer or undefined.
     * @param value
     * @param obj
     * @returns {*} or undefined
     */
    function getGlobalCall (value, obj) {
        var split = value.split('.'),
            rec = function (cur) {
                if (obj[cur] !== undefined) {
                    obj = obj[cur];
                    rec(split.shift());
                } else if (cur === value ) {
                    obj = undefined;
                }
            };
        rec(split.shift());
        return obj;
    }

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = whisker;
    } else {
        canny.add('whisker', whisker);
    }

}());

},{}],57:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":69}],58:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var scrubber = require('./lib/scrub');
var objectKeys = require('./lib/keys');
var forEach = require('./lib/foreach');
var isEnumerable = require('./lib/is_enum');

module.exports = function (cons, opts) {
    return new Proto(cons, opts);
};

(function () { // browsers bleh
    for (var key in EventEmitter.prototype) {
        Proto.prototype[key] = EventEmitter.prototype[key];
    }
})();

function Proto (cons, opts) {
    var self = this;
    EventEmitter.call(self);
    if (!opts) opts = {};
    
    self.remote = {};
    self.callbacks = { local : [], remote : [] };
    self.wrap = opts.wrap;
    self.unwrap = opts.unwrap;
    
    self.scrubber = scrubber(self.callbacks.local);
    
    if (typeof cons === 'function') {
        self.instance = new cons(self.remote, self);
    }
    else self.instance = cons || {};
}

Proto.prototype.start = function () {
    this.request('methods', [ this.instance ]);
};

Proto.prototype.cull = function (id) {
    delete this.callbacks.remote[id];
    this.emit('request', {
        method : 'cull',
        arguments : [ id ]
    });
};

Proto.prototype.request = function (method, args) {
    var scrub = this.scrubber.scrub(args);
    
    this.emit('request', {
        method : method,
        arguments : scrub.arguments,
        callbacks : scrub.callbacks,
        links : scrub.links
    });
};

Proto.prototype.handle = function (req) {
    var self = this;
    var args = self.scrubber.unscrub(req, function (id) {
        if (self.callbacks.remote[id] === undefined) {
            // create a new function only if one hasn't already been created
            // for a particular id
            var cb = function () {
                self.request(id, [].slice.apply(arguments));
            };
            self.callbacks.remote[id] = self.wrap ? self.wrap(cb, id) : cb;
            return cb;
        }
        return self.unwrap
            ? self.unwrap(self.callbacks.remote[id], id)
            : self.callbacks.remote[id]
        ;
    });
    
    if (req.method === 'methods') {
        self.handleMethods(args[0]);
    }
    else if (req.method === 'cull') {
        forEach(args, function (id) {
            delete self.callbacks.local[id];
        });
    }
    else if (typeof req.method === 'string') {
        if (isEnumerable(self.instance, req.method)) {
            self.apply(self.instance[req.method], args);
        }
        else {
            self.emit('fail', new Error(
                'request for non-enumerable method: ' + req.method
            ));
        }
    }
    else if (typeof req.method == 'number') {
        var fn = self.callbacks.local[req.method];
        if (!fn) {
            self.emit('fail', new Error('no such method'));
        }
        else self.apply(fn, args);
    }
};

Proto.prototype.handleMethods = function (methods) {
    var self = this;
    if (typeof methods != 'object') {
        methods = {};
    }
    
    // copy since assignment discards the previous refs
    forEach(objectKeys(self.remote), function (key) {
        delete self.remote[key];
    });
    
    forEach(objectKeys(methods), function (key) {
        self.remote[key] = methods[key];
    });
    
    self.emit('remote', self.remote);
    self.emit('ready');
};

Proto.prototype.apply = function (f, args) {
    try { f.apply(undefined, args) }
    catch (err) { this.emit('error', err) }
};

},{"./lib/foreach":59,"./lib/is_enum":60,"./lib/keys":61,"./lib/scrub":62,"events":66}],59:[function(require,module,exports){
module.exports = function forEach (xs, f) {
    if (xs.forEach) return xs.forEach(f)
    for (var i = 0; i < xs.length; i++) {
        f.call(xs, xs[i], i);
    }
}

},{}],60:[function(require,module,exports){
var objectKeys = require('./keys');

module.exports = function (obj, key) {
    if (Object.prototype.propertyIsEnumerable) {
        return Object.prototype.propertyIsEnumerable.call(obj, key);
    }
    var keys = objectKeys(obj);
    for (var i = 0; i < keys.length; i++) {
        if (key === keys[i]) return true;
    }
    return false;
};

},{"./keys":61}],61:[function(require,module,exports){
module.exports = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

},{}],62:[function(require,module,exports){
var traverse = require('traverse');
var objectKeys = require('./keys');
var forEach = require('./foreach');

function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) if (xs[i] === x) return i;
    return -1;
}

// scrub callbacks out of requests in order to call them again later
module.exports = function (callbacks) {
    return new Scrubber(callbacks);
};

function Scrubber (callbacks) {
    this.callbacks = callbacks;
}

// Take the functions out and note them for future use
Scrubber.prototype.scrub = function (obj) {
    var self = this;
    var paths = {};
    var links = [];
    
    var args = traverse(obj).map(function (node) {
        if (typeof node === 'function') {
            var i = indexOf(self.callbacks, node);
            if (i >= 0 && !(i in paths)) {
                // Keep previous function IDs only for the first function
                // found. This is somewhat suboptimal but the alternatives
                // are worse.
                paths[i] = this.path;
            }
            else {
                var id = self.callbacks.length;
                self.callbacks.push(node);
                paths[id] = this.path;
            }
            
            this.update('[Function]');
        }
        else if (this.circular) {
            links.push({ from : this.circular.path, to : this.path });
            this.update('[Circular]');
        }
    });
    
    return {
        arguments : args,
        callbacks : paths,
        links : links
    };
};
 
// Replace callbacks. The supplied function should take a callback id and
// return a callback of its own.
Scrubber.prototype.unscrub = function (msg, f) {
    var args = msg.arguments || [];
    forEach(objectKeys(msg.callbacks || {}), function (sid) {
        var id = parseInt(sid, 10);
        var path = msg.callbacks[id];
        traverse.set(args, path, f(id));
    });
    
    forEach(msg.links || [], function (link) {
        var value = traverse.get(args, link.from);
        traverse.set(args, link.to, value);
    });
    
    return args;
};

},{"./foreach":59,"./keys":61,"traverse":98}],63:[function(require,module,exports){
var dnode = require('./lib/dnode');

module.exports = function (cons, opts) {
    return new dnode(cons, opts);
};

},{"./lib/dnode":64}],64:[function(require,module,exports){
(function (process){
var protocol = require('dnode-protocol');
var Stream = require('stream');
var json = typeof JSON === 'object' ? JSON : require('jsonify');

module.exports = dnode;
dnode.prototype = {};
(function () { // browsers etc
    for (var key in Stream.prototype) {
        dnode.prototype[key] = Stream.prototype[key];
    }
})();

function dnode (cons, opts) {
    Stream.call(this);
    var self = this;
    
    self.opts = opts || {};
    
    self.cons = typeof cons === 'function'
        ? cons
        : function () { return cons || {} }
    ;
    
    self.readable = true;
    self.writable = true;
    
    process.nextTick(function () {
        if (self._ended) return;
        self.proto = self._createProto();
        self.proto.start();
        
        if (!self._handleQueue) return;
        for (var i = 0; i < self._handleQueue.length; i++) {
            self.handle(self._handleQueue[i]);
        }
    });
}

dnode.prototype._createProto = function () {
    var self = this;
    var proto = protocol(function (remote) {
        if (self._ended) return;
        
        var ref = self.cons.call(this, remote, self);
        if (typeof ref !== 'object') ref = this;
        
        self.emit('local', ref, self);
        
        return ref;
    }, self.opts.proto);
    
    proto.on('remote', function (remote) {
        self.emit('remote', remote, self);
        self.emit('ready'); // backwards compatability, deprecated
    });
    
    proto.on('request', function (req) {
        if (!self.readable) return;
        
        if (self.opts.emit === 'object') {
            self.emit('data', req);
        }
        else self.emit('data', json.stringify(req) + '\n');
    });
    
    proto.on('fail', function (err) {
        // errors that the remote end was responsible for
        self.emit('fail', err);
    });
    
    proto.on('error', function (err) {
        // errors that the local code was responsible for
        self.emit('error', err);
    });
    
    return proto;
};

dnode.prototype.write = function (buf) {
    if (this._ended) return;
    var self = this;
    var row;
    
    if (buf && typeof buf === 'object'
    && buf.constructor && buf.constructor.name === 'Buffer'
    && buf.length
    && typeof buf.slice === 'function') {
        // treat like a buffer
        if (!self._bufs) self._bufs = [];
        
        // treat like a buffer
        for (var i = 0, j = 0; i < buf.length; i++) {
            if (buf[i] === 0x0a) {
                self._bufs.push(buf.slice(j, i));
                
                var line = '';
                for (var k = 0; k < self._bufs.length; k++) {
                    line += String(self._bufs[k]);
                }
                
                try { row = json.parse(line) }
                catch (err) { return self.end() }
                
                j = i + 1;
                
                self.handle(row);
                self._bufs = [];
            }
        }
        
        if (j < buf.length) self._bufs.push(buf.slice(j, buf.length));
    }
    else if (buf && typeof buf === 'object') {
        // .isBuffer() without the Buffer
        // Use self to pipe JSONStream.parse() streams.
        self.handle(buf);
    }
    else {
        if (typeof buf !== 'string') buf = String(buf);
        if (!self._line) self._line = '';
        
        for (var i = 0; i < buf.length; i++) {
            if (buf.charCodeAt(i) === 0x0a) {
                try { row = json.parse(self._line) }
                catch (err) { return self.end() }
                
                self._line = '';
                self.handle(row);
            }
            else self._line += buf.charAt(i)
        }
    }
};

dnode.prototype.handle = function (row) {
    if (!this.proto) {
        if (!this._handleQueue) this._handleQueue = [];
        this._handleQueue.push(row);
    }
    else this.proto.handle(row);
};

dnode.prototype.end = function () {
    if (this._ended) return;
    this._ended = true;
    this.writable = false;
    this.readable = false;
    this.emit('end');
};

dnode.prototype.destroy = function () {
    this.end();
};

}).call(this,require('_process'))

},{"_process":74,"dnode-protocol":58,"jsonify":70,"stream":82}],65:[function(require,module,exports){
/*global HTMLElement */
/*jslint browser: true */

var domOpts = {};

domOpts.params = (function () {
    "use strict";
    var params = {}, i, nv, parts;
    if (location.search) {
        parts = location.search.substring(1).split('&');
        for (i = 0; i < parts.length; i++) {
            nv = parts[i].split('=');
            if (nv[0]) {
                params[nv[0]] = nv[1] || true;
            }
        }
    }
    return params;
}());

domOpts.createElement = function (tag, id, classes) {
    "use strict";
    var newNode = document.createElement(tag);
    if (id) {newNode.setAttribute('id', id); }
    if (classes) {newNode.setAttribute('class', classes); }
    return newNode;
};
module.exports =  domOpts;

// dom operations:
HTMLElement.prototype.domAddClass = function (addClasses) {
    "use strict";
    var attrClass = this.getAttribute('class'),
        addClassesList = addClasses.split(' '), newClasses = [], i;
    for (i = 0; i < addClassesList.length; i++) {
        if (!this.domHasClass(addClassesList[i])) {
            newClasses.push(addClassesList[i]);
        }
    }
    this.setAttribute('class', attrClass !== null ? attrClass + ' ' + newClasses.join(' ') : newClasses.join(' '));
    return this;
};
// TODO remove all classes with same name
HTMLElement.prototype.domRemoveClass = function (removeableClasses) {
    "use strict";
    var removeClasses = (removeableClasses && removeableClasses.split(' ')) || this.getAttribute('class').split(' '),
        attrClass = this.getAttribute('class'),
        currentClasses,
        i,
        idx;
    if (attrClass !== null) {
        currentClasses = attrClass.split(' ');
        for (i = 0; i < removeClasses.length; i++) {
            idx = currentClasses.indexOf(removeClasses[i]);
            if (idx >= 0) {
                currentClasses = currentClasses.slice(0, idx).concat(currentClasses.slice(idx + 1, currentClasses.length - 1));
            }
        }
        this.setAttribute('class', currentClasses.join(' '));
    }
    return this;
};

// dom operations:
HTMLElement.prototype.domHasClass = function (className) {
    "use strict";
    var classes = this.getAttribute('class'), currentClasses, i;
    if (classes !== null) {
        currentClasses = classes.split(' ');
        for (i = 0; i < currentClasses.length; i++) {
            if (currentClasses[i] === className) {return true; }
        }
    }
    return false;
};

HTMLElement.prototype.domRemove = function () {
    "use strict";
    this.parentNode.removeChild(this);
};
/**
 * remove all child elements from node
 */
HTMLElement.prototype.domEmpty = function () {
    "use strict";
    Array.prototype.slice.call(this.children).forEach(function (child) {
        child.domRemove(this);
    });
};

HTMLElement.prototype.domAppendTo = function (elem) {
    "use strict";
    var node = elem;
    if (typeof node === 'string') {
        node = document.getElementById(node);
    }
    node.appendChild(this);
    return this;
};

HTMLElement.prototype.domAppendChild = function (elem) {
    "use strict";
    var node = elem;
    if (typeof node === 'string') {
        node = document.getElementById(node);
    }
    this.appendChild(node);
    return this;
};

HTMLElement.prototype.domChildTags = function (tag) {
    "use strict";
    var tags = [];
    Array.prototype.slice.call(this.children).forEach(function (e) {
        if (e.tagName.toLowerCase() === tag.toLowerCase()) {
            tags.push(e);
        }
    });
    return tags;
};
},{}],66:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],67:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],68:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],69:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],70:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":71,"./lib/stringify":72}],71:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],72:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],73:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":74}],74:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],75:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],76:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],77:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],78:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":76,"./encode":77}],79:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":50}],80:[function(require,module,exports){
var Stream = require('stream');
var sockjs = require('sockjs-client');
var resolve = require('url').resolve;
var parse = require('url').parse;

module.exports = function (u, cb) {
    var uri = parse(u).protocol ? u : resolve(window.location.href, u);
    
    var stream = new Stream;
    stream.readable = true;
    stream.writable = true;
    
    var ready = false;
    var buffer = [];
    
    var sock = sockjs(uri);
    stream.sock = sock;
    
    stream.write = function (msg) {
        if (!ready || buffer.length) buffer.push(msg)
        else sock.send(msg)
    };
    
    stream.end = function (msg) {
        if (msg !== undefined) stream.write(msg);
        if (!ready) {
            stream._ended = true;
            return;
        }
        stream.writable = false;
        sock.close();
    };
    
    stream.destroy = function () {
        stream._ended = true;
        stream.writable = stream.readable = false;
        buffer.length = 0
        sock.close();
    };
    
    sock.onopen = function () {
        if (typeof cb === 'function') cb();
        ready = true;
        for (var i = 0; i < buffer.length; i++) {
            sock.send(buffer[i]);
        }
        buffer = [];
        stream.emit('connect');
        if (stream._ended) stream.end();
    };
    
    sock.onmessage = function (e) {
        stream.emit('data', e.data);
    };
    
    sock.onclose = function () {
        stream.emit('end');
        stream.writable = false;
        stream.readable = false;
    };
    
    return stream;
};

},{"sockjs-client":81,"stream":82,"url":99}],81:[function(require,module,exports){
/* SockJS client, version 0.3.1.7.ga67f.dirty, http://sockjs.org, MIT License

Copyright (c) 2011-2012 VMware, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// JSON2 by Douglas Crockford (minified).
var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g;return e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function f(a){return a<10?"0"+a:a}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver=="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")})}()


//     [*] Including lib/index.js
// Public object
var SockJS = (function(){
              var _document = document;
              var _window = window;
              var utils = {};


//         [*] Including lib/reventtarget.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */
var REventTarget = function() {};
REventTarget.prototype.addEventListener = function (eventType, listener) {
    if(!this._listeners) {
         this._listeners = {};
    }
    if(!(eventType in this._listeners)) {
        this._listeners[eventType] = [];
    }
    var arr = this._listeners[eventType];
    if(utils.arrIndexOf(arr, listener) === -1) {
        arr.push(listener);
    }
    return;
};

REventTarget.prototype.removeEventListener = function (eventType, listener) {
    if(!(this._listeners && (eventType in this._listeners))) {
        return;
    }
    var arr = this._listeners[eventType];
    var idx = utils.arrIndexOf(arr, listener);
    if (idx !== -1) {
        if(arr.length > 1) {
            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );
        } else {
            delete this._listeners[eventType];
        }
        return;
    }
    return;
};

REventTarget.prototype.dispatchEvent = function (event) {
    var t = event.type;
    var args = Array.prototype.slice.call(arguments, 0);
    if (this['on'+t]) {
        this['on'+t].apply(this, args);
    }
    if (this._listeners && t in this._listeners) {
        for(var i=0; i < this._listeners[t].length; i++) {
            this._listeners[t][i].apply(this, args);
        }
    }
};
//         [*] End of lib/reventtarget.js


//         [*] Including lib/simpleevent.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SimpleEvent = function(type, obj) {
    this.type = type;
    if (typeof obj !== 'undefined') {
        for(var k in obj) {
            if (!obj.hasOwnProperty(k)) continue;
            this[k] = obj[k];
        }
    }
};

SimpleEvent.prototype.toString = function() {
    var r = [];
    for(var k in this) {
        if (!this.hasOwnProperty(k)) continue;
        var v = this[k];
        if (typeof v === 'function') v = '[function]';
        r.push(k + '=' + v);
    }
    return 'SimpleEvent(' + r.join(', ') + ')';
};
//         [*] End of lib/simpleevent.js


//         [*] Including lib/eventemitter.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventEmitter = function(events) {
    this.events = events || [];
};
EventEmitter.prototype.emit = function(type) {
    var that = this;
    var args = Array.prototype.slice.call(arguments, 1);
    if (!that.nuked && that['on'+type]) {
        that['on'+type].apply(that, args);
    }
    if (utils.arrIndexOf(that.events, type) === -1) {
        utils.log('Event ' + JSON.stringify(type) +
                  ' not listed ' + JSON.stringify(that.events) +
                  ' in ' + that);
    }
};

EventEmitter.prototype.nuke = function(type) {
    var that = this;
    that.nuked = true;
    for(var i=0; i<that.events.length; i++) {
        delete that[that.events[i]];
    }
};
//         [*] End of lib/eventemitter.js


//         [*] Including lib/utils.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';
utils.random_string = function(length, max) {
    max = max || random_string_chars.length;
    var i, ret = [];
    for(i=0; i < length; i++) {
        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );
    }
    return ret.join('');
};
utils.random_number = function(max) {
    return Math.floor(Math.random() * max);
};
utils.random_number_string = function(max) {
    var t = (''+(max - 1)).length;
    var p = Array(t+1).join('0');
    return (p + utils.random_number(max)).slice(-t);
};

// Assuming that url looks like: http://asdasd:111/asd
utils.getOrigin = function(url) {
    url += '/';
    var parts = url.split('/').slice(0, 3);
    return parts.join('/');
};

utils.isSameOriginUrl = function(url_a, url_b) {
    // location.origin would do, but it's not always available.
    if (!url_b) url_b = _window.location.href;

    return (url_a.split('/').slice(0,3).join('/')
                ===
            url_b.split('/').slice(0,3).join('/'));
};

utils.getParentDomain = function(url) {
    // ipv4 ip address
    if (/^[0-9.]*$/.test(url)) return url;
    // ipv6 ip address
    if (/^\[/.test(url)) return url;
    // no dots
    if (!(/[.]/.test(url))) return url;

    var parts = url.split('.').slice(1);
    return parts.join('.');
};

utils.objectExtend = function(dst, src) {
    for(var k in src) {
        if (src.hasOwnProperty(k)) {
            dst[k] = src[k];
        }
    }
    return dst;
};

var WPrefix = '_jp';

utils.polluteGlobalNamespace = function() {
    if (!(WPrefix in _window)) {
        _window[WPrefix] = {};
    }
};

utils.closeFrame = function (code, reason) {
    return 'c'+JSON.stringify([code, reason]);
};

utils.userSetCode = function (code) {
    return code === 1000 || (code >= 3000 && code <= 4999);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
utils.countRTO = function (rtt) {
    var rto;
    if (rtt > 100) {
        rto = 3 * rtt; // rto > 300msec
    } else {
        rto = rtt + 200; // 200msec < rto <= 300msec
    }
    return rto;
}

utils.log = function() {
    if (_window.console && console.log && console.log.apply) {
        console.log.apply(console, arguments);
    }
};

utils.bind = function(fun, that) {
    if (fun.bind) {
        return fun.bind(that);
    } else {
        return function() {
            return fun.apply(that, arguments);
        };
    }
};

utils.flatUrl = function(url) {
    return url.indexOf('?') === -1 && url.indexOf('#') === -1;
};

utils.amendUrl = function(url) {
    var dl = _document.location;
    if (!url) {
        throw new Error('Wrong url for SockJS');
    }
    if (!utils.flatUrl(url)) {
        throw new Error('Only basic urls are supported in SockJS');
    }

    //  '//abc' --> 'http://abc'
    if (url.indexOf('//') === 0) {
        url = dl.protocol + url;
    }
    // '/abc' --> 'http://localhost:80/abc'
    if (url.indexOf('/') === 0) {
        url = dl.protocol + '//' + dl.host + url;
    }
    // strip trailing slashes
    url = url.replace(/[/]+$/,'');
    return url;
};

// IE doesn't support [].indexOf.
utils.arrIndexOf = function(arr, obj){
    for(var i=0; i < arr.length; i++){
        if(arr[i] === obj){
            return i;
        }
    }
    return -1;
};

utils.arrSkip = function(arr, obj) {
    var idx = utils.arrIndexOf(arr, obj);
    if (idx === -1) {
        return arr.slice();
    } else {
        var dst = arr.slice(0, idx);
        return dst.concat(arr.slice(idx+1));
    }
};

// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df
utils.isArray = Array.isArray || function(value) {
    return {}.toString.call(value).indexOf('Array') >= 0
};

utils.delay = function(t, fun) {
    if(typeof t === 'function') {
        fun = t;
        t = 0;
    }
    return setTimeout(fun, t);
};


// Chars worth escaping, as defined by Douglas Crockford:
//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196
var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    json_lookup = {
"\u0000":"\\u0000","\u0001":"\\u0001","\u0002":"\\u0002","\u0003":"\\u0003",
"\u0004":"\\u0004","\u0005":"\\u0005","\u0006":"\\u0006","\u0007":"\\u0007",
"\b":"\\b","\t":"\\t","\n":"\\n","\u000b":"\\u000b","\f":"\\f","\r":"\\r",
"\u000e":"\\u000e","\u000f":"\\u000f","\u0010":"\\u0010","\u0011":"\\u0011",
"\u0012":"\\u0012","\u0013":"\\u0013","\u0014":"\\u0014","\u0015":"\\u0015",
"\u0016":"\\u0016","\u0017":"\\u0017","\u0018":"\\u0018","\u0019":"\\u0019",
"\u001a":"\\u001a","\u001b":"\\u001b","\u001c":"\\u001c","\u001d":"\\u001d",
"\u001e":"\\u001e","\u001f":"\\u001f","\"":"\\\"","\\":"\\\\",
"\u007f":"\\u007f","\u0080":"\\u0080","\u0081":"\\u0081","\u0082":"\\u0082",
"\u0083":"\\u0083","\u0084":"\\u0084","\u0085":"\\u0085","\u0086":"\\u0086",
"\u0087":"\\u0087","\u0088":"\\u0088","\u0089":"\\u0089","\u008a":"\\u008a",
"\u008b":"\\u008b","\u008c":"\\u008c","\u008d":"\\u008d","\u008e":"\\u008e",
"\u008f":"\\u008f","\u0090":"\\u0090","\u0091":"\\u0091","\u0092":"\\u0092",
"\u0093":"\\u0093","\u0094":"\\u0094","\u0095":"\\u0095","\u0096":"\\u0096",
"\u0097":"\\u0097","\u0098":"\\u0098","\u0099":"\\u0099","\u009a":"\\u009a",
"\u009b":"\\u009b","\u009c":"\\u009c","\u009d":"\\u009d","\u009e":"\\u009e",
"\u009f":"\\u009f","\u00ad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601",
"\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f",
"\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d",
"\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029",
"\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d",
"\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061",
"\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065",
"\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069",
"\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d",
"\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0",
"\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4",
"\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8",
"\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc",
"\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"};

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    extra_lookup;

// JSON Quote string. Use native implementation when possible.
var JSONQuote = (JSON && JSON.stringify) || function(string) {
    json_escapable.lastIndex = 0;
    if (json_escapable.test(string)) {
        string = string.replace(json_escapable, function(a) {
            return json_lookup[a];
        });
    }
    return '"' + string + '"';
};

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unroll_lookup = function(escapable) {
    var i;
    var unrolled = {}
    var c = []
    for(i=0; i<65536; i++) {
        c.push( String.fromCharCode(i) );
    }
    escapable.lastIndex = 0;
    c.join('').replace(escapable, function (a) {
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        return '';
    });
    escapable.lastIndex = 0;
    return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
utils.quote = function(string) {
    var quoted = JSONQuote(string);

    // In most cases this should be very fast and good enough.
    extra_escapable.lastIndex = 0;
    if(!extra_escapable.test(quoted)) {
        return quoted;
    }

    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);

    return quoted.replace(extra_escapable, function(a) {
        return extra_lookup[a];
    });
}

var _all_protocols = ['websocket',
                      'xdr-streaming',
                      'xhr-streaming',
                      'iframe-eventsource',
                      'iframe-htmlfile',
                      'xdr-polling',
                      'xhr-polling',
                      'iframe-xhr-polling',
                      'jsonp-polling'];

utils.probeProtocols = function() {
    var probed = {};
    for(var i=0; i<_all_protocols.length; i++) {
        var protocol = _all_protocols[i];
        // User can have a typo in protocol name.
        probed[protocol] = SockJS[protocol] &&
                           SockJS[protocol].enabled();
    }
    return probed;
};

utils.detectProtocols = function(probed, protocols_whitelist, info) {
    var pe = {},
        protocols = [];
    if (!protocols_whitelist) protocols_whitelist = _all_protocols;
    for(var i=0; i<protocols_whitelist.length; i++) {
        var protocol = protocols_whitelist[i];
        pe[protocol] = probed[protocol];
    }
    var maybe_push = function(protos) {
        var proto = protos.shift();
        if (pe[proto]) {
            protocols.push(proto);
        } else {
            if (protos.length > 0) {
                maybe_push(protos);
            }
        }
    }

    // 1. Websocket
    if (info.websocket !== false) {
        maybe_push(['websocket']);
    }

    // 2. Streaming
    if (pe['xhr-streaming'] && !info.null_origin) {
        protocols.push('xhr-streaming');
    } else {
        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-streaming');
        } else {
            maybe_push(['iframe-eventsource',
                        'iframe-htmlfile']);
        }
    }

    // 3. Polling
    if (pe['xhr-polling'] && !info.null_origin) {
        protocols.push('xhr-polling');
    } else {
        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-polling');
        } else {
            maybe_push(['iframe-xhr-polling',
                        'jsonp-polling']);
        }
    }
    return protocols;
}
//         [*] End of lib/utils.js


//         [*] Including lib/dom.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// May be used by htmlfile jsonp and transports.
var MPrefix = '_sockjs_global';
utils.createHook = function() {
    var window_id = 'a' + utils.random_string(8);
    if (!(MPrefix in _window)) {
        var map = {};
        _window[MPrefix] = function(window_id) {
            if (!(window_id in map)) {
                map[window_id] = {
                    id: window_id,
                    del: function() {delete map[window_id];}
                };
            }
            return map[window_id];
        }
    }
    return _window[MPrefix](window_id);
};



utils.attachMessage = function(listener) {
    utils.attachEvent('message', listener);
};
utils.attachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.addEventListener(event, listener, false);
    } else {
        // IE quirks.
        // According to: http://stevesouders.com/misc/test-postmessage.php
        // the message gets delivered only to 'document', not 'window'.
        _document.attachEvent("on" + event, listener);
        // I get 'window' for ie8.
        _window.attachEvent("on" + event, listener);
    }
};

utils.detachMessage = function(listener) {
    utils.detachEvent('message', listener);
};
utils.detachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.removeEventListener(event, listener, false);
    } else {
        _document.detachEvent("on" + event, listener);
        _window.detachEvent("on" + event, listener);
    }
};


var on_unload = {};
// Things registered after beforeunload are to be called immediately.
var after_unload = false;

var trigger_unload_callbacks = function() {
    for(var ref in on_unload) {
        on_unload[ref]();
        delete on_unload[ref];
    };
};

var unload_triggered = function() {
    if(after_unload) return;
    after_unload = true;
    trigger_unload_callbacks();
};

// Onbeforeunload alone is not reliable. We could use only 'unload'
// but it's not working in opera within an iframe. Let's use both.
utils.attachEvent('beforeunload', unload_triggered);
utils.attachEvent('unload', unload_triggered);

utils.unload_add = function(listener) {
    var ref = utils.random_string(8);
    on_unload[ref] = listener;
    if (after_unload) {
        utils.delay(trigger_unload_callbacks);
    }
    return ref;
};
utils.unload_del = function(ref) {
    if (ref in on_unload)
        delete on_unload[ref];
};


utils.createIframe = function (iframe_url, error_callback) {
    var iframe = _document.createElement('iframe');
    var tref, unload_ref;
    var unattach = function() {
        clearTimeout(tref);
        // Explorer had problems with that.
        try {iframe.onload = null;} catch (x) {}
        iframe.onerror = null;
    };
    var cleanup = function() {
        if (iframe) {
            unattach();
            // This timeout makes chrome fire onbeforeunload event
            // within iframe. Without the timeout it goes straight to
            // onunload.
            setTimeout(function() {
                if(iframe) {
                    iframe.parentNode.removeChild(iframe);
                }
                iframe = null;
            }, 0);
            utils.unload_del(unload_ref);
        }
    };
    var onerror = function(r) {
        if (iframe) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    iframe.src = iframe_url;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function(){onerror('onerror');};
    iframe.onload = function() {
        // `onload` is triggered before scripts on the iframe are
        // executed. Give it few seconds to actually load stuff.
        clearTimeout(tref);
        tref = setTimeout(function(){onerror('onload timeout');}, 2000);
    };
    _document.body.appendChild(iframe);
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};

utils.createHtmlfile = function (iframe_url, error_callback) {
    var doc = new ActiveXObject('htmlfile');
    var tref, unload_ref;
    var iframe;
    var unattach = function() {
        clearTimeout(tref);
    };
    var cleanup = function() {
        if (doc) {
            unattach();
            utils.unload_del(unload_ref);
            iframe.parentNode.removeChild(iframe);
            iframe = doc = null;
            CollectGarbage();
        }
    };
    var onerror = function(r)  {
        if (doc) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[WPrefix] = _window[WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframe_url;
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};
//         [*] End of lib/dom.js


//         [*] Including lib/dom2.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AbstractXHRObject = function(){};
AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
    var that = this;

    try {
        that.xhr = new XMLHttpRequest();
    } catch(x) {};

    if (!that.xhr) {
        try {
            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');
        } catch(x) {};
    }
    if (_window.ActiveXObject || _window.XDomainRequest) {
        // IE8 caches even POSTs
        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);
    }

    // Explorer tends to keep connection open, even after the
    // tab gets closed: http://bugs.jquery.com/ticket/5280
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        that.xhr.open(method, url, true);
    } catch(e) {
        // IE raises an exception on wrong port.
        that.emit('finish', 0, '');
        that._cleanup();
        return;
    };

    if (!opts || !opts.no_credentials) {
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
        // "This never affects same-site requests."
        that.xhr.withCredentials = 'true';
    }
    if (opts && opts.headers) {
        for(var key in opts.headers) {
            that.xhr.setRequestHeader(key, opts.headers[key]);
        }
    }

    that.xhr.onreadystatechange = function() {
        if (that.xhr) {
            var x = that.xhr;
            switch (x.readyState) {
            case 3:
                // IE doesn't like peeking into responseText or status
                // on Microsoft.XMLHTTP and readystate=3
                try {
                    var status = x.status;
                    var text = x.responseText;
                } catch (x) {};
                // IE does return readystate == 3 for 404 answers.
                if (text && text.length > 0) {
                    that.emit('chunk', status, text);
                }
                break;
            case 4:
                that.emit('finish', x.status, x.responseText);
                that._cleanup(false);
                break;
            }
        }
    };
    that.xhr.send(payload);
};

AbstractXHRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xhr) return;
    utils.unload_del(that.unload_ref);

    // IE needs this field to be a function
    that.xhr.onreadystatechange = function(){};

    if (abort) {
        try {
            that.xhr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

var XHRCorsObject = utils.XHRCorsObject = function() {
    var that = this, args = arguments;
    utils.delay(function(){that._start.apply(that, args);});
};
XHRCorsObject.prototype = new AbstractXHRObject();

var XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){
        that._start(method, url, payload, {
            no_credentials: true
        });
    });
};
XHRLocalObject.prototype = new AbstractXHRObject();



// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
var XDRObject = utils.XDRObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){that._start(method, url, payload);});
};
XDRObject.prototype = new EventEmitter(['chunk', 'finish']);
XDRObject.prototype._start = function(method, url, payload) {
    var that = this;
    var xdr = new XDomainRequest();
    // IE caches even POSTs
    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);

    var onerror = xdr.ontimeout = xdr.onerror = function() {
        that.emit('finish', 0, '');
        that._cleanup(false);
    };
    xdr.onprogress = function() {
        that.emit('chunk', 200, xdr.responseText);
    };
    xdr.onload = function() {
        that.emit('finish', 200, xdr.responseText);
        that._cleanup(false);
    };
    that.xdr = xdr;
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        // Fails with AccessDenied if port number is bogus
        that.xdr.open(method, url);
        that.xdr.send(payload);
    } catch(x) {
        onerror();
    }
};

XDRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xdr) return;
    utils.unload_del(that.unload_ref);

    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =
        that.xdr.onload = null;
    if (abort) {
        try {
            that.xdr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xdr = null;
};

XDRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

// 1. Is natively via XHR
// 2. Is natively via XDR
// 3. Nope, but postMessage is there so it should work via the Iframe.
// 4. Nope, sorry.
utils.isXHRCorsCapable = function() {
    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {
        return 1;
    }
    // XDomainRequest doesn't work if page is served from file://
    if (_window.XDomainRequest && _document.domain) {
        return 2;
    }
    if (IframeTransport.enabled()) {
        return 3;
    }
    return 4;
};
//         [*] End of lib/dom2.js


//         [*] Including lib/sockjs.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SockJS = function(url, dep_protocols_whitelist, options) {
    if (this === window) {
        // makes `new` optional
        return new SockJS(url, dep_protocols_whitelist, options);
    }
    
    var that = this, protocols_whitelist;
    that._options = {devel: false, debug: false, protocols_whitelist: [],
                     info: undefined, rtt: undefined};
    if (options) {
        utils.objectExtend(that._options, options);
    }
    that._base_url = utils.amendUrl(url);
    that._server = that._options.server || utils.random_number_string(1000);
    if (that._options.protocols_whitelist &&
        that._options.protocols_whitelist.length) {
        protocols_whitelist = that._options.protocols_whitelist;
    } else {
        // Deprecated API
        if (typeof dep_protocols_whitelist === 'string' &&
            dep_protocols_whitelist.length > 0) {
            protocols_whitelist = [dep_protocols_whitelist];
        } else if (utils.isArray(dep_protocols_whitelist)) {
            protocols_whitelist = dep_protocols_whitelist
        } else {
            protocols_whitelist = null;
        }
        if (protocols_whitelist) {
            that._debug('Deprecated API: Use "protocols_whitelist" option ' +
                        'instead of supplying protocol list as a second ' +
                        'parameter to SockJS constructor.');
        }
    }
    that._protocols = [];
    that.protocol = null;
    that.readyState = SockJS.CONNECTING;
    that._ir = createInfoReceiver(that._base_url);
    that._ir.onfinish = function(info, rtt) {
        that._ir = null;
        if (info) {
            if (that._options.info) {
                // Override if user supplies the option
                info = utils.objectExtend(info, that._options.info);
            }
            if (that._options.rtt) {
                rtt = that._options.rtt;
            }
            that._applyInfo(info, rtt, protocols_whitelist);
            that._didClose();
        } else {
            that._didClose(1002, 'Can\'t connect to server', true);
        }
    };
};
// Inheritance
SockJS.prototype = new REventTarget();

SockJS.version = "0.3.1.7.ga67f.dirty";

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._debug = function() {
    if (this._options.debug)
        utils.log.apply(utils, arguments);
};

SockJS.prototype._dispatchOpen = function() {
    var that = this;
    if (that.readyState === SockJS.CONNECTING) {
        if (that._transport_tref) {
            clearTimeout(that._transport_tref);
            that._transport_tref = null;
        }
        that.readyState = SockJS.OPEN;
        that.dispatchEvent(new SimpleEvent("open"));
    } else {
        // The server might have been restarted, and lost track of our
        // connection.
        that._didClose(1006, "Server lost session");
    }
};

SockJS.prototype._dispatchMessage = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
            return;
    that.dispatchEvent(new SimpleEvent("message", {data: data}));
};

SockJS.prototype._dispatchHeartbeat = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
        return;
    that.dispatchEvent(new SimpleEvent('heartbeat', {}));
};

SockJS.prototype._didClose = function(code, reason, force) {
    var that = this;
    if (that.readyState !== SockJS.CONNECTING &&
        that.readyState !== SockJS.OPEN &&
        that.readyState !== SockJS.CLOSING)
            throw new Error('INVALID_STATE_ERR');
    if (that._ir) {
        that._ir.nuke();
        that._ir = null;
    }

    if (that._transport) {
        that._transport.doCleanup();
        that._transport = null;
    }

    var close_event = new SimpleEvent("close", {
        code: code,
        reason: reason,
        wasClean: utils.userSetCode(code)});

    if (!utils.userSetCode(code) &&
        that.readyState === SockJS.CONNECTING && !force) {
        if (that._try_next_protocol(close_event)) {
            return;
        }
        close_event = new SimpleEvent("close", {code: 2000,
                                                reason: "All transports failed",
                                                wasClean: false,
                                                last_event: close_event});
    }
    that.readyState = SockJS.CLOSED;

    utils.delay(function() {
                   that.dispatchEvent(close_event);
                });
};

SockJS.prototype._didMessage = function(data) {
    var that = this;
    var type = data.slice(0, 1);
    switch(type) {
    case 'o':
        that._dispatchOpen();
        break;
    case 'a':
        var payload = JSON.parse(data.slice(1) || '[]');
        for(var i=0; i < payload.length; i++){
            that._dispatchMessage(payload[i]);
        }
        break;
    case 'm':
        var payload = JSON.parse(data.slice(1) || 'null');
        that._dispatchMessage(payload);
        break;
    case 'c':
        var payload = JSON.parse(data.slice(1) || '[]');
        that._didClose(payload[0], payload[1]);
        break;
    case 'h':
        that._dispatchHeartbeat();
        break;
    }
};

SockJS.prototype._try_next_protocol = function(close_event) {
    var that = this;
    if (that.protocol) {
        that._debug('Closed transport:', that.protocol, ''+close_event);
        that.protocol = null;
    }
    if (that._transport_tref) {
        clearTimeout(that._transport_tref);
        that._transport_tref = null;
    }

    while(1) {
        var protocol = that.protocol = that._protocols.shift();
        if (!protocol) {
            return false;
        }
        // Some protocols require access to `body`, what if were in
        // the `head`?
        if (SockJS[protocol] &&
            SockJS[protocol].need_body === true &&
            (!_document.body ||
             (typeof _document.readyState !== 'undefined'
              && _document.readyState !== 'complete'))) {
            that._protocols.unshift(protocol);
            that.protocol = 'waiting-for-load';
            utils.attachEvent('load', function(){
                that._try_next_protocol();
            });
            return true;
        }

        if (!SockJS[protocol] ||
              !SockJS[protocol].enabled(that._options)) {
            that._debug('Skipping transport:', protocol);
        } else {
            var roundTrips = SockJS[protocol].roundTrips || 1;
            var to = ((that._options.rto || 0) * roundTrips) || 5000;
            that._transport_tref = utils.delay(to, function() {
                if (that.readyState === SockJS.CONNECTING) {
                    // I can't understand how it is possible to run
                    // this timer, when the state is CLOSED, but
                    // apparently in IE everythin is possible.
                    that._didClose(2007, "Transport timeouted");
                }
            });

            var connid = utils.random_string(8);
            var trans_url = that._base_url + '/' + that._server + '/' + connid;
            that._debug('Opening transport:', protocol, ' url:'+trans_url,
                        ' RTO:'+that._options.rto);
            that._transport = new SockJS[protocol](that, trans_url,
                                                   that._base_url);
            return true;
        }
    }
};

SockJS.prototype.close = function(code, reason) {
    var that = this;
    if (code && !utils.userSetCode(code))
        throw new Error("INVALID_ACCESS_ERR");
    if(that.readyState !== SockJS.CONNECTING &&
       that.readyState !== SockJS.OPEN) {
        return false;
    }
    that.readyState = SockJS.CLOSING;
    that._didClose(code || 1000, reason || "Normal closure");
    return true;
};

SockJS.prototype.send = function(data) {
    var that = this;
    if (that.readyState === SockJS.CONNECTING)
        throw new Error('INVALID_STATE_ERR');
    if (that.readyState === SockJS.OPEN) {
        that._transport.doSend(utils.quote('' + data));
    }
    return true;
};

SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {
    var that = this;
    that._options.info = info;
    that._options.rtt = rtt;
    that._options.rto = utils.countRTO(rtt);
    that._options.info.null_origin = !_document.domain;
    var probed = utils.probeProtocols();
    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);
};
//         [*] End of lib/sockjs.js


//         [*] Including lib/trans-websocket.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {
    var that = this;
    var url = trans_url + '/websocket';
    if (url.slice(0, 5) === 'https') {
        url = 'wss' + url.slice(5);
    } else {
        url = 'ws' + url.slice(4);
    }
    that.ri = ri;
    that.url = url;
    var Constructor = _window.WebSocket || _window.MozWebSocket;

    that.ws = new Constructor(that.url);
    that.ws.onmessage = function(e) {
        that.ri._didMessage(e.data);
    };
    // Firefox has an interesting bug. If a websocket connection is
    // created after onbeforeunload, it stays alive even when user
    // navigates away from the page. In such situation let's lie -
    // let's not open the ws connection at all. See:
    // https://github.com/sockjs/sockjs-client/issues/28
    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
    that.unload_ref = utils.unload_add(function(){that.ws.close()});
    that.ws.onclose = function() {
        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"));
    };
};

WebSocketTransport.prototype.doSend = function(data) {
    this.ws.send('[' + data + ']');
};

WebSocketTransport.prototype.doCleanup = function() {
    var that = this;
    var ws = that.ws;
    if (ws) {
        ws.onmessage = ws.onclose = null;
        ws.close();
        utils.unload_del(that.unload_ref);
        that.unload_ref = that.ri = that.ws = null;
    }
};

WebSocketTransport.enabled = function() {
    return !!(_window.WebSocket || _window.MozWebSocket);
};

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;
//         [*] End of lib/trans-websocket.js


//         [*] Including lib/trans-sender.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var BufferedSender = function() {};
BufferedSender.prototype.send_constructor = function(sender) {
    var that = this;
    that.send_buffer = [];
    that.sender = sender;
};
BufferedSender.prototype.doSend = function(message) {
    var that = this;
    that.send_buffer.push(message);
    if (!that.send_stop) {
        that.send_schedule();
    }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.send_schedule_wait = function() {
    var that = this;
    var tref;
    that.send_stop = function() {
        that.send_stop = null;
        clearTimeout(tref);
    };
    tref = utils.delay(25, function() {
        that.send_stop = null;
        that.send_schedule();
    });
};

BufferedSender.prototype.send_schedule = function() {
    var that = this;
    if (that.send_buffer.length > 0) {
        var payload = '[' + that.send_buffer.join(',') + ']';
        that.send_stop = that.sender(that.trans_url,
                                     payload,
                                     function() {
                                         that.send_stop = null;
                                         that.send_schedule_wait();
                                     });
        that.send_buffer = [];
    }
};

BufferedSender.prototype.send_destructor = function() {
    var that = this;
    if (that._send_stop) {
        that._send_stop();
    }
    that._send_stop = null;
};

var jsonPGenericSender = function(url, payload, callback) {
    var that = this;

    if (!('_send_form' in that)) {
        var form = that._send_form = _document.createElement('form');
        var area = that._send_area = _document.createElement('textarea');
        area.name = 'd';
        form.style.display = 'none';
        form.style.position = 'absolute';
        form.method = 'POST';
        form.enctype = 'application/x-www-form-urlencoded';
        form.acceptCharset = "UTF-8";
        form.appendChild(area);
        _document.body.appendChild(form);
    }
    var form = that._send_form;
    var area = that._send_area;
    var id = 'a' + utils.random_string(8);
    form.target = id;
    form.action = url + '/jsonp_send?i=' + id;

    var iframe;
    try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = _document.createElement('<iframe name="'+ id +'">');
    } catch(x) {
        iframe = _document.createElement('iframe');
        iframe.name = id;
    }
    iframe.id = id;
    form.appendChild(iframe);
    iframe.style.display = 'none';

    try {
        area.value = payload;
    } catch(e) {
        utils.log('Your browser is seriously broken. Go home! ' + e.message);
    }
    form.submit();

    var completed = function(e) {
        if (!iframe.onerror) return;
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
        // Opera mini doesn't like if we GC iframe
        // immediately, thus this timeout.
        utils.delay(500, function() {
                       iframe.parentNode.removeChild(iframe);
                       iframe = null;
                   });
        area.value = '';
        callback();
    };
    iframe.onerror = iframe.onload = completed;
    iframe.onreadystatechange = function(e) {
        if (iframe.readyState == 'complete') completed();
    };
    return completed;
};

var createAjaxSender = function(AjaxObject) {
    return function(url, payload, callback) {
        var xo = new AjaxObject('POST', url + '/xhr_send', payload);
        xo.onfinish = function(status, text) {
            callback(status);
        };
        return function(abort_reason) {
            callback(0, abort_reason);
        };
    };
};
//         [*] End of lib/trans-sender.js


//         [*] Including lib/trans-jsonp-receiver.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Parts derived from Socket.io:
//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js
// and jQuery-JSONP:
//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js
var jsonPGenericReceiver = function(url, callback) {
    var tref;
    var script = _document.createElement('script');
    var script2;  // Opera synchronous load trick.
    var close_script = function(frame) {
        if (script2) {
            script2.parentNode.removeChild(script2);
            script2 = null;
        }
        if (script) {
            clearTimeout(tref);
            script.parentNode.removeChild(script);
            script.onreadystatechange = script.onerror =
                script.onload = script.onclick = null;
            script = null;
            callback(frame);
            callback = null;
        }
    };

    // IE9 fires 'error' event after orsc or before, in random order.
    var loaded_okay = false;
    var error_timer = null;

    script.id = 'a' + utils.random_string(8);
    script.src = url;
    script.type = 'text/javascript';
    script.charset = 'UTF-8';
    script.onerror = function(e) {
        if (!error_timer) {
            // Delay firing close_script.
            error_timer = setTimeout(function() {
                if (!loaded_okay) {
                    close_script(utils.closeFrame(
                        1006,
                        "JSONP script loaded abnormally (onerror)"));
                }
            }, 1000);
        }
    };
    script.onload = function(e) {
        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"));
    };

    script.onreadystatechange = function(e) {
        if (/loaded|closed/.test(script.readyState)) {
            if (script && script.htmlFor && script.onclick) {
                loaded_okay = true;
                try {
                    // In IE, actually execute the script.
                    script.onclick();
                } catch (x) {}
            }
            if (script) {
                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"));
            }
        }
    };
    // IE: event/htmlFor/onclick trick.
    // One can't rely on proper order for onreadystatechange. In order to
    // make sure, set a 'htmlFor' and 'event' properties, so that
    // script code will be installed as 'onclick' handler for the
    // script object. Later, onreadystatechange, manually execute this
    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
    // set. For reference see:
    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
    // Also, read on that about script ordering:
    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
    if (typeof script.async === 'undefined' && _document.attachEvent) {
        // According to mozilla docs, in recent browsers script.async defaults
        // to 'true', so we may use it to detect a good browser:
        // https://developer.mozilla.org/en/HTML/Element/script
        if (!/opera/i.test(navigator.userAgent)) {
            // Naively assume we're in IE
            try {
                script.htmlFor = script.id;
                script.event = "onclick";
            } catch (x) {}
            script.async = true;
        } else {
            // Opera, second sync script hack
            script2 = _document.createElement('script');
            script2.text = "try{var a = document.getElementById('"+script.id+"'); if(a)a.onerror();}catch(x){};";
            script.async = script2.async = false;
        }
    }
    if (typeof script.async !== 'undefined') {
        script.async = true;
    }

    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
    tref = setTimeout(function() {
                          close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"));
                      }, 35000);

    var head = _document.getElementsByTagName('head')[0];
    head.insertBefore(script, head.firstChild);
    if (script2) {
        head.insertBefore(script2, head.firstChild);
    }
    return close_script;
};
//         [*] End of lib/trans-jsonp-receiver.js


//         [*] Including lib/trans-jsonp-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// mssage could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors


var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {
    utils.polluteGlobalNamespace();
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(jsonPGenericSender);
    that._schedule_recv();
};

// Inheritnace
JsonPTransport.prototype = new BufferedSender();

JsonPTransport.prototype._schedule_recv = function() {
    var that = this;
    var callback = function(data) {
        that._recv_stop = null;
        if (data) {
            // no data - heartbeat;
            if (!that._is_closing) {
                that.ri._didMessage(data);
            }
        }
        // The message can be a close message, and change is_closing state.
        if (!that._is_closing) {
            that._schedule_recv();
        }
    };
    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',
                                           jsonPGenericReceiver, callback);
};

JsonPTransport.enabled = function() {
    return true;
};

JsonPTransport.need_body = true;


JsonPTransport.prototype.doCleanup = function() {
    var that = this;
    that._is_closing = true;
    if (that._recv_stop) {
        that._recv_stop();
    }
    that.ri = that._recv_stop = null;
    that.send_destructor();
};


// Abstract away code that handles global namespace pollution.
var jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {
    var id = 'a' + utils.random_string(6);
    var url_id = url + '?c=' + escape(WPrefix + '.' + id);
    // Callback will be called exactly once.
    var callback = function(frame) {
        delete _window[WPrefix][id];
        user_callback(frame);
    };

    var close_script = constructReceiver(url_id, callback);
    _window[WPrefix][id] = close_script;
    var stop = function() {
        if (_window[WPrefix][id]) {
            _window[WPrefix][id](utils.closeFrame(1000, "JSONP user aborted read"));
        }
    };
    return stop;
};
//         [*] End of lib/trans-jsonp-polling.js


//         [*] Including lib/trans-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AjaxBasedTransport = function() {};
AjaxBasedTransport.prototype = new BufferedSender();

AjaxBasedTransport.prototype.run = function(ri, trans_url,
                                            url_suffix, Receiver, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(createAjaxSender(AjaxObject));
    that.poll = new Polling(ri, Receiver,
                            trans_url + url_suffix, AjaxObject);
};

AjaxBasedTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.poll) {
        that.poll.abort();
        that.poll = null;
    }
};

// xhr-streaming
var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);
};

XhrStreamingTransport.prototype = new AjaxBasedTransport();

XhrStreamingTransport.enabled = function() {
    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but
    // doesn't do streaming.
    return (_window.XMLHttpRequest &&
            'withCredentials' in new XMLHttpRequest() &&
            (!/opera/i.test(navigator.userAgent)));
};
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
XhrStreamingTransport.need_body = true;


// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/


// xdr-streaming
var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);
};

XdrStreamingTransport.prototype = new AjaxBasedTransport();

XdrStreamingTransport.enabled = function() {
    return !!_window.XDomainRequest;
};
XdrStreamingTransport.roundTrips = 2; // preflight, ajax



// xhr-polling
var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);
};

XhrPollingTransport.prototype = new AjaxBasedTransport();

XhrPollingTransport.enabled = XhrStreamingTransport.enabled;
XhrPollingTransport.roundTrips = 2; // preflight, ajax


// xdr-polling
var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);
};

XdrPollingTransport.prototype = new AjaxBasedTransport();

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.roundTrips = 2; // preflight, ajax
//         [*] End of lib/trans-xhr.js


//         [*] Including lib/trans-iframe.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Few cool transports do work only for same-origin. In order to make
// them working cross-domain we shall use iframe, served form the
// remote domain. New browsers, have capabilities to communicate with
// cross domain iframe, using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var IframeTransport = function() {};

IframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {
    var that = this;
    that.ri = ri;
    that.origin = utils.getOrigin(base_url);
    that.base_url = base_url;
    that.trans_url = trans_url;

    var iframe_url = base_url + '/iframe.html';
    if (that.ri._options.devel) {
        iframe_url += '?t=' + (+new Date);
    }
    that.window_id = utils.random_string(8);
    iframe_url += '#' + that.window_id;

    that.iframeObj = utils.createIframe(iframe_url, function(r) {
                                            that.ri._didClose(1006, "Unable to load an iframe (" + r + ")");
                                        });

    that.onmessage_cb = utils.bind(that.onmessage, that);
    utils.attachMessage(that.onmessage_cb);
};

IframeTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.iframeObj) {
        utils.detachMessage(that.onmessage_cb);
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (that.iframeObj.iframe.contentWindow) {
                that.postMessage('c');
            }
        } catch (x) {}
        that.iframeObj.cleanup();
        that.iframeObj = null;
        that.onmessage_cb = that.iframeObj = null;
    }
};

IframeTransport.prototype.onmessage = function(e) {
    var that = this;
    if (e.origin !== that.origin) return;
    var window_id = e.data.slice(0, 8);
    var type = e.data.slice(8, 9);
    var data = e.data.slice(9);

    if (window_id !== that.window_id) return;

    switch(type) {
    case 's':
        that.iframeObj.loaded();
        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));
        break;
    case 't':
        that.ri._didMessage(data);
        break;
    }
};

IframeTransport.prototype.postMessage = function(type, data) {
    var that = this;
    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);
};

IframeTransport.prototype.doSend = function (message) {
    this.postMessage('m', message);
};

IframeTransport.enabled = function() {
    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
    // huge delay, or not at all.
    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;
    return ((typeof _window.postMessage === 'function' ||
            typeof _window.postMessage === 'object') && (!konqueror));
};
//         [*] End of lib/trans-iframe.js


//         [*] Including lib/trans-iframe-within.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var curr_window_id;

var postMessage = function (type, data) {
    if(parent !== _window) {
        parent.postMessage(curr_window_id + type + (data || ''), '*');
    } else {
        utils.log("Can't postMessage, no parent window.", type, data);
    }
};

var FacadeJS = function() {};
FacadeJS.prototype._didClose = function (code, reason) {
    postMessage('t', utils.closeFrame(code, reason));
};
FacadeJS.prototype._didMessage = function (frame) {
    postMessage('t', frame);
};
FacadeJS.prototype._doSend = function (data) {
    this._transport.doSend(data);
};
FacadeJS.prototype._doCleanup = function () {
    this._transport.doCleanup();
};

utils.parent_origin = undefined;

SockJS.bootstrap_iframe = function() {
    var facade;
    curr_window_id = _document.location.hash.slice(1);
    var onMessage = function(e) {
        if(e.source !== parent) return;
        if(typeof utils.parent_origin === 'undefined')
            utils.parent_origin = e.origin;
        if (e.origin !== utils.parent_origin) return;

        var window_id = e.data.slice(0, 8);
        var type = e.data.slice(8, 9);
        var data = e.data.slice(9);
        if (window_id !== curr_window_id) return;
        switch(type) {
        case 's':
            var p = JSON.parse(data);
            var version = p[0];
            var protocol = p[1];
            var trans_url = p[2];
            var base_url = p[3];
            if (version !== SockJS.version) {
                utils.log("Incompatibile SockJS! Main site uses:" +
                          " \"" + version + "\", the iframe:" +
                          " \"" + SockJS.version + "\".");
            }
            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {
                utils.log("Only basic urls are supported in SockJS");
                return;
            }

            if (!utils.isSameOriginUrl(trans_url) ||
                !utils.isSameOriginUrl(base_url)) {
                utils.log("Can't connect to different domain from within an " +
                          "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) +
                          ")");
                return;
            }
            facade = new FacadeJS();
            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);
            break;
        case 'm':
            facade._doSend(data);
            break;
        case 'c':
            if (facade)
                facade._doCleanup();
            facade = null;
            break;
        }
    };

    // alert('test ticker');
    // facade = new FacadeJS();
    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');

    utils.attachMessage(onMessage);

    // Start
    postMessage('s');
};
//         [*] End of lib/trans-iframe-within.js


//         [*] Including lib/info.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var InfoReceiver = function(base_url, AjaxObject) {
    var that = this;
    utils.delay(function(){that.doXhr(base_url, AjaxObject);});
};

InfoReceiver.prototype = new EventEmitter(['finish']);

InfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {
    var that = this;
    var t0 = (new Date()).getTime();
    var xo = new AjaxObject('GET', base_url + '/info');

    var tref = utils.delay(8000,
                           function(){xo.ontimeout();});

    xo.onfinish = function(status, text) {
        clearTimeout(tref);
        tref = null;
        if (status === 200) {
            var rtt = (new Date()).getTime() - t0;
            var info = JSON.parse(text);
            if (typeof info !== 'object') info = {};
            that.emit('finish', info, rtt);
        } else {
            that.emit('finish');
        }
    };
    xo.ontimeout = function() {
        xo.close();
        that.emit('finish');
    };
};

var InfoReceiverIframe = function(base_url) {
    var that = this;
    var go = function() {
        var ifr = new IframeTransport();
        ifr.protocol = 'w-iframe-info-receiver';
        var fun = function(r) {
            if (typeof r === 'string' && r.substr(0,1) === 'm') {
                var d = JSON.parse(r.substr(1));
                var info = d[0], rtt = d[1];
                that.emit('finish', info, rtt);
            } else {
                that.emit('finish');
            }
            ifr.doCleanup();
            ifr = null;
        };
        var mock_ri = {
            _options: {},
            _didClose: fun,
            _didMessage: fun
        };
        ifr.i_constructor(mock_ri, base_url, base_url);
    }
    if(!_document.body) {
        utils.attachEvent('load', go);
    } else {
        go();
    }
};
InfoReceiverIframe.prototype = new EventEmitter(['finish']);


var InfoReceiverFake = function() {
    // It may not be possible to do cross domain AJAX to get the info
    // data, for example for IE7. But we want to run JSONP, so let's
    // fake the response, with rtt=2s (rto=6s).
    var that = this;
    utils.delay(function() {
        that.emit('finish', {}, 2000);
    });
};
InfoReceiverFake.prototype = new EventEmitter(['finish']);

var createInfoReceiver = function(base_url) {
    if (utils.isSameOriginUrl(base_url)) {
        // If, for some reason, we have SockJS locally - there's no
        // need to start up the complex machinery. Just use ajax.
        return new InfoReceiver(base_url, utils.XHRLocalObject);
    }
    switch (utils.isXHRCorsCapable()) {
    case 1:
        return new InfoReceiver(base_url, utils.XHRCorsObject);
    case 2:
        return new InfoReceiver(base_url, utils.XDRObject);
    case 3:
        // Opera
        return new InfoReceiverIframe(base_url);
    default:
        // IE 7
        return new InfoReceiverFake();
    };
};


var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {
    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);
    ir.onfinish = function(info, rtt) {
        ri._didMessage('m'+JSON.stringify([info, rtt]));
        ri._didClose();
    }
};
WInfoReceiverIframe.prototype.doCleanup = function() {};
//         [*] End of lib/info.js


//         [*] Including lib/trans-iframe-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {
    var that = this;
    that.protocol = 'w-iframe-eventsource';
    that.i_constructor.apply(that, arguments);
};

EventSourceIframeTransport.prototype = new IframeTransport();

EventSourceIframeTransport.enabled = function () {
    return ('EventSource' in _window) && IframeTransport.enabled();
};

EventSourceIframeTransport.need_body = true;
EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource


// w-iframe-eventsource
var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);
}
EventSourceTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-eventsource.js


//         [*] Including lib/trans-iframe-xhr-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {
    var that = this;
    that.protocol = 'w-iframe-xhr-polling';
    that.i_constructor.apply(that, arguments);
};

XhrPollingIframeTransport.prototype = new IframeTransport();

XhrPollingIframeTransport.enabled = function () {
    return _window.XMLHttpRequest && IframeTransport.enabled();
};

XhrPollingIframeTransport.need_body = true;
XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr


// w-iframe-xhr-polling
var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);
};

XhrPollingITransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-xhr-polling.js


//         [*] Including lib/trans-iframe-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// This transport generally works in any browser, but will cause a
// spinning cursor to appear in any browser other than IE.
// We may test this transport in all browsers - why not, but in
// production it should be only run in IE.

var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {
    var that = this;
    that.protocol = 'w-iframe-htmlfile';
    that.i_constructor.apply(that, arguments);
};

// Inheritance.
HtmlFileIframeTransport.prototype = new IframeTransport();

HtmlFileIframeTransport.enabled = function() {
    return IframeTransport.enabled();
};

HtmlFileIframeTransport.need_body = true;
HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile


// w-iframe-htmlfile
var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);
};
HtmlFileTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-htmlfile.js


//         [*] Including lib/trans-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var Polling = function(ri, Receiver, recv_url, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.Receiver = Receiver;
    that.recv_url = recv_url;
    that.AjaxObject = AjaxObject;
    that._scheduleRecv();
};

Polling.prototype._scheduleRecv = function() {
    var that = this;
    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);
    var msg_counter = 0;
    poll.onmessage = function(e) {
        msg_counter += 1;
        that.ri._didMessage(e.data);
    };
    poll.onclose = function(e) {
        that.poll = poll = poll.onmessage = poll.onclose = null;
        if (!that.poll_is_closing) {
            if (e.reason === 'permanent') {
                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');
            } else {
                that._scheduleRecv();
            }
        }
    };
};

Polling.prototype.abort = function() {
    var that = this;
    that.poll_is_closing = true;
    if (that.poll) {
        that.poll.abort();
    }
};
//         [*] End of lib/trans-polling.js


//         [*] Including lib/trans-receiver-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceReceiver = function(url) {
    var that = this;
    var es = new EventSource(url);
    es.onmessage = function(e) {
        that.dispatchEvent(new SimpleEvent('message',
                                           {'data': unescape(e.data)}));
    };
    that.es_close = es.onerror = function(e, abort_reason) {
        // ES on reconnection has readyState = 0 or 1.
        // on network error it's CLOSED = 2
        var reason = abort_reason ? 'user' :
            (es.readyState !== 2 ? 'network' : 'permanent');
        that.es_close = es.onmessage = es.onerror = null;
        // EventSource reconnects automatically.
        es.close();
        es = null;
        // Safari and chrome < 15 crash if we close window before
        // waiting for ES cleanup. See:
        //   https://code.google.com/p/chromium/issues/detail?id=89155
        utils.delay(200, function() {
                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
                    });
    };
};

EventSourceReceiver.prototype = new REventTarget();

EventSourceReceiver.prototype.abort = function() {
    var that = this;
    if (that.es_close) {
        that.es_close({}, true);
    }
};
//         [*] End of lib/trans-receiver-eventsource.js


//         [*] Including lib/trans-receiver-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var _is_ie_htmlfile_capable;
var isIeHtmlfileCapable = function() {
    if (_is_ie_htmlfile_capable === undefined) {
        if ('ActiveXObject' in _window) {
            try {
                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');
            } catch (x) {}
        } else {
            _is_ie_htmlfile_capable = false;
        }
    }
    return _is_ie_htmlfile_capable;
};


var HtmlfileReceiver = function(url) {
    var that = this;
    utils.polluteGlobalNamespace();

    that.id = 'a' + utils.random_string(6, 26);
    url += ((url.indexOf('?') === -1) ? '?' : '&') +
        'c=' + escape(WPrefix + '.' + that.id);

    var constructor = isIeHtmlfileCapable() ?
        utils.createHtmlfile : utils.createIframe;

    var iframeObj;
    _window[WPrefix][that.id] = {
        start: function () {
            iframeObj.loaded();
        },
        message: function (data) {
            that.dispatchEvent(new SimpleEvent('message', {'data': data}));
        },
        stop: function () {
            that.iframe_close({}, 'network');
        }
    };
    that.iframe_close = function(e, abort_reason) {
        iframeObj.cleanup();
        that.iframe_close = iframeObj = null;
        delete _window[WPrefix][that.id];
        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));
    };
    iframeObj = constructor(url, function(e) {
                                that.iframe_close({}, 'permanent');
                            });
};

HtmlfileReceiver.prototype = new REventTarget();

HtmlfileReceiver.prototype.abort = function() {
    var that = this;
    if (that.iframe_close) {
        that.iframe_close({}, 'user');
    }
};
//         [*] End of lib/trans-receiver-htmlfile.js


//         [*] Including lib/trans-receiver-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrReceiver = function(url, AjaxObject) {
    var that = this;
    var buf_pos = 0;

    that.xo = new AjaxObject('POST', url, null);
    that.xo.onchunk = function(status, text) {
        if (status !== 200) return;
        while (1) {
            var buf = text.slice(buf_pos);
            var p = buf.indexOf('\n');
            if (p === -1) break;
            buf_pos += p+1;
            var msg = buf.slice(0, p);
            that.dispatchEvent(new SimpleEvent('message', {data: msg}));
        }
    };
    that.xo.onfinish = function(status, text) {
        that.xo.onchunk(status, text);
        that.xo = null;
        var reason = status === 200 ? 'network' : 'permanent';
        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
    }
};

XhrReceiver.prototype = new REventTarget();

XhrReceiver.prototype.abort = function() {
    var that = this;
    if (that.xo) {
        that.xo.close();
        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));
        that.xo = null;
    }
};
//         [*] End of lib/trans-receiver-xhr.js


//         [*] Including lib/test-hooks.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// For testing
SockJS.getUtils = function(){
    return utils;
};

SockJS.getIframeTransport = function(){
    return IframeTransport;
};
//         [*] End of lib/test-hooks.js

                  return SockJS;
          })();
if ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);

// AMD compliance
if (typeof define === 'function' && define.amd) {
    define('sockjs', [], function(){return SockJS;});
}

if (typeof module === 'object' && module && module.exports) {
    module.exports = SockJS;
}
//     [*] End of lib/index.js

// [*] End of lib/all.js


},{}],82:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":66,"inherits":68,"readable-stream/duplex.js":84,"readable-stream/passthrough.js":93,"readable-stream/readable.js":94,"readable-stream/transform.js":95,"readable-stream/writable.js":96}],83:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],84:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":85}],85:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":87,"./_stream_writable":89,"core-util-is":57,"inherits":68,"process-nextick-args":73}],86:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":88,"core-util-is":57,"inherits":68}],87:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":85,"./internal/streams/BufferList":90,"./internal/streams/destroy":91,"./internal/streams/stream":92,"_process":74,"core-util-is":57,"events":66,"inherits":68,"isarray":83,"process-nextick-args":73,"safe-buffer":79,"string_decoder/":97,"util":49}],88:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":85,"core-util-is":57,"inherits":68}],89:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":85,"./internal/streams/destroy":91,"./internal/streams/stream":92,"_process":74,"core-util-is":57,"inherits":68,"process-nextick-args":73,"safe-buffer":79,"util-deprecate":101}],90:[function(require,module,exports){
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
},{"safe-buffer":79}],91:[function(require,module,exports){
'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":73}],92:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":66}],93:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":94}],94:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":85,"./lib/_stream_passthrough.js":86,"./lib/_stream_readable.js":87,"./lib/_stream_transform.js":88,"./lib/_stream_writable.js":89}],95:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":94}],96:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":89}],97:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":79}],98:[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],99:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":100,"punycode":75,"querystring":78}],100:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],101:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[20])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvRVJST1JTLmpzIiwibGliL2NsaWVudC9qcy9DT05TVC5qcyIsImxpYi9jbGllbnQvanMvVG9hc3QuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvSk1CRlVwbG9hZGVyQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9Kc29uSW1wb3J0Q29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9hdXRoQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9icmVhZGNydW1iQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9jcmVhdGVOZXdQcm9qZWN0Q29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9tZW51UmlnaHRDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL21vdmVQcm9qZWN0Q29tcG9uZW50LmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3BhZ2VIZWFkZXJDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXIuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvcHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci90ZXh0RWRpdG9yQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci90cmFuc2xhdGlvblZpZXdDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3VwbG9hZENvbnRyb2xsZXIuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvdXJsTWFuaXB1bGF0b3IuanMiLCJsaWIvY2xpZW50L2pzL2V2ZW50cy5qcyIsImxpYi9jbGllbnQvanMvaGFuZGxlU2Vzc2lvblRpbWVPdXQuanMiLCJsaWIvY2xpZW50L2pzL21haW4uanMiLCJsaWIvY2xpZW50L2pzL3RleHRFZGl0b3IuanMiLCJsaWIvY2xpZW50L2pzL3RyYWRlLmpzIiwibGliL2NsaWVudC9qcy91aUV2ZW50TWFuYWdlci5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL0pNQkZVcGxvYWRlci5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL0pzb25JbXBvcnQuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9hbmNob3JNZW51LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvYXV0aC5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2JyZWFkY3J1bWIuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9jb25uZWN0aW9uTG9zdC9pbmRleC5odG1sIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvY29ubmVjdGlvbkxvc3QvaW5kZXguanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9jcmVhdGVOZXdQcm9qZWN0LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvZGlzcGxheU1hbmFnZXIuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9mbGFnLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvaW1hZ2VWaWV3ZXIuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9pbnB1dEVkaXRNYW5hZ2VyLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvbWVudVJpZ2h0LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvb3ZlcmxheS5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3Byb2plY3RNYWluTmF2aWdhdGlvbi5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3Byb2plY3RPdmVydmlldy5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3RleHRzLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3RGVzY3JpcHRpb24uanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZC5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3VwbG9hZC5qcyIsImxpYi9jbGllbnQvanMvdW5pY29kZS5qcyIsImxpYi9jbGllbnQvanMvdXRpbC91cmwuanMiLCJsaWIvY2xpZW50L2pzL3V0aWwvd29yZENvdW50ZXIuanMiLCJub2RlX21vZHVsZXMvYmFzZTY0LWpzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXItcmVzb2x2ZS9lbXB0eS5qcyIsIm5vZGVfbW9kdWxlcy9idWZmZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvY2FubnktY29va2llTWFuYWdlci1saWIvY29va2llTWFuYWdlci5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ueS9jYW5ueS5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ueS9tb2QvYXN5bmMuanMiLCJub2RlX21vZHVsZXMvY2FubnkvbW9kL2Zsb3dDb250cm9sLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm55L21vZC9yZXBlYXQuanMiLCJub2RlX21vZHVsZXMvY2FubnkvbW9kL3doaXNrZXIuanMiLCJub2RlX21vZHVsZXMvY29yZS11dGlsLWlzL2xpYi91dGlsLmpzIiwibm9kZV9tb2R1bGVzL2Rub2RlLXByb3RvY29sL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Rub2RlLXByb3RvY29sL2xpYi9mb3JlYWNoLmpzIiwibm9kZV9tb2R1bGVzL2Rub2RlLXByb3RvY29sL2xpYi9pc19lbnVtLmpzIiwibm9kZV9tb2R1bGVzL2Rub2RlLXByb3RvY29sL2xpYi9rZXlzLmpzIiwibm9kZV9tb2R1bGVzL2Rub2RlLXByb3RvY29sL2xpYi9zY3J1Yi5qcyIsIm5vZGVfbW9kdWxlcy9kbm9kZS9icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2Rub2RlL2xpYi9kbm9kZS5qcyIsIm5vZGVfbW9kdWxlcy9kb20tb3B0cy9kb21PcHRzLmpzIiwibm9kZV9tb2R1bGVzL2V2ZW50cy9ldmVudHMuanMiLCJub2RlX21vZHVsZXMvaWVlZTc1NC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9pbmhlcml0cy9pbmhlcml0c19icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL2lzLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9qc29uaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3BhcnNlLmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvbGliL3N0cmluZ2lmeS5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzLW5leHRpY2stYXJncy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHVueWNvZGUvcHVueWNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2RlY29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZW5jb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zYWZlLWJ1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zaG9lL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc2hvZS9ub2RlX21vZHVsZXMvc29ja2pzLWNsaWVudC9zb2NranMuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL2lzYXJyYXkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9kdXBsZXgtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX2R1cGxleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcmVhZGFibGUuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV93cml0YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3QuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9zdHJpbmdfZGVjb2Rlci9saWIvc3RyaW5nX2RlY29kZXIuanMiLCJub2RlX21vZHVsZXMvdHJhdmVyc2UvaW5kZXguanMiLCJub2RlX21vZHVsZXMvdXJsL3VybC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXRpbC5qcyIsIm5vZGVfbW9kdWxlcy91dGlsLWRlcHJlY2F0ZS9icm93c2VyLmpzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBOzs7QUNBQTs7Ozs7QUFLQSxPQUFPLE9BQVAsR0FBaUI7QUFDYixzQkFBcUIsb0JBRFI7QUFFYixjQUFZLFlBRkM7QUFHYixpQkFBZTtBQUhGLENBQWpCOzs7OztBQ0xBLElBQUksSUFBSTtBQUNKLGtCQUFlO0FBQ1gsb0JBQWE7QUFDVCxtQkFBUSxPQURDO0FBRVQsa0JBQVE7QUFGQyxTQURGO0FBS1gsa0JBQVc7QUFDUCxtQkFBUSxRQUREO0FBRVAsa0JBQU87QUFGQTtBQUxBLEtBRFg7QUFXSixhQUFVO0FBQ04sZ0NBQXdCLE9BQU87QUFEekI7QUFYTixDQUFSOztBQWdCQSxPQUFPLE9BQVAsR0FBaUIsQ0FBakI7Ozs7O0FDaEJBOzs7Ozs7QUFNQSxJQUFJLFFBQVEsSUFBSyxTQUFTLEtBQVQsQ0FBZSxFQUFmLEVBQWtCO0FBQy9CLFFBQUksUUFBUSxJQUFaO0FBQUEsUUFDQSxtQkFBbUIsSUFEbkI7QUFBQSxRQUVBLHNCQUFzQixDQUZ0QjtBQUFBLFFBR0EsWUFBWSxTQUFTLGNBQVQsQ0FBd0IsRUFBeEIsQ0FIWjtBQUFBLFFBSUEsdUJBQXVCLElBSnZCO0FBQUEsUUFLQSxhQUFhLElBTGI7QUFBQSxRQU1BLFlBQVksU0FBWixTQUFZLEdBQVU7QUFDbEIsWUFBSSxXQUFXLFNBQVMsb0JBQVQsQ0FBOEIsTUFBOUIsRUFBc0MsQ0FBdEMsQ0FBZjtBQUNBLG9CQUFZ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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbHJEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6VkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOWZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsa0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzNHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5U0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDMUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNueEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUM5Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzkrQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3JOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3ZwQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZFQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBOztBQ0RBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvUUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1dEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIi8qKlxuICogRXJyb3IgY29uc3RhbnRzXG4gKlxuICogQHR5cGUge3tQUk9KRUNUX05PVF9FWElTVFM6IG51bWJlciwgSU5WQUxJRF9VUkw6IG51bWJlciwgTk9fUEVSTUlTU0lPTjogbnVtYmVyfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgUFJPSkVDVF9OT1RfRVhJU1RTIDogJ1BST0pFQ1RfTk9UX0VYSVNUUycsXG4gICAgVkFMSURBVElPTjogJ1ZBTElEQVRJT04nLFxuICAgIE5PX1BFUk1JU1NJT046ICdOT19QRVJNSVNTSU9OJ1xufSIsInZhciBDID0ge1xuICAgIEZJTEVfTUFOQUdFUiA6IHtcbiAgICAgICAgRklMRV9UWVBFUyA6IHtcbiAgICAgICAgICAgIElNQUdFIDogJ2ltYWdlJyxcbiAgICAgICAgICAgIEZJTEUgIDogJ2ZpbGUnXG4gICAgICAgIH0sXG4gICAgICAgIEVOQ09ESU5HIDoge1xuICAgICAgICAgICAgaW1hZ2UgOiAnYmFzZTY0JyxcbiAgICAgICAgICAgIGZpbGUgOiAndXRmOCdcbiAgICAgICAgfVxuICAgIH0sXG4gICAgU0VTU0lPTiA6IHtcbiAgICAgICAgcmVuZXdhbF9pbnRlcnZhbF9pbl9tczogMTAwMCAqIDE1XG4gICAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBDO1xuIiwiLyoqXG4gKiBUT0RPIGZhZGUgb3V0IHdoZW4gbWF4TGVuZ3RoT2ZNZXNzYWdlcyBleGNlZWRlZCBsb29rcyBub3Qgc28gbmljZVxuICogQHBhcmFtIGlkXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKiBAY29uc3RydWN0b3JcbiAqL1xudmFyIHRvYXN0ID0gbmV3IChmdW5jdGlvbiBUb2FzdChpZCl7XG4gICAgdmFyIERFTEFZID0gNDAwMCxcbiAgICBvcGFjaXR5RmFkZVN0ZXBzID0gMC4wNCxcbiAgICBtYXhMZW5ndGhPZk1lc3NhZ2VzID0gNCxcbiAgICB0b2FzdE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCksXG4gICAgaXNSZWFkeUZvclN0YXJ0QWdhaW4gPSB0cnVlLFxuICAgIG5ld01lc3NhZ2UgPSB0cnVlLFxuICAgIGluaXRUb2FzdCA9IGZ1bmN0aW9uKCl7XG4gICAgICAgIHZhciByb290Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdib2R5JylbMF07XG4gICAgICAgIHRvYXN0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICB0b2FzdE5vZGUuaWQgPSBpZDtcbiAgICAgICAgdG9hc3ROb2RlLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmZpeGVkO3otaW5kZXg6OTk5O3RvcDo0LjVlbTtyaWdodDoyZW07Ym9yZGVyLXJhZGl1czo1cHg7Y29sb3I6I2ZmZjtmb250LXNpemU6MS4yZW07Zm9udC13ZWlnaHQ6Ym9sZDtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoNjMsMTQzLDI1MSwwLjkpO3BhZGRpbmc6IDFlbSAwLjVlbTsgYm94LXNpemluZzogYm9yZGVyLWJveDsgbWF4LXdpZHRoOiA1MCU7IHRleHQtYWxpZ246IGNlbnRlcjsgd29yZC13cmFwOiBicmVhay13b3JkOyBicmVhay13b3JkOiBicmVhay1hbGw7XCJcbiAgICAgICAgcm9vdE5vZGUuYXBwZW5kQ2hpbGQodG9hc3ROb2RlKTtcbiAgICB9LFxuICAgIHRvYXN0ID0ge1xuICAgICAgICBmYWRlT3V0IDogZnVuY3Rpb24oX25vZGUsX2RvbmUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gX25vZGU7XG4gICAgICAgICAgICB2YXIgZG9uZSA9IF9kb25lO1xuICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgKGZ1bmN0aW9uIGRlY3JlbWVudE9wYWNpdHkoKXtcbiAgICAgICAgICAgICAgICBpZiAob3BhY2l0eSA+IG9wYWNpdHlGYWRlU3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgb3BhY2l0eSA9IG9wYWNpdHkgLSBvcGFjaXR5RmFkZVN0ZXBzO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWNyZW1lbnRPcGFjaXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0sNDApO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQQVJFTlQgTk9ERTonKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2cobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmKG5vZGUucGFyZW50Tm9kZSAhPSBudWxsKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBkb25lKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2hvd01lc3NhZ2UgOiBmdW5jdGlvbihtc2cpIHtcbiAgICAgICAgICAgIGlmKCF0b2FzdE5vZGUpe1xuICAgICAgICAgICAgICAgIGluaXRUb2FzdCgpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2FzdE5vZGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICB2YXIgcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3AnKTtcbiAgICAgICAgICAgIHAuc3R5bGUuY3NzVGV4dCA9IFwicGFkZGluZzowcHggMTBweFwiO1xuICAgICAgICAgICAgcC5pbm5lckhUTUwgPSBtc2c7XG4gICAgICAgICAgICB0b2FzdE5vZGUuaW5zZXJ0QmVmb3JlKHAsIHRvYXN0Tm9kZS5maXJzdENoaWxkKTtcbiAgICAgICAgICAgIChmdW5jdGlvbiBmYWRlT3V0VG9NdWNoTWVzc2FnZXMoKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvYXN0Tm9kZS5jaGlsZE5vZGVzLmxlbmd0aCA+IG1heExlbmd0aE9mTWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9hc3QuZmFkZU91dCh0b2FzdE5vZGUuY2hpbGRyZW5bdG9hc3ROb2RlLmNoaWxkcmVuLmxlbmd0aC0xXSwgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlT3V0VG9NdWNoTWVzc2FnZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgIHZhciB0aW1lT3V0ID0gREVMQVk7XG4gICAgICAgICAgICBuZXdNZXNzYWdlID0gdHJ1ZTtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGZhZGVPdXQoX2ZjKXtcbiAgICAgICAgICAgICAgICB2YXIgZmMgPSBfZmM7XG4gICAgICAgICAgICAgICAgdmFyIG9wYWNpdHkgPSB0b2FzdE5vZGUuc3R5bGUub3BhY2l0eTtcbiAgICAgICAgICAgICAgICBpZiAob3BhY2l0eSA+IG9wYWNpdHlGYWRlU3RlcHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYobmV3TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzZXRNZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdNZXNzYWdlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lT3V0ID0gREVMQVk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdE5vZGUuc3R5bGUub3BhY2l0eSA9IDE7XG4gICAgICAgICAgICAgICAgICAgIH1lbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5LW9wYWNpdHlGYWRlU3RlcHM7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdE5vZGUuc3R5bGUub3BhY2l0eSA9IG9wYWNpdHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lT3V0ID0gNDA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgdGltZXJcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFkZU91dChmYyk7XG4gICAgICAgICAgICAgICAgICAgIH0sIHRpbWVPdXQpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHdoaWxlICggdG9hc3ROb2RlLmZpcnN0Q2hpbGQgKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2FzdE5vZGUucmVtb3ZlQ2hpbGQoIHRvYXN0Tm9kZS5maXJzdENoaWxkICk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHkgPSAwO1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFja1xuICAgICAgICAgICAgICAgICAgICBmYyh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZihpc1JlYWR5Rm9yU3RhcnRBZ2Fpbil7XG4gICAgICAgICAgICAgICAgaXNSZWFkeUZvclN0YXJ0QWdhaW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB0aW1lT3V0ID0gREVMQVk7XG4gICAgICAgICAgICAgICAgZmFkZU91dChmdW5jdGlvbihfYil7XG4gICAgICAgICAgICAgICAgICAgIGlzUmVhZHlGb3JTdGFydEFnYWluID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHRvYXN0O1xufSkoJ3RvYXN0Jyk7XG5cbmlmKHR5cGVvZiBtb2R1bGUgIT0gXCJ1bmRlZmluZWRcIil7XG4gICAgY29uc29sZS5sb2coJ2V4cG9ydHMnKTtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHRvYXN0O1xufWVsc2Uge1xuICAgIGNvbnNvbGUubG9nKCdhc2lnbiB0byBnbG9iYWwgc2NvcGUnKTtcbiAgICB3aW5kb3cudG9hc3QgPSB0b2FzdDtcbn0iLCIvKipcbiAqIGNvbnRyb2xsZXIgZm9yIHRoZSBpbWFnZSB1cGxhb2RlciB2aWV3IC0gY2FsbHMgdGhlIHNlcnZlciB0byB1cGxvYWQgYSBpbWFnZSBhbmQgbm90aWZpZXIgdGhlIHVpIGV2ZW50IGhhbmRsZXJcbiAqIEB0eXBlIHt7fX1cbiAqL1xudmFyIGNhbm55ID0gcmVxdWlyZSgnY2FubnknKSxcbiAgICBKTUJGVXBsb2FkZXIgPSBjYW5ueS5KTUJGVXBsb2FkZXIsXG4gICAgZGlzcGxheU1hbmFnZXIgPSBjYW5ueS5kaXNwbGF5TWFuYWdlcixcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyLmpzJyksXG4gICAgdXBsb2FkSWQsXG4gICAgcHJvamVjdEluZm87XG4vKipcbiAqIENhbGwgdGhpcyBmb3IgZWFjaCBmaWxlIC0gd2lsbCBjYWxsIGEgY2FsbCBiYWNrIHdpdGggdGhlIHNlcnZlciBhbnN3ZXJcbiAqIEBwYXJhbSBmaWxlXG4gKi9cbmZ1bmN0aW9uIHNlbmRGaWxlKGZpbGUsIGRpcmVjdENhbGxiYWNrKSB7XG4gICAgdmFyIHVyaSA9ICcvdXBsb2FkSk1CRkZpbGU/cHJvamVjdElkPScgKyBwcm9qZWN0SW5mby5pZCArICcmcHJvamVjdD0nICsgcHJvamVjdEluZm8ubmFtZSxcbiAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgIGZkID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICB4aHIub3BlbihcIlBPU1RcIiwgdXJpLCB0cnVlKTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBkYXRhO1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCAmJiB4aHIuc3RhdHVzID09IDIwMCkge1xuICAgICAgICAgICAgLy8gSGFuZGxlIHJlc3BvbnNlLlxuICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICBkaXJlY3RDYWxsYmFjayAmJiBkaXJlY3RDYWxsYmFjayhkYXRhKTsgLy8gaGFuZGxlIHJlc3BvbnNlLlxuICAgICAgICAgICAgLy8ge2ZpbGU6IFwiLy9zdWIvc3ViMS9zdWIxX2JsdWVfY29rZS5qcGdcIiwgbmFtZTogXCJzdWIxX2JsdWVfY29rZS5qcGdcIiwgdHlwZTogXCJpbWFnZS9qcGdcIn1cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGRhdGEpO1xuICAgICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ0pNQkZGaWxlVXBsb2FkZWQnLCBwcm9qZWN0SW5mby5pZCwgdXBsb2FkSWQsIGRhdGEubmFtZSlcbiAgICAgICAgfSBlbHNlIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0ICYmIHhoci5zdGF0dXMgPT09IDQwNikge1xuICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ1VwbG9hZCBmYWlsdXJlLiBUaGUgZmlsZSBsYW5ndWFnZSBpcyBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZkLmFwcGVuZCgnbXlGaWxlJywgZmlsZSk7XG4gICAgLy8gSW5pdGlhdGUgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIHVwbG9hZFxuICAgIHhoci5zZW5kKGZkKTtcbn1cblxuLyoqXG4gKiBTYXZlIGRhdGEgaW4gbWVtYmVyIHZhcmlhYmxlIHVzZWQgYnkgZnVydGhlciB1cGxvYWQgb3BlcmF0aW9uc1xuICogQHBhcmFtIGRhdGE6IFByb2plY3QgZGF0YVxuICovXG5mdW5jdGlvbiBhcHBseVByb2plY3REYXRhKGRhdGEsIHByb2plY3QpIHtcbiAgICBwcm9qZWN0SW5mbyA9IHByb2plY3Rcbn1cblxudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICBzaG93Sk1CRlVwbG9hZGVyIDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ0pNQkZVcGxvYWRlclZpZXcnKTtcbiAgICB9XG59KTtcblxuSk1CRlVwbG9hZGVyLm9uVXBsb2FkKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgLy8gVE9ETyBhZGRpdGlvbmFsIHRvIHRoZSB1cGxvYWQgaWQgd2UgbmVlZCB0aGUgcHJvamVjdCBJRFxuICAgIGNvbnNvbGUubG9nKCd1cGxvYWRDb250cm9sbGVyOnVwbG9hZCBpZDogZmlsZTonLCB1cGxvYWRJZCwgZmlsZSk7XG4gICAgc2VuZEZpbGUoZmlsZSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgb25Mb2FkUHJvamVjdCA6IGFwcGx5UHJvamVjdERhdGFcbn07IiwidmFyIGNhbm55ID0gcmVxdWlyZSgnY2FubnknKSxcbiAgICBKc29uSW1wb3J0ID0gY2FubnkuSnNvbkltcG9ydCxcbiAgICBkaXNwbGF5TWFuYWdlciA9IGNhbm55LmRpc3BsYXlNYW5hZ2VyLFxuICAgIHVpRXZlbnRzID0gcmVxdWlyZSgnLi4vdWlFdmVudE1hbmFnZXIuanMnKSxcbiAgICB1cGxvYWRJZCxcbiAgICBwcm9qZWN0SW5mbztcblxuZnVuY3Rpb24gc2VuZEZpbGUoZmlsZSkge1xuICAgIHZhciB1cmkgPSAnL2ltcG9ydEpTT04/cHJvamVjdElkPScgKyBwcm9qZWN0SW5mby5pZCArICcmcHJvamVjdD0nICsgcHJvamVjdEluZm8ubmFtZSxcbiAgICAgICAgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAgICAgIGZkID0gbmV3IEZvcm1EYXRhKCk7XG5cbiAgICB4aHIub3BlbihcIlBPU1RcIiwgdXJpLCB0cnVlKTtcbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0KSB7XG4gICAgICAgICAgICB2YXIgZGF0YSA9IEpTT04ucGFyc2UoeGhyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgICAgICAvLyBkYXRhLm5hbWUgZG9lcyBub3QgZXhpc3QgLSBhbmQgaXMgYWxzbyBub3QgdXNlZCwgaXMgaXQgP1xuICAgICAgICAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdqc29uSW1wb3J0ZWQnLCBwcm9qZWN0SW5mby5pZCwgdXBsb2FkSWQsIGRhdGEubmFtZSlcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeGhyLnN0YXR1cyA9PT0gNDA2KSB7XG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ1VwbG9hZCBmYWlsdXJlLiBUaGVyZSBpcyBhbiBlcnJvcjo8YnIgLz4nICsgZGF0YS5tc2cpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmZC5hcHBlbmQoJ215RmlsZScsIGZpbGUpO1xuICAgIHhoci5zZW5kKGZkKTtcbn1cblxuZnVuY3Rpb24gYXBwbHlQcm9qZWN0RGF0YShkYXRhLCBwcm9qZWN0KSB7XG4gICAgcHJvamVjdEluZm8gPSBwcm9qZWN0O1xufVxuXG51aUV2ZW50cy5hZGRVaUV2ZW50TGlzdGVuZXIoe1xuICAgIHNob3dKU09OSW1wb3J0IDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ0pTT05JbXBvcnRWaWV3Jyk7XG4gICAgfVxufSk7XG5cbkpzb25JbXBvcnQub25VcGxvYWQoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICBzZW5kRmlsZShmaWxlKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbk5ld1Byb2plY3RDcmVhdGVkIDogYXBwbHlQcm9qZWN0RGF0YSxcbiAgICBvbkxvYWRQcm9qZWN0IDogYXBwbHlQcm9qZWN0RGF0YVxufTsiLCJ2YXIgYXN5bmMgPSByZXF1aXJlKCdjYW5ueS9tb2QvYXN5bmMnKSxcbiAgICBhdXRoID0gcmVxdWlyZSgnY2FubnknKS5hdXRoO1xuXG5hdXRoLm9uTG9nb3V0KGZ1bmN0aW9uICgpIHtcbiAgICBhc3luYy5kb0FqYXgoe1xuICAgICAgICBwYXRoIDogJy9sb2dvdXQnLFxuICAgICAgICBvblN1Y2Nlc3MgOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICB9XG4gICAgfSlcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHt9OyIsInZhciBicmVhZGNydW1iID0gcmVxdWlyZSgnLi4vdWlNb2R1bGVzL2JyZWFkY3J1bWInKSxcbiAgICBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JyksXG4gICAgdHJhZGUgPSByZXF1aXJlKCcuLi90cmFkZScpLFxuICAgIHVpRXZlbnRzID0gcmVxdWlyZSgnLi4vdWlFdmVudE1hbmFnZXInKTtcblxuY2FubnkuYWRkKCdicmVhZGNydW1iJywgYnJlYWRjcnVtYilcblxuYnJlYWRjcnVtYi5vbkNsaWNrKGZ1bmN0aW9uIChkaXJlY3RvcnlJZCkge1xuICAgIHRyYWRlLmdldERpcmVjdG9yeShkaXJlY3RvcnlJZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICBpZiAoZXJyICE9PSBmYWxzZSApIHtcbiAgICAgICAgICAgIC8vIFRPRE8gY2FsbCB0aGVcbiAgICAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdzaG93T3ZlcnZpZXdQYWdlJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnYnJlYWRjcnVtYkNvbnRyb2xsZXI6Z2V0RGlyZWN0b3J5IGNhbiBub3QgbG9hZCBwcm9qZWN0IGZvciBkaXJlY3RvcnkgbmFtZTonLCBkaXJlY3RvcnlJZCk7XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzZXRQYXRoIDogKHVybCkgPT4ge1xuICAgICAgICBsZXQgcGF0aCA9ICcvJ1xuICAgICAgICBpZiAodXJsID09PSAnLycpXG4gICAgICAgICAgICByZXR1cm4gYnJlYWRjcnVtYi51cGRhdGVGb2xkZXJzKFt7IGlkOiAnLycgLCBuYW1lOiAnJyB9XSlcbiAgICAgICAgXG4gICAgICAgIGJyZWFkY3J1bWIudXBkYXRlRm9sZGVycyh1cmwuc3BsaXQoJy8nKS5tYXAoZm9sZGVyID0+IHtcbiAgICAgICAgICAgICAgICBwYXRoID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdICE9PSAnLycgPyBwYXRoICsgJy8nICsgZm9sZGVyIDogcGF0aCArIGZvbGRlclxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBwYXRoICwgbmFtZTogZm9sZGVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICApKVxuICAgIH0sXG4gICAgZ2V0RGlyZWN0b3J5OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBjb25zb2xlLmxvZygnYnJlYWRjcnVtYkNvbnRyb2xsZXI6cGFyZW50RGlyZWN0b3JpZXMnLCBkYXRhLnBhcmVudERpcmVjdG9yaWVzKTtcbiAgICAgICAgYnJlYWRjcnVtYi51cGRhdGVGb2xkZXJzKGRhdGEucGFyZW50RGlyZWN0b3JpZXMpO1xuICAgIH1cbn07XG4iLCJ2YXIgY3JlYXRlTmV3UHJvamVjdCA9IHJlcXVpcmUoJ2Nhbm55JykuY3JlYXRlTmV3UHJvamVjdCxcbiAgICBkaXNwbGF5TWFuYWdlciA9IHJlcXVpcmUoJ2Nhbm55JykuZGlzcGxheU1hbmFnZXIsXG4gICAgdHJhZGUgPSByZXF1aXJlKCcuLi90cmFkZScpO1xuXG52YXIgY3VycmVudERpcmVjdG9yeTtcblxuY3JlYXRlTmV3UHJvamVjdC5vbkNyZWF0ZU5ld1Byb2plY3QoZnVuY3Rpb24ocHJvamVjdE5hbWUpIHtcbiAgICB0cmFkZS5jcmVhdGVOZXdQcm9qZWN0KHByb2plY3ROYW1lLCBjdXJyZW50RGlyZWN0b3J5KTtcbiAgICBkaXNwbGF5TWFuYWdlci5oaWRlKCdjcmVhdGVOZXdQcm9qZWN0VmlldycpO1xufSk7XG5cbmNyZWF0ZU5ld1Byb2plY3Qub25DcmVhdGVOZXdEaXJlY3RveShmdW5jdGlvbihkaXJlY3RvcnlOYW1lKSB7XG4gICAgdHJhZGUuY3JlYXRlTmV3RGlyZWN0b3J5KGRpcmVjdG9yeU5hbWUsIGN1cnJlbnREaXJlY3RvcnkpO1xuICAgIGRpc3BsYXlNYW5hZ2VyLmhpZGUoJ2NyZWF0ZU5ld0RpcmVjdG9yeVZpZXcnKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvLyBUT0RPIGludHJvZHVjZSBuZXcgZXZlbnQ6IG9uRGlyZWN0b3J5Q2hhbmdlZCAtIGJlY2F1c2UgYSBcImdldERpcmVjdG9yeVwiIGV2ZW50IGRvZXMgbm90IHJlYWxseSBleHBsYWluIHdoYXQnc1xuICAgIC8vIGhhcHBlbmluZyBoZXJlXG4gICAgZ2V0RGlyZWN0b3J5IDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBjdXJyZW50RGlyZWN0b3J5ID0gZGF0YS5jdXJyZW50RGlyZWN0b3J5O1xuICAgIH1cbn07XG4iLCJ2YXIgYW5jaG9yTWVudSA9IHJlcXVpcmUoJ2Nhbm55JykuYW5jaG9yTWVudSxcbiAgICB0cmFuc2xhdGlvblZpZXdDb25maWcgPSByZXF1aXJlKCcuLi91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3JykuY29uZmlnLFxuICAgIHVpRXZlbnRzID0gcmVxdWlyZSgnLi4vdWlFdmVudE1hbmFnZXInKTtcblxuLyoqXG4gKiBOaWNlIGFwcHJvYWNoIGJ1dCB0aGUgb3JkZXIgaXMgZGlmZmVyZW50IGZyb20gdGhlIERPTS5cbiAqIFRPRE8gSXQgd291bGQgYmUgYmV0dGVyIHRvIHJlYWQgdGhlIGVsZW1lbnRzIGZyb20gdGhlIERPTVxuICogIDEuIGl0J3MgZWFzaWVyIHRvIHJlaW5pdGlhbGl6ZSBpZiBhIGtleSBpcyByZW5hbWVkIG9yIGNyZWF0ZWQgbmV3IChZKVxuICogIDIuIHRoZSBvcmRlciB3aWxsIGJlIHNhbWUgYXMgaW4gdGhlIERPTSAoWSlcbiAqICBjb246IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCB0aGUgRE9NIGlzIHJlbmRlcmVkIC0gb3RoZXJ3aXNlIGVsZW1lbnRzIHdpbGwgYmUgbWlzc2luZ1xuICpcbiAqICBXZSBuZWVkOlxuICogICogRE9NIHJlbmRlciBzdWNjZXNzIGV2ZW50ICh0aGUgdHJhbnNsYXRpb25WaWV3IGNvbnRyb2xsZXIgaGFzIHRvIHRocm93IGl0KSAoc28gZmFyIHRoZSBjb250cm9sbGVyIGlzIGFkZGVkIGFmdGVyIHRoZSB0cmFuc2xhdGlvbkNvbnRyb2xsZXIgaXQgbG9va3MgbGlrZSB0aGF0IHRoaXMgaXMgbm90IGFuIGlzc3VlKVxuICogICogYW4gYSBpZiBhbmNob3IgaXMgY2xpY2tlZCAoaW4gdmlldykgZXZlbnQgOyB0aGVuIGFsc28gZm9jdXMgdGhlIGNvcnJlY3QgbWVudSByaWdodCBlbGVtZW50XG4gKiAgKiB0aGUgcmlnaHQgbWVudSBlbGVtZW50IGludGVyYWN0IG9ubHkgYXMgc2Nyb2xsIG92ZXJ2aWV3IC0gbm90IGFzIGFuY2hvciBoZWxwZXIgYXMgaXQgaXMgcmlnaHQgbm93XG4gKlxuICogQHBhcmFtIGtleXNcbiAqL1xuXG5hbmNob3JNZW51Lm9uU2VsZWN0KGZ1bmN0aW9uIChpZCkge1xuICAgIHZhciBkb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4ICsgaWQpO1xuICAgIGlmIChkb20pIHtcbiAgICAgICAgdmFyIGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIGVsZW1SZWN0ID0gZG9tLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbVJlY3QudG9wIC0gYm9keVJlY3QudG9wO1xuICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgb2Zmc2V0IC0gNjApO1xuICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnYW5jaG9yRm9jdXMnLCAnIycgKyBpZCk7XG4gICAgfVxufSk7XG5cbnVpRXZlbnRzLmFkZFVpRXZlbnRMaXN0ZW5lcih7XG4gICAgYW5jaG9yRm9jdXMgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgYW5jaG9yTWVudS5mb2N1c0VsZW1lbnQoaWQucmVwbGFjZSgnIycsICcnKSk7XG4gICAgfVxufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlbmFtZUNhdGVnb3J5IDogZnVuY3Rpb24gKG9sZE5hbWUsIG5ld05hbWUpIHtcbiAgICAgICAgYW5jaG9yTWVudS5yZW5kZXJNZW51KCk7XG4gICAgfSxcbiAgICByZW1vdmVDYXRlZ29yeTogZnVuY3Rpb24oY2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgIGFuY2hvck1lbnUucmVuZGVyTWVudSgpO1xuICAgIH0sXG4gICAgcmVuYW1lS2V5IDogZnVuY3Rpb24gKG9sZEtleSwgbmV3S2V5KSB7XG4gICAgICAgIGFuY2hvck1lbnUucmVuZGVyTWVudSgpO1xuICAgIH0sXG4gICAgcmVtb3ZlS2V5IDogZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIG9uQ3JlYXRlS2V5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIG9uS2V5Q2xvbmVkIDogZnVuY3Rpb24ocHJvamVjdElkLCBkYXRhKSB7XG4gICAgICAgIGFuY2hvck1lbnUucmVuZGVyTWVudSgpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgY29tcGxldGUgSlNPTiBvYmplY3QgZnJvbSBhIHNwZWNpZmljIHByb2plY3RcbiAgICAgKiBAcGFyYW0gcHJvamVjdERhdGFcbiAgICAgKi9cbiAgICBvbkxvYWRQcm9qZWN0IDogZnVuY3Rpb24gKHByb2plY3REYXRhKSB7XG4gICAgICAgIGFuY2hvck1lbnUucmVuZGVyTWVudSgpO1xuICAgIH0sXG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZDogZnVuY3Rpb24oKSB7XG4gICAgICAgIGFuY2hvck1lbnUucmVuZGVyTWVudSgpO1xuICAgIH1cbn07IiwiY29uc3Qgd2hpc2tlciA9IHJlcXVpcmUoJ2Nhbm55L21vZC93aGlza2VyJylcbmNvbnN0IGNhbm55ID0gcmVxdWlyZSgnY2FubnknKVxuY29uc3QgZGlzcGxheU1hbmFnZXIgPSBjYW5ueS5kaXNwbGF5TWFuYWdlclxuY29uc3QgdHJhZGUgPSByZXF1aXJlKCcuLi90cmFkZScpXG5jb25zdCBFUlJPUlMgPSByZXF1aXJlKCcuLi8uLi8uLi9FUlJPUlMnKVxuXG5jb25zdCBpbnB1dE5vZGVzID0ge1xuICAgIG5hbWUgOiB1bmRlZmluZWQsXG4gICAgdXJsIDogdW5kZWZpbmVkLFxufVxuLy8gd2hpc2tlciBjYWxsYmFjayBmb3IgcmVuZGVyaW5nIHRoZSB1aSBtb2R1bGVcbmxldCByZW5kZXJVaVxuLy8gc2F2ZSB0aGUgYWN0dWFsIGxvYWRlZCBwcm9qZWN0IGNvbmZpZyAtIG5lZWRlZCBmb3IgY29tcGFyaXNpb25cbmxldCBwcm9qZWN0XG5cbmZ1bmN0aW9uIG5vUmV0dXJuKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZS5rZXlDb2RlIHx8IGUud2hpY2hcbiAgICAgICAgaWYgKGtleSA9PT0gMTMpIGUucmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gbm9TcGFjZXMobm9kZSkge1xuICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBlLmtleUNvZGUgfHwgZS53aGljaFxuICAgICAgICBpZiAoa2V5ID09PSAzMikgZS5yZXR1cm5WYWx1ZSA9IGZhbHNlXG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgfSlcbiAgICByZXR1cm4gbm9kZVxufVxuXG5mdW5jdGlvbiB0cmltU2xhc2hlcyh1cmwpIHtcbiAgICBcbiAgICB3aGlsZSgvXFwvXFwvLy50ZXN0KHVybCkpXG4gICAgICAgIHVybCA9IHVybC5yZXBsYWNlKCcvLycsICcvJylcbiAgIFxuICAgIC8vIHJlbW92ZSBsYXN0IHNsYXNoIGlmIHRoZXJlIGlzIG9uZVxuICAgIGlmICh1cmwubGVuZ3RoID4gMSAmJiB1cmxbdXJsLmxlbmd0aCAtIDFdID09PSAnLycpXG4gICAgICAgIHVybCA9IHVybC5zbGljZSgwLCAtMSlcbiAgICBcbiAgIHJldHVybiB1cmxcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3BhY2VzKHMpIHtcbiAgICB3aGlsZSgvIC8udGVzdChzKSlcbiAgICAgICAgcyA9IHMucmVwbGFjZSgnICcsICdfJylcbiAgICByZXR1cm4gc1xufVxuXG5mdW5jdGlvbiBzdWJtaXQoKSB7XG4gICAgdHJhZGUubW92ZVByb2plY3Qoe1xuICAgICAgICBpZCA6IHByb2plY3QuaWQsXG4gICAgICAgIHVybCA6IHJlbW92ZVNwYWNlcyh0cmltU2xhc2hlcyhpbnB1dE5vZGVzLnVybC52YWx1ZSB8fCB1aS51cmwpKSxcbiAgICAgICAgbmFtZSA6IGlucHV0Tm9kZXMubmFtZS52YWx1ZSB8fCB1aS5uYW1lXG4gICAgfSwgKGVyciwge2lkLCBuYW1lLCB1cmx9KSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLmhpZGUoJ21vdmVQcm9qZWN0JylcbiAgICAgICAgICAgIGlmIChFUlJPUlNbZXJyLmVycm9yXSkge1xuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKGBDaGFuZ2luZyAke2lucHV0Tm9kZXMubmFtZS52YWx1ZX0gZmFpbGVkOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoZXJyLmVycm9yKVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZShgRmFpbHVyZSAke2lucHV0Tm9kZXMubmFtZS52YWx1ZX0gZmFpbGVkOiAke2Vyci5tZXNzYWdlfWApXG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoYEVSUk9SIFVOS05PV05gKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkaXNwbGF5TWFuYWdlci5oaWRlKCdtb3ZlUHJvamVjdCcpXG4gICAgICAgICAgICAvLyBzaG93L3JlbG9hZCBhY3R1YWwgZGlyZWN0b3J5XG4gICAgICAgICAgICB0cmFkZS5nZXREaXJlY3RvcnkodXJsKVxuICAgICAgICAgICAgaWYgKHByb2plY3QudXJsICE9PSB1cmwpXG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoYENoYW5nZSBwcm9qZWN0IGxvY2F0aW9uIHN1Y2Nlc3NmdWxseSB0byAke3VybH1gKVxuICAgICAgICAgICAgaWYgKHByb2plY3QubmFtZSAhPT0gbmFtZSlcbiAgICAgICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZShgUmVuYW1lIHByb2plY3Qgc3VjY2Vzc2Z1bGx5IHRvICR7bmFtZX1gKVxuICAgICAgICB9XG4gICAgfSlcbn1cblxuY29uc3QgdWkgPSB7XG4gICAgaW5wdXROYW1lIDogbiA9PiBpbnB1dE5vZGVzLm5hbWUgPSBub1JldHVybihuKSxcbiAgICBpbnB1dFVybCA6IG4gPT4gaW5wdXROb2Rlcy51cmwgPSBub1JldHVybihub1NwYWNlcyhuKSksXG4gICAgc3VibWl0IDogbiA9PiBuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgKCkgPT4gc3VibWl0KCkpLFxuICAgIGNhbmNlbCA6IG4gPT4gbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsICgpID0+IGRpc3BsYXlNYW5hZ2VyLmhpZGUoJ21vdmVQcm9qZWN0JykpLFxuICAgIG5hbWUgOiAnJyxcbiAgICB1cmwgOiAnJyxcbiAgICBpZDogJycsXG4gICAgcHJvamVjdExpbms6ICcnXG59XG5cbmNhbm55LmFkZCgnbW92ZVByb2plY3QnLCB7XG4gICAgYWRkIDogKG5vZGUgPT4ge1xuICAgICAgICB3aGlza2VyLmFkZChub2RlLCBmYyA9PiB7XG4gICAgICAgICAgICByZW5kZXJVaSA9IGZjXG4gICAgICAgICAgICByZW5kZXJVaSh1aSlcbiAgICAgICAgfSlcbiAgICB9KVxufSlcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2hvdyA6ICh7aWQsIHVybCwgbmFtZX0pID0+IHtcbiAgICAgICAgXG4gICAgICAgIHByb2plY3QgPSB7aWQsIHVybCwgbmFtZX1cbiAgICAgICAgXG4gICAgICAgIHJlbmRlclVpKHtcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgdXJsLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHByb2plY3RMaW5rIDogYC8ke2lkfS5wcmpgXG4gICAgICAgIH0pXG4gICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ21vdmVQcm9qZWN0JylcbiAgICB9XG59IiwidmFyIGNhbm55ID0gcmVxdWlyZSgnY2FubnknKTtcblxuLyoqXG4gKiBqdXN0IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgY2FsbGJhY2tzXG4gKi9cblxuLyoqXG4gKiBBcHBseSBwcm9qZWN0IGRlc2NyaXB0aW9uIGRhdGEgdG8gZG9tIGVsZW1lbnRzXG4gKiBAcGFyYW0gZGF0YTogUHJvamVjdCBjb25maWd1cmF0aW9uIGRhdGFcbiAqL1xuZnVuY3Rpb24gYXBwbHlQcm9qZWN0RGF0YShkYXRhLCBwcm9qZWN0KSB7XG4gICAgaWYgKHByb2plY3QuaGFzT3duUHJvcGVydHkoJ25hbWUnKSkge1xuICAgICAgICAvLyBwcm9qZWN0IHNwZWNpZmljIGNvbmZpZ1xuICAgICAgICBjYW5ueS50ZXh0cy5zZXRUZXh0cyh7cHJvamVjdE5hbWUgOiBwcm9qZWN0Lm5hbWV9KVxuICAgIH1cblxuICAgIC8vIEZJWE1FOiBDYXRlZ29yaWVzIHNob3VsZCBub3QgYmUgbmFtZWQgXCJfX2Rlc2NyaXB0aW9uXCIgYXMgdGhleSB3b3VsZCBvdmVycmlkZSB0aGUgcHJvamVjdCBkZXNjcmlwdGlvblxuICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdrZXlEZXNjcmlwdGlvbnMnKSkge1xuICAgICAgICAvLyBwcm9qZWN0IHNwZWNpZmljIGNvbmZpZyAtIGlmIHByb3BlcnR5IGlzIHByZXNlbnRcbiAgICAgICAgY2FubnkudGV4dHMuc2V0VGV4dHMoe1xuICAgICAgICAgICAgcHJvamVjdERlc2NyaXB0aW9uIDogKGRhdGEua2V5RGVzY3JpcHRpb25zWydfX2Rlc2NyaXB0aW9uJ10gPyBkYXRhLmtleURlc2NyaXB0aW9uc1snX19kZXNjcmlwdGlvbiddIDogJycpXG4gICAgICAgIH0pO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgb25Mb2FkUHJvamVjdCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgb25OZXdEaXJlY3RvcnlDcmVhdGVkIDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICBjYW5ueS50ZXh0cy5zZXRUZXh0cyh7XG4gICAgICAgICAgICBwcm9qZWN0TmFtZSA6IGRhdGEuZGlyZWN0b3J5SWRcbiAgICAgICAgfSk7XG4gICAgfVxufTsiLCJ2YXIgY2FubnkgPSByZXF1aXJlKCdjYW5ueScpLFxuICAgIGRvbU9wdHMgPSByZXF1aXJlKCdkb20tb3B0cycpLFxuICAgIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUuanMnKSxcbiAgICBldmVudHMgPSByZXF1aXJlKCcuLi9ldmVudHMuanMnKSxcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyLmpzJyksXG4gICAga2V5VmFsdWVDb3VudGVyID0ge1xuICAgICAgICBwcm9qZWN0TWFwIDoge30sXG4gICAgICAgIGdldENvdW50T2JqIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBrZXlNYXAgOiB7fSwgLy8ganVzdCBjb2xsZWN0IGFsbCB1bmlxdWUga2V5cyBmb3IgZ2V0dGluZyB0b3RhbCBudW1iZXIgb2YgZXhpc3Rpbmcga2V5c1xuICAgICAgICAgICAgICAgIGxhbmdNYXAgOiB7fSAgIC8vIHNhdmUgZm9yIGVhY2ggbGFuZ3VhZ2UgYWxsIFwidmFsaWRcIiBrZXlzXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHByb2plY3RDb25maWcgPSB7fSxcbiAgICBwcm9qZWN0SW5mbyA9IHt9LFxuICAgIGF2YWlsYWJsZUxhbmd1YWdlcyA9IFtdO1xuXG5jYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24ub25MYW5ndWFnZVNlbGVjdChmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGV2ZW50TmFtZTtcbiAgICBpZiAob2JqLmlzQWN0aXZlKSB7XG4gICAgICAgICBldmVudE5hbWUgPSBvYmouaXNJbmFjdGl2ZSA/ICdkZUFjdGl2YXRlTGFuZ3VhZ2UnIDogJ2FjdGl2YXRlTGFuZ3VhZ2UnO1xuICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoZXZlbnROYW1lLCBvYmoubGFuZ3VhZ2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnYWRkTGFuZ3VhZ2UnLCBvYmoubGFuZ3VhZ2UpO1xuICAgIH1cbiAgICBjb25zb2xlLmxvZygnQ2xpY2sgb24gbGFuZ3VhZ2UnLCBvYmopO1xufSk7XG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGVkaXRvck1vZGVFbmFibGVkID0gZmFsc2U7XG5cbiAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24ub25FbmFibGVFZGl0b3JNb2RlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6b25FbmFibGVFZGl0b3JNb2RlIHNob3cgSlNPTiBmb3JtYXQgaW4gbmV3IHRhYi4nKTtcbiAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2VuYWJsZUVkaXRvck1vZGUnLCAhZWRpdG9yTW9kZUVuYWJsZWQpO1xuICAgIH0pO1xuICAgIC8vbWF5YmUgc29tZW9uZSBlbHNlIGNhbGxzIHRoaXMgdG9vXG4gICAgdWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICAgICAgZW5hYmxlRWRpdG9yTW9kZSA6IGZ1bmN0aW9uIChlbmFibGVkKSB7XG4gICAgICAgICAgICBlZGl0b3JNb2RlRW5hYmxlZCA9IGVuYWJsZWQ7XG4gICAgICAgIH1cbiAgICB9KTtcblxufSgpKTtcblxuKGZ1bmN0aW9uKCkge1xuICAgIHZhciB3b3JkQ291bnRFbmFibGVkID0gZmFsc2U7XG5cbiAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24ub25Ub2dnbGVXb3JkQ291bnQoZnVuY3Rpb24oKSB7XG4gICAgICAgIHdvcmRDb3VudEVuYWJsZWQgPSAhd29yZENvdW50RW5hYmxlZDtcbiAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3RvZ2dsZVdvcmRDb3VudCcsIHdvcmRDb3VudEVuYWJsZWQpO1xuICAgIH0pO1xufSgpKTtcblxuY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLm9uU2hvd0pTT04oZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOm9uU2hvd0pTT04gc2hvdyBKU09OIGZvcm1hdCBpbiBuZXcgdGFiLicpO1xuICAgIHdpbmRvdy5vcGVuKFxuICAgICAgICAnLycgKyBwcm9qZWN0SW5mby5pZCArICcuanNvbj9jYXRlZ29yeT10cnVlJyxcbiAgICAgICAgJ19ibGFuaycgLy8gPC0gVGhpcyBpcyB3aGF0IG1ha2VzIGl0IG9wZW4gaW4gYSBuZXcgd2luZG93LlxuICAgICk7XG59KTtcblxuY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLm9uU2hvd0pNQkZVcGxvYWRlcihmdW5jdGlvbiAoKSB7XG4gICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6b25TaG93Sk1CRlVwbG9hZGVyIHNob3cgbWVzc2FnZSBidW5kbGUgdXBsb2FkZXInKTtcbiAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnc2hvd0pNQkZVcGxvYWRlcicpXG59KTtcblxuY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLm9uU2hvd0pTT05JbXBvcnQoZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOm9uU2hvd0pTT05JbXBvcnQgc2hvdyBKU09OIGltcG9ydCBvdmVybGF5Jyk7XG4gICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3Nob3dKU09OSW1wb3J0Jyk7XG59KTtcblxuY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLm9uU2hvd0pNQkYoZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOm9uU2hvd0pNQkYgc2hvdyBKTUJGIGZvcm1hdCBpbiBuZXcgdGFiLicpO1xuXG4gICAgdmFyIGxhbmcgPSB3aW5kb3cucHJvbXB0KCdFbnRlciBhIGxhbmd1YWdlIGNvZGUuIEUuZy46ICcgKyAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBleGlzdGluZ0xhbmd1YWdlcyA9IFtdO1xuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJvamVjdENvbmZpZy5rZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKHByb2plY3RDb25maWcua2V5c1tsYW5nXSkubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0xhbmd1YWdlcy5wdXNoKGxhbmcpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gZXhpc3RpbmdMYW5ndWFnZXM7XG4gICAgICAgIH0oKSkuam9pbignLCAnKSk7XG5cbiAgICBpZiAobGFuZyAhPT0gbnVsbCkge1xuICAgICAgICB3aW5kb3cub3BlbihcbiAgICAgICAgICAgICcvJyArIHByb2plY3RJbmZvLmlkICsgJy5wcm9wZXJ0aWVzJyArIChsYW5nICE9PSAnJyA/ICc/bGFuZz0nICsgbGFuZyA6ICcnKSxcbiAgICAgICAgICAgICdfYmxhbmsnIC8vIDwtIFRoaXMgaXMgd2hhdCBtYWtlcyBpdCBvcGVuIGluIGEgbmV3IHdpbmRvdy5cbiAgICAgICAgKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCduZXdQcm9qZWN0V2FzQ3JlYXRlZCcsIGZ1bmN0aW9uIChwcm9qZWN0TmFtZSkge1xuICAgIHRvYXN0LnNob3dNZXNzYWdlKCdBIG5ldyBwcm9qZWN0IHdpdGggbmFtZTogXCInICsgcHJvamVjdE5hbWUgKyAnXCIgd2FzIGNyZWF0ZWQuJyk7XG59KTtcbi8qKlxuICogc2VydmVyIGV2ZW50IGxpc3RlbmVyXG4gKi9cbmV2ZW50cy5hZGRTZXJ2ZXJMaXN0ZW5lcigna2V5VXBkYXRlZCcsIGZ1bmN0aW9uIChwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXlOYW1lLCBrZXlWYWx1ZSkge1xuICAgIC8vIFRPRE8gbW9yZSBjbGllbnQgY2hhbmdlcyBhcmUgY29taW5nLCB3ZSdsbCBmaW5pc2ggdGhlIGNvZGUgYmVsb3cgdGhlblxuICAgIC8vaWYgKHByb2plY3RJZCA9PT0gY3VycmVudFByb2plY3RJZCkge1xuICAgIC8vICAgIHZhciBwcm9qZWN0TmFtZSA9IHByb2plY3RJZC5zdWJzdHJpbmcocHJvamVjdElkLmxhc3RJbmRleE9mKCcvJykgKyAxKTtcbiAgICAvLyAgICB1cGRhdGVLZXlUb1Byb2plY3RNYXAocHJvamVjdE5hbWUsIGxhbmd1YWdlLCBrZXlOYW1lLCBrZXlWYWx1ZSk7XG4gICAgLy8gICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6dXBkYXRlS2V5JywgcHJvamVjdElkLCBsYW5ndWFnZSwga2V5TmFtZSwga2V5VmFsdWUpO1xuICAgIC8vfVxufSk7XG4vKipcbiAqIHNlcnZlciBldmVudCBsaXN0ZW5lclxuICovXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ2tleURlbGV0ZWQnLCBmdW5jdGlvbiAoYnVuZGxlTmFtZSwgb2JqKSB7XG4gICAgLy8gVE9ETyBtb3JlIGNsaWVudCBjaGFuZ2VzIGFyZSBjb21pbmcsIHdlJ2xsIGZpbmlzaCB0aGUgY29kZSBiZWxvdyB0aGVuXG4gICAgLy9pZiAoYnVuZGxlTmFtZSA9PT0gcHJvamVjdENvbmZpZy5wcm9qZWN0KSB7XG4gICAgLy8gICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6a2V5UmVuYW1lZCcsIGJ1bmRsZU5hbWUsIG9iaik7XG4gICAgLy8gICAgLy8gVE9ETyB1cGRhdGUgdGhlIHN0YXRpc3RpY3MuLi5cbiAgICAvL31cbn0pO1xuXG4vKipcbiAqXG4gKiBAcGFyYW0gcHJvamVjdE5hbWVcbiAqIEBwYXJhbSBsYW5nXG4gKiBAcGFyYW0ga2V5XG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gc2F2ZUtleVRvUHJvamVjdE1hcChwcm9qZWN0TmFtZSwgbGFuZywga2V5LCB2YWx1ZSkge1xuXG4gICAgLy8ganVzdCBjb2xsZWN0IGFsbCBrZXlzIChvbmx5IHRoZSB1bmlxdWUga2V5cyBhcmUgcmVsZXZhbnQpXG4gICAgaWYgKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOnNhdmVLZXlUb1Byb2plY3RNYXAgcHJvamVjdCBuYW1lIG5vdCBleGlzdHM6JywgcHJvamVjdE5hbWUpO1xuICAgICAgICBrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0gPSBrZXlWYWx1ZUNvdW50ZXIuZ2V0Q291bnRPYmooKTtcbiAgICB9XG5cbiAgICBrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0ua2V5TWFwW2tleV0gPSB0cnVlO1xuICAgIGlmIChrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0ubGFuZ01hcFtsYW5nXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXS5sYW5nTWFwW2xhbmddID0ge307XG4gICAgfVxuICAgIC8vIG9ubHkgc2F2ZSB0aGUga2V5cyBhcyBvYmplY3QgaWYgaXQgaXMgYSB2YWxpZCBrZXkgb3RoZXJ3aXNlIGRlbGV0ZSBpdFxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0ubGFuZ01hcFtsYW5nXVtrZXldID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXS5sYW5nTWFwW2xhbmddW2tleV0pIHtcbiAgICAgICAgLy8gaWYgdGhpcyBrZXkgZXhpc3RzIHRoYW4gcmVtb3ZlIGl0XG4gICAgICAgIGRlbGV0ZSBrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0ubGFuZ01hcFtsYW5nXVtrZXldO1xuICAgIH1cbn1cblxuLy8gVE9ETyBzaG91bGQgdXNlIHByb2plY3RJZCwgbm90IHByb2plY3ROYW1lXG5mdW5jdGlvbiB1cGRhdGVLZXlUb1Byb2plY3RNYXAocHJvamVjdE5hbWUsIGxhbmcsIGtleSwgdmFsdWUpIHtcbiAgICBzYXZlS2V5VG9Qcm9qZWN0TWFwKHByb2plY3ROYW1lLCBsYW5nLCBrZXksIHZhbHVlKTtcbiAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uc2V0TnVtYmVyT2ZUcmFuc2xhdGVkTGFuZ3VhZ2VLZXkoT2JqZWN0LmtleXMoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdLmxhbmdNYXBbbGFuZ10pLmxlbmd0aCwgbGFuZyk7XG4gICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLnNldE51bWJlck9mVHJhbnNsYXRpb25NYXhLZXlzKE9iamVjdC5rZXlzKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXS5rZXlNYXApLmxlbmd0aCk7XG59XG5cbi8vIHJlZ2lzdGVyIGxpc3RlbmVyIGZ1bmN0aW9uIHRvIHRoZSB1aSBldmVudHNcbnVpRXZlbnRzLmFkZFVpRXZlbnRMaXN0ZW5lcih7XG4gICAgLyoqXG4gICAgICogdGhlIGludGVybmFsIHVwZGF0ZUtleSBldmVudCAtIHRoZSBzZXJ2ZXIgd2lsbCBub3QgdHJpZ2dlciB0aGUgdXBkYXRlS2V5IGZvciB0aGUgb3duIGNsaWVudFxuICAgICAqL1xuICAgIHVwZGF0ZUtleSA6IGZ1bmN0aW9uIChwcm9qZWN0TmFtZSwgbGFuZywga2V5LCB2YWx1ZSkge1xuICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjp1cGRhdGVLZXknLCBwcm9qZWN0TmFtZSwgbGFuZywga2V5LCB2YWx1ZSk7XG4gICAgICAgIHVwZGF0ZUtleVRvUHJvamVjdE1hcChwcm9qZWN0TmFtZSwgbGFuZywga2V5LCB2YWx1ZSk7XG4gICAgfSxcbiAgICBwcm9qZWN0U2VsZWN0ZWQgOiBmdW5jdGlvbiAocHJvamVjdElkKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOnByb2plY3RTZWxlY3RlZCBDbGljayBvbiBwcm9qZWN0JywgcHJvamVjdElkKTtcbiAgICAgICAgdHJhZGUubG9hZFByb2plY3QocHJvamVjdElkLCBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpsb2FkUHJvamVjdCBmYWlscyBmb3IgcHJvamVjdElkOicsIHByb2plY3RJZCk7XG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgYWN0aXZhdGVMYW5ndWFnZSA6IGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5hY3RpdmF0ZUxhbmcobGFuZyk7XG4gICAgfSxcbiAgICBkZUFjdGl2YXRlTGFuZ3VhZ2UgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uZGVBY3RpdmF0ZUxhbmcobGFuZyk7XG4gICAgfSxcbiAgICBhZGRMYW5ndWFnZSA6IGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5hY3RpdmF0ZUxhbmcobGFuZyk7XG4gICAgfVxufSk7XG5cbmZ1bmN0aW9uIGNvbXB1dGVUb3RhbFRyYW5zbGF0aW9uUHJvZ3JlZSh0cmFuc2xhdGlvbnMpIHtcbiAgICB2YXIgdG90YWxQcm9ncmVzcyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHRyYW5zbGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgIE9iamVjdC5rZXlzKHRyYW5zbGF0aW9uc1tsYW5nXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICB0b3RhbFByb2dyZXNzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0b3RhbFByb2dyZXNzKS5sZW5ndGg7XG5cbn1cblxuZnVuY3Rpb24gY29tcHV0ZVRyYW5zbGF0aW9uUHJvZ3Jlc3ModHJhbnNsYXRpb25zKSB7XG4gICAgdmFyIHByb2dyZXNzQnlMYW5ndWFnZSA9IHt9O1xuICAgIE9iamVjdC5rZXlzKHRyYW5zbGF0aW9ucykuZm9yRWFjaChmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgIHByb2dyZXNzQnlMYW5ndWFnZVtsYW5nXSA9IE9iamVjdC5rZXlzKHRyYW5zbGF0aW9uc1tsYW5nXSkubGVuZ3RoO1xuICAgIH0pO1xuICAgIHJldHVybiBwcm9ncmVzc0J5TGFuZ3VhZ2U7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgdGhlIG9uTG9hZFByb2plY3QgJiBvbk5ld1Byb2plY3RDcmVhdGVkXG4gKiBAcGFyYW0gcHJvamVjdERhdGEgKHNlZSBwcm9qZWN0IEpTT04gZmlsZSlcbiAqL1xuZnVuY3Rpb24gYXBwbHlQcm9qZWN0RGF0YShkYXRhLCBwcm9qZWN0KSB7XG4gICAgcHJvamVjdENvbmZpZyA9IGRhdGE7XG4gICAgcHJvamVjdEluZm8gPSBwcm9qZWN0XG5cbiAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uc2V0QXZhaWxhYmxlTGFuZ3VhZ2VzKGRhdGEuYXZhaWxhYmxlTGFuZ3VhZ2VzKTtcblxuICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5zZXRBY3RpdmF0ZWRQcm9qZWN0TGFuZ3VhZ2VzKFxuICAgICAgICBjb21wdXRlVG90YWxUcmFuc2xhdGlvblByb2dyZWUoZGF0YS5rZXlzKSwgY29tcHV0ZVRyYW5zbGF0aW9uUHJvZ3Jlc3MoZGF0YS5rZXlzKSk7XG5cbiAgICBPYmplY3Qua2V5cyhkYXRhLmtleXMpLmZvckVhY2goZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGRhdGEua2V5c1tsYW5nXSkubGVuZ3RoID4gMCAmJiBhdmFpbGFibGVMYW5ndWFnZXMuaW5kZXhPZihsYW5nKSAhPT0gLTEpIHtcblxuICAgICAgICAgICAgT2JqZWN0LmtleXMoZGF0YS5rZXlzW2xhbmddKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBzYXZlS2V5VG9Qcm9qZWN0TWFwKGRhdGEucHJvamVjdCwgbGFuZywga2V5LCBkYXRhLmtleXNbbGFuZ11ba2V5XSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgaWYgKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW2RhdGEucHJvamVjdF0ubGFuZ01hcFtsYW5nXSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOm9uTG9hZFByb2plY3QgJywga2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbZGF0YS5wcm9qZWN0XS5sYW5nTWFwW2xhbmddKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpvbkxvYWRQcm9qZWN0IG1heEtleXMgYXJlJywgT2JqZWN0LmtleXMoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbZGF0YS5wcm9qZWN0XS5rZXlNYXApLmxlbmd0aCk7XG5cdFx0XHRcdC8vY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLnNldE51bWJlck9mVHJhbnNsYXRpb25NYXhLZXlzKE9iamVjdC5rZXlzKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3REYXRhLnByb2plY3RdLmtleU1hcCkubGVuZ3RoKTtcblx0XHRcdFx0Ly9jYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uc2V0TnVtYmVyT2ZUcmFuc2xhdGVkTGFuZ3VhZ2VLZXkoT2JqZWN0LmtleXMoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdERhdGEucHJvamVjdF0ubGFuZ01hcFtsYW5nXSkubGVuZ3RoLCBsYW5nKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIHRoaXMgYW5kIG1ha2Ugb25lIGNhbGwgOylcbiAgICAgICAgICAgICAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uYWN0aXZhdGVMYW5nKGxhbmcpO1xuICAgICAgICAgICAgICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5kZUFjdGl2YXRlTGFuZyhsYW5nKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6b25Mb2FkUHJvamVjdCBnZXQgbGFuZ3VhZ2Ugd2l0aG91dCBhbnkga2V5cyBmb3IgbG9jYWxlOicsIGxhbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyByZXNldCBvciByZWluaXRpYWxpemUgb3IgaW5pdGlhbGl6ZSB0aGUga2V5IHZhbHVlIGNvdW50ZXIgKG90aGVyd2lzZSB0aGUgY291bnRlciBjYW4ndCBkZXRlY3QgZGVsZXRlZCBrZXlzLiBFLmcuIGZyb20gdGhlIGVkaXRvciBtb2RlKVxuICAgIGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW2RhdGEucHJvamVjdF0gPSBrZXlWYWx1ZUNvdW50ZXIuZ2V0Q291bnRPYmooKTtcbiAgICAvLyBzaG93IGRlZmF1bHQgbGFuZ3VhZ2UgYXMgc2VsZWN0ZWQgbGFuZ3VhZ2UgaW4gbWVudVxuICAgIC8vIFRPRE8gY2hlY2sgd2hvIGRlY2lkZXMgdG8gc2hvdyB3aGljaCBsYW5ndWFnZSBhcyBkZWZhdWx0IC0gYW5kIHRoZW4gY2FsbCB0aGlzIGV2ZW50IGZyb20gdGhlcmVcbiAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnYWN0aXZhdGVMYW5ndWFnZScsIGRhdGEuZGVmYXVsdExhbmd1YWdlKTtcbn1cblxuLyoqXG4gKiB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhbGxiYWNrc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbk5ld1Byb2plY3RDcmVhdGVkIDogYXBwbHlQcm9qZWN0RGF0YSxcbiAgICBvbkxvYWRQcm9qZWN0IDogYXBwbHlQcm9qZWN0RGF0YVxufTsiLCJ2YXIgcHJvamVjdE92ZXJ2aWV3ID0gcmVxdWlyZSgnY2FubnknKS5wcm9qZWN0T3ZlcnZpZXcsXG4gICAgZGlzcGxheU1hbmFnZXIgPSByZXF1aXJlKCdjYW5ueScpLmRpc3BsYXlNYW5hZ2VyLFxuICAgIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUuanMnKSxcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyLmpzJyksXG4gICAgdG9hc3QgPSByZXF1aXJlKCcuLi9Ub2FzdC5qcycpLFxuICAgIGV2ZW50cyA9IHJlcXVpcmUoJy4uL2V2ZW50cy5qcycpO1xuXG5jb25zdCBtb3ZlUHJvamVjdCA9IHJlcXVpcmUoJy4vbW92ZVByb2plY3RDb21wb25lbnQnKVxuXG52YXIgcHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlciA9IChmdW5jdGlvbigpIHtcblxuICAgIHZhciBjdXJyZW50UGFyZW50RGlyZWN0b3J5LFxuICAgICAgICBjdXJyZW50RGlyZWN0b3J5LFxuICAgICAgICAvKipcbiAgICAgICAgICogTWFwcyBwcm9qZWN0IG5hbWVzIHRvIHByb2plY3RzIElEc1xuICAgICAgICAgKi9cbiAgICAgICAgcHJvamVjdHMsXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIGRpcmVjdG9yeSBuYW1lcyB0byBkaXJlY3RvcnkgSURzXG4gICAgICAgICAqL1xuICAgICAgICBkaXJlY3RvcmllcztcblxuICAgIHVpRXZlbnRzLmFkZFVpRXZlbnRMaXN0ZW5lcih7XG4gICAgICAgIHNob3dPdmVydmlld1BhZ2UgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdwcm9qZWN0c092ZXJ2aWV3Jyk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHByb2plY3RPdmVydmlldy5vblBhcmVudERpcmVjdG9yeVNlbGVjdGVkKGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoY3VycmVudFBhcmVudERpcmVjdG9yeSAhPT0gY3VycmVudERpcmVjdG9yeSkge1xuICAgICAgICAgICAgdHJhZGUuZ2V0RGlyZWN0b3J5KGN1cnJlbnRQYXJlbnREaXJlY3RvcnkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ05vIHBhcmVudCBkaXJlY3RvcnknKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uUHJvamVjdFNlbGVjdGVkKGZ1bmN0aW9uKHByb2plY3ROYW1lKSB7XG4gICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdwcm9qZWN0U2VsZWN0ZWQnLCBwcm9qZWN0c1twcm9qZWN0TmFtZV0uaWQpO1xuICAgIH0pO1xuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uRGlyZWN0b3J5U2VsZWN0ZWQoZnVuY3Rpb24oZGlyZWN0b3J5TmFtZSkge1xuICAgICAgICB2YXIgZGlyZWN0b3J5SWQgPSBkaXJlY3Rvcmllc1tkaXJlY3RvcnlOYW1lXTtcbiAgICAgICAgdHJhZGUuZ2V0RGlyZWN0b3J5KGRpcmVjdG9yeUlkLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlcjpjYW4gbm90IGxvYWQgcHJvamVjdCBmb3IgZGlyZWN0b3J5IG5hbWU6JywgZGlyZWN0b3J5SWQpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHByb2plY3RPdmVydmlldy5vbkNyZWF0ZVByb2plY3RQcmVzc2VkKGZ1bmN0aW9uKCkge1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdjcmVhdGVOZXdQcm9qZWN0VmlldycpO1xuICAgIH0pO1xuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uQ3JlYXRlRGlyZWN0b3J5UHJlc3NlZChmdW5jdGlvbigpIHtcbiAgICAgICAgZGlzcGxheU1hbmFnZXIuc2hvdygnY3JlYXRlTmV3RGlyZWN0b3J5VmlldycpO1xuICAgIH0pO1xuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uRGVsZXRlRm9sZGVyUHJlc3NlZChmdW5jdGlvbihkaXJOYW1lKSB7XG4gICAgICAgIHRyYWRlLmRlbGV0ZUZvbGRlcihkaXJOYW1lLCBjdXJyZW50RGlyZWN0b3J5LCBmdW5jdGlvbihlcnIsIGRpck5hbWUpIHtcbiAgICAgICAgICAgIHZhciB0b2FzdE1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIHByb2plY3RPdmVydmlldy5kZWxldGVQcm9qZWN0TGlzdE5vZGUoZGlyTmFtZSk7XG4gICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlID0gJ0ZvbGRlciBcIicgKyBkaXJOYW1lICsgJ1wiIGhhcyBiZWVuIGRlbGV0ZWQuJztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9hc3RNZXNzYWdlID0gJ1RoZXJlIHdhcyBhbiBlcnJvcjogXCInICsgZXJyLm1lc3NhZ2UgKyAnXCInO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UodG9hc3RNZXNzYWdlKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uTW92ZURpcmVjdG9yeVByZXNzZWQocHJvamVjdE5hbWUgPT4gbW92ZVByb2plY3Quc2hvdyhwcm9qZWN0c1twcm9qZWN0TmFtZV0pKVxuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uRGVsZXRlUHJvamVjdFByZXNzZWQoZnVuY3Rpb24ocHJvamVjdE5hbWUpIHtcbiAgICAgICAgdHJhZGUuZGVsZXRlUHJvamVjdChwcm9qZWN0c1twcm9qZWN0TmFtZV0uaWQsIGZ1bmN0aW9uKGVyciwgcHJvamVjdCkge1xuICAgICAgICAgICAgdmFyIHRvYXN0TWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdE92ZXJ2aWV3LmRlbGV0ZVByb2plY3RMaXN0Tm9kZShwcm9qZWN0Lm5hbWUpO1xuICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZSA9ICdQcm9qZWN0IFwiJyArIHByb2plY3QubmFtZSArICdcIiBoYXMgYmVlbiBkZWxldGVkLic7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvYXN0TWVzc2FnZSA9ICdUaGVyZSB3YXMgYW4gZXJyb3I6IFwiJyArIGVyci5tZXNzYWdlICsgJ1wiJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKHRvYXN0TWVzc2FnZSk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCduZXdEaXJlY3RvcnlDcmVhdGVkJywgZnVuY3Rpb24gKGRpcmVjdG9yeUlkKSB7XG4gICAgICAgIHZhciBsYXN0RGlyU2VwSWR4ID0gZGlyZWN0b3J5SWQubGFzdEluZGV4T2YoJy8nKTtcbiAgICAgICAgdmFyIHBhcmVudERpcmVjdG9yeSA9IGRpcmVjdG9yeUlkLnN1YnN0cmluZygwLCBsYXN0RGlyU2VwSWR4ICsgMSk7XG4gICAgICAgIGlmIChwYXJlbnREaXJlY3RvcnkgPT09IGN1cnJlbnRQYXJlbnREaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIHZhciBkaXJlY3RvcnlOYW1lID0gZGlyZWN0b3J5SWQuc3Vic3RyaW5nKGxhc3REaXJTZXBJZHggKyAxKTtcbiAgICAgICAgICAgIGRpcmVjdG9yaWVzW2RpcmVjdG9yeU5hbWVdID0gZGlyZWN0b3J5SWQ7XG4gICAgICAgICAgICAvLyBUT0RPIHNob3cgbWVzc2FnZSBvbmx5IGlmIHByb2plY3RPdmVydmlldyBpcyBjdXJyZW50bHkgdmlzaWJsZSAtIGJ1dCBjYW5ueS5mbG93Y29udHJvbCBjdXJyZW50bHkgZG9lcyBub3RcbiAgICAgICAgICAgIC8vIGhhdmUgYW55dGhpbmcgdG8gZmluZCBvdXQgd2hpY2ggdmlldyBpcyB0aGUgYWN0aXZlIG9uZVxuICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0EgbmV3IGRpcmVjdG9yeSBcIicgKyBkaXJlY3RvcnlOYW1lICsgJ1wiIGhhcyBiZWVuIGNyZWF0ZWQgYnkgYW5vdGhlciB1c2VyLicpO1xuICAgICAgICAgICAgcHJvamVjdE92ZXJ2aWV3LnNldFByb2plY3RzQW5kRGlyZWN0b3JpZXMoT2JqZWN0LmtleXMocHJvamVjdHMpLCBPYmplY3Qua2V5cyhkaXJlY3RvcmllcykpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgZnJvbSB0aGUgc2VydmVyIHdoaWNoIGhhbmRsZXMgYSBmcmVzaCBkaXJlY3RvcnkvcHJvamVjdHMgbGlzdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3tjdXJyZW50RGlyZWN0b3J5OnN0cmluZywgZGlyczpbe25hbWUsIGlkfV0sIHBhcmVudERpcmVjdG9yaWVzOlt7bmFtZSwgaWR9XSwgcGFyZW50RGlyZWN0b3J5OnN0cmluZywgcHJvamVjdHM6W3tuYW1lLCBpZH1dIH19IGRhdGEgLSBhbiBvYmplY3Qgd2l0aCAyIHByb3BlcnRpZXMgXCJwcm9qZWN0c1wiIGFuZCBcImRpcmVjdG9yaWVzXCIsIGVhY2ggbGlzdGluZyBwcm9qZWN0L2RpcmVjdG9yeSBuYW1lcy5cbiAgICAgICAgICovXG4gICAgICAgIGdldERpcmVjdG9yeTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdQcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyLmdldERpcmVjdG9yeTogJywgZGF0YSk7XG4gICAgICAgICAgICBpZiAoZGF0YSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiU2VydmVyIGNhbGwgZmFpbGVkXCIpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChkYXRhLmhhc093blByb3BlcnR5KCdwcm9qZWN0cycpICYmIGRhdGEuaGFzT3duUHJvcGVydHkoJ2RpcnMnKSkge1xuXG4gICAgICAgICAgICAgICAgcHJvamVjdHMgPSB7fTtcbiAgICAgICAgICAgICAgICBkYXRhLnByb2plY3RzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdHNbZW50cnkubmFtZV0gPSBlbnRyeTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGRpcmVjdG9yaWVzID0ge307XG4gICAgICAgICAgICAgICAgZGF0YS5kaXJzLmZvckVhY2goZnVuY3Rpb24oZW50cnkpIHtcbiAgICAgICAgICAgICAgICAgICBkaXJlY3Rvcmllc1tlbnRyeS5uYW1lXSA9IGVudHJ5LmlkO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgcHJvamVjdE92ZXJ2aWV3LnNldFByb2plY3RzQW5kRGlyZWN0b3JpZXMoT2JqZWN0LmtleXMocHJvamVjdHMpLCBPYmplY3Qua2V5cyhkaXJlY3RvcmllcykpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnRQYXJlbnREaXJlY3RvcnkgPSBkYXRhLnBhcmVudERpcmVjdG9yeTtcbiAgICAgICAgICAgICAgICBjdXJyZW50RGlyZWN0b3J5ID0gZGF0YS5jdXJyZW50RGlyZWN0b3J5O1xuXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignRGF0YSByY3ZkIGZyb20gc2VydmVyIGlzIG1pc3NpbmcgZXhwZWN0ZWQgcHJvcGVydGllcyAoXCJwcm9qZWN0c1wiLCBcImRpcnNcIiknKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgb25OZXdEaXJlY3RvcnlDcmVhdGVkIDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgZGlzcGxheU1hbmFnZXIuc2hvdygncHJvamVjdHNPdmVydmlldycpO1xuICAgICAgICAgICAgdHJhZGUuZ2V0RGlyZWN0b3J5KGRhdGEuZGlyZWN0b3J5SWQsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyLm9uTmV3RGlyZWN0b3J5Q3JlYXRlZDogdHJhZGUgY2FsbGJhY2snKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn0pKCk7XG5cbm1vZHVsZS5leHBvcnRzID0gcHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlcjtcbiIsInZhciB0ZXh0RWRpdG9yID0gcmVxdWlyZSgnY2FubnknKS50ZXh0RWRpdG9yLFxuICAgIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUuanMnKSxcbiAgICB0b2FzdCA9IHJlcXVpcmUoJy4uL1RvYXN0LmpzJyksXG4gICAgZXZlbnRzID0gcmVxdWlyZSgnLi4vZXZlbnRzLmpzJyksXG4gICAgY3VycmVudFByb2plY3RJZDtcbi8qKlxuICogcmV0dXJucyB0aGUgbGFuZ3VhZ2Ugb3IgZmFsc2VcbiAqIEBwYXJhbSBmaWxlTmFtZVxuICogQHJldHVybnMgeyp9XG4gKi9cbmZ1bmN0aW9uIGdldExhbmd1YWdlRnJvbUZpbGVOYW1lKGZpbGVOYW1lKSB7XG4gICAgdmFyIHJlZyA9IC9tZXNzYWdlc18oLiopXFwuLiouL2cuZXhlYyhmaWxlTmFtZSk7XG4gICAgaWYgKHJlZyAmJiByZWcubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHJldHVybiByZWdbMV07XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cblxuLyoqXG4gKiBoYW5kbGUgdGhlIGNoYW5nZSBwcm9qZWN0IGRlc2NyaXB0aW9uIGV2ZW50IGluIHRoZSB2aWV3XG4gKi9cbnRleHRFZGl0b3Iub25DaGFuZ2UoZnVuY3Rpb24gKGlkLCB2YWx1ZSwgZmMpIHtcbiAgICBjb25zb2xlLmxvZygndGV4dEVkaXRvckNvbnRyb2xsZXI6b25DaGFuZ2UnLCB2YWx1ZSk7XG4gICAgaWYgKGN1cnJlbnRQcm9qZWN0SWQpIHtcbiAgICAgICAgaWYgKCFpZCkge1xuICAgICAgICAgICAgLy8gVE9ETyB0byBrZWVwIGJhY2t3YXJkIGZ1bmN0aW9uYWxpdHkgdGhpcyBpcyB0aGUgXCJtYWluXCIgcHJvamVjdCBkZXNjcmlwdGlvbiAtIHdpbGwgYmUgY2hhbmdlZCBpbiBmdXR1cmVcbiAgICAgICAgICAgIGlkID0gJ19fZGVzY3JpcHRpb24nO1xuICAgICAgICB9XG4gICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoZSB0dl8gZnJvbSB0aGUgaWRcbiAgICAgICAgdHJhZGUuc2F2ZVByb2plY3REZXNjcmlwdGlvbihjdXJyZW50UHJvamVjdElkLCBpZCwgdmFsdWUsIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGZjKHRydWUpO1xuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdQcm9qZWN0IGRlc2NyaXB0aW9uIGNoYW5nZWQgZm9yIHByb2plY3QgJyArIGN1cnJlbnRQcm9qZWN0SWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYyhmYWxzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuLyoqXG4gKiBqdXN0IHRoZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgY2FsbGJhY2tzXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbkxvYWRQcm9qZWN0IDogZnVuY3Rpb24gKGRhdGEsIHtpZCwgbmFtZSwgdXJsfSkge1xuICAgICAgICBpZiAoaWQpIGN1cnJlbnRQcm9qZWN0SWQgPSBpZFxuICAgIH1cbn07IiwidmFyIGNhbm55ID0gcmVxdWlyZShcImNhbm55XCIpLFxuICAgIHRyYW5zbGF0aW9uVmlldyA9IHJlcXVpcmUoJy4uL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXcnKSxcbiAgICB0cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZCA9IHJlcXVpcmUoJy4uL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZCcpLFxuICAgIHdvcmRDb3VudGVyID0gcmVxdWlyZSgnLi4vdXRpbC93b3JkQ291bnRlcicpLFxuICAgIGRvbU9wdHMgPSByZXF1aXJlKCdkb20tb3B0cycpLFxuICAgIHVpRXZlbnRzID0gcmVxdWlyZSgnLi4vdWlFdmVudE1hbmFnZXIuanMnKSxcbiAgICBldmVudHMgPSByZXF1aXJlKCcuLi9ldmVudHMuanMnKSxcbiAgICB0cmFkZSA9IHJlcXVpcmUoJy4uL3RyYWRlLmpzJyksXG4gICAgdXJsID0gcmVxdWlyZSgnLi4vdXRpbC91cmwnKSxcbiAgICBzb3J0QnlLZXkgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIGlmIChhLmtleSA8IGIua2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gLTE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGEua2V5ID4gYi5rZXkpIHtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH0sXG4gICAgcHJvamVjdENvbmZpZyxcbiAgICBwcm9qZWN0SW5mbyxcbiAgICBhdmFpbGFibGVMYW5ndWFnZXMgPSBbXSxcbiAgICAvKipcbiAgICAgKiBBbiBvYmplY3QgKHVzZWQgYXMgYSBzZXQgZGF0YXN0cnVjdHVyZSBoZXJlKSBob2xkaW5nIGFsbCBleGlzdGluZyBrZXlzIG9mIHRoZSBwcm9qZWN0IChubyBtYXR0ZXIgZm9yIGhvdyBtYW55XG4gICAgICogbGFuZ3VhZ2VzIGl0IGlzIHVzZWQpLiBJdCBpcyBuZWVkZWQgd2hlbiBhZGRpbmcgYSBuZXcgbGFuZ3VhZ2UsIHNlZSB0aGUgZnVuY3Rpb24gZm9yIGFkZExhbmd1YWdlIHdoaWNoIGlzIGFkZGVkXG4gICAgICogdG8gdWlFdmVudHMuXG4gICAgICogQHR5cGUge3t9fVxuICAgICAqL1xuICAgIGV4aXN0aW5nS2V5cyA9IHt9O1xuXG50cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZC5vblVwbG9hZEJ1dHRvbihmdW5jdGlvbihpZCkge1xuICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdzaG93RmlsZVVwbG9hZCcsIGlkKTtcbn0pO1xuXG50cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZC5vbkRlbGV0ZUJ1dHRvbihmdW5jdGlvbihpZCkge1xuICAgIGlmIChjb25maXJtKCdEZWxldGUgdGhlIGltYWdlIGZvciBjYXRlZ29yeSDCuyAnICsgaWQgKyAnIMKrIGZvcmV2ZXI/JykpIHtcbiAgICAgICAgdHJhZGUucmVtb3ZlSW1hZ2UocHJvamVjdEluZm8uaWQsIGlkKTtcbiAgICB9XG59KTtcblxudHJhbnNsYXRpb25WaWV3Lm9uQ2F0ZWdvcnlDbGlja2VkKGZ1bmN0aW9uKGlkKSB7XG4gICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2FuY2hvckZvY3VzJywgJyMnICsgaWQpO1xufSk7XG4vKipcbiAqIFNldHVwIHRoZSBVSSBldmVudHMgYW5kIG1hbmFnZSB0aGUgbG9naWMgZm9yIHRoZW0uXG4gKlxuICogVE9ETyByZXBsYWNlIGJ1bmRsZSB3aXRoIGxvY2FsZSBhbmQgcmVmYWN0b3IgdGhlIGNhbGxzIGZyb20gdHJhbnNsYXRpb25WaWV3XG4gKi9cbnRyYW5zbGF0aW9uVmlldy5vblNhdmVLZXkoZnVuY3Rpb24oa2V5LCBsYW5nLCB2YWx1ZSkge1xuXG4gICAgLy8gVE9ETzogQ291bnQgd29yZHMgYW5kIHRlbGwgd29yZCBjb3VudCBsYWJlbCB0byB1cGRhdGVcblxuICAgIGNvbnNvbGUubG9nKCd0cmFuc2xhdGlvblZpZXdDb250cm9sbGVyOm9uU2F2ZVZhbHVlJywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB0cmFkZS5zYXZlS2V5KFxuICAgICAgICBwcm9qZWN0SW5mby5pZCxcbiAgICAgICAgbGFuZyB8fCBwcm9qZWN0Q29uZmlnLmRlZmF1bHRMYW5ndWFnZSxcbiAgICAgICAge1xuICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIGZ1bmN0aW9uKHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjYXRJZDtcblxuICAgICAgICAgICAgaWYgKHByb2plY3RJZCA9PT0gcHJvamVjdEluZm8uaWQpIHsgLy8gcHJldmVudCBhcHBseWluZyB0aGUgY2FsbGJhY2sgaWYgcHJvamVjdCBoYXMgYmVlbiBjaGFuZ2VkIGluIHRoZSBtZWFudGltZVxuICAgICAgICAgICAgICAgIGNhdElkID0ga2V5LnNwbGl0KCdfJylbMF07XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdLZXlzW2tleV0gPSB1bmRlZmluZWQ7IC8vIHNhdmUgdGhlIGtleVxuICAgICAgICAgICAgICAgIHByb2plY3RDb25maWcua2V5c1tsYW5nXVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25WaWV3LnByaW50QnVuZGxlVGVtcGxhdGUoW3tcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSB8fCAnJ1xuICAgICAgICAgICAgICAgIH1dLCBsYW5ndWFnZSwgYXZhaWxhYmxlTGFuZ3VhZ2VzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlQ2F0ZWdvcnlXb3JkQ291bnQoY2F0SWQsIGxhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdBdXRvIHNhdmU6IFwiJyArIGtleSArICdcIiAoc3VjY2VzcyknKTtcblxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uVmlldy5zZW5kU3VjY2VzcyhrZXksICd2YWx1ZV8nKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG5vdCBzdXJlIGlmIHRoaXMgaXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3VwZGF0ZUtleScsIHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn0pO1xuXG4vKipcbiAqIFNldHVwIHRoZSBVSSBldmVudHMgYW5kIG1hbmFnZSB0aGUgbG9naWMgZm9yIHRoZW0uXG4gKlxuICogVE9ETyByZXBsYWNlIGJ1bmRsZSB3aXRoIGxvY2FsZSBhbmQgcmVmYWN0b3IgdGhlIGNhbGxzIGZyb20gdHJhbnNsYXRpb25WaWV3XG4gKi9cbnRyYW5zbGF0aW9uVmlldy5vbkNyZWF0ZUtleShmdW5jdGlvbihrZXksIGxhbmcsIHZhbHVlKSB7XG4gICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6b25TYXZlVmFsdWUnLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgIHRyYWRlLmNyZWF0ZUtleShcbiAgICAgICAgcHJvamVjdEluZm8uaWQsXG4gICAgICAgIGxhbmcgfHwgcHJvamVjdENvbmZpZy5kZWZhdWx0TGFuZ3VhZ2UsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlIHx8IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2F0SWQgPSBrZXkuc3BsaXQoJ18nKVswXTtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHByb2plY3RJbmZvLmlkKSB7IC8vIHByZXZlbnQgYXBwbHlpbmcgdGhlIGNhbGxiYWNrIGlmIHByb2plY3QgaGFzIGJlZW4gY2hhbmdlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICBleGlzdGluZ0tleXNba2V5XSA9IHVuZGVmaW5lZDsgLy8gc2F2ZSB0aGUga2V5XG4gICAgICAgICAgICAgICAgcHJvamVjdENvbmZpZy5rZXlzW2xhbmd1YWdlXSA9IHByb2plY3RDb25maWcua2V5c1tsYW5ndWFnZV0gPyBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ3VhZ2VdIDoge307XG4gICAgICAgICAgICAgICAgcHJvamVjdENvbmZpZy5rZXlzW2xhbmd1YWdlXVtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25WaWV3LnByaW50QnVuZGxlVGVtcGxhdGUoW3tcbiAgICAgICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSB8fCAnJyxcbiAgICAgICAgICAgICAgICAgICAgd29yZHM6IDBcbiAgICAgICAgICAgICAgICB9XSwgbGFuZ3VhZ2UsIGF2YWlsYWJsZUxhbmd1YWdlcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNhdGVnb3J5V29yZENvdW50KGNhdElkLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0F1dG8gc2F2ZTogXCInICsga2V5ICsgJ1wiIChzdWNjZXNzKScpO1xuXG4gICAgICAgICAgICAgICAgdHJhbnNsYXRpb25WaWV3LnNlbmRTdWNjZXNzKGtleSwgJ3ZhbHVlXycpO1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gbm90IHN1cmUgaWYgdGhpcyBpcyBuZWVkZWRcbiAgICAgICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgndXBkYXRlS2V5JywgcHJvamVjdElkLCBsYW5ndWFnZSwga2V5LCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vbkNsb25lS2V5KGZ1bmN0aW9uKGtleUlkLCBrZXlOYW1lLCBmcm9tQ2F0ZWdvcnksIHRvQ2F0ZWdvcnkpIHtcbiAgICB0cmFkZS5jbG9uZUtleShcbiAgICAgICAgcHJvamVjdEluZm8uaWQsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGlkOiBrZXlJZCxcbiAgICAgICAgICAgIGtleToga2V5TmFtZSxcbiAgICAgICAgICAgIHNvdXJjZUNhdGVnb3J5OiBmcm9tQ2F0ZWdvcnksXG4gICAgICAgICAgICB0YXJnZXRDYXRlZ29yeTogdG9DYXRlZ29yeVxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihlcnIsIHByb2plY3RJZCwgZGF0YSkge1xuICAgICAgICAgICAgdmFyIHRleHRzO1xuICAgICAgICAgICAgaWYgKHByb2plY3RJZCA9PT0gcHJvamVjdEluZm8uaWQpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0tleXNbZGF0YS5rZXldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIHRleHRzID0gZGF0YS52YWx1ZXM7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgbGFuZyBpbiB0ZXh0cykge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGV4dHMuaGFzT3duUHJvcGVydHkobGFuZykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3RDb25maWcua2V5c1tsYW5nXVtkYXRhLmtleV0gPSB0ZXh0c1tsYW5nXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uVmlldy5wcmludEJ1bmRsZVRlbXBsYXRlKFt7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBkYXRhLmtleSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdGV4dHNbbGFuZ10gfHwgJydcbiAgICAgICAgICAgICAgICAgICAgICAgIH1dLCBsYW5nLCBhdmFpbGFibGVMYW5ndWFnZXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNhdGVnb3J5V29yZENvdW50KHRvQ2F0ZWdvcnksIGxhbmcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FubnkudHJhbnNsYXRpb25WaWV3RGVzY3JpcHRpb24uYWRkRGVzY3JpcHRpb25zKGRhdGEua2V5RGVzY3JpcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICk7XG59KTtcblxuLyoqXG4gKiBSZWFkIHRoZSBmcm9tIHBhcmFtIGFzIGRlZmF1bHQgbGFuZ3VhZ2Ugb3RoZXJ3aXNlIHRha2UgaXQgZnJvbSB0aGUgcHJvamVjdC5qc29uXG4gKiBAcGFyYW0gY29uZmlnXG4gKi9cbmZ1bmN0aW9uIHNhdmVQcm9qZWN0Q29uZmlnKGNvbmZpZywgcHJvamVjdCkge1xuICAgIHZhciBpZHgsXG4gICAgICAgIC8vIHRoZSBmcm9tIHBhcmFtZXRlciBjYW4gb3ZlcndyaXRlIHRoZSBkZWZhdWx0IGxhbmd1YWdlIChsZWdhY3kpXG4gICAgICAgIGRlZmF1bHRMYW5ndWFnZSA9IGRvbU9wdHMucGFyYW1zLmZyb20gPyBkb21PcHRzLnBhcmFtcy5mcm9tIDogY29uZmlnLmRlZmF1bHRMYW5ndWFnZTtcbiAgICBwcm9qZWN0Q29uZmlnID0gY29uZmlnO1xuICAgIHByb2plY3RJbmZvID0gcHJvamVjdDtcblxuICAgIC8vIFNldCAkeyBkZWZhdWx0TGFuZ3VhZ2UgfSBhcyBkZWZhdWx0IGluIGNhc2UgYSBwcm9qZWN0IHdhcyBqdXN0IGNyZWF0ZWQgKGkuZS4gZG9lcyBub3QgY29udGFpbiBhbnkga2V5cyB5ZXQpXG4gICAgLy8gVE9ETzogQmV0dGVyIGNyZWF0ZSAvIGFkZCBjaGVjayBvZiBvYmplY3QgdG8gZnVuY3Rpb25hbCBoZWxwZXIgb2JqZWN0IGluc3RlYWQgP1xuICAgIGF2YWlsYWJsZUxhbmd1YWdlcyA9XG4gICAgICAgIE9iamVjdC5rZXlzKHByb2plY3RDb25maWcua2V5cykubGVuZ3RoID09PSAwICYmIEpTT04uc3RyaW5naWZ5KHByb2plY3RDb25maWcua2V5cykgPT09IEpTT04uc3RyaW5naWZ5KHt9KSA/XG4gICAgICAgICAgICBbZGVmYXVsdExhbmd1YWdlXSA6IE9iamVjdC5rZXlzKHByb2plY3RDb25maWcua2V5cyk7XG5cbiAgICBpZHggPSBhdmFpbGFibGVMYW5ndWFnZXMuaW5kZXhPZihkZWZhdWx0TGFuZ3VhZ2UpO1xuXG4gICAgaWYgKGlkeCAhPT0gLTEgJiYgaWR4ICE9PSAwKSB7XG4gICAgICAgIC8vIG1vdmUgZGVmYXVsdCB0byB0aGUgYmVnaW4gb2YgdGhlIGxpc3QgKHRoaXMgZGVmaW5lcyB0aGUgb3JkZXIgaG93IHRoZSB0cmFuc2xhdGlvbiBsYW5ndWFnZXMgYXJlIHNob3duKVxuICAgICAgICBhdmFpbGFibGVMYW5ndWFnZXMuc3BsaWNlKDAsIDAsIGF2YWlsYWJsZUxhbmd1YWdlcy5zcGxpY2UoaWR4LCAxKVswXSk7XG4gICAgfVxufVxuXG4vLy8qKlxuLy8gKiBUT0RPIHJlcGxhY2UgYnVuZGxlIHdpdGggbG9jYWxlIGFuZCByZWZhY3RvciB0aGUgY2FsbHMgZnJvbSB0cmFuc2xhdGlvblZpZXdcbi8vICogVE9ETyB0aGlzIGNvZGUgaXMgbm90IGNhbGxlZCE/XG4vLyAqL1xuLy90cmFuc2xhdGlvblZpZXcub25BZGROZXdLZXkoZnVuY3Rpb24gKGxhbmcsIGtleSwgdmFsdWUsIGNiKSB7XG4vLyAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvbkFkZE5ld0tleScsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4vLyAgICBhbGVydCgnaHVodScpO1xuLy8gICAgdHJhZGUuc2VuZFJlc291cmNlKHtcbi8vICAgICAgICBidW5kbGU6IHByb2plY3RDb25maWcucHJvamVjdCxcbi8vICAgICAgICBsb2NhbGU6IGxhbmdcbi8vICAgIH0sIHtcbi8vICAgICAgICBrZXk6IGtleSxcbi8vICAgICAgICB2YWx1ZTogdmFsdWVcbi8vICAgIH0sIGZ1bmN0aW9uIChrZXkpIHtcbi8vICAgICAgICBjYihrZXkpXG4vLyAgICB9KTtcbi8vfSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vbkNyZWF0ZU5ld1Byb2plY3QoZnVuY3Rpb24ocHJqTmFtZSwgb2JqKSB7XG4gICAgdHJhZGUuY3JlYXRlTmV3UHJvamVjdChwcmpOYW1lLCBvYmopO1xufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vblJlbW92ZUNhdGVnb3J5KGZ1bmN0aW9uKG9iaikge1xuICAgIGNvbnNvbGUubG9nKCd0cmFuc2xhdGlvblZpZXdDb250cm9sbGVyOm9uUmVtb3ZlQ2F0ZWdvcnknLCBvYmosIHByb2plY3RJbmZvLmlkKTtcbiAgICB0cmFkZS5yZW1vdmVDYXRlZ29yeShwcm9qZWN0SW5mby5pZCwgb2JqLmNhdGVnb3J5KTtcbn0pO1xuXG50cmFuc2xhdGlvblZpZXcub25SZW5hbWVDYXRlZ29yeShmdW5jdGlvbihvYmopIHtcbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvblJlbmFtZUNhdGVnb3J5Jywgb2JqLCBwcm9qZWN0SW5mby5pZClcbiAgICB0cmFkZS5yZW5hbWVDYXRlZ29yeShwcm9qZWN0SW5mby5pZCwgb2JqLm9sZE5hbWUsIG9iai5uZXdOYW1lKTtcbn0pO1xuXG50cmFuc2xhdGlvblZpZXcub25SZW5hbWVLZXkoZnVuY3Rpb24ob2JqKSB7XG4gICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6b25SZW5hbWVLZXknLCBvYmosIHByb2plY3RJbmZvLmlkKTtcbiAgICB0cmFkZS5yZW5hbWVLZXkocHJvamVjdEluZm8uaWQsIHtcbiAgICAgICAgbmV3S2V5OiBvYmoubmV3S2V5LFxuICAgICAgICBvbGRLZXk6IG9iai5vbGRLZXlcbiAgICB9KTtcbn0pO1xuXG50cmFuc2xhdGlvblZpZXcub25SZW1vdmVLZXkoZnVuY3Rpb24ob2JqKSB7XG4gICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6b25SZW1vdmVLZXknLCBvYmosIHByb2plY3RJbmZvLmlkKTtcbiAgICB0cmFkZS5yZW1vdmVLZXkocHJvamVjdEluZm8uaWQsIG9iai5rZXksIGZ1bmN0aW9uKGtleSkge1xuICAgICAgICB2YXIgY2F0TmFtZSA9IGtleS5zcGxpdCgnXycpWzBdO1xuICAgICAgICBmb3IodmFyIGxhbmcgaW4gcHJvamVjdENvbmZpZy5rZXlzKSB7XG4gICAgICAgICAgICBpZiAocHJvamVjdENvbmZpZy5rZXlzLmhhc093blByb3BlcnR5KGxhbmcpKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHByb2plY3RDb25maWcua2V5c1tsYW5nXVtrZXldO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNhdGVnb3J5V29yZENvdW50KGNhdE5hbWUsIGxhbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxuLy8gcmVnaXN0ZXIgbGlzdGVuZXIgZnVuY3Rpb24gdG8gdGhlIHVpIGV2ZW50c1xudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICBhY3RpdmF0ZUxhbmd1YWdlOiBmdW5jdGlvbihsYW5nKSB7XG4vLyAgICAgICAgdHJhbnNsYXRpb25WaWV3SGVhZGVyLnNob3dMYW5nKGxhbmcpO1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcuc2hvd0xhbmcobGFuZyk7XG4gICAgfSxcbiAgICBkZUFjdGl2YXRlTGFuZ3VhZ2U6IGZ1bmN0aW9uKGxhbmcpIHtcbi8vICAgICAgICB0cmFuc2xhdGlvblZpZXdIZWFkZXIuaGlkZUxhbmcobGFuZyk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5oaWRlTGFuZyhsYW5nKTtcbiAgICB9LFxuICAgIHRvZ2dsZVdvcmRDb3VudDogZnVuY3Rpb24oYWN0aXZlKSB7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy50b2dnbGVXb3JkQ291bnQoYWN0aXZlKTtcbiAgICB9LFxuICAgIC8vIFRPRE8gIGRvbid0IHRyaWdnZXIgaXQgdHdpY2UgZm9yIHRoZSBzYW1lIGxhbmd1YWdlXG4gICAgYWRkTGFuZ3VhZ2U6IGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VzLnB1c2gobGFuZyk7XG4gICAgICAgIHByb2plY3RDb25maWcua2V5c1tsYW5nXSA9IHt9O1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcuYWRkTGFuZ3VhZ2UoT2JqZWN0LmtleXMoZXhpc3RpbmdLZXlzKSwgbGFuZyk7XG4vLyAgICAgICAgdHJhbnNsYXRpb25WaWV3SGVhZGVyLnNob3dMYW5nKGxhbmcpO1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcuc2hvd0xhbmcobGFuZyk7XG4gICAgfSxcbiAgICBlbmFibGVFZGl0b3JNb2RlOiBmdW5jdGlvbihlbmFibGVkKSB7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5lbmFibGVFZGl0b3JNb2RlKGVuYWJsZWQpO1xuICAgIH0sXG4gICAgZmlsZVVwbG9hZGVkOiBmdW5jdGlvbihwcm9qZWN0SWQsIGtleSwgdXJsKSB7XG4gICAgICAgIGNhbm55LnRyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkLmFwcGVuZEltYWdlKGtleSwgdXJsKVxuICAgIH0sXG4gICAgSk1CRkZpbGVVcGxvYWRlZDogZnVuY3Rpb24ocHJvamVjdElkKSB7XG4gICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KHByb2plY3RJZCwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpsb2FkUHJvamVjdCBmYWlscyBmb3IgcHJvamVjdElkOicsIHByb2plY3RJbmZvLmlkKTtcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICBqc29uSW1wb3J0ZWQ6IGZ1bmN0aW9uKHByb2plY3RJZCkge1xuICAgICAgICB0cmFkZS5sb2FkUHJvamVjdChwcm9qZWN0SWQsIGZ1bmN0aW9uKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdQcm9qZWN0IHdpdGggaWQgJyArIHByb2plY3RJZCArICcgY291bGQgbm90IGJlIGxvYWRlZC4nKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdrZXlVcGRhdGVkJywgZnVuY3Rpb24oKSB7XG4gICAgLy8gVE9ETyBtb3JlIGNsaWVudCBjaGFuZ2VzIGFyZSBjb21pbmcsIHdlJ2xsIGZpbmlzaCB0aGUgY29kZSBiZWxvdyB0aGVuXG4gICAgLy9pZiAocHJvamVjdElkID09PSBwcm9qZWN0Q29uZmlnLnByb2plY3RJZCkge1xuICAgIC8vICAgIGV4aXN0aW5nS2V5c1trZXlOYW1lXSA9IHVuZGVmaW5lZDsgLy8gc2F2ZSB0aGUga2V5IC8vIHdoYXQncyBoYXBwZW5pbmcgaGVyZT9cbiAgICAvLyAgICB2YXIgZGF0YSA9IHt9O1xuICAgIC8vICAgIGRhdGFba2V5TmFtZV0gPSBrZXlWYWx1ZTtcbiAgICAvLyAgICB0cmFuc2xhdGlvblZpZXcucHJpbnRCdW5kbGVUZW1wbGF0ZShbZGF0YV0sIGxhbmd1YWdlLCBhdmFpbGFibGVMYW5ndWFnZXMsIHByb2plY3RDb25maWcucHJvamVjdCk7XG4gICAgLy99XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqIGFsbCB1c2VycyB3aWxsIGJlIG5vdGlmaWVkIG9mIGNoYW5nZXNcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdvbktleUNsb25lZCcsIGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUubG9nKCdldmVudHMubGlzdGVuZXI6Om9uS2V5Q2xvbmVkJyArIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdrZXlEZWxldGVkJywgZnVuY3Rpb24oYnVuZGxlTmFtZSwgb2JqKSB7XG4gICAgLy8gVE9ETyBtb3JlIGNsaWVudCBjaGFuZ2VzIGFyZSBjb21pbmcsIHdlJ2xsIGZpbmlzaCB0aGUgY29kZSBiZWxvdyB0aGVuXG4gICAgLy9pZiAoYnVuZGxlTmFtZSA9PT0gcHJvamVjdENvbmZpZy5wcm9qZWN0KSB7XG4gICAgLy8gICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6a2V5UmVuYW1lZCcsIGJ1bmRsZU5hbWUsIG9iaik7XG4gICAgLy8gICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0tleSBkZWxldGVkIScgKyBvYmoua2V5KTtcbiAgICAvLyAgICB0cmFuc2xhdGlvblZpZXcubWFya0tleUFzUmVtb3ZlZChvYmoua2V5KTtcbiAgICAvL31cbn0pO1xuXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ2NhdGVnb3J5RGVsZXRlZCcsIGZ1bmN0aW9uKGJ1bmRsZU5hbWUsIG9iaikge1xuICAgIGNvbnNvbGUubG9nKCdldmVudHMubGlzdGVuZXI6OmNhdGVnb3J5RGVsZXRlZCcgKyBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xufSk7XG5cbmV2ZW50cy5hZGRTZXJ2ZXJMaXN0ZW5lcignY2F0ZWdvcnlSZW5hbWVkJywgZnVuY3Rpb24oYnVuZGxlTmFtZSwgb2JqKSB7XG4gICAgY29uc29sZS5sb2coJ2V2ZW50cy5saXN0ZW5lcjo6Y2F0ZWdvcnlSZW5hbWVkJyArIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59KTtcblxuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdpbWFnZVJlbW92ZWQnLCBmdW5jdGlvbihidW5kbGVOYW1lLCBjYXRlZ29yeU5hbWUpIHtcbiAgICBpZiAoYnVuZGxlTmFtZSA9PT0gcHJvamVjdEluZm8uaWQpIHtcbiAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0ltYWdlIHJlbW92ZWQgZm9yIGNhdGVnb3J5OiAnICsgY2F0ZWdvcnlOYW1lKTtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LnJlbW92ZUltYWdlKGNhdGVnb3J5TmFtZSk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogR2V0IHdvcmQgY291bnQgZm9yIGdpdmVuIGNhdGVnb3J5IGFuZCBsYW5ndWFnZVxuICogQHBhcmFtIGNhdGVnb3J5XG4gKiBAcGFyYW0gbGFuZ1xuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbmZ1bmN0aW9uIGNvdW50V29yZHNJbkNhdGVnb3J5KGNhdGVnb3J5LCBsYW5nKSB7XG4gICAgbGV0IHdvcmRDb3VudCA9IDA7XG4gICAgT2JqZWN0LmtleXMocHJvamVjdENvbmZpZy5rZXlzW2xhbmddKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICBpZiAoa2V5LnNwbGl0KCdfJylbMF0gPT09IGNhdGVnb3J5KSB7XG4gICAgICAgICAgICB3b3JkQ291bnQgKz0gd29yZENvdW50ZXIuY291bnRXb3Jkc0luU3RyaW5nKHByb2plY3RDb25maWcua2V5c1tsYW5nXVtrZXldKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB3b3JkQ291bnQ7XG59XG5cbi8qKlxuICogVXBkYXRlIG92ZXJhbGwgd29yZC1jb3VudCB2aWV3IGZvciBjYXRlZ29yeSBsYW5ndWFnZVxuICogQHBhcmFtIGNhdElkXG4gKiBAcGFyYW0gbGFuZ1xuICovXG5mdW5jdGlvbiB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudChjYXRJZCwgbGFuZykge1xuICAgIHRyYW5zbGF0aW9uVmlldy51cGRhdGVDYXRlZ29yeVdvcmRDb3VudCh7XG4gICAgICAgIGlkOiBjYXRJZCxcbiAgICAgICAgbGFuZ3VhZ2U6IGxhbmcsXG4gICAgICAgIHdvcmRzOiBjb3VudFdvcmRzSW5DYXRlZ29yeShjYXRJZCwgbGFuZylcbiAgICB9KTtcbn1cblxuLyoqXG4gKiBGaWx0ZXIgY2F0ZWdvcnkgbmFtZXMgYnkgaXRlcmF0aW5nIHRocm91Z2ggcHJvamVjdCBrZXlzXG4gKiBAcGFyYW0ga2V5c1xuICogQHJldHVybnMgQXJyYXlcbiAqL1xuZnVuY3Rpb24gZ2V0Q2F0ZWdvcmllc0J5S2V5cyhrZXlzKSB7XG4gICAgdmFyIGN1cnJlbnRDYXROYW1lLFxuICAgICAgICBkZWZhdWx0S2V5cyxcbiAgICAgICAgY2F0ZWdvcmllcyA9IFtdO1xuICAgIGZvciAodmFyIGxhbmcgaW4ga2V5cykge1xuICAgICAgICBpZiAoa2V5cy5oYXNPd25Qcm9wZXJ0eShsYW5nKSkge1xuICAgICAgICAgICAgZGVmYXVsdEtleXMgPSBrZXlzW2xhbmddO1xuICAgICAgICAgICAgZm9yICh2YXIga2V5IGluIGRlZmF1bHRLZXlzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGRlZmF1bHRLZXlzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudENhdE5hbWUgPSBrZXkuc3BsaXQoJ18nKVswXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhdGVnb3JpZXMuaW5kZXhPZihjdXJyZW50Q2F0TmFtZSkgPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goY3VycmVudENhdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBjYXRlZ29yaWVzO1xufVxuXG5cbi8qKlxuICogUmVtb3ZlcyBjYXRlZ29yeSByZWxhdGVkIGtleXMgZnJvbSBcInNlc3Npb25cIiBkYXRhIC0gc3RvcmVkIGluIHByb2plY3RDb25maWcua2V5c1xuICogKG1lbWJlciB2YXIgZGVjbGFyZWQgb24gdG9wIG9mIHRoaXMgZmlsZSlcbiAqIEludm9rZWQgYnkgY2F0ZWdvcnkgd2FzIHJlbW92ZWRcbiAqIEBwYXJhbSBjYXRlZ29yeVxuICovXG5mdW5jdGlvbiByZW1vdmVDYXRlZ29yeURhdGEoY2F0ZWdvcnkpIHtcbiAgICBPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXMpLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICB2YXIgbGFuZ0RhdGEgPSBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ107XG4gICAgICAgIE9iamVjdC5rZXlzKGxhbmdEYXRhKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgaWYgKGtleS5zcGxpdCgnXycpWzBdID09PSBjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBsYW5nRGF0YVtrZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbn1cblxuZnVuY3Rpb24gaGFuZGxlTmV3UHJvamVjdENvbmZpZyhuZXdQcm9qZWN0Q29uZmlnLCBwcm9qZWN0KSB7XG4gICAgLy8gcHJvamVjdCBzcGVjaWZpYyBjb25maWdcbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlciBnZXQgbmV3IGNvbmZpZycsIG5ld1Byb2plY3RDb25maWcpO1xuICAgIC8vIG4uYi4gbm90aGluZyBpcyBzYXZlZCBoZXJlIC0gXCJzYXZpbmdcIiBvbmx5IGhhcHBlbnMgYXMgaW4gXCJzdG9yZSBpbiBvdXIgZGF0YSBzdHJ1Y3R1cmVcIlxuICAgIHNhdmVQcm9qZWN0Q29uZmlnKG5ld1Byb2plY3RDb25maWcsIHByb2plY3QpO1xuICAgIC8vIGJlZm9yZSB0aGVyZSB3YXMgYSBjaGVjayBkbyBub3QgY2xlYXIgdGhlIHZpZXcgaWYgdGhlIGFjdHVhbCBwcm9qZWN0IGlzIHRoZSBzYW1lLlxuICAgIC8vIFRoZSBwcm9ibGVtIGlzIGlmIHlvdSByZW1vdmUgYSBrZXkgaW4gdGhlIGVkaXRvciB2aWV3IHRoYW4gdGhlIHRyYW5zbGF0aW9uIHZpZXcgY2FuJ3RcbiAgICAvLyBkZXRlY3QgdGhpcy5cbiAgICB0cmFuc2xhdGlvblZpZXcuY2xlYXJWaWV3KCk7XG4gICAgY2FubnkuZmxvd0NvbnRyb2wuc2hvdygncmVzb3VyY2VCdW5kbGUnKTtcbn1cblxuZnVuY3Rpb24gcmVuZGVyUHJvamVjdChwcm9qZWN0RGF0YSwgcHJvamVjdCwgY2IpIHtcbiAgICB2YXIgY2F0ZWdvcmllcyA9IGdldENhdGVnb3JpZXNCeUtleXMocHJvamVjdERhdGEua2V5cyk7XG5cbiAgICBoYW5kbGVOZXdQcm9qZWN0Q29uZmlnKHByb2plY3REYXRhLCBwcm9qZWN0KTtcblxuICAgIE9iamVjdC5rZXlzKHByb2plY3REYXRhLmtleXMpLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICB2YXIgc29ydGVkLCBkYXRhcyA9IFtdO1xuICAgICAgICBPYmplY3Qua2V5cyhwcm9qZWN0RGF0YS5rZXlzW2xhbmddKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgZGF0YXMucHVzaCh7XG4gICAgICAgICAgICAgICAga2V5OiBrZXksXG4gICAgICAgICAgICAgICAgdmFsdWU6IHByb2plY3REYXRhLmtleXNbbGFuZ11ba2V5XVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzb3J0ZWQgPSBkYXRhcy5zb3J0KHNvcnRCeUtleSk7XG5cbiAgICAgICAgc29ydGVkLmZvckVhY2goZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgZXhpc3RpbmdLZXlzW2RhdGEua2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gVE9ETyBwcm9qZWN0Q29uZmlnLnByb2plY3Qgd2lsbCBiZSByZW1vdmVkIGlmIHRoZSB0cmFkZSBjYWxsIG1vdmVkIHRvIHRoaXMgY29udHJvbGxlclxuICAgICAgICB0cmFuc2xhdGlvblZpZXcucHJpbnRCdW5kbGVUZW1wbGF0ZShzb3J0ZWQsIGxhbmcsIGF2YWlsYWJsZUxhbmd1YWdlcywgY2IgfHwgZnVuY3Rpb24oKSB7fSk7XG5cbiAgICAgICAgY2F0ZWdvcmllcy5mb3JFYWNoKGZ1bmN0aW9uKGNhdGVnb3J5KSB7XG4gICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudChjYXRlZ29yeSwgbGFuZyk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZW5hbWVDYXRlZ29yeTogZnVuY3Rpb24ob2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSgnUmVuYW1lZCBjYXRlZ29yeSAnICsgb2xkTmFtZSArICcgdG8gJyArIG5ld05hbWUgKyAnIScpO1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcucmVuYW1lQ2F0ZWdvcnkob2xkTmFtZSwgbmV3TmFtZSwgYXZhaWxhYmxlTGFuZ3VhZ2VzKTtcbiAgICB9LFxuICAgIHJlbW92ZUNhdGVnb3J5OiBmdW5jdGlvbihjYXROYW1lKSB7XG4gICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdSZW1vdmVkIGNhdGVnb3J5ICcgKyBjYXROYW1lICsgJyEnKTtcbiAgICAgICAgcmVtb3ZlQ2F0ZWdvcnlEYXRhKGNhdE5hbWUpO1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcucmVtb3ZlQ2F0ZWdvcnkoY2F0TmFtZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBpcyBjYWxsZWQgaWYgdGhlIHVzZXIgcmVuYW1lIGtleSByZXF1ZXN0IHdhcyBzdWNjZXNzZnVsXG4gICAgICogQHBhcmFtIG5ld0tleVxuICAgICAqIEBwYXJhbSBvbGRLZXlcbiAgICAgKi9cbiAgICByZW5hbWVLZXk6IGZ1bmN0aW9uKG9sZEtleSwgbmV3S2V5KSB7XG4gICAgICAgIGlmIChvbGRLZXkpIHtcbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdLZXkgcmVuYW1lZCBzdWNjZXNzZnVsISBGcm9tICcgKyBvbGRLZXkgKyAnIHRvICcgKyBuZXdLZXkpO1xuICAgICAgICAgICAgdHJhbnNsYXRpb25WaWV3LnJlbmFtZUtleShvbGRLZXksIG5ld0tleSwgYXZhaWxhYmxlTGFuZ3VhZ2VzKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdLZXkgcmVuYW1lZCBmYWlsZWQhJyk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHJlbW92ZUtleTogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdLZXkgcmVtb3ZlZCBzdWNjZXNzZnVsIScsIGtleSk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5yZW1vdmVLZXkoa2V5KTtcbiAgICB9LFxuICAgIGltYWdlUmVtb3ZlZDogZnVuY3Rpb24oY2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdJbWFnZSByZW1vdmVkIGZvciBjYXRlZ29yeTogJyArIGNhdGVnb3J5TmFtZSk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5yZW1vdmVJbWFnZShjYXRlZ29yeU5hbWUpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogV2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgY29tcGxldGUgSlNPTiBvYmplY3QgZnJvbSBhIHNwZWNpZmljIHByb2plY3RcbiAgICAgKiBAcGFyYW0gcHJvamVjdERhdGFcbiAgICAgKi9cbiAgICBvbkxvYWRQcm9qZWN0OiBmdW5jdGlvbihwcm9qZWN0RGF0YSwgcHJvamVjdCkge1xuICAgICAgICB2YXIgYW5jaG9yID0gdXJsLmhhc0FuY2hvcigpID8gdXJsLmdldEFuY2hvcigpLnJlcGxhY2UoJyMnLCAnJykgOiBmYWxzZTtcbiAgICAgICAgcmVuZGVyUHJvamVjdChwcm9qZWN0RGF0YSwgcHJvamVjdCwgZnVuY3Rpb24odmlld0lkKSB7XG4gICAgICAgICAgICBpZiAoYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXdJZCA9PT0gYW5jaG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0cmFuc2xhdGlvblZpZXcuY29uZmlnLnJvd1ByZWZpeCArIHZpZXdJZCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvIHRoZSBlbGVtZW50IGV4aXN0cz9cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2FuY2hvckZvY3VzJywgdXJsLmdldEFuY2hvcigpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxlbVJlY3QgPSBkb20uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZnNldCA9IGVsZW1SZWN0LnRvcCAtIGJvZHlSZWN0LnRvcDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3aW5kb3cuc2Nyb2xsVG8oMCwgb2Zmc2V0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gYWRkIHRoZSBkZXNjcmlwdGlvbnNcbiAgICAgICAgY2FubnkudHJhbnNsYXRpb25WaWV3RGVzY3JpcHRpb24uYWRkRGVzY3JpcHRpb25zKHByb2plY3REYXRhLmtleURlc2NyaXB0aW9ucyk7XG4gICAgICAgIE9iamVjdC5rZXlzKHByb2plY3REYXRhLmltYWdlcykuZm9yRWFjaChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIC8vIGltYWdlcyB3aXRob3V0IGEgc2xhc2ggYXQgZnJvbnQgYXJlIG9sZCBpbWFnZSB1cGxvYWQgLSB0aGlzIGlzIG9ubHkgdG8gYmUgYmFja3dhcmQgY29tcGF0aWJsZVxuICAgICAgICAgICAgY29uc3QgdXJsID0gcHJvamVjdERhdGEuaW1hZ2VzW2tleV1bMF0gPT09ICcvJyA/IHByb2plY3REYXRhLmltYWdlc1trZXldIDogYC8ke3Byb2plY3QuaWR9LyR7cHJvamVjdERhdGEuaW1hZ2VzW2tleV19YFxuICAgICAgICAgICAgY2FubnkudHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQuYXBwZW5kSW1hZ2Uoa2V5LCB1cmwpO1xuICAgICAgICB9KVxuICAgIH0sXG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZDogZnVuY3Rpb24ocHJvamVjdERhdGEsIHByb2plY3QpIHtcbiAgICAgICAgcmVuZGVyUHJvamVjdChwcm9qZWN0RGF0YSwgcHJvamVjdCk7XG4gICAgfVxufTsiLCJcbi8qKlxuICogY29udHJvbGxlciBmb3IgdGhlIGltYWdlIHVwbGFvZGVyIHZpZXcgLSBjYWxscyB0aGUgc2VydmVyIHRvIHVwbG9hZCBhIGltYWdlIGFuZCBub3RpZmllciB0aGUgdWkgZXZlbnQgaGFuZGxlclxuICogQHR5cGUge3t9fVxuICovXG52YXIgY2FubnkgPSByZXF1aXJlKCdjYW5ueScpLFxuICAgIHVwbG9hZCA9IGNhbm55LnVwbG9hZCxcbiAgICBkaXNwbGF5TWFuYWdlciA9IGNhbm55LmRpc3BsYXlNYW5hZ2VyLFxuICAgIHVpRXZlbnRzID0gcmVxdWlyZSgnLi4vdWlFdmVudE1hbmFnZXIuanMnKSxcbiAgICB1cGxvYWRJZCxcbiAgICBwcm9qZWN0SW5mbztcbi8qKlxuICogQ2FsbCB0aGlzIGZvciBlYWNoIGZpbGUgLSB3aWxsIGNhbGwgYSBjYWxsIGJhY2sgd2l0aCB0aGUgc2VydmVyIGFuc3dlclxuICogQHBhcmFtIGZpbGVcbiAqL1xuZnVuY3Rpb24gc2VuZEZpbGUoZmlsZSwgZGlyZWN0Q2FsbGJhY2spIHtcbiAgICB2YXIgdXJpID0gJy91cGxvYWRGaWxlP3Byb2plY3RJZD0nICsgcHJvamVjdEluZm8uaWQgKyAnJmtleT0nICsgdXBsb2FkSWQgKyAnJnByb2plY3Q9JyArIHByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgeGhyLm9wZW4oXCJQT1NUXCIsIHVyaSwgdHJ1ZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQgJiYgeGhyLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSByZXNwb25zZS5cbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgZGlyZWN0Q2FsbGJhY2sgJiYgZGlyZWN0Q2FsbGJhY2soZGF0YSk7IC8vIGhhbmRsZSByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIHtmaWxlOiBcIi8vc3ViL3N1YjEvc3ViMV9ibHVlX2Nva2UuanBnXCIsIG5hbWU6IFwic3ViMV9ibHVlX2Nva2UuanBnXCIsIHR5cGU6IFwiaW1hZ2UvanBnXCJ9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdmaWxlVXBsb2FkZWQnLCBwcm9qZWN0SW5mby5pZCwgdXBsb2FkSWQsIGRhdGEuZmlsZSlcbiAgICAgICAgfVxuICAgIH07XG4gICAgZmQuYXBwZW5kKCdteUZpbGUnLCBmaWxlKTtcbiAgICAvLyBJbml0aWF0ZSBhIG11bHRpcGFydC9mb3JtLWRhdGEgdXBsb2FkXG4gICAgeGhyLnNlbmQoZmQpO1xufVxuXG4vKipcbiAqIFNhdmUgZGF0YSBpbiBtZW1iZXIgdmFyaWFibGUgdXNlZCBieSBmdXJ0aGVyIHVwbG9hZCBvcGVyYXRpb25zXG4gKiBAcGFyYW0gZGF0YTogUHJvamVjdCBkYXRhXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UHJvamVjdERhdGEoZGF0YSwgcHJvamVjdCkge1xuICAgIHByb2plY3RJbmZvID0gcHJvamVjdDtcbn1cblxudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICBzaG93RmlsZVVwbG9hZCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB1cGxvYWRJZCA9IGlkO1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCd1cGxvYWRWaWV3Jyk7XG4gICAgfVxufSk7XG5cbnVwbG9hZC5vblVwbG9hZChmdW5jdGlvbiAoZmlsZSkge1xuICAgIC8vIFRPRE8gYWRkaXRpb25hbCB0byB0aGUgdXBsb2FkIGlkIHdlIG5lZWQgdGhlIHByb2plY3QgSURcbiAgICBjb25zb2xlLmxvZygndXBsb2FkQ29udHJvbGxlcjp1cGxvYWQgaWQ6IGZpbGU6JywgdXBsb2FkSWQsIGZpbGUpO1xuICAgIHNlbmRGaWxlKGZpbGUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTG9hZFByb2plY3QgOiBhcHBseVByb2plY3REYXRhXG59OyIsInZhciB0cmFkZSA9IHJlcXVpcmUoJy4uL3RyYWRlJyksXG4gICAgdWlFdmVudHMgPSByZXF1aXJlKCcuLi91aUV2ZW50TWFuYWdlcicpLFxuICAgIHVybCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsJyk7XG4vKipcbiAqIFRPRE8gaGFuZGxlIHRoZSBicm93c2VyIGJhY2sgYW5kIG5leHQgYnV0dG9uIGFuZCBsb2FkIHRoZSBjb3JyZWN0IHZpZXdcbiAqL1xuZnVuY3Rpb24gcHJvY2Vzc0FqYXhEYXRhKHJlc3BvbnNlLCB1cmxQYXRoKXtcbiAgICBkb2N1bWVudC50aXRsZSA9IHJlc3BvbnNlLnBhZ2VUaXRsZTtcbiAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUoe1xuICAgICAgICBcImh0bWxcIjogcmVzcG9uc2UuaHRtbCxcbiAgICAgICAgXCJwYWdlVGl0bGVcIjogcmVzcG9uc2UucGFnZVRpdGxlLFxuICAgICAgICBpZCA6IHJlc3BvbnNlLmlkLFxuICAgICAgICBpc1Byb2plY3QgOiByZXNwb25zZS5pc1Byb2plY3RcbiAgICB9LFwiXCIsIHVybFBhdGggKyB1cmwuZ2V0QW5jaG9yKCkpO1xufVxuXG4vKipcbiAqIE1hbmlwdWxhdGUgYnJvd3NlciBoaXN0b3J5IC8gbG9jYXRpb24gd2l0aCBnaXZlbiBwcm9qZWN0IGRhdGFcbiAqIEBwYXJhbSBkYXRhOiBQcm9qZWN0IHJlbGF0ZWQgZGF0YVxuICovXG5mdW5jdGlvbiBhcHBseVByb2plY3REYXRhKGRhdGEsIHByb2plY3QpIHtcbiAgICAvLyBhZGQgdGhlIHByb2plY3QgcGF0aCB0byB0aGUgVVJMXG4gICAgaWYgKHByb2plY3QubmFtZSkge1xuICAgICAgICBwcm9jZXNzQWpheERhdGEoe1xuICAgICAgICAgICAgcGFnZVRpdGxlIDogcHJvamVjdC5pZCxcbiAgICAgICAgICAgIGh0bWw6JycsXG4gICAgICAgICAgICBpZCA6IHByb2plY3QuaWQsXG4gICAgICAgICAgICBpc1Byb2plY3QgOiB0cnVlXG4gICAgICAgICAgICAvLyB0byBwZXJzaXN0cyB0aGUgbGlua3Mgd2Ugc2F2ZSB0aGUgaWQgaW4gVVJMIC0gaXQncyBub3QgaHVtYW4gcmVhZGFibGUgYnV0IGxpbmtzIHdpbGwgd29yayBmb3JldmVyXG4gICAgICAgIH0sICcvJyArIHByb2plY3QuaWQgKyAnLnByaicpO1xuICAgIH1cbn1cblxudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICBhbmNob3JGb2N1cyA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAvLyBzZXQgdGhlIGFuY2hvciB0byB0aGUgVVJMXG4gICAgICAgIHdpbmRvdy5oaXN0b3J5LnB1c2hTdGF0ZShudWxsLCBudWxsLCBpZClcbiAgICB9XG59KTtcblxud2luZG93Lm9ucG9wc3RhdGUgPSBmdW5jdGlvbiAoZSkge1xuLy8gICAgY29uc29sZS5sb2coJ29ucG9wc3RhdGUnLCBlLnN0YXRlLmlkKTtcbiAgICBpZiAoZS5zdGF0ZSkge1xuICAgICAgICBpZiAoZS5zdGF0ZS5pc1Byb2plY3QpIHtcbiAgICAgICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KGUuc3RhdGUuaWQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyID09PSBmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndXJsTWFuaXB1bGF0b3I6bG9hZFByb2plY3QgZmFpbHMgZm9yIHByb2plY3RJZDonLCBlLnN0YXRlLmlkKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYWRlLmdldERpcmVjdG9yeShlLnN0YXRlLmlkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjYWxsIHRoZVxuICAgICAgICAgICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnc2hvd092ZXJ2aWV3UGFnZScpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCd1cmxNYW5pcHVsYXRvcjpnZXREaXJlY3RvcnkgY2FuIG5vdCBsb2FkIHByb2plY3QgZm9yIGRpcmVjdG9yeSBuYW1lOicsIGUuc3RhdGUuaWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIFRPRE8gdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggYWN0aXZhdGluZyB0aGUgcHJvamVjdCB2aWV3IG9yIHRoZSBvdmVydmlldyBwYWdlLi4uXG4gKlxuICoganVzdCB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhbGxiYWNrc1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25Mb2FkUHJvamVjdCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgZ2V0RGlyZWN0b3J5OiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBwcm9jZXNzQWpheERhdGEoe1xuICAgICAgICAgICAgcGFnZVRpdGxlIDogJ3RyYW5zbGF0cm9uIG92ZXJ2aWV3JyxcbiAgICAgICAgICAgIGh0bWw6JycsXG4gICAgICAgICAgICBpZCA6IGRhdGEuY3VycmVudERpcmVjdG9yeSxcbiAgICAgICAgICAgIGlzUHJvamVjdCA6IGZhbHNlXG4gICAgICAgIH0sIGRhdGEuY3VycmVudERpcmVjdG9yeSk7XG4gICAgfVxufTsiLCIvKipcbiAqIENyZWF0ZWQgYnkgZWlnaHR5Zm91ci5cbiAqXG4gKiBBbGwgc2VydmVyIGV2ZW50cy4gTXVsdGlwbGUgY2xpZW50cyBjYW4gcmVnaXN0ZXIgb24gZWFjaCBldmVudFxuICogYW5kIHdpbGwgYmUgbm90aWZpZWQgaWYgbWV0aG9kIGlzIGNhbGxlZCBmcm9tIHNlcnZlci5cbiAqXG4gKiBUT0RPIFJFTkFNRSBGSUxFXG4gKiBUT0RPIHRvIHdoYXQ/IDopXG4gKiBXaGF0IGFib3V0IFwiZXh0ZXJuYWxDaGFuZ2VOb3RpZmljYXRpb25zXCI/XG4gKlxuICogVEJEIHdoeSBkb24ndCB3ZSBpbnRlZ3JhdGUgdGhpcyBvbmUgd2l0aCB1aSBldmVudHM/IHRoYXQgd291bGQgY3V0IGRvd24gb24gdGhlIG51bWJlciBvZiBjb21wb25lbnRzIHdlIGhhdmUgYW5kIHdlIFwib25seVwiICg/KVxuICogaGF2ZSB0byBkbyBzb21lIHNlbnNpYmxlIHJlbmFtaW5nIG9mIGV2ZW50cywgbGlrZSByZW5hbWluZyBhbGwgZXZlbnRzIGhhbmRsZWQgaGVyZSBieSBhZGRpbmcgXCJleHRlcm5hbFwiIG9yIHNpbWlsYXJcbiAqIChlLmcuIFwia2V5VXBkYXRlZFwiIGJlY29tZXMgXCJrZXlVcGRhdGVkRXh0ZXJuYWxseVwiKS5cbiAqL1xudmFyIGV2ZW50cyA9IChmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGV2ZW50UXVldWUgPSB7fSxcbiAgICAgICAgY2FsbFF1ZXVlID0gZnVuY3Rpb24gKG5hbWUsIGFyZ3MpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnb3Qgbm90aWZpY2F0aW9uIGZvciAnLCBuYW1lLCAnd2l0aCBwYXlsb2FkJywgYXJncyk7XG4gICAgICAgICAgICBpZiAoZXZlbnRRdWV1ZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50UXVldWVbbmFtZV0ubWFwKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICBmYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzZXJ2ZXJFdmVudHMgOiB7XG4gICAgICAgICAgICAvLyBUQkQgY2FuIGJlIHJlbW92ZWQ/XG4gICAgICAgICAgICBzZW5kRmlsZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBjYWxsUXVldWUoJ3NlbmRGaWxlJywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvLyBUQkQgY2FuIGJlIHJlbW92ZWQ/XG4gICAgICAgICAgICBzZW5kUGF0aExpc3QgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdzZW5kUGF0aExpc3QnLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGtleVVwZGF0ZWQgOiBmdW5jdGlvbiAocHJvamVjdElkLCBsYW5ndWFnZSwga2V5TmFtZSwga2V5VmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjYWxsUXVldWUoJ2tleVVwZGF0ZWQnLCBbIHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleU5hbWUsIGtleVZhbHVlIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uS2V5Q2xvbmVkIDogZnVuY3Rpb24ocHJvamVjdElkLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdvbktleUNsb25lZCcsIFtwcm9qZWN0SWQsIGRhdGFdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlSZW5hbWVkIDogZnVuY3Rpb24ocHJvamVjdElkLCBvbGRLZXlOYW1lLCBuZXdLZXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdrZXlSZW5hbWVkJywgWyBwcm9qZWN0SWQsIG9sZEtleU5hbWUsIG5ld0tleU5hbWUgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBAcGFyYW0gYnVuZGxlT2JqIHtsb2NhbGU6IHN0cmluZywgYnVuZGxlOiBzdHJpbmd9XG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YSB7b2xkS2V5OnN0cmluZywgbmV3S2V5OiBzdHJpbmd9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGtleURlbGV0ZWQgOiBmdW5jdGlvbiAocHJvamVjdElkLCBrZXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdrZXlEZWxldGVkJywgWyBwcm9qZWN0SWQsIGtleU5hbWUgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaW1hZ2VSZW1vdmVkIDogZnVuY3Rpb24gKHByb2plY3RJZCwgY2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdpbWFnZVJlbW92ZWQnLCBbIHByb2plY3RJZCwgY2F0ZWdvcnlOYW1lIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG5ld1Byb2plY3RXYXNDcmVhdGVkIDogZnVuY3Rpb24gKHByb2plY3RJZCkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgnbmV3UHJvamVjdFdhc0NyZWF0ZWQnLCBbIHByb2plY3RJZCBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yeVJlbmFtZWQgOiBmdW5jdGlvbiAocHJvamVjdElkLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdjYXRlZ29yeVJlbmFtZWQnLCBbIHByb2plY3RJZCwgb2xkTmFtZSwgbmV3TmFtZSBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYXRlZ29yeURlbGV0ZWQgOiBmdW5jdGlvbiAocHJvamVjdElkLCBjYXROYW1lKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdjYXRlZ29yeURlbGV0ZWQnLCBbIHByb2plY3RJZCwgY2F0TmFtZSBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXdEaXJlY3RvcnlDcmVhdGVkIDogZnVuY3Rpb24gKGRpcmVjdG9yeUlkKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCduZXdEaXJlY3RvcnlDcmVhdGVkJywgWyBkaXJlY3RvcnlJZCBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBwcm9qZWN0RGVzY3JpcHRpb25VcGRhdGVkIDogZnVuY3Rpb24gKHByb2plY3RJZCwgaWQsIGRlc2NyaXB0aW9uKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdwcm9qZWN0RGVzY3JpcHRpb25VcGRhdGVkJywgWyBwcm9qZWN0SWQsIGlkLCBkZXNjcmlwdGlvbiBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgYWRkU2VydmVyTGlzdGVuZXIgOiBmdW5jdGlvbiAobmFtZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChldmVudFF1ZXVlLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZVtuYW1lXS5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnRRdWV1ZVtuYW1lXSA9IFtjYl07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBldmVudHM7IiwiY29uc3QgQyA9IHJlcXVpcmUoJy4vQ09OU1QnKVxuY29uc3QgY29ubmVjdGlvbkxvc3QgPSByZXF1aXJlKCcuL3VpTW9kdWxlcy9jb25uZWN0aW9uTG9zdCcpXG5cbi8qKlxuICogUmVmcmVzaCB0aGUgdXNlciBzZXNzaW9uIGFuZCBkZXRlY3RzIGlmIHRoZSB1c2VyIGlzIG5vdCBhdXRoZW50aWNhdGVkIGFueW1vcmVcbiAqIHVzZWZ1bCBmb3I6XG4gKiAgKiBzZXNzaW9uIGtlZXAgYWxpdmVcbiAqICAqIGRldGVjdCBpZiB0aGUgdXNlciBpcyBub3QgYXV0aGVudGljYXRlZCBhbnltb3JlXG4gKiAgKiBkZXRlY3RzIHNlcnZlciBzaHV0IGRvd25cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYW5kbGVTZXNzaW9uVGltZU91dCgpIHtcbiAgICBjb25zdCBjb25uZWN0aW9uTG9zdFVpID0gY29ubmVjdGlvbkxvc3Qoe1xuICAgICAgICBvblJlbG9hZCA6ICgpID0+IGxvY2F0aW9uLnJlbG9hZCgpLFxuICAgICAgICBvbkNsb3NlIDogKCkgPT4gY29ubmVjdGlvbkxvc3RVaS5kZXN0cm95KClcbiAgICB9KVxuICAgIGNvbnN0IGludGVydmFsID0gc2V0SW50ZXJ2YWwoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZldGNoKGxvY2F0aW9uLnByb3RvY29sICsgJy8vJyArIGxvY2F0aW9uLmhvc3QgKyAnL3RvdWNoU2Vzc2lvbicsIHtcbiAgICAgICAgICAgIGNyZWRlbnRpYWxzOiBcInNhbWUtb3JpZ2luXCJcbiAgICAgICAgfSkudGhlbihkID0+IHtcbiAgICAgICAgICAgIGlmIChkLnN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJJbnRlcnZhbChpbnRlcnZhbClcbiAgICAgICAgICAgICAgICAvLyB3aG9vcHMgc2VydmVyIGhhcyBubyBhdXRoZW50aWNhdGlvbiBhbnltb3JlLi4uXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ0FVVEgnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KS5jYXRjaChlID0+IHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG4gICAgICAgICAgICBjb25uZWN0aW9uTG9zdFVpLnJlbmRlcignU0VSVkVSX0RPV04nLCAnTWF5YmUgYSBzZXJ2ZXIgcmVzdGFydCBoYXBwZW5zLiBQbGVhc2UgdHJ5IHRvIGxvZ2luIGFnYWluIGluIGZldyBtaW51dGVzJylcbiAgICAgICAgfSlcbiAgICB9LCBDLlNFU1NJT04ucmVuZXdhbF9pbnRlcnZhbF9pbl9tcylcbn0iLCIvKmdsb2JhbCBkb21PcHRzICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlICovXG5jb25zdCB1bmljb2RlID0gcmVxdWlyZSgnLi91bmljb2RlLmpzJylcbmNvbnN0IHRvYXN0ID0gcmVxdWlyZSgnLi9Ub2FzdC5qcycpXG5jb25zdCBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JylcbmNvbnN0IHRyYWRlID0gcmVxdWlyZSgnLi90cmFkZS5qcycpXG5jb25zdCBoYW5kbGVTZXNzaW9uVGltZU91dCA9IHJlcXVpcmUoJy4vaGFuZGxlU2Vzc2lvblRpbWVPdXQnKVxuY29uc3QgYnJlYWRDcnVtYkNvbnRyb2xsZXIgPSByZXF1aXJlKCcuL2NvbnRyb2xsZXIvYnJlYWRjcnVtYkNvbnRyb2xsZXIuanMnKVxuXG53aW5kb3cuZG9tT3B0cyA9IHdpbmRvdy5kb21PcHRzIHx8IHJlcXVpcmUoJ2RvbS1vcHRzJyk7XG4vLyBtYWRlIGl0IHB1YmxpYyAtIGp1c3QgZm9yIGRldmVsb3BtZW50XG53aW5kb3cuY2FubnkgPSBjYW5ueTtcblxuY2FubnkuYWRkKCdyZXBlYXQnLCAgICAgICAgIHJlcXVpcmUoJ2Nhbm55L21vZC9yZXBlYXQnKSk7XG5jYW5ueS5hZGQoJ3doaXNrZXInLCAgICAgICAgcmVxdWlyZSgnY2FubnkvbW9kL3doaXNrZXInKSk7XG5jYW5ueS5hZGQoJ2FzeW5jJywgICAgICAgICAgcmVxdWlyZSgnY2FubnkvbW9kL2FzeW5jJykpO1xuY2FubnkuYWRkKCdmbG93Q29udHJvbCcsICAgIHJlcXVpcmUoJ2Nhbm55L21vZC9mbG93Q29udHJvbCcpKCdmbG93Q29udHJvbCcpKTtcbmNhbm55LmFkZCgnZGlzcGxheU1hbmFnZXInLCByZXF1aXJlKCcuL3VpTW9kdWxlcy9kaXNwbGF5TWFuYWdlci5qcycpKTtcbmNhbm55LmFkZCgndGV4dEVkaXRvcicsICAgICByZXF1aXJlKCcuL3RleHRFZGl0b3IuanMnKSk7XG5jYW5ueS5hZGQoJ2Nvb2tpZU1hbmFnZXInLCAgcmVxdWlyZSgnY2FubnktY29va2llTWFuYWdlci1saWInKSk7XG5cbmNhbm55LmFkZCgndGV4dHMnLCAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3RleHRzLmpzJykpO1xuY2FubnkuYWRkKCdhdXRoJywgICAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvYXV0aC5qcycpKTtcbmNhbm55LmFkZCgncHJvamVjdE1haW5OYXZpZ2F0aW9uJywgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3Byb2plY3RNYWluTmF2aWdhdGlvbi5qcycpKTtcbmNhbm55LmFkZCgndHJhbnNsYXRpb25WaWV3JywgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlldy5qcycpKTtcbmNhbm55LmFkZCgndHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQnLCByZXF1aXJlKCcuL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZC5qcycpKTtcbi8vY2FubnkuYWRkKCd0cmFuc2xhdGlvblZpZXdIZWFkZXInLCAgcmVxdWlyZSgnLi91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3SGVhZGVyLmpzJykpO1xuY2FubnkuYWRkKCdpbWFnZVZpZXdlcicsICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvaW1hZ2VWaWV3ZXIuanMnKSk7XG5jYW5ueS5hZGQoJ3Byb2plY3RPdmVydmlldycsICAgICAgICByZXF1aXJlKCcuL3VpTW9kdWxlcy9wcm9qZWN0T3ZlcnZpZXcuanMnKSk7XG5jYW5ueS5hZGQoJ2NyZWF0ZU5ld1Byb2plY3QnLCAgICAgICByZXF1aXJlKCcuL3VpTW9kdWxlcy9jcmVhdGVOZXdQcm9qZWN0LmpzJykpO1xuY2FubnkuYWRkKCdtZW51UmlnaHQnLCAgICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvbWVudVJpZ2h0LmpzJykpO1xuY2FubnkuYWRkKCdhbmNob3JNZW51JywgICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvYW5jaG9yTWVudS5qcycpKTtcblxuY2FubnkuYWRkKCd0cmFuc2xhdGlvblZpZXdEZXNjcmlwdGlvbicsIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlld0Rlc2NyaXB0aW9uLmpzJykpO1xuY2FubnkuYWRkKCd1cGxvYWQnLCAgICAgICAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvdXBsb2FkLmpzJykpO1xuY2FubnkuYWRkKCdKTUJGVXBsb2FkZXInLCAgICAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvSk1CRlVwbG9hZGVyLmpzJykpO1xuY2FubnkuYWRkKCdKc29uSW1wb3J0JywgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL0pzb25JbXBvcnQuanMnKSk7XG5cbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci9wYWdlSGVhZGVyQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci90ZXh0RWRpdG9yQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL3VybE1hbmlwdWxhdG9yLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvcHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL2NyZWF0ZU5ld1Byb2plY3RDb250cm9sbGVyLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihicmVhZENydW1iQ29udHJvbGxlcik7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci9hdXRoQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL21lbnVSaWdodENvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci91cGxvYWRDb250cm9sbGVyLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvSk1CRlVwbG9hZGVyQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL0pzb25JbXBvcnRDb250cm9sbGVyLmpzJykpO1xuXG5jYW5ueS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgLy8gY3JlYXRlIHdlYnNvY2tldCBjb25uZWN0aW9uIHZpYSB0cmFkZVxuICAgIHRyYWRlLmluaXRpYWxpemUoZnVuY3Rpb24gKHVzZXJPYmplY3QsIHNlc3Npb25zRW5hYmxlZCkge1xuXG4gICAgICAgIGlmICh1c2VyT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICBhbGVydCgnQSBmYXRhbCBlcnJvciBoYXBwZW5zIHdoaWxlIGxvYWRpbmcgdGhlIHZpZXcnKVxuICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKClcbiAgICAgICAgICAgIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIGNhbm55LnRleHRzLnNldFRleHRzKHt1c2VyTmFtZTogdXNlck9iamVjdC5uYW1lfSk7XG5cbiAgICAgICAgaWYgKHVzZXJPYmplY3QuaXNBZG1pbikge1xuICAgICAgICAgICAgZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKCdpc0FkbWluJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2Vzc2lvbnNFbmFibGVkKSB7XG4gICAgICAgICAgICAvLyB0cmlnZ2VyIGEgXCJzZXNzaW9uIGtlZXAgYWxpdmVcIiBhbmQgZGV0ZWN0cyBpZiB0aGUgdXNlciBpcyBub3QgYXV0aGVudGljYXRlZCBhbnltb3JlIG9yIHRoZSBzZXJ2ZXIgaXMgZG93blxuICAgICAgICAgICAgaGFuZGxlU2Vzc2lvblRpbWVPdXQoKVxuICAgICAgICB9XG5cbiAgICB9KTtcbn0pO1xuXG53aW5kb3cuY2FubnkgPSBjYW5ueTtcbndpbmRvdy5kb21PcHRzID0gcmVxdWlyZSgnZG9tLW9wdHMnKTtcbndpbmRvdy51bmljb2RlID0gdW5pY29kZTtcbndpbmRvdy50b2FzdCA9IHRvYXN0O1xuXG4vLyBRVUVTVElPTjogY2FuIGl0IGhhcHBlbiB0aGF0IHRoZSBhYm92ZSBjYWxsIHRvIHRyYWRlLmluaXRpYWxpemUgKGluIGNhbm55LnJlYWR5KSBmaW5pc2hlcyBlYXJsaWVyIHRoYW4gdGhlIG5leHQgbGluZXM/XG4vLyBpLmUuIHRoZSBjYWxsYmFjayBmb3IgdHJhZGUucmVhZHkgd2lsbCBuZXZlciBiZSBleGVjdXRlZD8gaWYgeWVzOiB3aHkgbm90IHBhc3MgdGhlIGNhbGxiYWNrIGFscmVhZHkgdG8gdHJhZGUuaW5pdGlhbGl6ZT9cbnRyYWRlLnJlYWR5KGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgY29uc3QgcHJqID0gKGZ1bmN0aW9uIGdldFByb2plY3ROYW1lQW5kUGF0aEZyb21VUkwoKSB7XG4gICAgICAgIGNvbnN0IHNwbGl0ID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoJy8nKVxuICAgICAgICBsZXQgcGF0aCA9IGxvY2F0aW9uLnBhdGhuYW1lXG4gICAgICAgIGxldCBwcmpOYW1lXG4gICAgICAgIFxuICAgICAgICBpZiAoL1xcLnByai8udGVzdChzcGxpdFtzcGxpdC5sZW5ndGggLSAxXSkpIHtcbiAgICAgICAgICAgIC8vIHJlbW92ZSAucHJqIGV4dGVuc2lvbiBhbmQgZmlyc3Qgc2xhc2hcbiAgICAgICAgICAgIHByak5hbWUgPSBwYXRoLnJlcGxhY2UoJy5wcmonLCAnJykucmVwbGFjZSgnLycsICcnKVxuICAgICAgICAgICAgcGF0aCA9IHNwbGl0LnNsaWNlKDAsIC0xKS5qb2luKCcvJylcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKHBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAgICAgcGF0aCA9ICcvJyArIHBhdGhcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHBhdGggOiBwYXRoLFxuICAgICAgICAgICAgcHJvamVjdElkIDogcHJqTmFtZVxuICAgICAgICB9O1xuICAgIH0oKSk7XG5cbiAgICAvLyBRVUVTVElPTjogc2luY2UgdGhpcyBpcyB3b3JraW5nIG9uIHRoZSBVUkwgdGhlIGFwcGxpY2F0aW9uIHdhcyBsb2FkZWQgd2l0aCBhbmQgdGhpcyBVUkwgY2FuIGJlIGVpdGhlciBhIGRpcmVjdG9yeSBVUkxcbiAgICAvLyBvciBhIHByb2plY3QgVVJMOiB3aHkgY2FuJ3Qgd2UgZGVjaWRlIGZpcnN0IHdoYXQgd2UgYWN0dWFsbHkgaGF2ZSBpbiB0aGUgVVJMIGFuZCB0aGVuIGVpdGhlciBjYWxsIGdldERpcmVjdG9yeVxuICAgIC8vIG9yIGxvYWRQcm9qZWN0PyBBTlNXRVI6IGRlcGVuZHMuIGlmIHRoZSBVUkwgcG9pbnRzIHRvIGEgZGlyZWN0b3J5LCB3ZSBvbmx5IGhhdmUgdG8gZG8gdGhlIGdldERpcmVjdG9yeSBjYWxsLlxuICAgIC8vIGlmIHRoZSBVUkwgaXMgYSBwcm9qZWN0LCB0d28gY2FsbHMgaGF2ZSB0byBiZSBtYWRlOiBvbmUgbG9hZFByb2plY3QgY2FsbCBhbmQgb25lIGV4dHJhIGdldERpcmVjdG9yeSBjYWxsIGZvciB0aGVcbiAgICAvLyBwYXJlbnQgb2YgdGhlIHByb2plY3QgKG1haW5seSBmb3IgbmF2aWdhdGlvbiBjb21wb25lbnQgd2hpY2ggbmVlZHMgdG8ga25vdyB0aGUgc2libGluZ3Mgb2YgdGhlIHByb2plY3QpLiBCdXQ6IHRha2VcbiAgICAvLyBjYXJlIHRoYXQgdGhpcyBleHRyYSBnZXREaXJlY3RvcnkgbXVzdCAqbm90KiBjaGFuZ2UgdGhlIHN0YXRlIG9mIHRoZSBicmVhZGNydW1iIHRyYWlsICh0aGF0IG9uZSBzaG91bGQgc3RpbGwgc2hvd1xuICAgIC8vIHRoZSBzZWxlY3RlZCBwcm9qZWN0KVxuICAgIFxuICAgIFxuICAgIGlmIChwcmoucHJvamVjdElkKSB7XG4gICAgICAgIC8vIHRoaXMgaXMgdGhlIGluaXRpYWwgY2FsbCB0byB0cmlnZ2VyIGEgcHJvamVjdCBsb2FkIC0geW91IHdpbGwgZ2V0XG4gICAgICAgIC8vIHRoZSBwcm9qZWN0Lmpzb24gYW5kIGFsbCB0cmFuc2xhdGlvbnNcbiAgICAgICAgdHJhZGUubG9hZFByb2plY3QocHJqLnByb2plY3RJZCwgZnVuY3Rpb24gKGVyciwgZGF0YSwgcHJvamVjdCkge1xuICAgICAgICAgICAgLy8gY2FsbGJhY2sgaXMgb25seSBjYWxsZWQgaWYgYW4gZXJyb3Igb2NjdXJzXG4gICAgICAgICAgICBpZiAoZXJyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0xvYWRpbmcgcHJvamVjdCBcXCcnICsgcHJqLnByb2plY3RJZCArICdcXCcgZmFpbGVkIC0gcHJvamVjdCBkb2VzblxcJ3QgZXhpc3RzJyk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpsb2FkUHJvamVjdCBmYWlscyBmb3IgcHJvamVjdElkOicsIHByai5wcm9qZWN0SWQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyByZXF1aXJlZCBmb3IgdGhlIGJyZWFkY3J1bWJcbiAgICAgICAgICAgICAgICBicmVhZENydW1iQ29udHJvbGxlci5zZXRQYXRoKHByb2plY3QudXJsKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIH0gZWxzZSB7XG4gICAgICAgIHRyYWRlLmdldERpcmVjdG9yeShwcmoucGF0aCwgZnVuY3Rpb24gKG9iaikgeyB9KTtcbiAgICB9XG4gICAgXG59KTsiLCIvKipcbiAqIHRleHRFZGl0b3JcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciB0ZXh0RWRpdG9yID0gKGZ1bmN0aW9uICgpIHtcblxuICAgICAgICB2YXIgdGV4dHMgPSB7XG4gICAgICAgICAgICBvcmlnaW5UZXh0IDogJ0RvdWJsZSBjbGljayB0byBlZGl0IHRoaXMgdGV4dCcsXG4gICAgICAgICAgICBlZGl0QnRuIDogJ0VkaXQnLFxuICAgICAgICAgICAgY2FuY2VsQnRuIDogJ0NhbmNlbCcsXG4gICAgICAgICAgICBjaGFuZ2VCdG4gOiAnU2F2ZSBjaGFuZ2VzJ1xuICAgICAgICB9LFxuICAgICAgICBvbkNoYW5nZUFsbExpc3QgPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBmaW5kQ2xvc2VzdEFuY2VzdG9yV2l0aElkKGVsZW1lbnQpIHtcbiAgICAgICAgICAgIHdoaWxlICgoZWxlbWVudCA9IGVsZW1lbnQucGFyZW50RWxlbWVudCkgJiYgIWVsZW1lbnQuaWQpIHt9XG4gICAgICAgICAgICByZXR1cm4gZWxlbWVudDtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxDaGFuZ2VMaXN0KGlkLCB2YWx1ZSwgZmMpIHtcbiAgICAgICAgICAgIG9uQ2hhbmdlQWxsTGlzdC5mb3JFYWNoKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYihpZCwgdmFsdWUsIGZjKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gZWRpdFdpdGhUZXh0YXJlYShub2RlLCBidXR0b25XcmFwLCBvYmopIHtcbiAgICAgICAgICAgIHZhciBvcGVuID0gZmFsc2UsXG4gICAgICAgICAgICAgICAgZGl2V3JhcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIGJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIGNhbmNlbEJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgIGFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpLFxuICAgICAgICAgICAgICAgIGpzVGV4dE47XG5cbiAgICAgICAgICAgIGlmIChvYmogJiYgb2JqLmhhc093blByb3BlcnR5KCdwbGFjZWhvbGRlcicpKSB7XG4gICAgICAgICAgICAgICAgYXJlYS5zZXRBdHRyaWJ1dGUoJ3BsYWNlaG9sZGVyJywgb2JqLnBsYWNlaG9sZGVyKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgZnVuY3Rpb24gY2xvc2UoKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd0ZXh0RWRpdG9yLWhpZGUnKTtcbiAgICAgICAgICAgICAgICBvcGVuID0gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGVkaXQoKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFvcGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIGpzVGV4dE4gPSBub2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy10ZXh0Jyk7XG4gICAgICAgICAgICAgICAgICAgIG9wZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBhcmVhLnZhbHVlID0ganNUZXh0Ti5pbm5lckhUTUw7XG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKCd0ZXh0RWRpdG9yLWhpZGUnKVxuICAgICAgICAgICAgICAgICAgICB9LCAxMDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gc2V0IGNsYXNzZXNcbiAgICAgICAgICAgIGNhbmNlbEJ1dHRvbi5jbGFzc05hbWUgPSAndGV4dEVkaXRvci1idXR0b24gdGV4dEVkaXRvci1idXR0b24tY2FuY2VsIG9jdGljb24gb2N0aWNvbi14JztcbiAgICAgICAgICAgIGJ1dHRvbi5jbGFzc05hbWUgPSAndGV4dEVkaXRvci1idXR0b24gdGV4dEVkaXRvci1idXR0b24tY2hhbmdlIG9jdGljb24gb2N0aWNvbi1jaGVjayc7XG4gICAgICAgICAgICBhcmVhLmNsYXNzTmFtZSA9ICd0ZXh0RWRpdG9yLWFyZWEnO1xuICAgICAgICAgICAgZGl2V3JhcHBlci5jbGFzc05hbWUgPSAndGV4dEVkaXRvci13cmFwLWFyZWEnO1xuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd0ZXh0RWRpdG9yLWhpZGUnKTtcblxuICAgICAgICAgICAgLy8gcmVnaXN0ZXIgbGlzdGVuZXJzXG4gICAgICAgICAgICBjYW5jZWxCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBjbG9zZSk7XG4gICAgICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHZhbCA9IGFyZWEudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGlkID0gZmluZENsb3Nlc3RBbmNlc3RvcldpdGhJZCh0aGlzKS5pZCxcbiAgICAgICAgICAgICAgICAgICAgcmV0ID0gY2FsbENoYW5nZUxpc3QoaWQsIHZhbCwgZnVuY3Rpb24gKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAganNUZXh0Ti5pbm5lckhUTUwgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCd0ZXh0RWRpdG9yOnRvVGV4dGFyZWFOb2RlIHRleHQgbm90IGFjY2VwdGVkISBJZ25vcmUgY2hhbmdlcy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZGJsY2xpY2snLCBlZGl0KTtcblxuICAgICAgICAgICAgLy8gc2V0IHRpdGxlc1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdGV4dHMub3JpZ2luVGV4dCk7XG4gICAgICAgICAgICBjYW5jZWxCdXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsIHRleHRzLmNhbmNlbEJ0bik7XG4gICAgICAgICAgICBidXR0b24uc2V0QXR0cmlidXRlKCd0aXRsZScsIHRleHRzLmNoYW5nZUJ0bik7XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0byB3cmFwcGVyIGRpdlxuICAgICAgICAgICAgZGl2V3JhcHBlci5hcHBlbmRDaGlsZChhcmVhKTtcbiAgICAgICAgICAgIGJ1dHRvbldyYXAuYXBwZW5kQ2hpbGQoY2FuY2VsQnV0dG9uKTtcbiAgICAgICAgICAgIGJ1dHRvbldyYXAuYXBwZW5kQ2hpbGQoYnV0dG9uKTtcblxuICAgICAgICAgICAgLy8gYXBwZW5kIHRvIHBhcmVudFxuICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChkaXZXcmFwcGVyKTtcblxuICAgICAgICAgICAgLy8gcmV0dXJuIGNsaWNrIGZ1bmN0aW9uXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmICghb3BlbikgeyAvLyBzaG93IGlucHV0XG4gICAgICAgICAgICAgICAgICAgIGVkaXQoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgeyAvLyBzaG93IHRleHRcbiAgICAgICAgICAgICAgICAgICAgY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZWdpc3RlciBhIGZ1bmN0aW9uIHRvIGEgc3BlY2lmaWMgZWRpdG9yLlxuICAgICAgICAgICAgICogSWYgdGhlIGZ1bmN0aW9uIHJldHVybnMgdW5kZWZpbmVkIHRoYW4gdGhlIGVkaXRvciBleHBlY3QgdGhhdCB0aGUgcGFzc2VkIGNhbGxiYWNrXG4gICAgICAgICAgICAgKiBpcyBjYWxsZWQgd2l0aCB0cnVlIG9yIGZhbHNlLiBJZiB0aGUgbWV0aG9kIHJldHVybnMgdHJ1ZSB0aGUgdGV4dCB3aWxsIGNoYW5nZS5cbiAgICAgICAgICAgICAqIElmIHRoZSBtZXRob2QgcmV0dXJucyBmYWxzZSB0aGUgdGV4dCBpcyBub3QgY2hhbmdlZC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gaWRcbiAgICAgICAgICAgICAqIEBwYXJhbSBmYyA8LSBpcyBjYWxsZWQgd2l0aCAodGV4dFZhbHVlLCBjYWxsYmFja0Z1bmN0aW9uKSBjYW4gcmV0dXJuIHVuZGVmaW5lZCwgZmFsc2UgYW5kIHRydWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25DaGFuZ2UgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICBvbkNoYW5nZUFsbExpc3QucHVzaChmYyk7XG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGlkXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBvYmopIHtcbiAgICAgICAgICAgICAgICB2YXIgYnV0dG9uV3JhcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICAgICAgICAgICAgICBlZGl0SWNvbkJ1dHRvbiA9ICBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICBidXR0b25XcmFwLmNsYXNzTmFtZSA9J3RleHRFZGl0b3ItYnV0dG9uV3JhcCc7XG4gICAgICAgICAgICAgICAgZWRpdEljb25CdXR0b24uY2xhc3NOYW1lID0gJ3RleHRFZGl0b3ItYnV0dG9uIHRleHRFZGl0b3ItYnV0dG9uLWVkaXQgb2N0aWNvbiBvY3RpY29uLXBlbmNpbCc7XG4gICAgICAgICAgICAgICAgZWRpdEljb25CdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBlZGl0V2l0aFRleHRhcmVhKG5vZGUsIGJ1dHRvbldyYXAsIG9iaikpO1xuICAgICAgICAgICAgICAgIGVkaXRJY29uQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0ZXh0cy5lZGl0QnRuKTtcbiAgICAgICAgICAgICAgICAvLyBhcHBlbmQgZWRpdEljb25CdXR0b24gdG8gcGFyZW50XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCd0ZXh0RWRpdG9yLW1haW4td3JhcCcpO1xuICAgICAgICAgICAgICAgIGJ1dHRvbldyYXAuYXBwZW5kQ2hpbGQoZWRpdEljb25CdXR0b24pO1xuICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoYnV0dG9uV3JhcCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KCkpO1xuXG4gICAgLy8gZXhwb3J0IGFzIG1vZHVsZSBvciBiaW5kIHRvIGdsb2JhbFxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoJ2V4cG9ydHMnKSkgeyBtb2R1bGUuZXhwb3J0cyA9IHRleHRFZGl0b3I7IH0gZWxzZSB7Y2FubnkuYWRkKCd0ZXh0RWRpdG9yJywgdGV4dEVkaXRvcik7IH1cblxufSgpKTsiLCIvKmpzbGludCBicm93c2VyOiB0cnVlICovXG4vKipcbiAqIGhhbmRsZSB0aGUgY29ubmVjdGlvbiBiZXR3ZWVuIHNlcnZlciBhbmQgY2xpZW50XG4gKi9cbmNvbnN0IGNhbm55ID0gcmVxdWlyZSgnY2FubnknKVxuY29uc3QgZXZlbnRzID0gcmVxdWlyZSgnLi9ldmVudHMuanMnKVxuY29uc3Qgc2hvZSA9IHJlcXVpcmUoJ3Nob2UnKVxuY29uc3QgZG5vZGUgPSByZXF1aXJlKCdkbm9kZScpXG5jb25zdCBjb25uZWN0aW9uTG9zdCA9IHJlcXVpcmUoJy4vdWlNb2R1bGVzL2Nvbm5lY3Rpb25Mb3N0L2luZGV4LmpzJylcblxud2luZG93LmRvbU9wdHMgPSB3aW5kb3cuZG9tT3B0cyB8fCByZXF1aXJlKCdkb20tb3B0cycpO1xuXG4vKipcbiAqIFNvbWUgb2YgdGhlIGNhbGxiYWNrcyBhcmUgaGFuZGxlZCB2aWEgdGhlIHJlZ2lzdGVyZWQgY29udHJvbGxlciAtIGFkZENvbnRyb2xsZXIgbWV0aG9kLlxuICovXG52YXIgdHJhZGUgPSAoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIC8vIHJlYWR5IHF1ZXVlIGNhbGwgcmVnaXN0ZXJlZCBjYWxsIGJhY2tzIHdoZW4gdHJhZGUgaXMgcmVhZHlcbiAgICB2YXIgY2JzID0gW10sXG4gICAgICAgIHNlcnZlcixcbiAgICAgICAgcmVnaXN0ZXJlZENvbnRyb2xsZXIgPSBbXSxcbiAgICAgICAgLy8gdGhpcyBmbGFnIHNob3VsZCBiZSB0cnVlIGlmIHRoZXJlIGlzIGEgc3RhYmxlIHNlcnZlciBjb25uZWN0aW9uXG4gICAgICAgIGhhc1NlcnZlckNvbm5lY3Rpb24gPSBmYWxzZSxcbiAgICAgICAgdHJ5VG9SZWNvbm5lY3QgPSBmYWxzZSxcbiAgICAgICAgY29ubmVjdGlvbkxvc3RVaSA9IGNvbm5lY3Rpb25Mb3N0KHtcbiAgICAgICAgICAgIG9uUmVsb2FkIDogKCkgPT4gbG9jYXRpb24ucmVsb2FkKCksXG4gICAgICAgICAgICBvblJlY29ubmVjdCA6ICgpID0+IHtcbiAgICAgICAgICAgICAgICB0cnlUb1JlY29ubmVjdCA9IHRydWVcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTG9zdFVpLnNob3dQcm9ncmVzcygpXG4gICAgICAgICAgICAgICAgc3RyZWFtID0gc2hvZSgnL3RyYWRlJylcbiAgICAgICAgICAgICAgICBjcmVhdGVDb25uZWN0aW9uKCh1c2VyT2JqZWN0LCBzZXNzaW9uc0VuYWJsZWQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHVzZXJPYmplY3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgaXMgdGhlIGNhc2Ugd2hlbiB0aGUgc2Vzc2lvbiBlbmRzIG9uIHNlcnZlciBzaWRlXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTG9zdFVpLnJlbmRlcignUkVDT05ORUNUX0ZBSUwnKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5kZXN0cm95KClcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeVRvUmVjb25uZWN0ID0gZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25DbG9zZSA6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uTG9zdFVpLmRlc3Ryb3koKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuICAgIGxldCBzdHJlYW0gPSBzaG9lKCcvdHJhZGUnKVxuICAgIGxldCBkXG5cbiAgICBmdW5jdGlvbiBpbml0KHMsIGZjKSB7XG4gICAgICAgIHNlcnZlciA9IHM7XG5cbiAgICAgICAgaWYgKHNlcnZlci5zZXRVc2VyUmlnaHRzKSB7XG4gICAgICAgICAgICBzZXJ2ZXIuc2V0VXNlclJpZ2h0cyhjYW5ueS5jb29raWVNYW5hZ2VyLmZvclNlc3Npb25Db29raWUoJ3RyYW5zbGF0cm9uX3Nlc3Npb24nKS5nZXRWYWx1ZXMoKSwgZmMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZmMoe25hbWU6J0xvZ291dCcsIGlzQWRtaW46IHRydWV9LCBmYWxzZSk7XG4gICAgICAgIH1cblxuICAgICAgICBzZXJ2ZXIuYXR0YWNoQ2xpZW50Q2FsbGJhY2tzKGV2ZW50cy5zZXJ2ZXJFdmVudHMpO1xuICAgICAgICAvLyBjYWxsIHJlYWR5IHF1ZXVlXG4gICAgICAgIGNicy5tYXAoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNyZWF0ZUNvbm5lY3Rpb24oZmMpIHtcbiAgICAgICAgZCA9IGRub2RlKClcbiAgICAgICAgZC5vbigncmVtb3RlJywgZnVuY3Rpb24gKHNlcnZlcikge1xuICAgICAgICAgICAgaGFzU2VydmVyQ29ubmVjdGlvbiA9IHRydWVcbiAgICAgICAgICAgIGluaXQoc2VydmVyLCBmYyk7XG4gICAgICAgIH0pXG4gICAgICAgIGQub24oJ2ZhaWwnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpXG4gICAgICAgICAgICBoYXNTZXJ2ZXJDb25uZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdDT05ORUNUSU9OX0ZBSUwnKVxuICAgICAgICB9KVxuICAgICAgICBkLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGVycilcbiAgICAgICAgICAgIC8vIHNvbWV0aGluZyBoYXBwZW5zXG4gICAgICAgICAgICAvLyBlLmcuIGEgVUkgdXBkYXRlIHRocm93cyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIGhhc1NlcnZlckNvbm5lY3Rpb24gPSBmYWxzZVxuICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ0VYQ0VQVElPTicsIGVyci5uYW1lKVxuICAgICAgICB9KVxuICAgICAgICBkLm9uKCdlbmQnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAvLyB0aGlzIGlzIGNhbGxlZCBpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zZXMgZnJvbSBzZXJ2ZXJcbiAgICAgICAgICAgIGhhc1NlcnZlckNvbm5lY3Rpb24gPSBmYWxzZVxuICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhZGU6ZW5kJywgZXJyKTtcbiAgICAgICAgICAgIC8vIHRoZSBzZXRUaW1lb3V0IGlzIGZvciBhdm9pZCBmbGlja2VyaW5nIGlmIHBhZ2UgcmVsb2FkIHZpYSBlLmcuIEY1XG4gICAgICAgICAgICBpZiAodHJ5VG9SZWNvbm5lY3QpXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ1JFQ09OTkVDVF9GQUlMJylcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdDT05ORUNUSU9OX0VORCcpLCAxMDAwKVxuICAgICAgICB9KVxuICAgICAgICBkLnBpcGUoc3RyZWFtKS5waXBlKGQpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayBpZiBjb25uZWN0aW9uIGlzIGF2YWlsYWJsZSAtIG90aGVyd2lzZSBzZW5kIHZpZXcgZXJyb3JcbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Nvbm5lY3RlZCgpIHtcbiAgICAgICAgaWYgKGhhc1NlcnZlckNvbm5lY3Rpb24pXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICBjb25uZWN0aW9uTG9zdFVpLnJlbmRlcignUkVDT05ORUNUJylcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZnVuY3Rpb25OYW1lIHRoZSBmdW5jdGlvbiB0byBjYWxsXG4gICAgICogQHBhcmFtIGFyZ3MgYW4gYXJyYXkgb2YgcGFyYW1ldGVycyB3aGljaCBhcmUgcGFzc2VkIHRvIHRoZSBmdW5jdGlvblxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhbGxDb250cm9sbGVyKGZ1bmN0aW9uTmFtZSwgYXJncykge1xuICAgICAgICByZWdpc3RlcmVkQ29udHJvbGxlci5mb3JFYWNoKGZ1bmN0aW9uIChjb250cm9sbGVyKSB7XG4gICAgICAgICAgICBpZiAoY29udHJvbGxlci5oYXNPd25Qcm9wZXJ0eShmdW5jdGlvbk5hbWUpKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2NvbnRyb2xsZXI6JywgZnVuY3Rpb25OYW1lKVxuICAgICAgICAgICAgICAgICAgICBjb250cm9sbGVyW2Z1bmN0aW9uTmFtZV0uYXBwbHkobnVsbCwgYXJncylcbiAgICAgICAgICAgICAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ0ZBVEFMJywgZS5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgaW5pdGlhbGl6ZSA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgY3JlYXRlQ29ubmVjdGlvbihmYylcbiAgICAgICAgfSxcbiAgICAgICAgYWRkQ29udHJvbGxlciA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIHJlZ2lzdGVyZWRDb250cm9sbGVyLnB1c2gob2JqKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIExvYWQgdGhlIHdob2xlIHByb2plY3QgZmlsZXMgd2l0aCBhbGwgcmVxdWlyZWQgZGF0YSAocHJvamVjdCBzcGVjaWZpYyBqc29uKVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXG4gICAgICAgICAqL1xuICAgICAgICBsb2FkUHJvamVjdCA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIGNiKSB7XG4gICAgICAgICAgICBzZXJ2ZXIubG9hZFByb2plY3QocHJvamVjdElkLCBmdW5jdGlvbiAoZGF0YSwge2lkLCBuYW1lLCB1cmx9KSB7XG4gICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gb3ZlcndyaXRlIHByb2plY3QgaWRcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcm9qZWN0SWQgPSBpZFxuICAgICAgICAgICAgICAgICAgICBkYXRhLnByb2plY3QgPSBuYW1lXG4gICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdvbkxvYWRQcm9qZWN0JywgW2RhdGEsIHtpZCwgbmFtZSwgdXJsfV0pO1xuICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYihudWxsLCBkYXRhLCB7aWQsIG5hbWUsIHVybH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNhbGxiYWNrIGEgZXJyb3Igc28gdGhlIGNhbGxlciBoYXMgdGhlIGNvbnRyb2wgYWJvdXQgZXJyb3IgaGFuZGxpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZWZhY3RvciBjb2RlIGFuZCBtYWtlIHVzZSBvZiBlcnJvciBvYmplY3QgaW5zdGVhZCBvZiBmYWxzZSAtIGFuZCBwYXNzIGVtcHR5IG9iamVjdCB0byBvdGhlciBhcmdzIGluc3RlYWQgb2Ygbm90aGluZ1xuICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYihmYWxzZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGFjdHVhbGx5IHNhbWUgYXMgc2F2ZUtleSBidXQgdGhlIGludGVybmFsIGNvbnRyb2xsZXIgY2FsbCBpcyBkaWZmZXJlbnRcbiAgICAgICAgICogQHBhcmFtIHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0gbGFuZ3VhZ2VcbiAgICAgICAgICogQHBhcmFtIGtleUFuZFZhbHVlXG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlS2V5IDogZnVuY3Rpb24gKHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleUFuZFZhbHVlLCBjYikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLnNhdmVLZXkocHJvamVjdElkLCBsYW5ndWFnZSwga2V5QW5kVmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVyciwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgZXJyb3IgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYihwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignb25DcmVhdGVLZXknLCBbcHJvamVjdElkLCBsYW5ndWFnZSwga2V5LCB2YWx1ZV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge3tpZCA6c3RyaW5nLCBzb3VyY2VDYXRlZ29yeTpzdHJpbmcsIHRhcmdldENhdGVnb3J5OnN0cmluZ319IGtleUFuZFZhbHVlXG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgY2xvbmVLZXk6IGZ1bmN0aW9uKHByb2plY3RJZCwga2V5QW5kVmFsdWUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuY2xvbmVLZXkocHJvamVjdElkLCBrZXlBbmRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyLCBwcm9qZWN0SWQsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiKGVyciwgcHJvamVjdElkLCBkYXRhKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ29uS2V5Q2xvbmVkJywgW3Byb2plY3RJZCwgZGF0YV0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTYXZlIGNoYW5nZXMgdG8gYSBrZXkncyB2YWx1ZS4gQ2hhbmdlIHdpbGwgYmUgYnJvYWRjYXN0IHRvIG90aGVyIGNsaWVudHMuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGxhbmd1YWdlXG4gICAgICAgICAqIEBwYXJhbSB7e2tleTpzdHJpbmcsIHZhbHVlOnN0cmluZ319IGtleUFuZFZhbHVlXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiIC0gY2FsbGJhY2sgdG8gZXhlY3V0ZSBhZnRlciBzYXZpbmdcbiAgICAgICAgICovXG4gICAgICAgIHNhdmVLZXkgOiBmdW5jdGlvbiAocHJvamVjdElkLCBsYW5ndWFnZSwga2V5QW5kVmFsdWUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuc2F2ZUtleShwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXlBbmRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvciBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleSwgdmFsdWUpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdE5hbWVcbiAgICAgICAgICogQHBhcmFtIGN1cnJlbnREaXJJZCBpZiBvZiB0aGUgZGlyZWN0b3J5IGluIHdoaWNoIHRoZSBuZXcgcHJvamVjdCB3aWxsIGJlIGNyZWF0ZWRcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZU5ld1Byb2plY3QgOiBmdW5jdGlvbiAocHJvamVjdE5hbWUsIGN1cnJlbnREaXJJZCkge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLmNyZWF0ZU5ld1Byb2plY3QoY3VycmVudERpcklkLCBwcm9qZWN0TmFtZSwge30sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVyciwgcHJvamVjdERhdGEsIHByb2plY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGVycm9yIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ29uTmV3UHJvamVjdENyZWF0ZWQnLCBbcHJvamVjdERhdGEsIHByb2plY3RdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGRpcmVjdG9yeU5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGN1cnJlbnREaXJlY3RvcnlcbiAgICAgICAgICovXG4gICAgICAgIGNyZWF0ZU5ld0RpcmVjdG9yeSA6IGZ1bmN0aW9uKGRpcmVjdG9yeU5hbWUsIGN1cnJlbnREaXJlY3RvcnkpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5jcmVhdGVOZXdEaXJlY3RvcnkoZGlyZWN0b3J5TmFtZSwgY3VycmVudERpcmVjdG9yeSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyLCBkaXJlY3RvcnlEYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvciBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdvbk5ld0RpcmVjdG9yeUNyZWF0ZWQnLCBbZGlyZWN0b3J5RGF0YV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5hbWVzIGEgY2F0ZWdvcnkuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG9sZE5hbWVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5ld05hbWVcbiAgICAgICAgICovXG4gICAgICAgIHJlbmFtZUNhdGVnb3J5IDogZnVuY3Rpb24gKHByb2plY3RJZCwgb2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLnJlbmFtZUNhdGVnb3J5KHByb2plY3RJZCwgb2xkTmFtZSwgbmV3TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgb2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcigncmVuYW1lQ2F0ZWdvcnknLCBbb2xkTmFtZSwgbmV3TmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEgY2F0ZWdvcnkgd2l0aCBhbGwgaXQncyBjaGlsZCBrZXlzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBjYXROYW1lXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVDYXRlZ29yeSA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIGNhdE5hbWUpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5yZW1vdmVDYXRlZ29yeShwcm9qZWN0SWQsIGNhdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIGNhdE5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ3JlbW92ZUNhdGVnb3J5JywgW2NhdE5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVuYW1lcyBhIGtleSBmb3IgYWxsIGxhbmd1YWdlc1xuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSB7e25ld0tleTogc3RyaW5nLCBvbGRLZXk6IHN0cmluZ319IG9ialxuICAgICAgICAgKi9cbiAgICAgICAgcmVuYW1lS2V5IDogZnVuY3Rpb24gKHByb2plY3RJZCwgb2JqKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIucmVuYW1lS2V5KHByb2plY3RJZCwge1xuICAgICAgICAgICAgICAgICAgICBuZXdLZXkgOiBvYmoubmV3S2V5LFxuICAgICAgICAgICAgICAgICAgICBvbGRLZXkgOiBvYmoub2xkS2V5XG4gICAgICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVyciwgb2xkS2V5LCBuZXdLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdyZW5hbWVLZXknLCBbb2xkS2V5LCBuZXdLZXldKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ3JlbmFtZUtleScsIFtmYWxzZV0pXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVtb3ZlcyBhIGtleSBmb3IgYWxsIGxhbmd1YWdlcy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5TmFtZVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlS2V5IDogZnVuY3Rpb24gKHByb2plY3RJZCwga2V5TmFtZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5yZW1vdmVLZXkocHJvamVjdElkLCBrZXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCBrZXlOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKGtleU5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ3JlbW92ZUtleScsIFtrZXlOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdGVnb3J5TmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVtb3ZlSW1hZ2UgOiBmdW5jdGlvbihwcm9qZWN0SWQsIGNhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLnJlbW92ZUltYWdlKHByb2plY3RJZCwgY2F0ZWdvcnlOYW1lLCBmdW5jdGlvbiAoZXJyLCBjYXRlZ29yeU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdpbWFnZVJlbW92ZWQnLCBbY2F0ZWdvcnlOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEdldCB0aGUgY29udGVudHMgb2YgdGhlIGRpcmVjdG9yeS5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIGRpciB0aGUgc2VsZWN0ZWQgZGlyZWN0b3J5LlxuICAgICAgICAgKiBAcGFyYW0gY2Ige3Byb2plY3RzOltTdHJpbmddOmRpcnM6W1N0cmluZ119XG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXJlY3RvcnkgOiBmdW5jdGlvbiAoZGlyLCBjYikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLmdldERpcmVjdG9yeShkaXIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIGFyZ3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSgnSW50ZXJuYWwgc2VydmVyIGVycm9yISBQbGVhc2UgcmVwb3J0IHRoaXMgbWVzc2FnZSB0byBhIGRldmVsb3BlcjogJyArIGVyci5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBvbmx5IGNhbGwgdGhlIGNvbnRyb2xsZXIgaWYgbm90IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYihhcmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFyZ3MgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ2dldERpcmVjdG9yeScsIFthcmdzXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIHNhdmUgdGhlIHByb2plY3QgZGVzY3JpcHRpb25cbiAgICAgICAgICogQHBhcmFtIHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0gaWRcbiAgICAgICAgICogQHBhcmFtIGRlc2NyaXB0aW9uXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgc2F2ZVByb2plY3REZXNjcmlwdGlvbiA6IGZ1bmN0aW9uKHByb2plY3RJZCwgaWQsIGRlc2NyaXB0aW9uLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLnNhdmVQcm9qZWN0RGVzY3JpcHRpb24ocHJvamVjdElkLCBpZCwgZGVzY3JpcHRpb24sXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayh0cnVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdzYXZlZFByb2plY3REZXNjcmlwdGlvbicsIFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhmYWxzZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1vdmUgYSBwcm9qZWN0LiBDYW4gYmUgdXNlZCBmb3I6XG4gICAgICAgICAqICAqIG1vdmUgcHJvamVjdFxuICAgICAgICAgKiAgKiByZW5hbWUgcHJvamVjdFxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gaWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHVybCAtIHRoZSBuZXcgVVJMIChvcHRpb25hbClcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSB0aGUgbmV3IG5hbWUgKG9wdGlvbmFsKVxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYiAtIGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkXG4gICAgICAgICAqL1xuICAgICAgICBtb3ZlUHJvamVjdCA6IGZ1bmN0aW9uICh7aWQsIHVybCwgbmFtZX0sIGNiKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHNlcnZlci5tb3ZlUHJvamVjdCh7aWQsIHVybCwgbmFtZX0sIChlcnIsIHByb2plY3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBwcm9qZWN0IHx8IHt9KVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUT0RPIHN1bW1hcml6ZSBwcm9qZWN0TmFtZSArIGN1cnJlbnREaXJJZCB0byBvbmUgcHJvamVjdElkXG4gICAgICAgICAqIERlbGV0ZSBhIHByb2plY3QuXG4gICAgICAgICAqIEBwYXJhbSBwcm9qZWN0TmFtZVxuICAgICAgICAgKiBAcGFyYW0gY3VycmVudERpcklkIC0gQGRlcHJlY2F0ZWRcbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICBkZWxldGVQcm9qZWN0IDogZnVuY3Rpb24gKGlkLCBjYikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpIHtcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuZGVsZXRlUHJvamVjdChpZCxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgcHJvamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNoYW5nZSB0bzogcHJqTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiICYmIGNiKG51bGwsIHByb2plY3QpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ3Byb2plY3REZWxldGVkJywgW3Byb2plY3RdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYihlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBEZWxldGUgYSBwcm9qZWN0LlxuICAgICAgICAgKiBAcGFyYW0gZGlyTmFtZVxuICAgICAgICAgKiBAcGFyYW0gY3VycmVudERpcklkXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlRm9sZGVyIDogZnVuY3Rpb24gKGRpck5hbWUsIGN1cnJlbnREaXJJZCwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5kZWxldGVGb2xkZXIoY3VycmVudERpcklkLCBkaXJOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCBkaXJOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKG51bGwsIGRpck5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ2ZvbGRlckRlbGV0ZWQnLCBbZGlyTmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGVycilcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLy8gTm90IHJlYWxseSB0ZXN0ZWRcbiAgICAgICAgcmVhZHkgOiBmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgIGlmIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjYnMucHVzaChjYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0cmFkZTsiLCJ2YXIgdWlFdmVudCA9IChmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGV2ZW50UXVldWVzID0ge1xuICAgICAgICAgICAgYWN0aXZhdGVMYW5ndWFnZSA6IFtdLFxuICAgICAgICAgICAgZGVBY3RpdmF0ZUxhbmd1YWdlIDogW10sXG4gICAgICAgICAgICBhZGRMYW5ndWFnZTogW10sXG4gICAgICAgICAgICBzaG93RXhwb3J0RGlhbG9nOiBbXSxcbiAgICAgICAgICAgIHByb2plY3RTZWxlY3RlZDogW10sXG4gICAgICAgICAgICBzaG93T3ZlcnZpZXdQYWdlOiBbXSxcbiAgICAgICAgICAgIHVwZGF0ZUtleTogW10sXG4gICAgICAgICAgICBhbmNob3JGb2N1czogW10sXG4gICAgICAgICAgICBlbmFibGVFZGl0b3JNb2RlOiBbXSxcbiAgICAgICAgICAgIHRvZ2dsZVdvcmRDb3VudDogW10sXG4gICAgICAgICAgICBzaG93RmlsZVVwbG9hZDogW10sXG4gICAgICAgICAgICBzaG93Sk1CRlVwbG9hZGVyOiBbXSxcbiAgICAgICAgICAgIHNob3dKU09OSW1wb3J0OiBbXSxcbiAgICAgICAgICAgIEpNQkZGaWxlVXBsb2FkZWQ6IFtdLFxuICAgICAgICAgICAganNvbkltcG9ydGVkOiBbXSxcbiAgICAgICAgICAgIGZpbGVVcGxvYWRlZDogW11cbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIGFkZFVpRXZlbnRMaXN0ZW5lciA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKG9iaikuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50UXVldWVzLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnRRdWV1ZXNba2V5XS5wdXNoKG9ialtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgY2FsbFVpZXZlbnQgOiBmdW5jdGlvbiAoZXZlbnROYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICB2YXIgYXJnc0xpc3QgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSwgYXJndW1lbnRzLmxlbmd0aCk7XG4gICAgICAgICAgICBpZiAoZXZlbnRRdWV1ZXMuaGFzT3duUHJvcGVydHkoZXZlbnROYW1lKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50UXVldWVzW2V2ZW50TmFtZV0uZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICBmYy5hcHBseShudWxsLCBhcmdzTGlzdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHVpRXZlbnQ7XG4iLCIvKipcbiAqIHNob3dzIHRoZSB1cGxvYWRlciBmb3JtIHRvIHVwbG9hZCBhIGltYWdlIHRvIHRoZSBzZXJ2ZXJcbiAqL1xudmFyIG9uVXBsb2FkID0gZnVuY3Rpb24gKCkge30sXG4gICAgYnJhaW4gPSB7XG4gICAgICAgIGZpbGVJbnB1dCA6IHtcbiAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCB1cGxvYWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcblxuZnVuY3Rpb24gdXBsb2FkKCkge1xuICAgIGNvbnNvbGUubG9nKCdjLXVwbG9hZDp0cmlnZ2VyIHVwbG9hZCcpO1xuICAgIHZhciBmaWxlID0gdGhpcy5maWxlc1swXTtcbiAgICBpZiAoZmlsZSkge1xuICAgICAgICAvLyBzZW5kIGl0IGRpcmVjdCBhZnRlciBkcm9wXG4gICAgICAgIFtdLnNsaWNlLmNhbGwodGhpcy5maWxlcykuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xuICAgICAgICAgICAgLy8gVE9ETyBpbnN0ZWFkIHBhc3MgIGRpcmVjdGx5IGEgYXJyYXkgb2YgZmlsZXMgLSBzbyB3ZSBzYXZlIFBPU1QgY2FsbHNcbiAgICAgICAgICAgIG9uVXBsb2FkKGZpbGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gY2xlYW51cCB2YWx1ZSBvdGhlcndpc2UgZmlsZSB3aXRoIHNhbWUgbmFtZSBjYW4ndCB1cGxvYWRlZCBhZ2FpblxuICAgICAgICB0aGlzLnZhbHVlID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEByZXR1cm5zIHt7YWRkOiBGdW5jdGlvbiwgcmVhZHk6IEZ1bmN0aW9ufX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25VcGxvYWQgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25VcGxvYWQgPSBmYztcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgIGlmIChicmFpbi5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgYnJhaW5bYXR0cl0uaW5pdChub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwiLyoqXG4gKiBzaG93cyB0aGUgdXBsb2FkZXIgZm9ybSB0byB1cGxvYWQgYSBpbWFnZSB0byB0aGUgc2VydmVyXG4gKi9cbnZhciBvblVwbG9hZCA9IGZ1bmN0aW9uICgpIHt9LFxuICAgIGJyYWluID0ge1xuICAgICAgICBmaWxlSW5wdXQgOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbmZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbMF07XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgICAgLy8gc2VuZCBpdCBkaXJlY3QgYWZ0ZXIgZHJvcFxuICAgICAgICBbXS5zbGljZS5jYWxsKHRoaXMuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gaW5zdGVhZCBwYXNzICBkaXJlY3RseSBhIGFycmF5IG9mIGZpbGVzIC0gc28gd2Ugc2F2ZSBQT1NUIGNhbGxzXG4gICAgICAgICAgICBvblVwbG9hZChmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNsZWFudXAgdmFsdWUgb3RoZXJ3aXNlIGZpbGUgd2l0aCBzYW1lIG5hbWUgY2FuJ3QgdXBsb2FkZWQgYWdhaW5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7e2FkZDogRnVuY3Rpb24sIHJlYWR5OiBGdW5jdGlvbn19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uVXBsb2FkIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIG9uVXBsb2FkID0gZmM7XG4gICAgfSxcbiAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICBpZiAoYnJhaW4uaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgIGJyYWluW2F0dHJdLmluaXQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59OyIsIi8qKlxuICogYW5jaG9yTWVudVxuICpcbiAqIFRPRE8gc2hvdyB0aGUgYWN0dWFsIGZyYW1lOlxuICogICogZGV0ZWN0IHdoaWNoIGRvbWUgY2F0ZWdvcmllcyBpbiBkb20gYXJlIGluIHZpZXcgYW5kIGFkZCBhIGNsYXNzZXMgdG8gdGhlIG1lbnUgdWwgY2F0ZWdvcnkuXG4gKiAgICAgICogdGhlIGV4cGVjdGVkIGVmZmVjdCB3aWxsIGJlIGxvb2sgbGlrZSBhIGZyYW1lIHdoaWNoIGNhdGVnb3JpZXMgYXJlIGluIHZpZXdcbiAqICAgICAgKiBmaXJzdC1jaGlsZCBib3JkZXItdG9wIGxhc3QtY2hpbGQgYm9yZGVyIGJvdHRvbSBhbmQgdGhlIHJlc3QgYm9yZGVyIGxlZnQgYW5kIHJpZ2h0IHdpbGwgZ2l2ZSBhIGZyYW1lIGVmZmVjdFxuICpcbiAqICBkbyBpdCBmb3IgYWxsIGMtYW5jaG9yTWVudS1wYXJlbnQgZWxlbWVudCB3aGljaCBjb3VsZCBiZSBmb3VuZCBpbiB2aWV3XG4gKlxuICogVGhlIGFuY2hvciBtZW51IHNob3dzIGFsbCBlbGVtZW50cyB3aGljaCBoYXZlIHRoZSBjbGFzcyBjLWFuY2hvck1lbnUtcGFyZW50IGFzIHBhcmVudCBhbmQgc2VhcmNoZXMgZm9yIGNoaWxkcmVuXG4gKiB3aXRoIGNsYXNzIGMtYW5jaG9yTWVudS1jaGlsZC4gSXQgcmVuZGVycyBhIHVsIGxpIGxpc3QgYW5kIHJlZ2lzdGVyZWQgYSBjbGljayBjYWxsIHRvIHRocm93IGEgY2xpY2sgZXZlbnQgd2l0aCB0aGUgaWQuXG4gKlxuICogQHR5cGUge2V4cG9ydHN9XG4gKi9cbnZhciB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbC91cmwnKSxcbiAgICB0cmFuc2xhdGlvblZpZXdDb25maWcgPSByZXF1aXJlKCcuL3RyYW5zbGF0aW9uVmlldycpLmNvbmZpZyxcbiAgICByb290Tm9kZSxcbiAgICBwYXJlbnROb2RlTGlzdCA9IFtdLFxuICAgIG9uU2VsZWN0ID0gZnVuY3Rpb24gKCkge30sXG4gICAgc2hyaW5rT2Zmc2V0Rm9yVmlld0RldGVjdGlvbiA9IDEwMCxcbiAgICBoaWdobGlnaHRUb3BNb3N0S2V5ID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgIHZhciBoaWdobGlnaHRlZEl0ZW07XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIGNoZWNrIGlmIG5vZGUgaXMgYWxpZ25lZCB0b3AgbW9zdCBpbiB0aGUgYnJvd3NlciB2aWV3XG4gICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICovXG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIGZpcnN0T3BlbkNhdGVnb3J5ID0gcm9vdE5vZGUucXVlcnlTZWxlY3RvcignbGkuYy1pblZpZXcnKSxcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFpblZpZXdDYXRlZ29yeU5vZGUsXG4gICAgICAgICAgICAgICAgY3VycmVudE1haW5WaWV3Q2F0ZWdvcnlDaGlsZE5vZGVzLFxuICAgICAgICAgICAgICAgIG1haW5WaWV3VG9wTW9zdEtleU5vZGU7XG5cbiAgICAgICAgICAgIGlmICghZmlyc3RPcGVuQ2F0ZWdvcnkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFJlc2V0IHByZXZpb3VzIGhpZ2hsaWdodGVkIGl0ZW1cbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlZEl0ZW0uY2xhc3NMaXN0LnJlbW92ZSgnYy1rZXktaGlnaGxpZ2h0Jyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIEhpZ2hsaWdodCB0b3Btb3N0IGl0ZW1cbiAgICAgICAgICAgIGN1cnJlbnRNYWluVmlld0NhdGVnb3J5Tm9kZSA9IGRvY3VtZW50LmJvZHkucXVlcnlTZWxlY3RvcignIycgKyB0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4ICsgZmlyc3RPcGVuQ2F0ZWdvcnkuYXR0cmlidXRlcy5kYXRhLm5vZGVWYWx1ZS5yZXBsYWNlKCdhbmNob3JfJywgJycpKTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50TWFpblZpZXdDYXRlZ29yeU5vZGUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TWFpblZpZXdDYXRlZ29yeUNoaWxkTm9kZXMgPSBjdXJyZW50TWFpblZpZXdDYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvckFsbCgnLmMtYW5jaG9yTWVudS1jaGlsZCcpO1xuICAgICAgICAgICAgICAgIG1haW5WaWV3VG9wTW9zdEtleU5vZGUgPSBnZXRGaXJzdEVsZW1lbnRJblZpZXdwb3J0KGN1cnJlbnRNYWluVmlld0NhdGVnb3J5Q2hpbGROb2Rlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FuY2hvck1lbnU6Q2FuXFwndCBmaW5kIHRoZSBjYXRlZ29yeSBub2RlIHdpdGggaWQnLCB0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4ICsgZmlyc3RPcGVuQ2F0ZWdvcnkuYXR0cmlidXRlcy5kYXRhLm5vZGVWYWx1ZS5yZXBsYWNlKCdhbmNob3JfJywgJycpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG1haW5WaWV3VG9wTW9zdEtleU5vZGUpIHtcbiAgICAgICAgICAgICAgICBoaWdobGlnaHRlZEl0ZW0gPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YT1hbmNob3JfJyArIG1haW5WaWV3VG9wTW9zdEtleU5vZGUuaWQucmVwbGFjZSh0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4LCAnJykgKyAnXScpO1xuICAgICAgICAgICAgICAgIGlmIChoaWdobGlnaHRlZEl0ZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWRJdGVtLmNsYXNzTGlzdC5hZGQoJ2Mta2V5LWhpZ2hsaWdodCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pKCk7XG5cbmZ1bmN0aW9uIGZvY3VzRWxlbWVudChpZCwgZWxlbSkge1xuICAgIHZhciBkb207XG4gICAgLy8gaGFuZGxlIHRoZSBhY3RpdmUgY2xhc3MgZnJvbSBtZW51XG4gICAgW10uc2xpY2UuY2FsbChyb290Tm9kZS5xdWVyeVNlbGVjdG9yQWxsKCcuYy1hY3RpdmUnKSkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICBuLmNsYXNzTGlzdC5yZW1vdmUoJ2MtYWN0aXZlJyk7XG4gICAgfSk7XG4gICAgZWxlbS5jbGFzc0xpc3QuYWRkKCdjLWFjdGl2ZScpO1xuICAgIGVsZW0ucGFyZW50Tm9kZS5wYXJlbnROb2RlLmNsYXNzTGlzdC5hZGQoJ2MtYWN0aXZlJyk7XG4gICAgLy8gaGFuZGxlIHRoZSBjb21tb24gZG9tIGFjdGl2ZSBjbGFzc1xuICAgIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmMtYW5jaG9yTWVudS1mb2N1cycpKS5mb3JFYWNoKGZ1bmN0aW9uIChuKSB7XG4gICAgICAgIG4uY2xhc3NMaXN0LnJlbW92ZSgnYy1hbmNob3JNZW51LWZvY3VzJyk7XG4gICAgfSk7XG4gICAgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCArIGlkKTtcbiAgICBpZiAoZG9tKSB7XG4gICAgICAgIGRvbS5jbGFzc0xpc3QuYWRkKCdjLWFuY2hvck1lbnUtZm9jdXMnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zb2xlLmxvZygnYW5jaG9yTWVudTpmb2N1c0VsZW1lbnQgY2FuXFwndCBmaW5kIGVsZW1lbnQgZm9yIGEgYW5jaG9yJywgaWQpO1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBpdGVtcyBbe2lkIDogc3RyaW5nLCBjaGlsZHJlbiA6IFtzdHJpbmddfV1cbiAqL1xuZnVuY3Rpb24gYWRkSXRlbXMocm9vdCwgaXRlbXMpIHtcbiAgICB2YXIgdWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpLFxuICAgICAgICBhbmNob3IgPSB1dGlsLmdldEFuY2hvcigpO1xuICAgIHJvb3QuYXBwZW5kQ2hpbGQodWwpO1xuICAgIGl0ZW1zLmZvckVhY2goZnVuY3Rpb24gKGNhdE9iaikge1xuICAgICAgICB2YXIgbGkgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdsaScpLFxuICAgICAgICAgICAgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgLy8gVE9ETyBjaGVjayB3aXRoIGxvZ1xuICAgICAgICBpZiAodHlwZW9mIGNhdE9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ2FuY2hvck1lbnU6Y2F0ZWdvcnkgbmVlZHMgdG8gYmUgYW4gb2JqZWN0JywgY2F0T2JqKTtcbiAgICAgICAgfVxuICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNhdE9iai5pZCkpO1xuICAgICAgICBsaS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgbGkuc2V0QXR0cmlidXRlKCdkYXRhJywgJ2FuY2hvcl8nICsgY2F0T2JqLmlkKTtcbiAgICAgICAgc3Bhbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIG9uU2VsZWN0KGNhdE9iai5pZCk7XG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQoY2F0T2JqLmlkLCBsaSk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChjYXRPYmouY2hpbGRyZW4pIHtcbiAgICAgICAgICAgIGFkZEl0ZW1zKGxpLCBjYXRPYmouY2hpbGRyZW4pXG4gICAgICAgIH1cbiAgICAgICAgdWwuYXBwZW5kQ2hpbGQobGkpO1xuICAgICAgICBpZiAoJyMnICsgY2F0T2JqLmlkID09PSBhbmNob3IpIHtcbiAgICAgICAgICAgIGZvY3VzRWxlbWVudChjYXRPYmouaWQsIGxpKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIGNoZWNrIGlzIHRoZSBub2RlIGlzIGluIHRoZSB2aWV3XG4gKiBAcGFyYW0gbm9kZVxuICovXG5mdW5jdGlvbiBpc05vZGVJblZpZXcobm9kZSkge1xuICAgIHZhciB5T2Zmc2V0ID0gd2luZG93LnNjcm9sbFkgfHwgd2luZG93LnBhZ2VZT2Zmc2V0LFxuICAgICAgICB3ID0ge1xuICAgICAgICAgICAgdG9wOiB5T2Zmc2V0LFxuICAgICAgICAgICAgYm90dG9tIDogeU9mZnNldCArIHdpbmRvdy5pbm5lckhlaWdodFxuICAgICAgICB9LFxuICAgICAgICBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGVsZW1SZWN0ID0gbm9kZS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgb2Zmc2V0ID0gZWxlbVJlY3QudG9wIC0gYm9keVJlY3QudG9wICsgc2hyaW5rT2Zmc2V0Rm9yVmlld0RldGVjdGlvbixcbiAgICAgICAgbm9kZUhlaWdodCA9IG9mZnNldCArIG5vZGUub2Zmc2V0SGVpZ2h0IC0gKHNocmlua09mZnNldEZvclZpZXdEZXRlY3Rpb24gKiAyKTtcbiAgICByZXR1cm4gb2Zmc2V0ID4gdy50b3AgJiYgb2Zmc2V0IDwgdy5ib3R0b20gfHwgICAgLy8gaXMgdG9wIGZyYW1lIGluIHZpZXdcbiAgICAgICAgbm9kZUhlaWdodCA+IHcudG9wICYmIG5vZGVIZWlnaHQgPCB3LmJvdHRvbSB8fCAgLy8gaXMgYm90dG9tIGZyYW1lIGluIHZpZXdcbiAgICAgICAgb2Zmc2V0IDwgdy50b3AgJiYgbm9kZUhlaWdodCA+IHcuYm90dG9tOyAgICAvLyBpcyB0b3AgZnJhbWUgYWJvdmUgdmlldyBhbmQgYm90dG9tIGZyYW1lIGJlbG93IHZpZXdcbn1cblxuZnVuY3Rpb24gY3V0Q2F0ZWdvcmllcyh2YWwpIHtcbiAgICB2YXIgc3BsaXQgPSB2YWwuc3BsaXQoJ18nKTtcbiAgICBpZiAoc3BsaXQubGVuZ3RoID4gMSkge1xuICAgICAgICBzcGxpdC5zcGxpY2UoMCwgMSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGlkIDogdmFsLFxuICAgICAgICB2YWx1ZSA6IHNwbGl0LmpvaW4oJ18nKVxuICAgIH1cbn1cblxuZnVuY3Rpb24gZXhwYW5kQ2F0ZWdvcmllc0luVmlldygpICAgICB7XG4gICAgcGFyZW50Tm9kZUxpc3QuZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBsaSA9IHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJ1tkYXRhPWFuY2hvcl8nICsgb2JqLmlkICsgJ10nKTtcbiAgICAgICAgaWYgKGlzTm9kZUluVmlldyhvYmoubm9kZSkpIHtcbiAgICAgICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ2MtaW5WaWV3Jyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QucmVtb3ZlKCdjLWluVmlldycpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldEZpcnN0RWxlbWVudEluVmlld3BvcnQobm9kZXMpIHtcbiAgICB2YXIga2V5Tm9kZSxcbiAgICAgICAgcGFnZVNjcm9sbE9mZnNldCA9IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wIHx8IChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCksXG4gICAgICAgIGkgPSBub2Rlcy5sZW5ndGgsXG4gICAgICAgIG5vZGVNYXJnaW47XG5cbiAgICB3aGlsZShpLS0pIHtcbiAgICAgICAga2V5Tm9kZSA9IG5vZGVzW2ldO1xuICAgICAgICBub2RlTWFyZ2luID0gcGFyc2VJbnQod2luZG93LmdldENvbXB1dGVkU3R5bGUoa2V5Tm9kZSwgbnVsbCkubWFyZ2luQm90dG9tLCAxMCk7XG4gICAgICAgIGlmKGdldFBhZ2VPZmZzZXRGb3JFbGVtZW50KGtleU5vZGUpIC0gbm9kZU1hcmdpbiAqIDIgPD0gcGFnZVNjcm9sbE9mZnNldCkge1xuICAgICAgICAgICAgcmV0dXJuIGtleU5vZGU7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZXR1cm4gZmlyc3Qga2V5IG5vZGUgZm9yIGN1cnJlbnQgYWN0aXZlIGNhdGVnb3J5XG4gICAgcmV0dXJuIG5vZGVzWzBdO1xufVxuXG5mdW5jdGlvbiBnZXRQYWdlT2Zmc2V0Rm9yRWxlbWVudChlbGVtKSB7XG4gICAgdmFyIGJvZHlSZWN0ID0gZG9jdW1lbnQuYm9keS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgZWxlbVJlY3QgPSBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiBlbGVtUmVjdC50b3AgLSBib2R5UmVjdC50b3A7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGZvY3VzRWxlbWVudCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgbGkgPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YT1hbmNob3JfJyArIGlkICsgJ10nKTtcbiAgICAgICAgaWYgKGxpKSB7XG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQoaWQsbGkpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBvblNlbGVjdCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICBvblNlbGVjdCA9IGZjO1xuICAgIH0sXG4gICAgcmVuZGVyTWVudSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGNhdE9iaiA9IFtdO1xuICAgICAgICAvLyBjbGVhciBwYXJlbnQgbm9kZSBsaXN0XG4gICAgICAgIHBhcmVudE5vZGVMaXN0ID0gW107XG5cbiAgICAgICAgW10uc2xpY2UuY2FsbChkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsKCcuYy1hbmNob3JNZW51LXBhcmVudCcpKS5mb3JFYWNoKGZ1bmN0aW9uIChwYXJlbnQpIHtcbiAgICAgICAgICAgIHZhciBpZCA9IHBhcmVudC5nZXRBdHRyaWJ1dGUoJ2lkJyksXG4gICAgICAgICAgICAgICAgY2hpbGRyZW4gPSBbXTtcbiAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgIGlkID0gaWQucmVwbGFjZSh0cmFuc2xhdGlvblZpZXdDb25maWcucm93UHJlZml4LCAnJyk7XG4gICAgICAgICAgICAgICAgLy8gY29sbGVjdCBwYXJlbnRzXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZUxpc3QucHVzaCh7bm9kZSA6IHBhcmVudCwgaWQgOiBpZH0pO1xuXG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChwYXJlbnQucXVlcnlTZWxlY3RvckFsbCgnLmMtYW5jaG9yTWVudS1jaGlsZCcpKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaWQgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2lkJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGRyZW4ucHVzaChjdXRDYXRlZ29yaWVzKGlkLnJlcGxhY2UodHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCwgJycpKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXRPYmoucHVzaCh7aWQgOiBpZCwgY2hpbGRyZW4gOiBjaGlsZHJlbn0pO1xuXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBbXS5zbGljZS5jYWxsKHJvb3ROb2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgY2hpbGQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChjaGlsZCk7XG4gICAgICAgIH0pO1xuICAgICAgICBhZGRJdGVtcyhyb290Tm9kZSwgY2F0T2JqKTtcbiAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW5bMF0uc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gMTI1ICsgJ3B4JztcbiAgICAgICAgXG4gICAgICAgIC8vIHRpbWUgZGVsYXllZCB0cmlnZ2VyIHRoZSBpbml0IHZpZXdcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBleHBhbmRDYXRlZ29yaWVzSW5WaWV3KCk7XG4gICAgICAgICAgICBoaWdobGlnaHRUb3BNb3N0S2V5KCk7XG4gICAgICAgIH0sIDEwMDApXG4gICAgfSxcbiAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICByb290Tm9kZSA9IG5vZGU7XG4gICAgfSxcbiAgICByZWFkeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICBleHBhbmRDYXRlZ29yaWVzSW5WaWV3KCk7XG4gICAgICAgICAgICBoaWdobGlnaHRUb3BNb3N0S2V5KCk7XG4gICAgICAgIH0pO1xuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcigncmVzaXplJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHJvb3ROb2RlLmNoaWxkcmVuWzBdKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuY2hpbGRyZW5bMF0uc3R5bGUuaGVpZ2h0ID0gd2luZG93LmlubmVySGVpZ2h0IC0gMTI1ICsgJ3B4JztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGluaXQgdGhlIG1lbnUgd2l0aCBhIHRpbWUgZGVsYXlcbiAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBleHBhbmRDYXRlZ29yaWVzSW5WaWV3KCk7XG4gICAgICAgICAgICBoaWdobGlnaHRUb3BNb3N0S2V5KCk7XG4gICAgICAgIH0sIDE1MDApXG5cbiAgICB9XG59OyIsInZhciBvbkxvZ291dCA9IGZ1bmN0aW9uICgpIHtjb25zb2xlLmxvZygnYXV0aDpvbkxvZ291dCBpcyBub3QgaGFuZGxlZCcpfSxcbiAgICBicmFpbiA9IHtcbiAgICAgICAgbG9nb3V0QnV0dG9uIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkxvZ291dCk7XG4gICAgICAgIH1cbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbkxvZ291dCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICBvbkxvZ291dCA9IGZjO1xuICAgIH0sXG4gICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgaWYgKGJyYWluLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICBicmFpblthdHRyXShub2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn07IiwidmFyIHJlcGVhdEZjUG9pbnRlcixcbiAgICBvbkNsaWNrID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgY29uc29sZS53YXJuKCdicmVhZGNydW1iOmNsaWNrIGhhbmRsZXIgbm90IHJlZ2lzdGVyZWQnLCBpdGVtKTtcbiAgICB9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbkNsaWNrIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIG9uQ2xpY2sgPSBmYztcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7fSxcbiAgICAvKipcbiAgICAgKlxuICAgICAqIEBwYXJhbSBwYXJlbnREaXJlY3RvcmllcyBbU3RyaW5nXVxuICAgICAqL1xuICAgIHVwZGF0ZUZvbGRlcnMgOiBmdW5jdGlvbiAocGFyZW50RGlyZWN0b3JpZXMpIHtcbiAgICAgICAgcmVwZWF0RmNQb2ludGVyKHBhcmVudERpcmVjdG9yaWVzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgcmV0dXJuIHtuYW1lIDogaXRlbS5uYW1lLCBvbkNsaWNrIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIG9uQ2xpY2soaXRlbS5pZCk7XG4gICAgICAgICAgICB9fVxuICAgICAgICB9KSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBmb3IgY2FubnkgcmVwZWF0IHRvIGdldFxuICAgICAqL1xuICAgIHJlZ2lzdGVyQ2FubnlSZXBlYXQgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgcmVwZWF0RmNQb2ludGVyID0gZmM7XG4gICAgfVxufVxuIiwibW9kdWxlLmV4cG9ydHMgPSBcIjxkaXYgY2xhc3M9XFxcImNvbm5lY3Rpb25Mb3N0XFxcIj5cXG4gIDxzZWN0aW9uPlxcbiAgICA8aSBjbGFzcz1cXFwib2N0aWNvbiBvY3RpY29uLXBsdWdcXFwiPjwvaT5cXG4gICAgPGgyPnt7aXRlbS50aXRsZX19PC9oMj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiZXJyb3JDb2RlXFxcIj48cD5FcnJvciBjb2RlOiA8c3Ryb25nPnt7aXRlbS5lcnJvckNvZGV9fTwvc3Ryb25nPjxzcGFuIGNsYXNzPVxcXCJlcnJvck1lc3NhZ2VcXFwiIHdrLWJpbmQ9XFxcIml0ZW0uZXJyb3JNZXNzYWdlXFxcIj48L3NwYW4+PC9wPjwvZGl2PlxcbiAgICA8ZGl2IGNsYXNzPVxcXCJidXR0b24tc2VjdGlvblxcXCI+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwicmVjb25uZWN0XFxcIiB3ay1iaW5kPVxcXCJpdGVtLnJlY29ubmVjdFxcXCIgdGl0bGU9XFxcIlRyeSB0byByZWNvbm5lY3QgeW91ciBjaGFuZ2VzIHdpbGwgYmUgb3ZlcndyaXR0ZW5cXFwiPnJlY29ubmVjdDwvYnV0dG9uPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcImNsb3NlXFxcIiB3ay1iaW5kPVxcXCJpdGVtLmNsb3NlXFxcIiB0aXRsZT1cXFwiWW91IGNhbiBjbG9zZSB0aGlzIHZpZXcgdG8gcmVzY3VyZSB5b3UgY2hhbmdlcyBtYW51YWxseVxcXCI+Y2xvc2U8L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJyZWxvYWRcXFwiIHdrLWJpbmQ9XFxcIml0ZW0ucmVsb2FkXFxcIiB0aXRsZT1cXFwiSWYgeW91IGRvIGEgcGFnZSByZWxvYWQgYWxsIHlvdXIgdW5zYXZlZCBjaGFuZ2VzIHdpbGwgYmUgbG9zdFxcXCI+cmVsb2FkIHBhZ2U8L2J1dHRvbj5cXG4gICAgPC9kaXY+XFxuICA8L3NlY3Rpb24+XFxuICA8ZGl2IGNsYXNzPVxcXCJwcm9ncmVzc1VpXFxcIj48L2Rpdj5cXG48L2Rpdj5cIjtcbiIsImNvbnN0IHdoaXNrZXIgPSByZXF1aXJlKCdjYW5ueS9tb2Qvd2hpc2tlcicpXG5jb25zdCB0ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vaW5kZXguaHRtbCcpXG5jb25zdCBURVhUUyA9IGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgc3dpdGNoKGNvZGUpIHtcbiAgICAgICAgY2FzZSAnRVhDRVBUSU9OJzpcbiAgICAgICAgICAgIHJldHVybiAnd293Li4uIG5vdCBnb29kIC0gcGxlYXNlIHJlcG9ydCB0aGlzIHByb2JsZW0gdG8gYSBkZXZlbG9wZXInXG4gICAgICAgIGNhc2UgJ0ZBVEFMJzpcbiAgICAgICAgICAgIHJldHVybiAnZGFtbWVkLi4uIHRoaXMgc2hvdWxkIG5vdCBoYXBwZW4gLSBwbGVhc2UgY29uc3VsdCBkZXYgb2YgdHJ1c3QnXG4gICAgICAgIGNhc2UgJ0FVVEgnOlxuICAgICAgICAgICAgcmV0dXJuICdTZXNzaW9uIHRpbWVvdXQgcGxlYXNlIGxvZ2luIGFnYWluJ1xuICAgICAgICBjYXNlICdSRUNPTk5FQ1RfRkFJTCc6XG4gICAgICAgICAgICByZXR1cm4gJ2NhblxcJ3QgY3JlYXRlIGEgY29ubmVjdGlvbidcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHJldHVybiAnd2hvb29wcy4uLiBzZXJ2ZXIgY29ubmVjdGlvbiBsb3N0J1xuICAgIH1cbn1cbi8qKlxuICpcbiAqIEBwYXJhbSBvblJlbG9hZFxuICogQHBhcmFtIG9uUmVjb25uZWN0XG4gKiBAcmV0dXJucyB7e3JlbmRlcjogKGZ1bmN0aW9uKHN0cmluZykpLCBkZXN0cm95OiAoZnVuY3Rpb24oKSl9fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh7b25SZWxvYWQsIG9uUmVjb25uZWN0LCBvbkNsb3NlfSkge1xuICAgIC8vIHNhdmVzIHRoZSBhY3RpdmUgbm9kZVxuICAgIGxldCB1aTtcblxuICAgIGZ1bmN0aW9uIHJlbmRlcih7ZXJyb3JDb2RlLCBlcnJvck1lc3NhZ2V9KSB7XG4gICAgICAgIGlmICh1aSkgdWkucmVtb3ZlKClcbiAgICAgICAgY29uc3QgZCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXG4gICAgICAgIGQuaW5uZXJIVE1MID0gdGVtcGxhdGVcbiAgICAgICAgd2hpc2tlci5hZGQoZC5jaGlsZHJlblswXSwge1xuICAgICAgICAgICAgcmVjb25uZWN0IDogbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yQ29kZSA9PT0gJ1JFQ09OTkVDVF9GQUlMJyB8fCBlcnJvckNvZGUgPT09ICdGQVRBTCcgfHwgZXJyb3JDb2RlID09PSAnQVVUSCcgfHwgZXJyb3JDb2RlID09PSAnU0VSVkVSX0RPV04nIHx8IGVycm9yQ29kZSA9PT0gJ0VYQ0VQVElPTicpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgICAgICAgIG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvblJlY29ubmVjdClcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSA6IG4gPT4gbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uQ2xvc2UpLFxuICAgICAgICAgICAgcmVsb2FkIDogbiA9PiBuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25SZWxvYWQpLFxuICAgICAgICAgICAgZXJyb3JDb2RlLFxuICAgICAgICAgICAgdGl0bGUgOiBURVhUUyhlcnJvckNvZGUpLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlIDogbiA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yTWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICBuLmlubmVySFRNTCA9IGAgJHtlcnJvck1lc3NhZ2V9YFxuICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh1aSA9IGQuY2hpbGRyZW5bMF0pXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNob3cgdGhlIG1vZHVsZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZXJyIC0gZXJyb3IgY29kZSB0byBwcmludCBvbiB0aGUgdmlld1xuICAgICAgICAgKi9cbiAgICAgICAgcmVuZGVyIDogKGVyciwgbXNnKSA9PiByZW5kZXIoe2Vycm9yQ29kZSA6IGVyciwgZXJyb3JNZXNzYWdlOiBtc2d9KSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZSB0aGUgbW9kdWxlIGZyb20gdWlcbiAgICAgICAgICovXG4gICAgICAgIGRlc3Ryb3kgOiAoKSA9PiB7XG4gICAgICAgICAgICB1aS5yZW1vdmUoKVxuICAgICAgICAgICAgdWkgPSB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIGluZGljYXRlcyB0aGF0IHRoZSB2aWV3IGlzIGJ1c3lcbiAgICAgICAgICovXG4gICAgICAgIHNob3dQcm9ncmVzcyA6ICgpID0+IHtcbiAgICAgICAgICAgIHVpLmNsYXNzTGlzdC5hZGQoJ3Byb2dyZXNzJylcbiAgICAgICAgfVxuICAgIH1cbn0iLCJ2YXIgb25DcmVhdGVOZXdQcm9qZWN0ID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybignY3JlYXRlTmV3UHJvamVjdC5vbkNyZWF0ZU5ld1Byb2plY3Qgbm90IHNldCcpfSxcbiAgICBvbkNyZWF0ZU5ld0RpcmVjdG9yeSA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4oJ2NyZWF0ZU5ld1Byb2plY3Qub25DcmVhdGVOZXdEaXJlY3Rvcnkgbm90IHNldCcpfTtcblxudmFyIHByb2plY3ROYW1lSW5wdXROb2RlLFxuICAgIGRpcmVjdG9yeU5hbWVJbnB1dE5vZGU7XG5cbmZ1bmN0aW9uIG5vU3BhY2VzKG5vZGUpIHtcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gZS5rZXlDb2RlIHx8IGUud2hpY2hcbiAgICAgICAgaWYgKGtleSA9PT0gMzIpIGUucmV0dXJuVmFsdWUgPSBmYWxzZVxuICAgICAgICByZXR1cm4gdHJ1ZVxuICAgIH0pXG4gICAgcmV0dXJuIG5vZGVcbn1cblxuZnVuY3Rpb24gaXNWYWxpZFByb2plY3ROYW1lKHByb2plY3ROYW1lKSB7XG4gICAgcmV0dXJuIChwcm9qZWN0TmFtZS5sZW5ndGggPiAwICYmIHByb2plY3ROYW1lLnNlYXJjaCgnXFxcXC58LHwgJykgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbn1cblxuZnVuY3Rpb24gaXNWYWxpZERpcmVjdG9yeU5hbWUoZGlyZWN0b3J5TmFtZSkge1xuICAgIC8vIFRCRCBtb3JlIGZvcmJpZGRlbiBjaGFyYWN0ZXJzP1xuICAgIHJldHVybiAoZGlyZWN0b3J5TmFtZS5sZW5ndGggPiAwICYmIGRpcmVjdG9yeU5hbWUuc2VhcmNoKCcvJykgPT09IC0xKSA/IHRydWUgOiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgYWRkIDogZnVuY3Rpb24obm9kZSwgYXR0cmlidXRlKSB7XG4gICAgICAgIHN3aXRjaCAoYXR0cmlidXRlKSB7XG4gICAgICAgICAgICBjYXNlICdjcmVhdGVOZXdQcm9qZWN0SW5wdXRQcm9qZWN0JyA6XG4gICAgICAgICAgICAgICAgcHJvamVjdE5hbWVJbnB1dE5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnbmV3RGlyZWN0b3J5TmFtZUlucHV0JyA6XG4gICAgICAgICAgICAgICAgZGlyZWN0b3J5TmFtZUlucHV0Tm9kZSA9IG5vU3BhY2VzKG5vZGUpXG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjcmVhdGVOZXdQcm9qZWN0U3VibWl0JyA6XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvamVjdE5hbWUgPSBwcm9qZWN0TmFtZUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWRQcm9qZWN0TmFtZShwcm9qZWN0TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ3JlYXRlTmV3UHJvamVjdChwcm9qZWN0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZUlucHV0Tm9kZS5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjcmVhdGVOZXdEaXJlY3RvcnlTdWJtaXQnIDpcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBkaXJlY3RvcnlOYW1lID0gZGlyZWN0b3J5TmFtZUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzVmFsaWREaXJlY3RvcnlOYW1lKGRpcmVjdG9yeU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkNyZWF0ZU5ld0RpcmVjdG9yeShkaXJlY3RvcnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdG9yeU5hbWVJbnB1dE5vZGUuY2xhc3NMaXN0LmFkZCgnZXJyb3InKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnY2FuY2VsJzpcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbm55LmRpc3BsYXlNYW5hZ2VyLmhpZGUodGhpcy5kYXRhc2V0LnZpZXcpXG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGFzcyBpbiBsaXN0ZW5lciBmb3IgZXhlY3V0aW9uIG9mIGNyZWF0aW5nIG5ldyBwcm9qZWN0LlxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICovXG4gICAgb25DcmVhdGVOZXdQcm9qZWN0IDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICBvbkNyZWF0ZU5ld1Byb2plY3QgPSBmdW5jO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogUGFzcyBpbiBsaXN0ZW5lciBmb3IgZXhlY3V0aW9uIG9mIGNyZWF0aW5nIGEgbmV3IGRpcmVjdG9yeS5cbiAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAqL1xuICAgIG9uQ3JlYXRlTmV3RGlyZWN0b3kgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIG9uQ3JlYXRlTmV3RGlyZWN0b3J5ID0gZnVuYztcbiAgICB9XG59O1xuIiwidmFyIE92ZXJsYXkgPSByZXF1aXJlKCcuL292ZXJsYXknKSxcblx0ZGlzcGxheU1hbmFnZXIgPSBmdW5jdGlvbigpIHtcblxuXHRcdHZhciBtYWluQ29udHJvbGxlciA9IGNhbm55LmZsb3dDb250cm9sLFxuXHRcdFx0b3ZlcmxheUNvbnRyb2xsZXIgPSBjYW5ueS5mbG93Q29udHJvbC5jcmVhdGVOZXdJbnN0YW5jZSgnb3ZlcmxheXMnKSxcblx0XHRcdGNoaWxkcmVuID0ge1xuXHRcdFx0XHRvdmVybGF5OiB7XG5cdFx0XHRcdFx0aWRzOiBbXSxcblx0XHRcdFx0XHRjb250cm9sbGVyOiBvdmVybGF5Q29udHJvbGxlcixcblx0XHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKG5vZGUsIGlkKSB7XG5cblx0XHRcdFx0XHRcdHZhciBvdmVybGF5ID0gbmV3IE92ZXJsYXkobm9kZSwgaWQpO1xuXHRcdFx0XHRcdFx0b3ZlcmxheS5vbkNsaWNrKGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRzZXREaXNwbGF5U3RhdGVCeUlkKGlkLCBmYWxzZSk7XG5cdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0dGhpcy5jb250cm9sbGVyLmFkZChvdmVybGF5Lm5vZGUsIHtcblx0XHRcdFx0XHRcdFx0J3ZpZXcnOiBvdmVybGF5LmlkXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHRoaXMuaWRzLnB1c2gob3ZlcmxheS5pZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXHRcdFx0XHR2aWV3OiB7XG5cdFx0XHRcdFx0aWRzOiBbXSxcblx0XHRcdFx0XHRjb250cm9sbGVyOiBtYWluQ29udHJvbGxlcixcblx0XHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKG5vZGUsIGlkKSB7XG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRyb2xsZXIuYWRkKG5vZGUsIHtcblx0XHRcdFx0XHRcdFx0J3ZpZXcnOiBpZFxuXHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR0aGlzLmlkcy5wdXNoKGlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRmdW5jdGlvbiBzZXREaXNwbGF5U3RhdGVCeUlkKGlkLCBzaG93KSB7XG5cdFx0XHRPYmplY3Qua2V5cyhjaGlsZHJlbikubWFwKGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0dmFyIHBvb2wgPSBjaGlsZHJlblt0eXBlXSxcblx0XHRcdFx0XHRpZHMgPSBwb29sLmlkcyxcblx0XHRcdFx0XHRjdXJyZW50SWQ7XG5cblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpZHMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRjdXJyZW50SWQgPSBpZHNbaV07XG5cdFx0XHRcdFx0aWYgKGlkID09PSBjdXJyZW50SWQpIHtcblx0XHRcdFx0XHRcdGlmIChzaG93KSB7XG5cdFx0XHRcdFx0XHRcdHBvb2wuY29udHJvbGxlci5zaG93KGN1cnJlbnRJZCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRlbHNlIGlmIChwb29sLmNvbnRyb2xsZXIubW9kW2lkXSkge1xuXHRcdFx0XHRcdFx0XHRwb29sLmNvbnRyb2xsZXIubW9kW2lkXS5mb3JFYWNoKGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRcdFx0XHRcdG9iai5oaWRlKCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0YWRkOiBmdW5jdGlvbihub2RlLCBkZXNjcmlwdG9yKSB7XG5cdFx0XHRcdHZhciBrZXlzLCBrZXk7XG5cdFx0XHRcdGlmICh0eXBlb2YgZGVzY3JpcHRvciA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRrZXlzID0gT2JqZWN0LmtleXMoZGVzY3JpcHRvcik7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdFx0aWYgKGNoaWxkcmVuLmhhc093blByb3BlcnR5KGtleSkpIHtcblx0XHRcdFx0XHRcdFx0Y2hpbGRyZW5ba2V5XS5hZGQobm9kZSwgZGVzY3JpcHRvcltrZXldKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y29uc29sZS53YXJuKCdQYXJhbWV0ZXIgdG8gYWRkIGNoaWxkIHRvIGRpc3BsYXlNYW5hZ2VyIGlzIG5vdCB2YWxpZDogJyArIGRlc2NyaXB0b3IpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0c2hvdzogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0c2V0RGlzcGxheVN0YXRlQnlJZChpZCwgdHJ1ZSk7XG5cdFx0XHR9LFxuXHRcdFx0aGlkZTogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0c2V0RGlzcGxheVN0YXRlQnlJZChpZCwgZmFsc2UpO1xuXHRcdFx0fVxuXG5cdFx0fTtcblx0fTtcblxubW9kdWxlLmV4cG9ydHMgPSBkaXNwbGF5TWFuYWdlcjsiLCIvKipcbiAqIGhhbmRsZXMgYWxsIHRleHRzXG4gKi9cbnZhciBkb21PcHRzID0gcmVxdWlyZSgnZG9tLW9wdHMnKSxcbiAgICBmbGFnTWFwID0ge1xuICAgICAgICBkYTogJ2RrJyxcbiAgICAgICAgZGU6ICdkZScsXG4gICAgICAgIGZyOiAnZnInLFxuICAgICAgICBubDogJ25sJyxcbiAgICAgICAgZW46ICd1cycsXG4gICAgICAgIGVuX0dCOiAnZ2InLFxuICAgICAgICBzdjogJ3NlJyxcbiAgICAgICAgZXM6ICdlcydcbiAgICB9O1xuXG5mdW5jdGlvbiBnZXRMYW5nKGxhbmcpIHtcbiAgICB2YXIgZmxhZ0xhbmcgPSBsYW5nO1xuICAgIGlmIChmbGFnTWFwLmhhc093blByb3BlcnR5KGxhbmcpKSB7XG4gICAgICAgIGZsYWdMYW5nID0gZmxhZ01hcFtsYW5nXTtcbiAgICB9XG4gICAgcmV0dXJuIGZsYWdMYW5nO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBnZXRGbGFnIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnc3BhbicsIG51bGwsICdmbGFnLWljb24gZmxhZy1pY29uLScgKyBnZXRMYW5nKGxhbmcpKTtcbiAgICB9LFxuICAgIGdldEZsYWdDbGFzc2VzIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgcmV0dXJuIFsnZmxhZy1pY29uJywgJ2ZsYWctaWNvbi0nICsgZ2V0TGFuZyhsYW5nKV07XG4gICAgfVxufTsiLCIvKmdsb2JhbCBhY2UgKi9cbi8qanNsaW50IGJyb3dzZXI6IHRydWUgKi9cbmNvbnN0IGV2ZW50cyA9IHJlcXVpcmUoJy4uL2V2ZW50cy5qcycpXG5jb25zdCBDID0gcmVxdWlyZSgnLi4vQ09OU1QuanMnKVxuXG53aW5kb3cuZG9tT3B0cyA9IHdpbmRvdy5kb21PcHRzIHx8IHJlcXVpcmUoJ2RvbS1vcHRzJyk7XG5cbnZhciBpbWFnZVZpZXdlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgbm9kZVRvQXBwZW5kLFxuICAgICAgICBpbml0ID0gZmFsc2UsXG4gICAgICAgIGNvbmZpZyA9IHtcbiAgICAgICAgICAgIGlkUHJlZml4IDogJ2ltYWdlVmlld2VyXydcbiAgICAgICAgfSxcbiAgICAgICAgc2V0dXBDb250YWluZXJDU1MgPSBmdW5jdGlvbiAobm9kZSwgY3NzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wIGluIGNzcykge1xuICAgICAgICAgICAgICAgIG5vZGUuc3R5bGVbcHJvcF0gPSAgY3NzW3Byb3BdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBzZXR0aW5ncyA9IHtcbiAgICAgICAgICAgIG1heFdpZHRoIDogMzAwLFxuICAgICAgICAgICAgbWF4SGVpZ2h0OiAzMDBcbiAgICAgICAgfSxcbiAgICAgICAgZmMgPSB7XG4gICAgICAgICAgICBoaWRlSW1hZ2VWaWV3ZXIgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXMgPSBub2RlVG9BcHBlbmQuZG9tQ2hpbGRUYWdzKCdpbWcnKTtcblxuICAgICAgICAgICAgICAgIGlmIChwcmVzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdGhlcmUgYXJlIG90aGVyIG9wZW4gaW1hZ2VzXG4gICAgICAgICAgICAgICAgICAgIHByZXMuZm9yRWFjaChmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZS5kb21BZGRDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93SW1hZ2UgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGltZywgaWQgPSBjb25maWcuaWRQcmVmaXggKyBvYmouaWQsXG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbEltZyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGlkKTtcblxuICAgICAgICAgICAgICAgIGlmIChhY3R1YWxJbWcgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0dWFsSW1nLmRvbVJlbW92ZUNsYXNzKCdoaWRkZW4nKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpbWcgPSBuZXcgSW1hZ2UoKTtcbiAgICAgICAgICAgICAgICAgICAgaW1nLm9ubG9hZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdET05FIElNQUdFJyk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIGltZy5zcmMgPSAgXCJkYXRhOmltYWdlL3BuZztiYXNlNjQsXCIgKyBvYmouZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgc2V0dXBDb250YWluZXJDU1MoaW1nLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhXaWR0aCA6ICcxMDAlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIG1heEhlaWdodCA6ICcxMDAlJ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgaW1nLnNldEF0dHJpYnV0ZSgnaWQnLCBpZCk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5kb21BcHBlbmRUbyhub2RlVG9BcHBlbmQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ3NlbmRGaWxlJywgZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgaWYgKGluaXQpIHtcbiAgICAgICAgICAgICAgICBmYy5oaWRlSW1hZ2VWaWV3ZXIoKTtcblxuICAgICAgICAgICAgICAgIGlmIChvYmouZmlsZVR5cGUgPT09IEMuRklMRV9NQU5BR0VSLkZJTEVfVFlQRVMuSU1BR0UpIHtcbiAgICAgICAgICAgICAgICAgICAgZmMuc2hvd0ltYWdlKG9iaik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcblxuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICAgIGluaXQgPSB0cnVlO1xuICAgICAgICAgICAgbm9kZVRvQXBwZW5kID0gbm9kZTtcbiAgICAgICAgICAgIG5vZGVUb0FwcGVuZC5zZXRBdHRyaWJ1dGUoJ2lkJywgJ2ltYWdlVmlld2VyJyk7XG5cbiAgICAgICAgICAgIHNldHVwQ29udGFpbmVyQ1NTKG5vZGVUb0FwcGVuZCwge1xuICAgICAgICAgICAgICAgIHdpZHRoIDogc2V0dGluZ3MubWF4V2lkdGggKyAncHgnLFxuICAgICAgICAgICAgICAgIGhlaWdodDogc2V0dGluZ3MubWF4SGVpZ2h0ICsgJ3B4J1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldHVwIDogZnVuY3Rpb24gKGNvbmZpZykge1xuICAgICAgICAgICAgdmFyIG9iajtcbiAgICAgICAgICAgIGZvciAob2JqIGluIGNvbmZpZykge1xuICAgICAgICAgICAgICAgIHNldHRpbmdzW29ial0gPSBjb25maWdbb2JqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGltYWdlVmlld2VyOyIsIlxuZnVuY3Rpb24gYWRkRWRpdChub2RlLCBmYykge1xuICAgdmFyIGRpdiA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ2lucHV0RWRpdE1hbmFnZXItYnV0dG9uIGVkaXQgb2N0aWNvbiBvY3RpY29uLXBlbmNpbCcpO1xuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2MtZWRpdCcpO1xuICAgICAgICBmYyhldmVudCk7XG4gICAgfSk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnZWRpdCcpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGl2KTtcbn1cbmZ1bmN0aW9uIGFkZENhbmNlbChub2RlLCBmYykge1xuICAgIHZhciBkaXYgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyLWJ1dHRvbiBjYW5jZWwgb2N0aWNvbiBvY3RpY29uLXgnKTtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLWVkaXQnKTtcbiAgICAgICAgZmMoZXZlbnQpO1xuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ2NhbmNlbCcpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGl2KTtcbn1cblxuZnVuY3Rpb24gYWRkU2F2ZShub2RlLCBmYykge1xuICAgIHZhciBkaXYgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyLWJ1dHRvbiBzYXZlIG9jdGljb24gb2N0aWNvbi1jaGVjaycpO1xuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmYyhldmVudCk7XG4gICAgfSk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnc2F2ZSBjaGFuZ2VzJyk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChkaXYpO1xufVxuXG5mdW5jdGlvbiBhZGRDbG9uZShub2RlLCBmYykge1xuICAgIHZhciBkaXYgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyLWJ1dHRvbiBzYXZlIG9jdGljb24gb2N0aWNvbi1maWxlLXN5bWxpbmstZmlsZScpO1xuICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBmYyhldmVudCk7XG4gICAgfSk7XG4gICAgZGl2LnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnbW92ZSBrZXkgaW50byBvdGhlciBjYXRlZ29yeScpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGl2KTtcbn1cblxuZnVuY3Rpb24gYWRkRGVsZXRlKG5vZGUsIGZjKSB7XG4gICAgdmFyIGRpdiA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ2lucHV0RWRpdE1hbmFnZXItYnV0dG9uIGRlbGV0ZSBvY3RpY29uIG9jdGljb24tdHJhc2hjYW4nKTtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZmMoZXZlbnQpO1xuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ3JlbW92ZSB0aGlzIGtleScpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGl2KTtcbn1cblxuZnVuY3Rpb24gY2xvc2VFZGl0b3JWaWV3KGtleUlucHV0Tm9kZSkge1xuICAgIHZhciBlZGl0b3JQYW5lbE5vZGUgPSBrZXlJbnB1dE5vZGUucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKCcuaW5wdXRFZGl0TWFuYWdlci53cmFwJyk7XG4gICAgaWYgKGVkaXRvclBhbmVsTm9kZSkge1xuICAgICAgICBlZGl0b3JQYW5lbE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1lZGl0Jyk7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAvKipcbiAgICAgKiBlYWNoIGtleSBpbnB1dCBub2RlIGhhc3RcbiAgICAgKiBAcGFyYW0ga2V5SW5wdXROb2RlXG4gICAgICovXG4gICAgY2xvc2VFZGl0VmlldyA6IGZ1bmN0aW9uIChrZXlJbnB1dE5vZGUpIHtcbiAgICAgICAgaWYgKGtleUlucHV0Tm9kZSkge1xuICAgICAgICAgICAgY2xvc2VFZGl0b3JWaWV3KGtleUlucHV0Tm9kZSk7XG4gICAgICAgIH1cbiAgICB9LFxuICAgIGFkZEVkaXRvclBhbmVsIDogZnVuY3Rpb24gKGtleU5vZGUsIGxpc3RlbmVycykge1xuICAgICAgICB2YXIgY29udGFpbmVyTm9kZSA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ2lucHV0RWRpdE1hbmFnZXIgd3JhcCcpO1xuXG4gICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoJ29uRWRpdCcpKSB7XG4gICAgICAgICAgICBhZGRFZGl0KGNvbnRhaW5lck5vZGUsIGxpc3RlbmVycy5vbkVkaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoJ29uRGVsZXRlJykpIHtcbiAgICAgICAgICAgIGFkZERlbGV0ZShjb250YWluZXJOb2RlLCBsaXN0ZW5lcnMub25EZWxldGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoJ29uU2F2ZScpKSB7XG4gICAgICAgICAgICBhZGRTYXZlKGNvbnRhaW5lck5vZGUsIGxpc3RlbmVycy5vblNhdmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoJ29uQ2xvbmUnKSkge1xuICAgICAgICAgICAgYWRkQ2xvbmUoY29udGFpbmVyTm9kZSwgbGlzdGVuZXJzLm9uQ2xvbmUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lcnMuaGFzT3duUHJvcGVydHkoJ29uQ2FuY2VsJykpIHtcbiAgICAgICAgICAgIGFkZENhbmNlbChjb250YWluZXJOb2RlLCBsaXN0ZW5lcnMub25DYW5jZWwpO1xuICAgICAgICB9XG5cbiAgICAgICAgY29udGFpbmVyTm9kZS5kb21BcHBlbmRUbyhrZXlOb2RlKTtcblxuICAgICAgICByZXR1cm4gY29udGFpbmVyTm9kZTtcbiAgICB9LFxuICAgIHJlbW92ZVBhbmVsIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgbm9kZS5xdWVyeVNlbGVjdG9yKCcuaW5wdXRFZGl0TWFuYWdlci53cmFwJykuZG9tUmVtb3ZlKCk7XG4gICAgfVxufSIsIlxudmFyIHJvb3ROb2RlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBzaG93IDogZnVuY3Rpb24gKCkge1xuICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QuYWRkKCdjLXNob3cnKTtcbiAgICB9LFxuICAgIGhpZGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJvb3ROb2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2Mtc2hvdycpO1xuICAgIH0sXG4gICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgaWYgKGF0dHIgPT09ICdidXR0b24nKSB7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgaWYgKHJvb3ROb2RlLmNsYXNzTGlzdC5jb250YWlucygnYy1zaG93JykpIHtcbiAgICAgICAgICAgICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLXNob3cnKTtcbiAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LmFkZCgnYy1zaG93Jyk7XG4gICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJvb3ROb2RlID0gbm9kZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIE92ZXJsYXkobm9kZSwgaWQpIHtcblxuXHR2YXIgaWQgPSBpZCxcblx0XHRub2RlID0gbm9kZSxcblx0XHRjbGlja0hhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRcdGNvbnNvbGUud2FybignQ2xpY2sgbGlzdGVuZXIgbm90IGF0dGFjaGVkIGZvciBvdmVybGF5IHdpdGggaWQ6ICcgKyBpZCk7XG5cdFx0fTtcblxuXHRub2RlLmNsYXNzTGlzdC5hZGQoJ2Rpc3BsYXlNYW5hZ2VyLW92ZXJsYXknKTtcblx0bm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG5cdFx0aWYgKG5vZGUgPT09IGUudGFyZ2V0KSB7XG5cdFx0XHRjbGlja0hhbmRsZXIoKTtcblx0XHR9XG5cdH0pO1xuXG5cdHJldHVybiB7XG5cdFx0aWQ6IGlkLFxuXHRcdG5vZGU6IG5vZGUsXG5cdFx0b25DbGljazogZnVuY3Rpb24oY2IpIHtcblx0XHRcdGNsaWNrSGFuZGxlciA9IGNiO1xuXHRcdH1cblx0fVxufTsiLCIvKmdsb2JhbCAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG5cbnZhciBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JyksXG4gICAgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZycpLFxuICAgIHRleHRzID0gcmVxdWlyZSgnLi90ZXh0cycpO1xuXG4vKipcbiAqIEUuZy46IGNhbm55LW1vZD1cImZsb3dDb250cm9sXCIgY2FubnktdmFyPVwieyd2aWV3JyA6ICd2aWV3VG9TaG93J31cIlxuICpcbiAqIHlvdSBjYW4gYWN0aXZhdGUgYSBpbml0aWFsIHZpZXcgd2l0aCBhIGFuY2hvciBpbiB0aGUgVVJMIGUuZy46IHlvdXJkb21haW4uaHRtbCN2aWV3VG9TaG93XG4gKiBPciBwYXNzIGEgY29tbWEgc2VwYXJhdGVkIG1vZHVsZSBsaXN0IGZvciBhY3RpdmF0ZSBtb3JlIG1vZHVsZSAjdmlld1RvU2hvdyxvdGhlclZpZXdcbiAqXG4gKiBUT0RPIG1hZGUgaXQgcG9zc2libGUgdG8gc3VtbWFyaXplIHZpZXdzIHdpdGggb25lIGlkZW50aWZpZXIuXG4gKiBJbnN0ZWFkIG9mIGNhbGw6IGdkb20uZmxvd0NvbnRyb2wuc2hvdygndmlldzEnLCAndmlldzInLCAndmlldzMnKSBjYWxsIGdkb20uZmxvd0NvbnRyb2wuc2hvdygndmlldycpLlxuICovXG52YXIgcHJvamVjdE1haW5OYXZpZ2F0aW9uID0gKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBtYWluTm9kZSxcbiAgICAgICAgc2VsZWN0TGFuZ3VhZ2VRdWV1ZSA9IFtdLFxuICAgICAgICBvblNob3dKU09OUXVldWUgPSBbXSxcbiAgICAgICAgb25FbmFibGVFZGl0b3JNb2RlUXVldWUgPSBbXSxcbiAgICAgICAgb25Ub2dnbGVXb3JkQ291bnRRdWV1ZSA9IFtdLFxuICAgICAgICBvblNob3dKTUJGUXVldWUgPSBbXSxcbiAgICAgICAgb25TaG93Sk1CRlVwbG9hZGVyUXVldWUgPSBbXSxcbiAgICAgICAgb25TaG93SlNPTkltcG9ydFF1ZXVlID0gW10sXG4gICAgICAgIGJ1bmRsZU5hbWUgPSB3aW5kb3cuZG9tT3B0cy5wYXJhbXMuYnVuZGxlLFxuICAgICAgICBtb2RWaWV3cyA9IHtcbiAgICAgICAgICAgIG1haW4gOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG1haW5Ob2RlID0gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBtZW51VG9nZ2xlQnV0dG9uIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBuZXcgc3ZnSWNvbihub2RlLCB7XG4gICAgICAgICAgICAgICAgICAgIGhhbWJ1cmdlckNyb3NzIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXJsIDogJy9kaXN0L2FuaW1hdGVkU1ZHL3N2Zy9oYW1idXJnZXIuc3ZnJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1hdGlvbiA6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsIDogJ3BhdGg6bnRoLWNoaWxkKDEpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BlcnRpZXMgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIDogeyB2YWwgOiAne1wicGF0aFwiIDogXCJtIDUuMDkxNjc4OSwyMC44MTg5OTQgNTMuODE2NjQyMSwwXCJ9JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gOiB7IHZhbCA6ICd7XCJwYXRoXCIgOiBcIk0gMTIuOTcyOTQ0LDUwLjkzNjE0NyA1MS4wMjcwNTYsMTIuODgyMDM1XCJ9JyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgOiAncGF0aDpudGgtY2hpbGQoMiknLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbmltUHJvcGVydGllcyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyb20gOiB7IHZhbCA6ICd7XCJ0cmFuc2Zvcm1cIiA6IFwiczEgMVwiLCBcIm9wYWNpdHlcIiA6IDF9JywgYmVmb3JlIDogJ3tcInRyYW5zZm9ybVwiIDogXCJzMCAwXCJ9JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gOiB7IHZhbCA6ICd7XCJvcGFjaXR5XCIgOiAwfScgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsIDogJ3BhdGg6bnRoLWNoaWxkKDMpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BlcnRpZXMgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIDogeyB2YWwgOiAne1wicGF0aFwiIDogXCJtIDUuMDkxNjc4OCw0Mi45NTY5OCA1My44MTY2NDIyLDBcIn0nIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0byA6IHsgdmFsIDogJ3tcInBhdGhcIiA6IFwiTSAxMi45NzI5NDQsMTIuODgyMDM1IDUxLjAyNzA1Niw1MC45MzYxNDdcIn0nIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICAgICAgZWFzaW5nIDogbWluYS5lbGFzdGljLCBzcGVlZDogMTIwMCwgc2l6ZSA6IHt3IDogJzRlbScsIGggOiAnM2VtJ31cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobWFpbk5vZGUuY2xhc3NMaXN0LmNvbnRhaW5zKCdjLW9wZW4nKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbk5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1vcGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluTm9kZS5jbGFzc0xpc3QuYWRkKCdjLW9wZW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd1Jlc291cmNlQnVuZGxlRWRpdG9yIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAvLyByZWxvYWQgdGhlIHBhZ2UgYmVjYXVzZSB0aGUgZmlsZXMgYXJlIG5vdCBzeW5jZWRcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsICcjJyk7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9jYXRpb24ucmVsb2FkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd01lc3NhZ2VCdW5kbGVGb3JtYXQgOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU2hvd0pNQkZRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0pTT05CdW5kbGUgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvblNob3dKU09OUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dKTUJGVXBsb2FkZXIgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvblNob3dKTUJGVXBsb2FkZXJRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0pTT05JbXBvcnQgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvblNob3dKU09OSW1wb3J0UXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZUVkaXRvck1vZGUgOiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICBvbkVuYWJsZUVkaXRvck1vZGVRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9nZ2xlV29yZENvdW50IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb25Ub2dnbGVXb3JkQ291bnRRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZnJvbSA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5mcm9tLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnRvLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gbG9jYWxlcyBbXVxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZXMsIG5vZGUpIHtcbiAgICAgICAgdmFyIHVsID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcubGFuZ3VhZ2VzJyksIGxpLCBsYW5ndWFnZU5hbWVOb2RlLCBwcm9ncmVzc05vZGUsIGZsYWdJQztcbiAgICAgICAgaWYgKHVsKSB7XG4gICAgICAgICAgICAvLyByZW1vdmUgYWxsIGV4aXN0aW5nIGNoaWxkcmVuIGZpcnN0XG4gICAgICAgICAgICBbXS5zbGljZS5jYWxsKHVsLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpJykpLmZvckVhY2goZnVuY3Rpb24gKGVsZW0pIHtcbiAgICAgICAgICAgICAgICB1bC5yZW1vdmVDaGlsZChlbGVtKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdWwgPSB3aW5kb3cuZG9tT3B0cy5jcmVhdGVFbGVtZW50KCd1bCcsIG51bGwsICduYXZpZ2F0aW9uTWVudSBsYW5ndWFnZXMnKTtcbiAgICAgICAgfVxuICAgICAgICBsb2NhbGVzLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdmFyIG51bU9mVHJhbnNLZXlzID0gd2luZG93LmRvbU9wdHMuY3JlYXRlRWxlbWVudCgnc3BhbicsIG51bGwsICdudW1PZlRyYW5zS2V5cycpLFxuICAgICAgICAgICAgICAgIG1heEtleU5vZGUgPSB3aW5kb3cuZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ21heEtleScpO1xuICAgICAgICAgICAgbGkgPSB3aW5kb3cuZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdsaScpO1xuICAgICAgICAgICAgbGFuZ3VhZ2VOYW1lTm9kZSA9IHdpbmRvdy5kb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgIHByb2dyZXNzTm9kZSA9IHdpbmRvdy5kb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBudWxsLCAncHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgIG51bU9mVHJhbnNLZXlzLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCctJykpO1xuICAgICAgICAgICAgbnVtT2ZUcmFuc0tleXMuZG9tQXBwZW5kVG8ocHJvZ3Jlc3NOb2RlKTtcbiAgICAgICAgICAgIHByb2dyZXNzTm9kZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLycpKTtcbiAgICAgICAgICAgIG1heEtleU5vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy0nKSk7XG4gICAgICAgICAgICBtYXhLZXlOb2RlLmRvbUFwcGVuZFRvKHByb2dyZXNzTm9kZSk7XG5cbiAgICAgICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoJ2xhbmcnKTtcbiAgICAgICAgICAgIGxpLmNsYXNzTGlzdC5hZGQoa2V5KTtcblxuICAgICAgICAgICAgbGkuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5hY3RpdmUgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZSA9IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdjLWFjdGl2ZScpO1xuXG4gICAgICAgICAgICAgICAgaWYgKGlzQWN0aXZlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xhc3NMaXN0LnRvZ2dsZSgnYy1pbmFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICBpc0luYWN0aXZlID0gdGhpcy5jbGFzc0xpc3QuY29udGFpbnMoJ2MtaW5hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbm8gc3RhdGVcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBzZWxlY3RMYW5ndWFnZVF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgIGZjKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzQWN0aXZlIDogaXNBY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBpc0luYWN0aXZlIDogaXNJbmFjdGl2ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3QgOiBidW5kbGVOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2U6IGtleVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBsYW5ndWFnZU5hbWVOb2RlLmlubmVySFRNTCA9IHRleHRzLmdldExhbmd1YWdlTmFtZXMoa2V5KTtcbiAgICAgICAgICAgIGxhbmd1YWdlTmFtZU5vZGUuY2xhc3NOYW1lID0gJ2xhbmdOYW1lJztcbiAgICAgICAgICAgIGxhbmd1YWdlTmFtZU5vZGUuZG9tQXBwZW5kVG8obGkpO1xuICAgICAgICAgICAgcHJvZ3Jlc3NOb2RlLmRvbUFwcGVuZFRvKGxpKTtcbiAgICAgICAgICAgIGZsYWdJQyA9IGZsYWcuZ2V0RmxhZyhrZXkpO1xuICAgICAgICAgICAgZmxhZ0lDLmNsYXNzTGlzdC5hZGQoJ2ljb24nLCAnb2N0aWNvbicsICdvY3RpY29uLXBsdXMnKTtcbiAgICAgICAgICAgIGZsYWdJQy5kb21BcHBlbmRUbyhsaSk7XG4gICAgICAgICAgICBsaS5kb21BcHBlbmRUbyh1bCk7XG4gICAgICAgIH0pO1xuICAgICAgICB1bC5kb21BcHBlbmRUbyhub2RlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiB1cGRhdGUgYWxsIGxhbmd1YWdlIG1heCBrZXlzIGZvciBhbGwgbGFuZ3VhZ2VzXG4gICAgICogQHBhcmFtIGtleXNcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZU1heEtleXMoa2V5cywgbm9kZSkge1xuICAgICAgICBbXS5zbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnLmxhbmd1YWdlcyAubGFuZycpKS5mb3JFYWNoKGZ1bmN0aW9uKGxhbmdOb2RlKSB7XG4gICAgICAgICAgICBsYW5nTm9kZS5xdWVyeVNlbGVjdG9yKCcubWF4S2V5JykuaW5uZXJIVE1MID0ga2V5cztcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIGEgc3BlY2lmaWMgbGFuZ3VhZ2VcbiAgICAgKiBAcGFyYW0ga2V5XG4gICAgICogQHBhcmFtIGxhbmdcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVwZGF0ZU51bWJlck9mTGFuZ0tleXMoa2V5LCBsYW5nLCBub2RlKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb246dXBkYXRlTnVtYmVyT2ZMYW5nS2V5cycsIGtleSwgbGFuZyk7XG4gICAgICAgIG5vZGUucXVlcnlTZWxlY3RvcignLmxhbmd1YWdlcyAubGFuZy4nICsgbGFuZyArICcgLm51bU9mVHJhbnNLZXlzJykuaW5uZXJIVE1MID0ga2V5O1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIHNldE51bWJlck9mVHJhbnNsYXRpb25NYXhLZXlzIDogZnVuY3Rpb24gKG1heEtleXMpIHtcbiAgICAgICAgICAgIHVwZGF0ZU1heEtleXMobWF4S2V5cywgbW9kVmlld3MuZnJvbS5ub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2V0TnVtYmVyT2ZUcmFuc2xhdGVkTGFuZ3VhZ2VLZXkgOiBmdW5jdGlvbiAobnVtYmVyT2ZLZXlzLCBsYW5nKSB7XG4gICAgICAgICAgICB1cGRhdGVOdW1iZXJPZkxhbmdLZXlzKG51bWJlck9mS2V5cywgbGFuZywgbW9kVmlld3MuZnJvbS5ub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25MYW5ndWFnZVNlbGVjdCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgc2VsZWN0TGFuZ3VhZ2VRdWV1ZS5wdXNoKGZjKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TaG93SlNPTiA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25TaG93SlNPTlF1ZXVlLnB1c2goZmMpO1xuICAgICAgICB9LFxuICAgICAgICBvblNob3dKTUJGIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICBvblNob3dKTUJGUXVldWUucHVzaChmYyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2hvd0pNQkZVcGxvYWRlciA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25TaG93Sk1CRlVwbG9hZGVyUXVldWUucHVzaChmYyk7IFxuICAgICAgICB9LFxuICAgICAgICBvblNob3dKU09OSW1wb3J0IDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICBvblNob3dKU09OSW1wb3J0UXVldWUucHVzaChmYyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRW5hYmxlRWRpdG9yTW9kZSA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25FbmFibGVFZGl0b3JNb2RlUXVldWUucHVzaChmYyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uVG9nZ2xlV29yZENvdW50IDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICBvblRvZ2dsZVdvcmRDb3VudFF1ZXVlLnB1c2goZmMpO1xuICAgICAgICB9LFxuICAgICAgICBhY3RpdmF0ZUxhbmcgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBtYWluTm9kZS5xdWVyeVNlbGVjdG9yKCdsaS4nICsgbGFuZyk7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2MtaW5hY3RpdmUnKTtcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnYy1hY3RpdmUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVBY3RpdmF0ZUxhbmcgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgdmFyIG5vZGUgPSBtYWluTm9kZS5xdWVyeVNlbGVjdG9yKCdsaS4nICsgbGFuZyk7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2MtaW5hY3RpdmUnKTtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEFwcGx5IHRoZSBjdXJyZW50IHByb2plY3QncyBudW1iZXIgdG8gdGhlIGZsYWdzOiBhY3RpdmF0ZSBmbGFnIHdoZXJlIHRyYW5zbGF0aW9ucyBleGlzdCBhbmQgc2hvdyBudW1iZXIgb2ZcbiAgICAgICAgICogdHJhbnNsYXRlZCBrZXlzLlxuICAgICAgICAgKiBAcGFyYW0ga2V5c1RvdGFsIHRoZSB0b3RhbCBudW1iZXIgb2Yga2V5c1xuICAgICAgICAgKiBAcGFyYW0gdHJhbnNsYXRlZEtleXNQZXJMYW5nIHRoZSBudW1iZXIgb2YgdHJhbnNsYXRlZCBrZXlzIHBlciBsYW5ndWFnZVxuICAgICAgICAgKi9cbiAgICAgICAgc2V0QWN0aXZhdGVkUHJvamVjdExhbmd1YWdlcyA6IGZ1bmN0aW9uIChrZXlzVG90YWwsIHRyYW5zbGF0ZWRLZXlzUGVyTGFuZykge1xuICAgICAgICAgICAgW10uc2xpY2UuY2FsbChtYWluTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcignLnByb2dyZXNzJyk7XG4gICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgIGlmIChwcm9ncmVzc05vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NOb2RlLmNoaWxkcmVuWzBdLmlubmVySFRNTCA9IFwiLVwiO1xuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc05vZGUuY2hpbGRyZW5bMV0uaW5uZXJIVE1MID0gXCItXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHRyYW5zbGF0ZWRLZXlzUGVyTGFuZykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChtYWluTm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdsaS4nICsga2V5KSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcHJvZ3Jlc3NOb2RlID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcucHJvZ3Jlc3MnKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdjLWFjdGl2ZScpO1xuICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTm9kZS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSB0cmFuc2xhdGVkS2V5c1Blckxhbmdba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NOb2RlLmNoaWxkcmVuWzFdLmlubmVySFRNTCA9IGtleXNUb3RhbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgc2V0QXZhaWxhYmxlTGFuZ3VhZ2VzIDogZnVuY3Rpb24gKGxhbmd1YWdlcykge1xuICAgICAgICAgICAgc2V0TG9jYWxlKGxhbmd1YWdlcywgbW9kVmlld3MuZnJvbS5ub2RlKTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnbmF2LWNvbnRyb2xsZXIgcmVhZHkgZXZlbnQnKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHsgICAgLy8gcGFydCBvZiBhcGlcbiAgICAgICAgICAgIGlmIChtb2RWaWV3cy5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgICAgIG1vZFZpZXdzW2F0dHJdKG5vZGUpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnTElOSyBOT1QgSU1QTEVNRU5URUQnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59KCkpO1xuXG5tb2R1bGUuZXhwb3J0cyA9ICBwcm9qZWN0TWFpbk5hdmlnYXRpb247IiwidmFyIHByb2plY3RPdmVydmlldyA9IChmdW5jdGlvbigpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgY29tcG9uZW50Um9vdE5vZGUsXG4gICAgICAgIHJlbmRlclByb2plY3RzQW5kRGlyZWN0b3JpZXNMaXN0LFxuICAgICAgICBvbkNyZWF0ZVByb2plY3RQcmVzc2VkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uQ3JlYXRlUHJvamVjdFByZXNzZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25QYXJlbnREaXJlY3RvcnlTZWxlY3RlZCA9IGZ1bmN0aW9uKCkge2NvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uUGFyZW50RGlyZWN0b3J5U2VsZWN0ZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25Qcm9qZWN0U2VsZWN0ZWQgPSBmdW5jdGlvbigpIHsgY29uc29sZS53YXJuKCdwcm9qZWN0T3ZlcnZpZXcub25Qcm9qZWN0U2VsZWN0ZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25EZWxldGVQcm9qZWN0UHJlc3NlZCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4oJ3Byb2plY3RPdmVydmlldy5vbkRlbGV0ZVByb2plY3RQcmVzc2VkIG5vdCBzZXQnKX0sXG4gICAgICAgIG9uTW92ZWRQcm9qZWN0UHJlc3NlZCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4oJ3Byb2plY3RPdmVydmlldy5vbk1vdmVkUHJvamVjdFByZXNzZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25EZWxldGVGb2xkZXJQcmVzc2VkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uRGVsZXRlRm9sZGVyUHJlc3NlZCBub3Qgc2V0Jyl9LFxuICAgICAgICBvbkRpcmVjdG9yeVNlbGVjdGVkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uRGlyZWN0b3J5U2VsZWN0ZWQgbm90IHNldCcpfSxcbiAgICAgICAgb25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uQ3JlYXRlRGlyZWN0b3J5UHJlc3NlZCBub3Qgc2V0Jyl9LFxuICAgICAgICBlZGl0TW9kZUVuYWJsZWQgPSBmYWxzZTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgZnJvbSBjYW5ueSB3aGVuIHJlZ2lzdGVyaW5nIGNvbXBvbmVudHMuIFRoZSBvbmx5IGNvbXBvbmVudCB3aGljaCB3ZSBleHBlY3QgdG8gYmUgcmVnaXN0ZXJlZCBpc1xuICAgICAgICAgKiBcInByb2plY3RPdmVydmlld0NvbnRhaW5lclwiICh0aGUgcm9vdCBub2RlIG9mIHRoZSBjb21wb25lbnQpLlxuICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgKiBAcGFyYW0gdmFyc1xuICAgICAgICAgKi9cbiAgICAgICAgYWRkOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICAgICAgaWYgKGNvbXBvbmVudFJvb3ROb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb21wb25lbnRSb290Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3OmFkZCBtdWx0aXBsZSB2aWV3cyBkZXRlY3RlZCAtIGl0IHNob3VsZCBiZSByZWdpc3RlcmVkIG9ubHkgb25lcyBpbiB0aGUgRE9NIScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGVkIGZyb20gY2Fubnkgb24gZG9jdW1lbnRSZWFkeSBldmVudC5cbiAgICAgICAgICovXG4gICAgICAgIHJlYWR5OiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgdmFyIGNyZWF0ZVByb2plY3RCdXR0b25Ob2RlID0gY29tcG9uZW50Um9vdE5vZGUucXVlcnlTZWxlY3RvcignLmpzLWNyZWF0ZVByb2plY3RCdXR0b24nKTtcbiAgICAgICAgICAgIGlmICghY3JlYXRlUHJvamVjdEJ1dHRvbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBjaGlsZCBub2RlIHdpdGggY2xhc3MgXCJjcmVhdGVQcm9qZWN0QnV0dG9uIGZvdW5kIGluc2lkZSBcInByb2plY3RPdmVydmlld0NvbnRhaW5lclwiJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNyZWF0ZVByb2plY3RCdXR0b25Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DcmVhdGVQcm9qZWN0UHJlc3NlZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgY3JlYXRlRm9sZGVyQnV0dG9uTm9kZSA9IGNvbXBvbmVudFJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy1jcmVhdGVGb2xkZXJCdXR0b24nKTtcbiAgICAgICAgICAgIGlmICghY3JlYXRlRm9sZGVyQnV0dG9uTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGNoaWxkIG5vZGUgd2l0aCBjbGFzcyBcImNyZWF0ZUZvbGRlckJ1dHRvbiBmb3VuZCBpbnNpZGUgXCJwcm9qZWN0T3ZlcnZpZXdDb250YWluZXJcIicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjcmVhdGVGb2xkZXJCdXR0b25Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciB0b2dnbGVFZGl0TW9kZUJ1dHRvbk5vZGUgPSBjb21wb25lbnRSb290Tm9kZS5xdWVyeVNlbGVjdG9yKCcuanMtdG9nZ2xlRWRpdE1vZGVCdXR0b24nKTtcbiAgICAgICAgICAgIGlmICghdG9nZ2xlRWRpdE1vZGVCdXR0b25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gY2hpbGQgbm9kZSB3aXRoIGNsYXNzIFwiY3JlYXRlRm9sZGVyQnV0dG9uIGZvdW5kIGluc2lkZSBcInByb2plY3RPdmVydmlld0NvbnRhaW5lclwiJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvZ2dsZUVkaXRNb2RlQnV0dG9uTm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGVkaXRNb2RlRW5hYmxlZCA9ICFlZGl0TW9kZUVuYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudFJvb3ROb2RlLmNsYXNzTGlzdC50b2dnbGUoJ2VkaXRNb2RlLWVuYWJsZWQnLCBlZGl0TW9kZUVuYWJsZWQpO1xuICAgICAgICAgICAgICAgICAgICB0b2dnbGVFZGl0TW9kZUJ1dHRvbk5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgnYWN0aXZlJywgZWRpdE1vZGVFbmFibGVkKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHNlbGVjdFBhcmVudERpcmVjdG9yeUJ1dHRvbiA9IGNvbXBvbmVudFJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy1zZWxlY3RQYXJlbnREaXJlY3RvcnlCdXR0b24nKTtcbiAgICAgICAgICAgIGlmICghc2VsZWN0UGFyZW50RGlyZWN0b3J5QnV0dG9uKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gY2hpbGQgbm9kZSB3aXRoIGNsYXNzIFwic2VsZWN0UGFyZW50RGlyZWN0b3J5QnV0dG9uXCIgZm91bmQgaW5zaWRlIFwicHJvamVjdE92ZXJ2aWV3Q29udGFpbmVyXCInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc2VsZWN0UGFyZW50RGlyZWN0b3J5QnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgb25QYXJlbnREaXJlY3RvcnlTZWxlY3RlZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogSW5mb3JtIHRoZSB1aSBtb2R1bGUgYWJvdXQgdGhlIG5ldyBjdXJyZW50IHNldCBvZiBkaXJlY3RvcmllcyBhbmQgcHJvamVjdHMgdG8gbGlzdC4gVGhpcyB3aWxsIGFsc28gdHJpZ2dlclxuICAgICAgICAgKiBhIG5ldyByZW5kZXJpbmcgb2YgdGhlIHByb2plY3RzIGxpc3Qgd2l0aCB0aGUgbmV3IGNvbnRlbnQuXG4gICAgICAgICAqIEBwYXJhbSBwcm9qZWN0TmFtZXNcbiAgICAgICAgICogQHBhcmFtIGRpcmVjdG9yeU5hbWVzXG4gICAgICAgICAqL1xuICAgICAgICBzZXRQcm9qZWN0c0FuZERpcmVjdG9yaWVzOiBmdW5jdGlvbiAocHJvamVjdE5hbWVzLCBkaXJlY3RvcnlOYW1lcykge1xuICAgICAgICAgICAgdmFyIHByb2plY3RzQW5kRGlyZWN0b3JpZXMgPSBbXTtcblxuICAgICAgICAgICAgaWYgKCFwcm9qZWN0TmFtZXMgfHwgIWRpcmVjdG9yeU5hbWVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfSBlbHNlIGlmICghcmVuZGVyUHJvamVjdHNBbmREaXJlY3Rvcmllc0xpc3QpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZW5kZXJQcm9qZWN0c0FuZERpcmVjdG9yaWVzTGlzdCBmdW5jdGlvbiBoYXMgbm90IGJlZW4gc2V0LCBuZXcgbGlzdCBjYW5ub3QgYmUgc2hvd24nKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdnb3QgcHJvamVjdHMnLCBwcm9qZWN0TmFtZXMpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dvdCBkaXJlY3RvcmllcycsIGRpcmVjdG9yeU5hbWVzKTtcblxuICAgICAgICAgICAgcHJvamVjdE5hbWVzLmZvckVhY2goZnVuY3Rpb24ocHJvamVjdE5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0c0FuZERpcmVjdG9yaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lIDogcHJvamVjdE5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGRpciA6IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuUHJvamVjdExpc3RJdGVtIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3Qgc2VsZWN0ZWQ6JywgcHJvamVjdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uUHJvamVjdFNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25Qcm9qZWN0U2VsZWN0ZWQocHJvamVjdE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9qZWN0TGlzdEl0ZW0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGlvbkNvbmZpcm1lZCA9IHdpbmRvdy5jb25maXJtKCdSZWFsbHkgZGVsZXRlIHByb2plY3QgJyArIHByb2plY3ROYW1lICsgJz8nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkRlbGV0ZVByb2plY3RQcmVzc2VkICYmIGRlbGV0aW9uQ29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGVQcm9qZWN0UHJlc3NlZChwcm9qZWN0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIG1vdmVQcm9qZWN0IDogKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25Nb3ZlZFByb2plY3RQcmVzc2VkKHByb2plY3ROYW1lKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRpcmVjdG9yeU5hbWVzLmZvckVhY2goZnVuY3Rpb24oZGlyZWN0b3J5TmFtZSkge1xuICAgICAgICAgICAgICAgIHByb2plY3RzQW5kRGlyZWN0b3JpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgOiBkaXJlY3RvcnlOYW1lLFxuICAgICAgICAgICAgICAgICAgICBkaXIgOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBvcGVuUHJvamVjdExpc3RJdGVtIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnZGlyZWN0b3J5IHNlbGVjdGVkOicsIGRpcmVjdG9yeU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGlyZWN0b3J5U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRpcmVjdG9yeVNlbGVjdGVkKGRpcmVjdG9yeU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBkZWxldGVQcm9qZWN0TGlzdEl0ZW0gOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBkZWxldGlvbkNvbmZpcm1lZCA9IHdpbmRvdy5jb25maXJtKCdSZWFsbHkgZGVsZXRlIGZvbGRlciAnICsgZGlyZWN0b3J5TmFtZSArICc/Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25EZWxldGVGb2xkZXJQcmVzc2VkICYmIGRlbGV0aW9uQ29uZmlybWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGVGb2xkZXJQcmVzc2VkKGRpcmVjdG9yeU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgcmVuZGVyUHJvamVjdHNBbmREaXJlY3Rvcmllc0xpc3QocHJvamVjdHNBbmREaXJlY3Rvcmllcyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGb3IgY2FubnktcmVwZWF0IHJlZ2lzdGVyZWQgb24gdGhlIHByb2plY3RzIGxpc3QsIHByb3ZpZGUgdGhlIGZ1bmN0aW9uIGZvciByZW5kZXJpbmcgdGhlIGxpc3QuXG4gICAgICAgICAqIEBwYXJhbSBmdW5jIGEgZnVuY3Rpb24gd2hpY2ggd2lsbCBzZXQgdGhlIGxpc3Qgb2YgcHJvamVjdHMgYW5kIGRpcmVjdG9yaWVzLlxuICAgICAgICAgKi9cbiAgICAgICAgc2V0UmVuZGVyUHJvamVjdHNBbmREaXJlY3Rvcmllc0xpc3RGdW5jdGlvbiA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgIHJlbmRlclByb2plY3RzQW5kRGlyZWN0b3JpZXNMaXN0ID0gZnVuYztcbiAgICAgICAgfSxcbiAgICAgICAgZGVsZXRlUHJvamVjdExpc3ROb2RlIDogZnVuY3Rpb24oaXRlbU5hbWUpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gY29tcG9uZW50Um9vdE5vZGUucXVlcnlTZWxlY3RvcigndHJbZGF0YS1saXN0SXRlbT0nICsgaXRlbU5hbWUgKyAnXScpO1xuICAgICAgICAgICAgaWYgKG5vZGUgJiYgbm9kZS5wYXJlbnROb2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBjYWxsYmFjayB3aGljaCB3aWxsIHJlYWN0IHRvIFwidG8gcGFyZW50IGRpcmVjdG9yeVwiIGV2ZW50LlxuICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgICAgICovXG4gICAgICAgIG9uUGFyZW50RGlyZWN0b3J5U2VsZWN0ZWQgOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgb25QYXJlbnREaXJlY3RvcnlTZWxlY3RlZCA9IGxpc3RlbmVyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBjYWxsYmFjayB3aGljaCB3aWxsIHJlYWN0IHRvIGNsaWNrcyBvbiBhIHByb2plY3QuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBzaG91bGQgZXhwZWN0XG4gICAgICAgICAqIG9uZSBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlIHByb2plY3QgbmFtZS5cbiAgICAgICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICAgICAqL1xuICAgICAgICBvblByb2plY3RTZWxlY3RlZCA6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvblByb2plY3RTZWxlY3RlZCA9IGxpc3RlbmVyO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogUmVnaXN0ZXIgYSBsaXN0ZW5lciBjYWxsYmFjayB3aGljaCB3aWxsIHJlYWN0IHRvIGNsaWNrcyBvbiBhIGRpcmVjdG9yeS4gVGhlIGNhbGxiYWNrIGZ1bmN0aW9uIHNob3VsZCBleHBlY3RcbiAgICAgICAgICogb25lIHBhcmFtZXRlciB3aGljaCBpcyB0aGUgZGlyZWN0b3J5IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAgICAgKi9cbiAgICAgICAgb25EaXJlY3RvcnlTZWxlY3RlZCA6IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBvbkRpcmVjdG9yeVNlbGVjdGVkID0gbGlzdGVuZXI7XG4gICAgICAgIH0sXG4gICAgICAgIG9uQ3JlYXRlUHJvamVjdFByZXNzZWQgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBvbkNyZWF0ZVByb2plY3RQcmVzc2VkID0gZnVuYztcbiAgICAgICAgfSxcbiAgICAgICAgb25EZWxldGVQcm9qZWN0UHJlc3NlZCA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgICAgIG9uRGVsZXRlUHJvamVjdFByZXNzZWQgPSBmdW5jO1xuICAgICAgICB9LFxuICAgICAgICBvbkRlbGV0ZUZvbGRlclByZXNzZWQgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBvbkRlbGV0ZUZvbGRlclByZXNzZWQgPSBmdW5jO1xuICAgICAgICB9LFxuICAgICAgICBvbkNyZWF0ZURpcmVjdG9yeVByZXNzZWQgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBvbkNyZWF0ZURpcmVjdG9yeVByZXNzZWQgPSBmdW5jO1xuICAgICAgICB9LFxuICAgICAgICBvbk1vdmVEaXJlY3RvcnlQcmVzc2VkIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgb25Nb3ZlZFByb2plY3RQcmVzc2VkID0gZnVuYztcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2plY3RPdmVydmlldztcbiIsIi8qKlxuICogaGFuZGxlcyBhbGwgdGV4dHNcbiAqL1xudmFyIHRleHRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIG5vZGUsXG4gICAgICAgIGxhbmd1YWdlTmFtZXMgPSB7XG4gICAgICAgICAgICBkYTogJ0Rhbm1hcmsnLFxuICAgICAgICAgICAgZGU6ICdEZXV0c2NobGFuZCcsXG4gICAgICAgICAgICBmcjogJ0ZyYW5jZScsXG4gICAgICAgICAgICBubDogJ05lZGVybGFuZCcsXG4gICAgICAgICAgICBlbjogJ1VuaXRlZCBTdGF0ZXMgKERlZmF1bHQpJyxcbiAgICAgICAgICAgIGVuX0dCOiAnVW5pdGVkIEtpbmdkb20nLFxuICAgICAgICAgICAgc3Y6ICdTdmVyaWdlJyxcbiAgICAgICAgICAgIGVzOiAnRXNwYW5vbCdcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dHMgPSB7XG4gICAgICAgICAgICBjaGFuZ2VUZXh0cyA6ICBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIGRhdGEgOiB7XG4gICAgICAgICAgICAgICAgcHJvamVjdE5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHByb2plY3REZXNjcmlwdGlvbjogJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldExhbmd1YWdlTmFtZXMgOiBmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGxhbmd1YWdlTmFtZXNba2V5XX0sXG4gICAgICAgIHNldFRleHRzIDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRleHRzLmNoYW5nZVRleHRzKCdtc2cnLCBkYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGV4dHMgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0ZXh0czp5ZXMgdGV4dCBpcyB0cmlnZ2VyZWQnKTtcbiAgICAgICAgICAgIHRleHRzLmNoYW5nZVRleHRzID0gZmM7XG4gICAgICAgICAgICB0ZXh0cy5jaGFuZ2VUZXh0cygnbXNnJywgdGV4dHMuZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChlbGVtLCBhdHRyKSB7XG4gICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndGV4dHMgcmVhZHkhJyk7XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0ZXh0czsiLCJ2YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZy5qcycpLFxuICAgIGlucHV0RWRpdE1hbmFnZXIgPSByZXF1aXJlKCcuL2lucHV0RWRpdE1hbmFnZXIuanMnKSxcbiAgICB3b3JkQ291bnRlciA9IHJlcXVpcmUoJy4uL3V0aWwvd29yZENvdW50ZXInKSxcbiAgICBkaXNwbGF5TWFuYWdlciA9IHJlcXVpcmUoJ2Nhbm55JykuZGlzcGxheU1hbmFnZXIsXG4gICAgY29uZiA9IHtcbiAgICAgICAgcm93UHJlZml4OiBcInR2X1wiLFxuICAgICAgICBpbnB1dFByZWZpeDogXCJrZXlWYWx1ZV9cIixcbiAgICAgICAgaW5wdXRUcmFuc1ByZWZpeDogXCJ0cmFuc19cIlxuICAgIH0sXG4gICAgY2F0UHJlZml4ID0gJ3R2Xyc7XG4vKipcbiAqIFJlbmFtZSBhbGwgRE9NIGlkIGF0dHJpYnV0ZXMgZnJvbSBvbGQgdG8gbmV3IGtleVxuICogQHBhcmFtIG9sZEtleVxuICogQHBhcmFtIG5ld0tleVxuICovXG5mdW5jdGlvbiByZW5hbWVET01JZHMob2xkS2V5LCBuZXdLZXksIGF2YWlsYWJsZUxhbmd1YWdlcykge1xuICAgIE9iamVjdC5rZXlzKGNvbmYpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHByb3AgPT09ICdpbnB1dFRyYW5zUHJlZml4Jykge1xuICAgICAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VzLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChnZXRMYW5ndWFnZVRleHRJZChvbGRLZXksIGxhbmcpKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaWQnLCBnZXRMYW5ndWFnZVRleHRJZChuZXdLZXksIGxhbmcpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2xhdGlvblZpZXc6cmVuYW1lSWRzIGNhbiBub3QgZmluZCBkb20gbm9kZSBmb3IgaWQnLCBnZXRMYW5ndWFnZVRleHRJZChuZXdLZXksIGxhbmcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmZbcHJvcF0gKyBvbGRLZXkpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaWQnLCBjb25mW3Byb3BdICsgbmV3S2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3OnJlbmFtZUlkcyBjYW4gbm90IGZpbmQgZG9tIG5vZGUgZm9yIGlkJywgY29uZltwcm9wXSArIG9sZEtleSwgJ3Byb3BlcnR5OicsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHRleHRBcmVhS2V5UHJlc3NMaXN0ZW5lcihlKSB7XG4gICAgdmFyIGtleSA9IGUua2V5Q29kZSB8fCBlLndoaWNoO1xuICAgIC8vIFRPRE8gYWxsb3cgZW50ZXIgLSBpdCdzIHVzZWZ1bCBmb3IgZm9ybWF0dGluZyBhIHRleHQgLSBidXQgaXQncyBhIG1lc3MgZm9yIGFsbCBvdGhlclxuICAgIGlmIChrZXkgPT09IDEzKSB7XG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGtleUtleVByZXNzTGlzdGVuZXIoZSkge1xuICAgIHZhciBrZXkgPSBlLmtleUNvZGUgfHwgZS53aGljaDtcbiAgICBpZiAoa2V5ID09PSAzMikge1xuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0tleShzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZy5sZW5ndGggPiAwICYmIHN0cmluZy5zZWFyY2goJ1xcXFwufCx8ICcpID09PSAtMSkgPyB0cnVlIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldExhbmd1YWdlVGV4dElkKGtleSwgbGFuZykge1xuICAgIHJldHVybiBjb25mLmlucHV0VHJhbnNQcmVmaXggKyBba2V5LCBsYW5nXS5qb2luKCdfJyk7XG59XG5cbmZ1bmN0aW9uIGdldFdvcmRDb3VudFRleHQoY291bnQpIHtcbiAgICByZXR1cm4gJ1dvcmRzOiAnICsgY291bnQ7XG59XG5cbi8qKlxuICogQ291bnQgb25seSBsZXR0ZXJzXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyQ291bnQodmFsdWUpIHtcbiAgICB3aGlsZSAoL3suKj99Ly50ZXN0KHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC97Lio/fS8sICcnKVxuXG4gICAgcmV0dXJuIFsuLi52YWx1ZV0uZmlsdGVyKChjaGFyKSA9PiAvW2EtekEtel0vLnRlc3QoY2hhcikpLmxlbmd0aFxufVxuXG5mdW5jdGlvbiBnZXRXb3JkQ291bnRIZWFkbGluZShjYXRlZ29yeSkge1xuICAgIHJldHVybiAnT3ZlcmFsbCB3b3JkcyBpbiAnICsgY2F0ZWdvcnk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmRDb3VudEZvckxhbmd1YWdlKGxhbmcpIHtcbiAgICB2YXIgY291bnRXcmFwcGVyID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnZGF0YSBqc18nICsgbGFuZyksXG4gICAgICAgIGZsYWdDbGFzcyA9IGZsYWcuZ2V0RmxhZ0NsYXNzZXMobGFuZykucG9wKCksXG4gICAgICAgIHdvcmRDb3VudExhYmVsID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ3dvcmRDb3VudExhYmVsICcuY29uY2F0KGZsYWdDbGFzcykpO1xuICAgIHdvcmRDb3VudExhYmVsLmlubmVySFRNTCA9IGdldFdvcmRDb3VudFRleHQoMCk7XG4gICAgY291bnRXcmFwcGVyLmFwcGVuZENoaWxkKHdvcmRDb3VudExhYmVsKTtcbiAgICByZXR1cm4gY291bnRXcmFwcGVyO1xufVxuXG4vKipcbiAqIGhhbmRsZSB0aGUgdHJhbnNsYXRpb24gb3ZlcnZpZXdcbiAqIFRPRE8gcmVmYWN0b3IgYmFzZS5jb25uZWN0aW9uXG4gKi9cbnZhciB0cmFuc2xhdGlvblZpZXcgPSAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogVE9ETyByZW1vdmUgcHJvamVjdCBuYW1lIC0gb25seSB0aGUgY29udHJvbGxlciBuZWVkcyB0byBrbm93IHRoaXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQGRlcHJlY2F0ZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTYXZlT25MZWF2ZShub2RlLCBrZXksIGxhbmcsIHRleHQpIHtcbiAgICAgICAgdmFyIHRleHRMaXN0ID0gW3RleHRdLFxuICAgICAgICAgICAgdGV4dElkeCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSBpZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0SWRGcm9tUm93KG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnaWQnKS5yZXBsYWNlKGNvbmYucm93UHJlZml4LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT2xkOiBcIiArIHRleHRMaXN0W3RleHRJZHhdKTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBpZiAodGV4dExpc3RbdGV4dElkeF0gIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGV4dExpc3QucHVzaChuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGV4dElkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2codGV4dExpc3QpO1xuICAgICAgICAgICAgb25TYXZlS2V5ICYmIG9uU2F2ZUtleShnZXRJZEZyb21Sb3cobm9kZSksIGxhbmcsIG5ld1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgdGhlIGF0dGFjaGVkIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIG5vZGUuXG4gICAgICogSXQgcmVtb3ZlcyB0aGUgJ2NoYW5nZScgYW5kICdrZXlwcmVzcycgZXZlbnQgZnJvbSBhbGwgdGV4dEFyZWEncyBhbmQgaW5wdXQgZmllbGRzIGFuZFxuICAgICAqIHNldCBpdCB0byBcInJlYWQgb25seVwiXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb3dOb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnNGcm9tUm93KHJvd05vZGUpIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChyb3dOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJykpLmZvckVhY2goZnVuY3Rpb24odGFyZWEpIHtcbiAgICAgICAgICAgIHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhbHNlKTtcbiAgICAgICAgICAgIHRhcmVhLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAndHJ1ZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBbXS5zbGljZS5jYWxsKHJvd05vZGUucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSkuZm9yRWFjaChmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmYWxzZSk7XG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JywgJ3RydWUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjYXROb2RlVG9JbnNlcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5PEhUTUxFbGVtZW50Pn0gY2F0Tm9kZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRDYXRlZ29yeShjYXROb2RlVG9JbnNlcnQsIGNhdE5vZGVzKSB7XG4gICAgICAgIHZhciBjYXRUb0FwcGVuZElEID0gY2F0Tm9kZVRvSW5zZXJ0LmlkLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBzaG93bkNhdE5vZGUsXG4gICAgICAgICAgICBzaG93bkNhdElEO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNob3duQ2F0Tm9kZSA9IGNhdE5vZGVzW2ldO1xuICAgICAgICAgICAgc2hvd25DYXRJRCA9IGNhdE5vZGVzW2ldLmlkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoY2F0VG9BcHBlbmRJRCA8IHNob3duQ2F0SUQpIHtcbiAgICAgICAgICAgICAgICByb290Tm9kZS5pbnNlcnRCZWZvcmUoY2F0Tm9kZVRvSW5zZXJ0LCBzaG93bkNhdE5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhdE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBjYXRUb0FwcGVuZElEID4gc2hvd25DYXRJRCkge1xuICAgICAgICAgICAgcm9vdE5vZGUuYXBwZW5kQ2hpbGQoY2F0Tm9kZVRvSW5zZXJ0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb290Tm9kZSwgLy8gbWFpbiBub2RlIGFsbCBjb250ZW50IGFyZSBhZGRlZCB0byBoZXJlXG4gICAgICAgIHJlbmRlclRleHRGYyxcbiAgICAgICAgc2VsZWN0b3JzID0ge1xuICAgICAgICAgICAgcm9vdDogXCJyZXNvdXJjZUJ1bmRsZVRhYmxlXCIsXG4gICAgICAgICAgICBkZWJ1ZzogXCJkZWJ1Z0luY29tbWluZ1wiLFxuICAgICAgICAgICAgdHBsOiB7XG4gICAgICAgICAgICAgICAgdGFibGVCb2R5OiAndGFibGVCb2R5J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBRVUVTVElPTjogYXJlIHRoZXNlIHJlYWwgcXVldWVzP1xuICAgICAgICBvblF1ZXVlcyA9IHtcbiAgICAgICAgICAgIGFkZE5ld0tleTogW10sXG4gICAgICAgICAgICBjcmVhdGVOZXdQcm9qZWN0OiBbXSxcbiAgICAgICAgICAgIHJlbW92ZUtleTogW10sXG4gICAgICAgICAgICByZW5hbWVLZXk6IFtdLFxuICAgICAgICAgICAgY2F0ZWdvcnlDbGlja2VkOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZUNhdGVnb3J5OiBbXSxcbiAgICAgICAgICAgIHJlbmFtZUNhdGVnb3J5OiBbXVxuICAgICAgICB9LFxuICAgICAgICB1aSA9IHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHNlbmRTdWNjZXNzOiAnc2VuZFN1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUtleTogJ3VwZGF0ZUtleSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5wdXRQcmVmaXhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VuZFN1Y2Nlc3M6IGZ1bmN0aW9uKGtleSwgaW5wdXRQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGtleSksXG4gICAgICAgICAgICAgICAgICAgIG5vZGUyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW5wdXRQcmVmaXggKyBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMSkge1xuICAgICAgICAgICAgICAgICAgICB1aS5yZW1vdmVTdGF0ZUNsYXNzZXMobm9kZTEpLmNsYXNzTGlzdC5yZW1vdmUodWkuY3NzLnNlbmRTdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLnJlbW92ZVN0YXRlQ2xhc3Nlcyhub2RlMSkuY2xhc3NMaXN0LmFkZCh1aS5jc3Muc2VuZFN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlMikge1xuICAgICAgICAgICAgICAgICAgICB1aS5yZW1vdmVTdGF0ZUNsYXNzZXMobm9kZTIpLmNsYXNzTGlzdC5yZW1vdmUodWkuY3NzLnNlbmRTdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLnJlbW92ZVN0YXRlQ2xhc3Nlcyhub2RlMikuY2xhc3NMaXN0LmFkZCh1aS5jc3Muc2VuZFN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUlucHV0RmllbGRzOiBmdW5jdGlvbihrZXksIGlucHV0UHJlZml4KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3OnVwZGF0ZUlucHV0RmllbGRzJywgJ2lzIHRoaXMgc3RpbGwgaW4gdXNlPz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Jyk7XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbnB1dFByZWZpeCArIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkucmVtb3ZlU3RhdGVDbGFzc2VzKG5vZGUpLmRvbUFkZENsYXNzKHVpLmNzcy51cGRhdGVLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVTdGF0ZUNsYXNzZXM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NzU3RhdGUsIGNsYXNzZXMgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIE9iamVjdC5rZXlzKClcbiAgICAgICAgICAgICAgICBmb3IgKGNzc1N0YXRlIGluIHVpLmNzcykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzICs9IGNzc1N0YXRlICsgJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLmRvbVJlbW92ZUNsYXNzKGNsYXNzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgKHJlZ2lzdGVyZWQgZnJvbSBjb250cm9sbGVyKSB0byBiZSBjYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIGEga2V5IG11c3QgYmUgc2F2ZWRcbiAgICAgICAgICovXG4gICAgICAgIG9uU2F2ZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXc6b25TYXZlS2V5IG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNyZWF0ZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXc6b25DcmVhdGVLZXkgbm90IGluaXRpYWxpemVkJylcbiAgICAgICAgfSxcbiAgICAgICAgb25DbG9uZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXc6b25DbG9uZUtleSBub3QgaW5pdGlhbGl6ZWQnKVxuICAgICAgICB9LFxuICAgICAgICBicmFpbiA9IHtcbiAgICAgICAgICAgIGNsb25lS2V5T3ZlcmxheToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGV4dEZjKCdjbG9uZUtleU92ZXJsYXlUZXh0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5TmFtZTogZGF0YS5rZXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlOYW1lOiBkYXRhLmNvbnRleHROYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb25lS2V5SW5wdXRDYXRlZ29yeToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvbmVLZXlCdXR0b25TdWJtaXQ6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicmFpbi5jbG9uZUtleUlucHV0Q2F0ZWdvcnkubm9kZS52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFpbi5jbG9uZUtleUlucHV0Q2F0ZWdvcnkubm9kZS5jbGFzc0xpc3QuYWRkKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYnJhaW4uY2xvbmVLZXlPdmVybGF5LmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvbmVLZXkoZGF0YS5rZXksIGRhdGEua2V5TmFtZSwgZGF0YS5jb250ZXh0TmFtZSwgYnJhaW4uY2xvbmVLZXlJbnB1dENhdGVnb3J5Lm5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdElucHV0UHJvamVjdDoge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdFByb2plY3REZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdFN1Ym1pdDogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0VmFsdWUgPSBicmFpbi5jcmVhdGVOZXdQcm9qZWN0SW5wdXRQcm9qZWN0Lm5vZGUudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVOZXdLZXkocHJvamVjdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlYWQgZGVzY3JpcHRpb24gZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZXMuY3JlYXRlTmV3UHJvamVjdC5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyhwcm9qZWN0VmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYnJhaW4uY3JlYXRlTmV3UHJvamVjdFByb2plY3REZXNjcmlwdGlvbi5ub2RlLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgaWYgY2xvc2VkIGlzIG5lZWRlZD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hbmFnZXIuaGlkZSgnY3JlYXRlTmV3UHJvamVjdFZpZXcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBjbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWluLmNyZWF0ZU5ld1Byb2plY3RJbnB1dFByb2plY3Qubm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmNDQ0NCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCkpLFxuICAgICAgICAgICAgcHJvamVjdFNob3c6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3RyYW5zbGF0aW9uVmlld1Byb2plY3RDYXRlZ29yeUtleScpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvamVjdElucHV0Q2F0ZWdvcnk6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2plY3RJbnB1dEtleToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsIDogKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbml0IDogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS5kaXNwbGF5TWFuYWdlci5oaWRlKHRoaXMuZGF0YXNldC52aWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICBwcm9qZWN0U3VibWl0OiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5S2V5ID0gYnJhaW4ucHJvamVjdElucHV0Q2F0ZWdvcnkubm9kZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gYnJhaW4ucHJvamVjdElucHV0S2V5Lm5vZGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0tleTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU5ld0tleShjYXRlZ29yeUtleSkgJiYgdmFsaWRhdGVOZXdLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGRlZmF1bHQgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5ID0gY2F0ZWdvcnlLZXkgKyAnXycgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ3JlYXRlS2V5KG5ld0tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZXBsYWNlIHdpdGggY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFpbi5wcm9qZWN0SW5wdXRDYXRlZ29yeS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhaW4ucHJvamVjdElucHV0S2V5Lm5vZGUuY2xhc3NMaXN0LmFkZCgnZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LFxuICAgICAgICBmYyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt7cm93UHJlZml4OiBzdHJpbmcsIGlucHV0UHJlZml4OiBzdHJpbmcsIGlucHV0VHJhbnNQcmVmaXg6IHN0cmluZ319XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldCBjb25maWcgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25mO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZUVkaXRvck1vZGU6IGZ1bmN0aW9uKGVuYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LmFkZCgnYy1lbmFibGVFZGl0b3JNb2RlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1lbmFibGVFZGl0b3JNb2RlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZVdvcmRDb3VudDogZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgnYy13b3JkQ291bnRFbmFibGVkJywgZW5hYmxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kU3VjY2VzczogdWkuc2VuZFN1Y2Nlc3MsXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJyYWluLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYWluW2F0dHJdLmluaXQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdLZXlPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBuZXdLZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHROYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJ18nO1xuICAgICAgICAgICAgICAgIGlmICgvXFwuLy50ZXN0KG9iai5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICcuJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdLZXkgPSBvYmoua2V5LnNwbGl0KGRlbGltaXRlcik7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3S2V5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHNsaWNlIGlmIHdlIG5lZWQgdGhlIGNvbXBsZXRlIGtleSBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TmFtZSA9IG5ld0tleS5zcGxpY2UoMCwgMSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBvYmoua2V5LCAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9iai5rZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHROYW1lOiBjb250ZXh0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAga2V5TmFtZTogbmV3S2V5LmpvaW4oZGVsaW1pdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9iai52YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNCdW5kbGVFcXVhbDogZnVuY3Rpb24oYnVuZGxlMSwgYnVuZGxlMikge1xuICAgICAgICAgICAgICAgIGlmIChidW5kbGUxLmJ1bmRsZSA9PT0gYnVuZGxlMi5idW5kbGUgJiYgYnVuZGxlMS5sb2NhbGUgPT09IGJ1bmRsZTIubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZUZyb206IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlOiBkb21PcHRzLnBhcmFtcy5idW5kbGUgfHwgJ21lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmdldEZyb21QYXJhbSgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGcm9tUGFyYW06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21PcHRzLnBhcmFtcy5mcm9tIHx8ICdkZSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZVRvOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1bmRsZTogZG9tT3B0cy5wYXJhbXMuYnVuZGxlIHx8ICdtZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogZG9tT3B0cy5wYXJhbXMudG8gfHwgbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZTogZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1bmRsZSA9IGRvbU9wdHMucGFyYW1zLmJ1bmRsZSB8fCAnbWVzc2FnZXMnO1xuICAgICAgICAgICAgICAgIHJldHVybiBidW5kbGUgKyAnXycgKyBsb2NhbGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW5kZXIgdGhlIGkxOG4gaW5wdXQgZmllbGQgZm9yIGtleXMgZnJvbSBhIHNpbmdsZSBsYW5ndWFnZS4gVGhlIHJvdyBoZWFkZXIgKGkuZS4gdGhlIGFjdHVhbCBrZXkgZmllbGQpIGlzXG4gICAgICAgICAgICAgKiByZW5kZXJlZCwgdG9vIGlmIGl0IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBidW5kbGVzIHtrZXk6IHN0cmluZywgZGF0YTogc3RyaW5nfVxuICAgICAgICAgICAgICogQHBhcmFtIGFjdHVhbExhbmd1YWdlXG4gICAgICAgICAgICAgKiBAcGFyYW0gYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlc1xuICAgICAgICAgICAgICogQHBhcmFtIHByb2plY3ROYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHByaW50QnVuZGxlVGVtcGxhdGU6IGZ1bmN0aW9uKGJ1bmRsZXMsIGFjdHVhbExhbmd1YWdlLCBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzLCBjYikge1xuICAgICAgICAgICAgICAgIHZhciBrZXlPYmosXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROb2RlLFxuICAgICAgICAgICAgICAgICAgICBzaG93bkNhdGVnb3JpZXMgPSBbXS5zbGljZS5jYWxsKHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeU5vZGUnKSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTZXR1cCBoZWFkZXIgYW5kIGhhbmRsZSB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmVDYXRlZ29yeU5vZGUoY29udGV4dE5hbWUsIGxhbmd1YWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsgY29udGV4dE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXRlZ29yeU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeU5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVtcGxhdGVzIC5jYXRlZ29yeU5vZGUnKS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlOb2RlLmNsYXNzTGlzdC5hZGQoJ2MtYW5jaG9yTWVudS1wYXJlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnlOYW1lID0gY29udGV4dE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5Tm9kZUlkID0gY2F0ZWdvcnlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5Tm9kZS5zZXRBdHRyaWJ1dGUoJ2lkJywgY29uZi5yb3dQcmVmaXggKyBjYXRlZ29yeU5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCcuaGVhZGxpbmVXcmFwcGVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMiA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCdoMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIG1ha2UgYSBzcGFuIGZvciBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMi5hcHBlbmRDaGlsZCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNhdGVnb3J5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSAna2V5TmFtZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZXMuY2F0ZWdvcnlDbGlja2VkLmZvckVhY2goZnVuY3Rpb24oZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyhjYXRlZ29yeU5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRQYW5lbCA9IGlucHV0RWRpdE1hbmFnZXIuYWRkRWRpdG9yUGFuZWwoY2F0ZWdvcnlOb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVkaXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0TmFtZSA9IGtleUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnZhbHVlID0gY29udGV4dE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TYXZlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbmFtZUNhdGVnb3J5LmZvckVhY2goZnVuY3Rpb24oZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkTmFtZTogY29udGV4dE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOYW1lOiBrZXlJbnB1dE5vZGUudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllcyA9IHdpbmRvdy5jb25maXJtKCdEZWxldGUgdGhpcyBjYXRlZ29yeT9cXG5BbGwga2V5cyB3aXRoaW4gd2l0aCB3aWxsIGJlIGxvc3QuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblF1ZXVlcy5yZW1vdmVDYXRlZ29yeS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWRpdFBhbmVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5SW5wdXROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIGNvbmYucm93UHJlZml4ICsgY2F0ZWdvcnlOYW1lICsgJ19pbnB1dCcsICdjYXRlZ29yeUZpZWxkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywga2V5S2V5UHJlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyLmFwcGVuZENoaWxkKGtleUlucHV0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS52YWx1ZSA9IGNhdGVnb3J5TmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGRlc2NyaXB0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdERlc2NOb2RlID0gY2F0ZWdvcnlOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy1jYXQtZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gJ2pzLXRleHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXREZXNjTm9kZS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhdERlc2NOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS50ZXh0RWRpdG9yLmFkZChjYXREZXNjTm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjYXRlZ29yeU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdBZGQgaGVyZSB0aGUgY2F0ZWdvcnkgZGVzY3JpcHRpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55LnRyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkLmFkZChjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLmpzLWltYWdlVXBsb2FkLWVkaXRCdXR0b24nKSwgY2F0ZWdvcnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWRkIGtleSBpbnB1dCBmaWVsZCBhbmQgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlOYW1lSW5wdXQgPSBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLmFkZE5ld0tleXJvdyBpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlOYW1lSW5wdXQuc2V0QXR0cmlidXRlKCdjYXRlZ29yeScsIGNhdGVnb3J5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleU5hbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGtleUtleVByZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignbGFiZWwnKS5pbm5lclRleHQgPSBjYXRlZ29yeU5hbWUgKyBcIl9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVOZXdLZXkoa2V5TmFtZUlucHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdLZXkgPSBrZXlOYW1lSW5wdXQuZ2V0QXR0cmlidXRlKCdjYXRlZ29yeScpICsgJ18nICsga2V5TmFtZUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVmYWN0b3IgdGhpcyAtIHNlcnZlciBzaG91bGQgYWRkIHRoZSBrZXkgZm9yIGFsbCBhdmFpbGFibGUgbGFuZ3VhZ2VzIC0gb3IgcGFzcyBkZWZhdWx0IGxhbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNyZWF0ZUtleShuZXdLZXksIGFjdHVhbExhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmNvbG9yID0gJyNmZjAwMDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleU5hbWVJbnB1dC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNmZjQ0NDRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG92ZXJhbGwgd29yZCBjb3VudCBmb3IgZWFjaCBsYW5ndWFnZSBvZiBhIGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJhbGxXb3Jkc1dyYXBwZXIgPSBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLm92ZXJhbGxXb3JkQ291bnRXcmFwcGVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJhbGxIZWFkbGluZSA9IG92ZXJhbGxXb3Jkc1dyYXBwZXIucXVlcnlTZWxlY3RvcignLm92ZXJhbGxXb3Jkc0hlYWRsaW5lJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzV3JhcHBlciA9IG92ZXJhbGxXb3Jkc1dyYXBwZXIucXVlcnlTZWxlY3RvcignLnRyYW5zbGF0aW9uQ29udGFpbmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmFsbEhlYWRsaW5lLmlubmVySFRNTCA9IGdldFdvcmRDb3VudEhlYWRsaW5lKGNhdGVnb3J5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VzLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1dyYXBwZXIuYXBwZW5kQ2hpbGQoY3JlYXRlV29yZENvdW50Rm9yTGFuZ3VhZ2UobGFuZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGJ1bmRsZXMuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleU9iaiA9IGZjLmdldFZpZXdLZXlPYmplY3QoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gd2hpY2ggd2hvIGNhbGMgdGhlIGNhdGUuLi5cbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5vZGUgPSBwcmVwYXJlQ2F0ZWdvcnlOb2RlKGtleU9iai5jb250ZXh0TmFtZSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydENhdGVnb3J5KHByb2plY3ROb2RlLCBzaG93bkNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgICAgICAgICBmYy5hZGRSb3dXaXRoTGFuZ3VhZ2VzKHByb2plY3ROb2RlLCBrZXlPYmosIGFjdHVhbExhbmd1YWdlLCBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgY2IocHJvamVjdE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpLnJlcGxhY2UoY29uZi5yb3dQcmVmaXgsICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGtleU9iai5rZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSB3b3JkIGNvdW50IGZvciBhIGdpdmVuIGNhdGVnb3J5XG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgY29uZi5yb3dQcmVmaXggKyBkYXRhLmlkICsgJyAub3ZlcmFsbFdvcmRDb3VudFdyYXBwZXIgLmpzXycgKyBkYXRhLmxhbmd1YWdlICsgJyAud29yZENvdW50TGFiZWwnKTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gZ2V0V29yZENvdW50VGV4dChkYXRhLndvcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjcmVhdGVzIGEga2V5IGZpZWxkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZEtleUZpZWxkOiBmdW5jdGlvbihub2RlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleUlucHV0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYuaW5wdXRQcmVmaXggKyBkYXRhLmtleSksXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlJbnB1dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIGNvbmYuaW5wdXRQcmVmaXggKyBkYXRhLmtleSwgJ2tleUZpZWxkJyk7XG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdkYXRhIGtleSBvY3RpY29uIG9jdGljb24ta2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRFZGl0TWFuYWdlci5hZGRFZGl0b3JQYW5lbChrZXlOb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllcyA9IHdpbmRvdy5jb25maXJtKCdEZWxldGUgdGhpcyBrZXk/XFxuVGhpcyBrZXkgd2l0aCBhbGwgdHJhbnNsYXRpb25zIHdpbGwgcmVtb3ZlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbW92ZUtleS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBkYXRhLmtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVkaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBhY3R1YWwga2V5IGZvciByZXN0b3JpbmcgaWYgY2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5rZXlOYW1lID0ga2V5SW5wdXROb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUga2V5OiB0YWtlIGlkIGF0dHJpYnV0ZSBhbmQgcmVtb3ZlIHRoZSB2YWx1ZSBmcm9tIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5rZXkgPSBrZXlJbnB1dE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpLnJlcGxhY2UoY29uZi5pbnB1dFByZWZpeCwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29udGV4dE5hbWUgPSBkYXRhLmtleS5zcGxpdCgnXycpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnZhbHVlID0gZGF0YS5rZXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlldzphZGRLZXlGaWVsZCBzYXZlIG5ldyBrZXknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLmNvbnRleHROYW1lID8gZGF0YS5jb250ZXh0TmFtZSArICdfJyArIGtleUlucHV0Tm9kZS52YWx1ZSA6IGtleUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5SW5wdXROb2RlLnZhbHVlICE9ICcnICYmIHZhbHVlICE9IGRhdGEua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbmFtZUtleS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRLZXk6IGRhdGEua2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWluLmNsb25lS2V5T3ZlcmxheS5zZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3RyYW5zbGF0aW9uVmlld0Nsb25lS2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgaW5wdXQga2V5IGxpc3RlbmVyIHRvIGNhcHR1cmUgd3JvbmcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGtleUtleVByZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmFwcGVuZENoaWxkKChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YS5rZXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICdrZXlOYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGFuXG4gICAgICAgICAgICAgICAgICAgIH0oKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuYXBwZW5kQ2hpbGQoa2V5SW5wdXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoa2V5Tm9kZSwgbm9kZS5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS52YWx1ZSA9IGRhdGEua2V5TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxsIHRoaXMgdG8gdXBkYXRlL2NyZWF0ZSBhIGxhbmd1YWdlIGZpZWxkXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gbGFuZ1xuICAgICAgICAgICAgICogQHBhcmFtIHdvcmRDb3VudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRMYW5ndWFnZUZpZWxkOiBmdW5jdGlvbihub2RlLCBrZXksIHZhbHVlLCBsYW5nLCB3b3JkQ291bnQpIHtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdldExhbmd1YWdlVGV4dElkKGtleSwgbGFuZykpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgd29yZENvdW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEluZm9ybWF0aW9uTm9kZTtcblxuICAgICAgICAgICAgICAgIGlmICghdGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJywgZ2V0TGFuZ3VhZ2VUZXh0SWQoa2V5LCBsYW5nKSwgJ3RleHRGaWVsZCcpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZSA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ2RhdGEgdHBsIGpzXycgKyBsYW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEluZm9ybWF0aW9uTm9kZSA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ3RleHRJbmZvcm1hdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB3b3JkQ291bnROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ3RleHRJbmZvcm1hdGlvbi13b3JkQ291bnRMYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ291bnROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ3RleHRJbmZvcm1hdGlvbi1jaGFyQ291bnRMYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICB3b3JkQ291bnROb2RlLmlubmVySFRNTCA9IGdldFdvcmRDb3VudFRleHQoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dEluZm9ybWF0aW9uTm9kZS5hcHBlbmRDaGlsZChmbGFnLmdldEZsYWcobGFuZykpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0SW5mb3JtYXRpb25Ob2RlLmFwcGVuZENoaWxkKHdvcmRDb3VudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRleHRJbmZvcm1hdGlvbk5vZGUuYXBwZW5kQ2hpbGQoY2hhckNvdW50Tm9kZSlcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb3VudE5vZGUuaW5uZXJIVE1MID0gZ2V0Q2hhcmFjdGVyQ291bnQodGhpcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRDb3VudE5vZGUuaW5uZXJIVE1MID0gZ2V0V29yZENvdW50VGV4dCh3b3JkQ291bnRlci5jb3VudFdvcmRzSW5TdHJpbmcodGhpcy52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0ZXh0QXJlYUtleVByZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTYXZlT25MZWF2ZSh0ZXh0Tm9kZSwga2V5LCBsYW5nLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZCh0ZXh0SW5mb3JtYXRpb25Ob2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRhdGFOb2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3b3JkQ291bnROb2RlID0gdGV4dE5vZGUucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudGV4dEluZm9ybWF0aW9uLXdvcmRDb3VudExhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb3VudE5vZGUgPSB0ZXh0Tm9kZS5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXh0SW5mb3JtYXRpb24tY2hhckNvdW50TGFiZWwnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnZhbHVlID0gdmFsdWUgPyB1bmljb2RlLmVuY29kZSh2YWx1ZSkgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB3b3JkQ291bnROb2RlLmlubmVySFRNTCA9IGdldFdvcmRDb3VudFRleHQod29yZENvdW50ZXIuY291bnRXb3Jkc0luU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50Tm9kZS5pbm5lckhUTUwgPSBnZXRDaGFyYWN0ZXJDb3VudCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjcmVhdGVzIGEgcm93XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRoZSBleGlzdGluZyByb3cgb3IgaW4gY2FzZSBpZiBub3QgZXhpc3RzIGEgbmV3IGNyZWF0ZWQgcm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFJvdzogZnVuY3Rpb24obm9kZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgcm93XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsga2V5KSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25Db250YWluZXIgPSByb3cgIT09IG51bGwgPyByb3cucXVlcnlTZWxlY3RvcignLnRyYW5zbGF0aW9uQ29udGFpbmVyJykgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwidHJhbnNsYXRpb25Db250YWluZXJcIjtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcm93IGJ1dCBpdCBpcyBtYXJrZWQgYXMgcmVtb3ZlZCB0aGFuIHJlbW92ZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAocm93ICYmIHJvdy5jbGFzc0xpc3QuY29udGFpbnMoJ2MtcmVtb3ZlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5kb21SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSByb3cgaWYgdGhlIHJvdyBpcyBub3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBjb25mLnJvd1ByZWZpeCArIGtleSwgJ3JvdyBjLXJvdyBjLWFuY2hvck1lbnUtY2hpbGQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBkZXNjcmlwdGlvbiBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXREZXNjTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSAnanMtdGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIGNhdERlc2NOb2RlLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICBjYXREZXNjTm9kZS5jbGFzc05hbWUgPSAnanMtcm93LWRlc2NyaXB0aW9uJztcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGNhdERlc2NOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FubnkudGV4dEVkaXRvci5hZGQoY2F0RGVzY05vZGUsIHtpZDoga2V5LCBwbGFjZWhvbGRlcjogJ0FkZCBoZXJlIHRoZSBrZXkgZGVzY3JpcHRpb24nfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB0cmFuc2xhdGlvbiBhcmVhIGZpZWxkIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodHJhbnNsYXRpb25Db250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnF1ZXJ5U2VsZWN0b3IoJy5rZXlzV3JhcHBlcicpLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkUm93V2l0aExhbmd1YWdlczogZnVuY3Rpb24obm9kZSwgZGF0YSwgYWN0dWFsTGFuZ3VhZ2UsIGFsbFByb2plY3RMYW5ndWFnZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gZmMuZ2V0Um93KG5vZGUsIGRhdGEua2V5KTtcblxuICAgICAgICAgICAgICAgIGZjLmFkZEtleUZpZWxkKHJvdywgZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBhbGxQcm9qZWN0TGFuZ3VhZ2VzLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgICAgICBmYy5hZGRMYW5ndWFnZUZpZWxkKHJvdy5xdWVyeVNlbGVjdG9yKCcudHJhbnNsYXRpb25Db250YWluZXInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsTGFuZ3VhZ2UgPT09IGxhbmcgPyBkYXRhLnZhbHVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZExhbmd1YWdlOiBmdW5jdGlvbihrZXlzLCBsYW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLmFkZExhbmd1YWdlRmllbGQocm93LnF1ZXJ5U2VsZWN0b3IoJy50cmFuc2xhdGlvbkNvbnRhaW5lcicpLCBrZXksIG51bGwsIGxhbmcsIDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2F0ZWdvcnkgPSBrZXkuc3BsaXQoJ18nKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzLmluZGV4T2YoY3VycmVudENhdGVnb3J5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goY3VycmVudENhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlldzphZGRMYW5ndWFnZSBmb3VuZCBrZXkgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpbiB2aWV3OicsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbihjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVyYWxsV29yZENvdW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBjb25mLnJvd1ByZWZpeCArIGNhdGVnb3J5ICsgJyAub3ZlcmFsbFdvcmRDb3VudFdyYXBwZXIgLnRyYW5zbGF0aW9uQ29udGFpbmVyJylcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmFsbFdvcmRDb3VudC5hcHBlbmRDaGlsZChjcmVhdGVXb3JkQ291bnRGb3JMYW5ndWFnZShsYW5nKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhclZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgcmVzZXQgYWxsIGZvciBub3dcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGRvIGl0IGJldHRlciA7KVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwocm9vdE5vZGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dMYW5nOiBmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdyB0aGUgbGFuZyB0YWJcbiAgICAgICAgICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLWhpZGVfJyArIGxhbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVtb3ZlIGEgY2F0ZWdvcnlcbiAgICAgICAgICAgICAqIFRPRE8gaXQncyBub3QgY2FsbGVkIGlmIG93biB1c2VyIHJlbmFtZXMgYSBjYXRlZ29yeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW5hbWVDYXRlZ29yeTogZnVuY3Rpb24ob2xkTmFtZSwgbmV3TmFtZSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcykge1xuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeU5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIG9sZE5hbWUpLFxuICAgICAgICAgICAgICAgICAgICByb3dzID0gY2F0ZWdvcnlOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jLXJvdycpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkbGluZSA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCdoMicpLFxuICAgICAgICAgICAgICAgICAgICBhZGRLZXlOb2RlID0gY2F0ZWdvcnlOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5hZGROZXdLZXlyb3cnKTtcblxuICAgICAgICAgICAgICAgIGNhdGVnb3J5Tm9kZS5pZCA9IGNvbmYucm93UHJlZml4ICsgbmV3TmFtZTtcblxuICAgICAgICAgICAgICAgIGhlYWRsaW5lLnF1ZXJ5U2VsZWN0b3IoJy5rZXlOYW1lJykuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgPSBuZXdOYW1lO1xuXG4gICAgICAgICAgICAgICAgYWRkS2V5Tm9kZS5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpLmlubmVySFRNTCA9IG5ld05hbWUgKyAnXyc7XG4gICAgICAgICAgICAgICAgYWRkS2V5Tm9kZS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnNldEF0dHJpYnV0ZSgnY2F0ZWdvcnknLCBuZXdOYW1lKTtcblxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwocm93cykuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gcm93LmlkLnJlcGxhY2UoY29uZi5yb3dQcmVmaXgsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0TmFtZSA9IGlkLnNwbGl0KCdfJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdLZXlOYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TmFtZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdLZXlOYW1lID0gbmV3TmFtZSArICdfJyArIHNwbGl0TmFtZS5qb2luKCdfJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmFtZURPTUlkcyhpZCwgbmV3S2V5TmFtZSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2xhdGlvblZpZXc6cmVuYW1lQ2F0ZWdvcnkgc2hvdWxkIG5vdCBoYXYgYW4gZW1wdHkgaWQnLCByb3cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5wdXRFZGl0TWFuYWdlci5jbG9zZUVkaXRWaWV3KGhlYWRsaW5lKTtcbiAgICAgICAgICAgICAgICBoZWFkbGluZS5xdWVyeVNlbGVjdG9yKCcuY2F0ZWdvcnlGaWVsZCcpLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAndHJ1ZScpO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZW1vdmUgYSBjYXRlZ29yeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVDYXRlZ29yeTogZnVuY3Rpb24oY2F0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsgY2F0KTtcbiAgICAgICAgICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5kb21SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzaG93IGEga2V5IGFzIGRlbGV0ZWRcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFya0tleUFzUmVtb3ZlZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsga2V5KSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSWM7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyAmJiAhcm93LmNsYXNzTGlzdC5jb250YWlucygnYy1yZW1vdmVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LmNsYXNzTGlzdC5hZGQoJ2MtcmVtb3ZlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVJYyA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ3JlbW92ZS1idXR0b24gb2N0aWNvbiBvY3RpY29uLXgnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSWMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5kb21SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUljLmRvbUFwcGVuZFRvKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzRnJvbVJvdyhyb3cpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVkaXRNYW5hZ2VyLnJlbW92ZVBhbmVsKHJvdyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3Om1hcmtrZXlBc1JlbW92ZWQgbm8gbm9kZSBmb3VuZCBmb3Iga2V5Jywga2V5LCByb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJlbW92ZSBhIGtleVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgICAgICAgICByb3cuZG9tUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVuYW1lIGEga2V5XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG9sZEtleVxuICAgICAgICAgICAgICogQHBhcmFtIG5ld0tleVxuICAgICAgICAgICAgICogQHBhcmFtIGF2YWlsYWJsZVByb2plY3RMYW5ndWFnZXMgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVuYW1lS2V5OiBmdW5jdGlvbihvbGRLZXksIG5ld0tleSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcykge1xuICAgICAgICAgICAgICAgIHZhciBrZXlJbnB1dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLmlucHV0UHJlZml4ICsgb2xkS2V5KSxcbiAgICAgICAgICAgICAgICAgICAga2V5TmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXlJbnB1dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5TmFtZSA9IGZjLmdldFZpZXdLZXlPYmplY3Qoe2tleTogbmV3S2V5fSkua2V5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lRE9NSWRzKG9sZEtleSwgbmV3S2V5LCBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnZhbHVlID0ga2V5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIGVkaXQgdmlld1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVkaXRNYW5hZ2VyLmNsb3NlRWRpdFZpZXcoa2V5SW5wdXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgdGhlIGlucHV0IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLmtleU5hbWUnKS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IGtleU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUltYWdlOiBmdW5jdGlvbihjYXRlZ29yeU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VCb3ggPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCcjJyArIGNvbmYucm93UHJlZml4ICsgY2F0ZWdvcnlOYW1lICsgJyAuaW1hZ2VVcGxvYWQtaW1hZ2VCb3gnKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW1hZ2VCb3guZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUJveC5yZW1vdmVDaGlsZChpbWFnZUJveC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW1hZ2VCb3guY2xhc3NMaXN0LnJlbW92ZSgnYy1zaG93Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZUxhbmc6IGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QuYWRkKCdjLWhpZGVfJyArIGxhbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ3JlYXRlTmV3UHJvamVjdDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICBvblF1ZXVlcy5jcmVhdGVOZXdQcm9qZWN0LnB1c2goY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2F0ZWdvcnlDbGlja2VkOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgIG9uUXVldWVzLmNhdGVnb3J5Q2xpY2tlZC5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkFkZE5ld0tleTogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICBvblF1ZXVlcy5hZGROZXdLZXkucHVzaChjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZW5hbWVLZXk6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgb25RdWV1ZXMucmVuYW1lS2V5LnB1c2goY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVtb3ZlS2V5OiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbW92ZUtleS5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlbW92ZUNhdGVnb3J5OiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbW92ZUNhdGVnb3J5LnB1c2goY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVuYW1lQ2F0ZWdvcnk6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgb25RdWV1ZXMucmVuYW1lQ2F0ZWdvcnkucHVzaChjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgbG9naWMgZm9yIGhhbmRsaW5nIHNhdmluZyBjaGFuZ2VzIHRvIGEga2V5LlxuICAgICAgICAgICAgICogQHBhcmFtIGZ1bmNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25TYXZlS2V5OiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgb25TYXZlS2V5ID0gZnVuYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCBsb2dpYyBmb3IgaGFuZGxpbmcgc2F2aW5nIGNoYW5nZXMgdG8gYSBrZXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvbkNyZWF0ZUtleTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgICAgIG9uQ3JlYXRlS2V5ID0gZnVuYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsb25lS2V5OiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgb25DbG9uZUtleSA9IGZ1bmM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJXaGlza2VyOiBmdW5jdGlvbihmYykge1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHRGYyA9IGZjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIHJldHVybiBmYztcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNsYXRpb25WaWV3O1xuIiwidmFyIG5vZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhZGQgOiBmdW5jdGlvbiAoZWxlbSAsYXR0cikge1xuICAgICAgICBub2RlID0gZWxlbTtcbiAgICB9LFxuICAgIGFkZERlc2NyaXB0aW9ucyA6IGZ1bmN0aW9uIChrZXlEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5RGVzY3JpcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChrZXkpLFxuICAgICAgICAgICAgICAgIGNoaWxkO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy10ZXh0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmlubmVySFRNTCA9IGtleURlc2NyaXB0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59IiwiLyoqXG4gKiBpcyBmb3IgdGhlIHRyYW5zbGF0aW9uIHZpZXcgdG8gYWRkIHRoZSBpbWFnZSB1cGxvYWQgYnV0dG9uIGFuZCBzaG93IHRoZSBpbWFnZXNcbiAqL1xudmFyIHJvb3ROb2RlLFxuICAgIG9uVXBsb2FkQnV0dG9uID0gZnVuY3Rpb24gKCkgeyBjb25zb2xlLndhcm4oJ3RyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkOjpvblVwbG9hZEJ1dHRvbigpIG5vdCBpbXBsZW1lbnRlZC4nKTsgfSxcbiAgICBvbkRlbGV0ZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHsgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZDo6b25EZWxldGVCdXR0b24oKSBub3QgaW1wbGVtZW50ZWQuJyk7IH07XG5cbmZ1bmN0aW9uIHVwbG9hZEJ1dHRvbihpZCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbm9kZS5jbGFzc05hbWUgPSAndXBsb2FkLWJ0biBvY3RpY29uIG9jdGljb24tY2xvdWQtdXBsb2FkJztcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBvblVwbG9hZEJ1dHRvbihpZCk7XG4gICAgfSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ3VwbG9hZCBhIGltYWdlIGZpbGUnKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZWRpdFBhbmVsKGlkKSB7XG4gICAgdmFyIGRlbGV0ZUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBlZGl0QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIGNhbmNlbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBwYW5lbFdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHBhbmVsV3JhcC5jbGFzc05hbWUgPSAnaW1hZ2VVcGxvYWQtaW1hZ2VCb3gtZWRpdFBhbmVsJztcbiAgICBlZGl0QnRuLmNsYXNzTmFtZSA9ICdlZGl0LWJ0biBvY3RpY29uIG9jdGljb24tcGVuY2lsJztcbiAgICBlZGl0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBwYW5lbFdyYXAuY2xhc3NMaXN0LmFkZCgnYy1lZGl0Jyk7XG4gICAgfSk7XG4gICAgY2FuY2VsQnRuLmNsYXNzTmFtZSA9ICdjYW5jZWwtYnRuIG9jdGljb24gb2N0aWNvbi14JztcbiAgICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhbmVsV3JhcC5jbGFzc0xpc3QucmVtb3ZlKCdjLWVkaXQnKTtcbiAgICB9KTtcbiAgICBkZWxldGVCdG4uY2xhc3NOYW1lID0gJ2RlbGV0ZS1idG4gb2N0aWNvbiBvY3RpY29uLXRyYXNoY2FuJztcbiAgICBkZWxldGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uRGVsZXRlQnV0dG9uKGlkKTtcbiAgICB9KTtcbiAgICBcbiAgICBkZWxldGVCdG4uc2V0QXR0cmlidXRlKCd0aXRsZScsICdyZW1vdmUgaW1hZ2UnKTtcbiAgICBjYW5jZWxCdG4uc2V0QXR0cmlidXRlKCd0aXRsZScsICdjYW5jZWwnKTtcbiAgICBlZGl0QnRuLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnZWRpdCcpO1xuXG4gICAgcGFuZWxXcmFwLmFwcGVuZENoaWxkKGVkaXRCdG4pO1xuICAgIHBhbmVsV3JhcC5hcHBlbmRDaGlsZChjYW5jZWxCdG4pO1xuICAgIHBhbmVsV3JhcC5hcHBlbmRDaGlsZChkZWxldGVCdG4pO1xuICAgIHJldHVybiBwYW5lbFdyYXA7XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlKGZpbGUpIHtcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLnNyYyA9IGZpbGU7XG4gICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4oZmlsZSwgJ19ibGFuaycpO1xuICAgICAgICB3aW4uZm9jdXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW1nO1xufVxuXG5mdW5jdGlvbiBhZGRJbWFnZUNvbnRlbnQoaWQsIGltZykge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIHJlc2l6ZUFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXNpemVBYmxlLmNsYXNzTmFtZSA9ICdpbWFnZVVwbG9hZC1pbWFnZUJveC1yZXNpemVhYmxlJzsgXG4gICAgbm9kZS5jbGFzc05hbWUgPSAnaW1hZ2VVcGxvYWQtaW1hZ2VCb3gtY29udGVudCc7XG4gICAgcmVzaXplQWJsZS5hcHBlbmRDaGlsZChpbWcpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQocmVzaXplQWJsZSk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChlZGl0UGFuZWwoaWQpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25VcGxvYWRCdXR0b24gOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25VcGxvYWRCdXR0b24gPSBmYztcbiAgICB9LFxuICAgIG9uRGVsZXRlQnV0dG9uOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25EZWxldGVCdXR0b24gPSBmYztcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodXBsb2FkQnV0dG9uKGF0dHIpKVxuICAgIH0sXG4gICAgYXBwZW5kSW1hZ2UgOiBmdW5jdGlvbiAoaWQsIHVybCkge1xuICAgICAgICB2YXIgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ3R2XycgKyBpZCksXG4gICAgICAgICAgICBpbWdDb250YWluZXI7XG4gICAgICAgIGlmIChkb20pIHtcbiAgICAgICAgICAgIGltZ0NvbnRhaW5lciA9IGRvbS5xdWVyeVNlbGVjdG9yKCcuanMtaW1hZ2VVcGxvYWQtYm94Jyk7XG4gICAgICAgICAgICBpZiAoaW1nQ29udGFpbmVyKSB7XG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChpbWdDb250YWluZXIuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgICAgICAgICAgICAgbi5yZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpbWdDb250YWluZXIuY2xhc3NMaXN0LmFkZCgnYy1zaG93Jyk7XG4gICAgICAgICAgICAgICAgaW1nQ29udGFpbmVyLmFwcGVuZENoaWxkKGFkZEltYWdlQ29udGVudChpZCwgZ2V0SW1hZ2UoYC9pbWFnZXMke3VybH1gKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSIsIi8qKlxuICogc2hvd3MgdGhlIHVwbG9hZGVyIGZvcm0gdG8gdXBsb2FkIGEgaW1hZ2UgdG8gdGhlIHNlcnZlclxuICovXG52YXIgb25VcGxvYWQgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICBicmFpbiA9IHtcbiAgICAgICAgZmlsZUlucHV0IDoge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwbG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5mdW5jdGlvbiB1cGxvYWQoKSB7XG4gICAgY29uc29sZS5sb2coJ2MtdXBsb2FkOnRyaWdnZXIgdXBsb2FkJyk7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmZpbGVzWzBdO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICAgIC8vIHNlbmQgaXQgZGlyZWN0IGFmdGVyIGRyb3BcbiAgICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLmZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGluc3RlYWQgcGFzcyAgZGlyZWN0bHkgYSBhcnJheSBvZiBmaWxlcyAtIHNvIHdlIHNhdmUgUE9TVCBjYWxsc1xuICAgICAgICAgICAgb25VcGxvYWQoZmlsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjbGVhbnVwIHZhbHVlIG90aGVyd2lzZSBmaWxlIHdpdGggc2FtZSBuYW1lIGNhbid0IHVwbG9hZGVkIGFnYWluXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQHJldHVybnMge3thZGQ6IEZ1bmN0aW9uLCByZWFkeTogRnVuY3Rpb259fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvblVwbG9hZCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICBvblVwbG9hZCA9IGZjO1xuICAgIH0sXG4gICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgaWYgKGJyYWluLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICBicmFpblthdHRyXS5pbml0KG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufTsiLCJcbnZhciB1bmljb2RlID0gKGZ1bmN0aW9uKCl7XG5cbiAgICBTdHJpbmcucHJvdG90eXBlLmdldEVhY2hDaGFyID0gZnVuY3Rpb24oY2Ipe1xuICAgICAgICB2YXIgbmV3U3RyaW5nID0gdGhpcztcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuZXdTdHJpbmcubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG5ld1N0cmluZ1tpXSA9IGNiKG5ld1N0cmluZ1tpXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ld1N0cmluZy50b1N0cmluZygpO1xuICAgIH1cbiAgICB2YXIgcmVnID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFx1KFswLTlhLWZBLUZdezR9KScsXCJnXCIpO1xuICAgIHJldHVybiB7XG4gICAgICAgIGVuY29kZSA6IGZ1bmN0aW9uKHN0cmluZyl7XG4gICAgICAgICAgICBpZighc3RyaW5nKXtyZXR1cm4gJyc7fVxuICAgICAgICAgICAgdmFyIG5ld3N0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZyxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiAobWF0Y2gsIHN1Ym1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KHN1Ym1hdGNoLCAxNikpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5ld3N0cmluZztcbiAgICAgICAgfSxcbiAgICAgICAgZGVjb2RlIDogZnVuY3Rpb24oc3RyaW5nKXtcbiAgICAgICAgICAgIHJldHVybiBzdHJpbmcuZ2V0RWFjaENoYXIoZnVuY3Rpb24oYyl7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0YWJsZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBpZih0YWJsZVtpXSA9PSBjKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmb3VuZDonK3RhYmxlW2ldKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRhYmxlW2ldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBjO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cblxuICAgIH1cbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdW5pY29kZTtcblxudmFyIHRhYmxlID0gW1xuICAgICdcXHUwMEMwJyxcbiAgICAnXFx1MDBDMScsXG4gICAgJ1xcdTAwQzInLFxuICAgICdcXHUwMEMzJyxcbiAgICAnXFx1MDBDNCcsXG4gICAgJ1xcdTAwQzUnLFxuICAgICdcXHUwMEM2JyxcbiAgICAnXFx1MDBDNycsXG4gICAgJ1xcdTAwQzgnLFxuICAgICdcXHUwMEM5JyxcbiAgICAnXFx1MDBDQScsXG4gICAgJ1xcdTAwQ0InLFxuICAgICdcXHUwMENDJyxcbiAgICAnXFx1MDBDRCcsXG4gICAgJ1xcdTAwQ0UnLFxuICAgICdcXHUwMENGJyxcbiAgICAnXFx1MDBEMCcsXG4gICAgJ1xcdTAwRDEnLFxuICAgICdcXHUwMEQyJyxcbiAgICAnXFx1MDBEMycsXG4gICAgJ1xcdTAwRDQnLFxuICAgICdcXHUwMEQ1JyxcbiAgICAnXFx1MDBENicsXG4gICAgJ1xcdTAwRDgnLFxuICAgICdcXHUwMEQ5JyxcbiAgICAnXFx1MDBEQScsXG4gICAgJ1xcdTAwREInLFxuICAgICdcXHUwMERDJyxcbiAgICAnXFx1MDBERCcsXG4gICAgJ1xcdTAwREUnLFxuICAgICdcXHUwMERGJyxcbiAgICAnXFx1MDBFMCcsXG4gICAgJ1xcdTAwRTEnLFxuICAgICdcXHUwMEUyJyxcbiAgICAnXFx1MDBFMycsXG4gICAgJ1xcdTAwRTQnLFxuICAgICdcXHUwMEU1JyxcbiAgICAnXFx1MDBFNicsXG4gICAgJ1xcdTAwRTcnLFxuICAgICdcXHUwMEU4JyxcbiAgICAnXFx1MDBFOScsXG4gICAgJ1xcdTAwRUEnLFxuICAgICdcXHUwMEVCJyxcbiAgICAnXFx1MDBFQycsXG4gICAgJ1xcdTAwRUQnLFxuICAgICdcXHUwMEVFJyxcbiAgICAnXFx1MDBFRicsXG4gICAgJ1xcdTAwRjAnLFxuICAgICdcXHUwMEYxJyxcbiAgICAnXFx1MDBGMicsXG4gICAgJ1xcdTAwRjMnLFxuICAgICdcXHUwMEY0JyxcbiAgICAnXFx1MDBGNScsXG4gICAgJ1xcdTAwRjYnLFxuICAgICdcXHUwMEY4JyxcbiAgICAnXFx1MDBGOScsXG4gICAgJ1xcdTAwRkEnLFxuICAgICdcXHUwMEZCJyxcbiAgICAnXFx1MDBGQycsXG4gICAgJ1xcdTAwRkQnLFxuICAgICdcXHUwMEZFJyxcbiAgICAnXFx1MDBGRidcbl07IiwiZnVuY3Rpb24gZ2V0QW5jaG9yKCkge1xuICAgIHZhciBocmVmID0gbG9jYXRpb24uaHJlZjtcbiAgICBpZiAoLyMvLnRlc3QoaHJlZikpIHtcbiAgICAgICAgcmV0dXJuICcjJyArIGxvY2F0aW9uLmhyZWYucmVwbGFjZSgvLiojLywgJycpO1xuICAgIH1cbiAgICByZXR1cm4gJyc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldEFuY2hvciA6IGdldEFuY2hvcixcbiAgICBoYXNBbmNob3IgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBnZXRBbmNob3IoKSAhPT0gJyc7XG4gICAgfVxufSIsImNvbnN0IHJlZ0V4UHVuYyA9IG5ldyBSZWdFeHAoL1tcXC4sXFxzITs/OlxcXCJdKy9naSlcblxuLyoqXG4gKiBDb3VudCBhbW91bnQgb2Ygd29yZHMgaW4gYSBnaXZlbiBTdHJpbmdcbiAqIEBwYXJhbSBzdHJcbiAqIEByZXR1cm5zIE51bWJlclxuICovXG5tb2R1bGUuZXhwb3J0cy5jb3VudFdvcmRzSW5TdHJpbmcgPSBmdW5jdGlvbiBjb3VudFdvcmRzSW5TdHJpbmcoc3RyKSB7XG4gICAgaWYgKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UocmVnRXhQdW5jLCAnICcpLnRyaW0oKS5zcGxpdCgnICcpLmxlbmd0aDtcbiAgICB9XG4gICAgcmV0dXJuIDA7XG59IiwiJ3VzZSBzdHJpY3QnXG5cbmV4cG9ydHMuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxuZXhwb3J0cy5mcm9tQnl0ZUFycmF5ID0gZnJvbUJ5dGVBcnJheVxuXG52YXIgbG9va3VwID0gW11cbnZhciByZXZMb29rdXAgPSBbXVxudmFyIEFyciA9IHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJyA/IFVpbnQ4QXJyYXkgOiBBcnJheVxuXG52YXIgY29kZSA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvJ1xuZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcbiAgbG9va3VwW2ldID0gY29kZVtpXVxuICByZXZMb29rdXBbY29kZS5jaGFyQ29kZUF0KGkpXSA9IGlcbn1cblxucmV2TG9va3VwWyctJy5jaGFyQ29kZUF0KDApXSA9IDYyXG5yZXZMb29rdXBbJ18nLmNoYXJDb2RlQXQoMCldID0gNjNcblxuZnVuY3Rpb24gcGxhY2VIb2xkZXJzQ291bnQgKGI2NCkge1xuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBpZiAobGVuICUgNCA+IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDQnKVxuICB9XG5cbiAgLy8gdGhlIG51bWJlciBvZiBlcXVhbCBzaWducyAocGxhY2UgaG9sZGVycylcbiAgLy8gaWYgdGhlcmUgYXJlIHR3byBwbGFjZWhvbGRlcnMsIHRoYW4gdGhlIHR3byBjaGFyYWN0ZXJzIGJlZm9yZSBpdFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcbiAgLy8gaWYgdGhlcmUgaXMgb25seSBvbmUsIHRoZW4gdGhlIHRocmVlIGNoYXJhY3RlcnMgYmVmb3JlIGl0IHJlcHJlc2VudCAyIGJ5dGVzXG4gIC8vIHRoaXMgaXMganVzdCBhIGNoZWFwIGhhY2sgdG8gbm90IGRvIGluZGV4T2YgdHdpY2VcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcbn1cblxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XG4gIC8vIGJhc2U2NCBpcyA0LzMgKyB1cCB0byB0d28gY2hhcmFjdGVycyBvZiB0aGUgb3JpZ2luYWwgZGF0YVxuICByZXR1cm4gKGI2NC5sZW5ndGggKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG59XG5cbmZ1bmN0aW9uIHRvQnl0ZUFycmF5IChiNjQpIHtcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcbiAgdmFyIGxlbiA9IGI2NC5sZW5ndGhcbiAgcGxhY2VIb2xkZXJzID0gcGxhY2VIb2xkZXJzQ291bnQoYjY0KVxuXG4gIGFyciA9IG5ldyBBcnIoKGxlbiAqIDMgLyA0KSAtIHBsYWNlSG9sZGVycylcblxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXG4gIGwgPSBwbGFjZUhvbGRlcnMgPiAwID8gbGVuIC0gNCA6IGxlblxuXG4gIHZhciBMID0gMFxuXG4gIGZvciAoaSA9IDA7IGkgPCBsOyBpICs9IDQpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cbiAgICBhcnJbTCsrXSA9ICh0bXAgPj4gMTYpICYgMHhGRlxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAyKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA+PiA0KVxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDEwKSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCA0KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDIpXSA+PiAyKVxuICAgIGFycltMKytdID0gKHRtcCA+PiA4KSAmIDB4RkZcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBhcnJcbn1cblxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcbiAgcmV0dXJuIGxvb2t1cFtudW0gPj4gMTggJiAweDNGXSArIGxvb2t1cFtudW0gPj4gMTIgJiAweDNGXSArIGxvb2t1cFtudW0gPj4gNiAmIDB4M0ZdICsgbG9va3VwW251bSAmIDB4M0ZdXG59XG5cbmZ1bmN0aW9uIGVuY29kZUNodW5rICh1aW50OCwgc3RhcnQsIGVuZCkge1xuICB2YXIgdG1wXG4gIHZhciBvdXRwdXQgPSBbXVxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gMykge1xuICAgIHRtcCA9ICh1aW50OFtpXSA8PCAxNikgKyAodWludDhbaSArIDFdIDw8IDgpICsgKHVpbnQ4W2kgKyAyXSlcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcbiAgfVxuICByZXR1cm4gb3V0cHV0LmpvaW4oJycpXG59XG5cbmZ1bmN0aW9uIGZyb21CeXRlQXJyYXkgKHVpbnQ4KSB7XG4gIHZhciB0bXBcbiAgdmFyIGxlbiA9IHVpbnQ4Lmxlbmd0aFxuICB2YXIgZXh0cmFCeXRlcyA9IGxlbiAlIDMgLy8gaWYgd2UgaGF2ZSAxIGJ5dGUgbGVmdCwgcGFkIDIgYnl0ZXNcbiAgdmFyIG91dHB1dCA9ICcnXG4gIHZhciBwYXJ0cyA9IFtdXG4gIHZhciBtYXhDaHVua0xlbmd0aCA9IDE2MzgzIC8vIG11c3QgYmUgbXVsdGlwbGUgb2YgM1xuXG4gIC8vIGdvIHRocm91Z2ggdGhlIGFycmF5IGV2ZXJ5IHRocmVlIGJ5dGVzLCB3ZSdsbCBkZWFsIHdpdGggdHJhaWxpbmcgc3R1ZmYgbGF0ZXJcbiAgZm9yICh2YXIgaSA9IDAsIGxlbjIgPSBsZW4gLSBleHRyYUJ5dGVzOyBpIDwgbGVuMjsgaSArPSBtYXhDaHVua0xlbmd0aCkge1xuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXG4gIH1cblxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXG4gIGlmIChleHRyYUJ5dGVzID09PSAxKSB7XG4gICAgdG1wID0gdWludDhbbGVuIC0gMV1cbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9ICc9PSdcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XG4gICAgdG1wID0gKHVpbnQ4W2xlbiAtIDJdIDw8IDgpICsgKHVpbnQ4W2xlbiAtIDFdKVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDEwXVxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDIpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz0nXG4gIH1cblxuICBwYXJ0cy5wdXNoKG91dHB1dClcblxuICByZXR1cm4gcGFydHMuam9pbignJylcbn1cbiIsIiIsIi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuLyogZXNsaW50LWRpc2FibGUgbm8tcHJvdG8gKi9cblxuJ3VzZSBzdHJpY3QnXG5cbnZhciBiYXNlNjQgPSByZXF1aXJlKCdiYXNlNjQtanMnKVxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcblxuZXhwb3J0cy5CdWZmZXIgPSBCdWZmZXJcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcbmV4cG9ydHMuSU5TUEVDVF9NQVhfQllURVMgPSA1MFxuXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxuZXhwb3J0cy5rTWF4TGVuZ3RoID0gS19NQVhfTEVOR1RIXG5cbi8qKlxuICogSWYgYEJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUYDpcbiAqICAgPT09IHRydWUgICAgVXNlIFVpbnQ4QXJyYXkgaW1wbGVtZW50YXRpb24gKGZhc3Rlc3QpXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcbiAqICAgICAgICAgICAgICAgaW1wbGVtZW50YXRpb24gKG1vc3QgY29tcGF0aWJsZSwgZXZlbiBJRTYpXG4gKlxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxuICogT3BlcmEgMTEuNissIGlPUyA0LjIrLlxuICpcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxuICogdXNpbmcgX19wcm90b19fLiBGaXJlZm94IDQtMjkgbGFja3Mgc3VwcG9ydCBmb3IgYWRkaW5nIG5ldyBwcm9wZXJ0aWVzIHRvIGBVaW50OEFycmF5YFxuICogKFNlZTogaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk1NDM4KS4gSUUgMTAgbGFja3Mgc3VwcG9ydFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXG4gKi9cbkJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUID0gdHlwZWRBcnJheVN1cHBvcnQoKVxuXG5pZiAoIUJ1ZmZlci5UWVBFRF9BUlJBWV9TVVBQT1JUICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiBjb25zb2xlLmVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gIGNvbnNvbGUuZXJyb3IoXG4gICAgJ1RoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSAnICtcbiAgICAnYGJ1ZmZlcmAgdjUueC4gVXNlIGBidWZmZXJgIHY0LnggaWYgeW91IHJlcXVpcmUgb2xkIGJyb3dzZXIgc3VwcG9ydC4nXG4gIClcbn1cblxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xuICAvLyBDYW4gdHlwZWQgYXJyYXkgaW5zdGFuY2VzIGNhbiBiZSBhdWdtZW50ZWQ/XG4gIHRyeSB7XG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXG4gICAgYXJyLl9fcHJvdG9fXyA9IHtfX3Byb3RvX186IFVpbnQ4QXJyYXkucHJvdG90eXBlLCBmb286IGZ1bmN0aW9uICgpIHsgcmV0dXJuIDQyIH19XG4gICAgcmV0dXJuIGFyci5mb28oKSA9PT0gNDJcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUJ1ZmZlciAobGVuZ3RoKSB7XG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW52YWxpZCB0eXBlZCBhcnJheSBsZW5ndGgnKVxuICB9XG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIHZhciBidWYgPSBuZXcgVWludDhBcnJheShsZW5ndGgpXG4gIGJ1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBidWZcbn1cblxuLyoqXG4gKiBUaGUgQnVmZmVyIGNvbnN0cnVjdG9yIHJldHVybnMgaW5zdGFuY2VzIG9mIGBVaW50OEFycmF5YCB0aGF0IGhhdmUgdGhlaXJcbiAqIHByb3RvdHlwZSBjaGFuZ2VkIHRvIGBCdWZmZXIucHJvdG90eXBlYC4gRnVydGhlcm1vcmUsIGBCdWZmZXJgIGlzIGEgc3ViY2xhc3Mgb2ZcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcbiAqIGFuZCB0aGUgYFVpbnQ4QXJyYXlgIG1ldGhvZHMuIFNxdWFyZSBicmFja2V0IG5vdGF0aW9uIHdvcmtzIGFzIGV4cGVjdGVkIC0tIGl0XG4gKiByZXR1cm5zIGEgc2luZ2xlIG9jdGV0LlxuICpcbiAqIFRoZSBgVWludDhBcnJheWAgcHJvdG90eXBlIHJlbWFpbnMgdW5tb2RpZmllZC5cbiAqL1xuXG5mdW5jdGlvbiBCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIC8vIENvbW1vbiBjYXNlLlxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nT3JPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcbiAgICAgIClcbiAgICB9XG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcbiAgfVxuICByZXR1cm4gZnJvbShhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gRml4IHN1YmFycmF5KCkgaW4gRVMyMDE2LiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvOTdcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxuICAgIEJ1ZmZlcltTeW1ib2wuc3BlY2llc10gPT09IEJ1ZmZlcikge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQnVmZmVyLCBTeW1ib2wuc3BlY2llcywge1xuICAgIHZhbHVlOiBudWxsLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICB3cml0YWJsZTogZmFsc2VcbiAgfSlcbn1cblxuQnVmZmVyLnBvb2xTaXplID0gODE5MiAvLyBub3QgdXNlZCBieSB0aGlzIGltcGxlbWVudGF0aW9uXG5cbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG5cbiAgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIGZyb21BcnJheUJ1ZmZlcih2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZnJvbVN0cmluZyh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldClcbiAgfVxuXG4gIHJldHVybiBmcm9tT2JqZWN0KHZhbHVlKVxufVxuXG4vKipcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXG4gKiBpZiB2YWx1ZSBpcyBhIG51bWJlci5cbiAqIEJ1ZmZlci5mcm9tKHN0clssIGVuY29kaW5nXSlcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxuICogQnVmZmVyLmZyb20oYnVmZmVyKVxuICogQnVmZmVyLmZyb20oYXJyYXlCdWZmZXJbLCBieXRlT2Zmc2V0WywgbGVuZ3RoXV0pXG4gKiovXG5CdWZmZXIuZnJvbSA9IGZ1bmN0aW9uICh2YWx1ZSwgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBmcm9tKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIE5vdGU6IENoYW5nZSBwcm90b3R5cGUgKmFmdGVyKiBCdWZmZXIuZnJvbSBpcyBkZWZpbmVkIHRvIHdvcmthcm91bmQgQ2hyb21lIGJ1Zzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XG5CdWZmZXIucHJvdG90eXBlLl9fcHJvdG9fXyA9IFVpbnQ4QXJyYXkucHJvdG90eXBlXG5CdWZmZXIuX19wcm90b19fID0gVWludDhBcnJheVxuXG5mdW5jdGlvbiBhc3NlcnRTaXplIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfSBlbHNlIGlmIChzaXplIDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInNpemVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBuZWdhdGl2ZScpXG4gIH1cbn1cblxuZnVuY3Rpb24gYWxsb2MgKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgaWYgKHNpemUgPD0gMCkge1xuICAgIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbiAgfVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgLy8gT25seSBwYXkgYXR0ZW50aW9uIHRvIGVuY29kaW5nIGlmIGl0J3MgYSBzdHJpbmcuIFRoaXNcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXG4gICAgLy8gYmUgaW50ZXJwcmV0dGVkIGFzIGEgc3RhcnQgb2Zmc2V0LlxuICAgIHJldHVybiB0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgICAgOiBjcmVhdGVCdWZmZXIoc2l6ZSkuZmlsbChmaWxsKVxuICB9XG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcbn1cblxuLyoqXG4gKiBDcmVhdGVzIGEgbmV3IGZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKiBhbGxvYyhzaXplWywgZmlsbFssIGVuY29kaW5nXV0pXG4gKiovXG5CdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGFsbG9jKHNpemUsIGZpbGwsIGVuY29kaW5nKVxufVxuXG5mdW5jdGlvbiBhbGxvY1Vuc2FmZSAoc2l6ZSkge1xuICBhc3NlcnRTaXplKHNpemUpXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSA8IDAgPyAwIDogY2hlY2tlZChzaXplKSB8IDApXG59XG5cbi8qKlxuICogRXF1aXZhbGVudCB0byBCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqICovXG5CdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cbi8qKlxuICogRXF1aXZhbGVudCB0byBTbG93QnVmZmVyKG51bSksIGJ5IGRlZmF1bHQgY3JlYXRlcyBhIG5vbi16ZXJvLWZpbGxlZCBCdWZmZXIgaW5zdGFuY2UuXG4gKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICByZXR1cm4gYWxsb2NVbnNhZmUoc2l6ZSlcbn1cblxuZnVuY3Rpb24gZnJvbVN0cmluZyAoc3RyaW5nLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcbiAgICBlbmNvZGluZyA9ICd1dGY4J1xuICB9XG5cbiAgaWYgKCFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImVuY29kaW5nXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXG4gIH1cblxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcbiAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW5ndGgpXG5cbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuXG4gIGlmIChhY3R1YWwgIT09IGxlbmd0aCkge1xuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxuICAgIC8vIGNhdXNlIGV2ZXJ5dGhpbmcgYWZ0ZXIgdGhlIGZpcnN0IGludmFsaWQgY2hhcmFjdGVyIHRvIGJlIGlnbm9yZWQuIChlLmcuXG4gICAgLy8gJ2FieHhjZCcgd2lsbCBiZSB0cmVhdGVkIGFzICdhYicpXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcbiAgfVxuXG4gIHJldHVybiBidWZcbn1cblxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcbiAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCA8IDAgPyAwIDogY2hlY2tlZChhcnJheS5sZW5ndGgpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgIGJ1ZltpXSA9IGFycmF5W2ldICYgMjU1XG4gIH1cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwIHx8IGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0KSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcJ29mZnNldFxcJyBpcyBvdXQgb2YgYm91bmRzJylcbiAgfVxuXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnbGVuZ3RoXFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgdmFyIGJ1ZlxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgYnVmID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXkpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcbiAgfSBlbHNlIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldCwgbGVuZ3RoKVxuICB9XG5cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tT2JqZWN0IChvYmopIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihvYmopKSB7XG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXG4gICAgdmFyIGJ1ZiA9IGNyZWF0ZUJ1ZmZlcihsZW4pXG5cbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ1ZlxuICAgIH1cblxuICAgIG9iai5jb3B5KGJ1ZiwgMCwgMCwgbGVuKVxuICAgIHJldHVybiBidWZcbiAgfVxuXG4gIGlmIChvYmopIHtcbiAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcob2JqKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqLmxlbmd0aCAhPT0gJ251bWJlcicgfHwgbnVtYmVySXNOYU4ob2JqLmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcigwKVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqKVxuICAgIH1cblxuICAgIGlmIChvYmoudHlwZSA9PT0gJ0J1ZmZlcicgJiYgQXJyYXkuaXNBcnJheShvYmouZGF0YSkpIHtcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iai5kYXRhKVxuICAgIH1cbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxufVxuXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcbiAgLy8gTm90ZTogY2Fubm90IHVzZSBgbGVuZ3RoIDwgS19NQVhfTEVOR1RIYCBoZXJlIGJlY2F1c2UgdGhhdCBmYWlscyB3aGVuXG4gIC8vIGxlbmd0aCBpcyBOYU4gKHdoaWNoIGlzIG90aGVyd2lzZSBjb2VyY2VkIHRvIHplcm8uKVxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIGFsbG9jYXRlIEJ1ZmZlciBsYXJnZXIgdGhhbiBtYXhpbXVtICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICdzaXplOiAweCcgKyBLX01BWF9MRU5HVEgudG9TdHJpbmcoMTYpICsgJyBieXRlcycpXG4gIH1cbiAgcmV0dXJuIGxlbmd0aCB8IDBcbn1cblxuZnVuY3Rpb24gU2xvd0J1ZmZlciAobGVuZ3RoKSB7XG4gIGlmICgrbGVuZ3RoICE9IGxlbmd0aCkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGVxZXFlcVxuICAgIGxlbmd0aCA9IDBcbiAgfVxuICByZXR1cm4gQnVmZmVyLmFsbG9jKCtsZW5ndGgpXG59XG5cbkJ1ZmZlci5pc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyIChiKSB7XG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWVcbn1cblxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGEpIHx8ICFCdWZmZXIuaXNCdWZmZXIoYikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgbXVzdCBiZSBCdWZmZXJzJylcbiAgfVxuXG4gIGlmIChhID09PSBiKSByZXR1cm4gMFxuXG4gIHZhciB4ID0gYS5sZW5ndGhcbiAgdmFyIHkgPSBiLmxlbmd0aFxuXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBNYXRoLm1pbih4LCB5KTsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKGFbaV0gIT09IGJbaV0pIHtcbiAgICAgIHggPSBhW2ldXG4gICAgICB5ID0gYltpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbkJ1ZmZlci5pc0VuY29kaW5nID0gZnVuY3Rpb24gaXNFbmNvZGluZyAoZW5jb2RpbmcpIHtcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICBjYXNlICdoZXgnOlxuICAgIGNhc2UgJ3V0ZjgnOlxuICAgIGNhc2UgJ3V0Zi04JzpcbiAgICBjYXNlICdhc2NpaSc6XG4gICAgY2FzZSAnbGF0aW4xJzpcbiAgICBjYXNlICdiaW5hcnknOlxuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgY2FzZSAndWNzMic6XG4gICAgY2FzZSAndWNzLTInOlxuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgIHJldHVybiB0cnVlXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZVxuICB9XG59XG5cbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xuICBpZiAoIUFycmF5LmlzQXJyYXkobGlzdCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbGVuZ3RoID0gMFxuICAgIGZvciAoaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICBsZW5ndGggKz0gbGlzdFtpXS5sZW5ndGhcbiAgICB9XG4gIH1cblxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcbiAgdmFyIHBvcyA9IDBcbiAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gICAgfVxuICAgIGJ1Zi5jb3B5KGJ1ZmZlciwgcG9zKVxuICAgIHBvcyArPSBidWYubGVuZ3RoXG4gIH1cbiAgcmV0dXJuIGJ1ZmZlclxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xuICAgIHJldHVybiBzdHJpbmcubGVuZ3RoXG4gIH1cbiAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHN0cmluZykgfHwgaXNBcnJheUJ1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5ieXRlTGVuZ3RoXG4gIH1cbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XG4gICAgc3RyaW5nID0gJycgKyBzdHJpbmdcbiAgfVxuXG4gIHZhciBsZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChsZW4gPT09IDApIHJldHVybiAwXG5cbiAgLy8gVXNlIGEgZm9yIGxvb3AgdG8gYXZvaWQgcmVjdXJzaW9uXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxlblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICBjYXNlIHVuZGVmaW5lZDpcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gbGVuICogMlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGxlbiA+Pj4gMVxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoIC8vIGFzc3VtZSB1dGY4XG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5CdWZmZXIuYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGhcblxuZnVuY3Rpb24gc2xvd1RvU3RyaW5nIChlbmNvZGluZywgc3RhcnQsIGVuZCkge1xuICB2YXIgbG93ZXJlZENhc2UgPSBmYWxzZVxuXG4gIC8vIE5vIG5lZWQgdG8gdmVyaWZ5IHRoYXQgXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXCIgc2luY2UgaXQncyBhIHJlYWQtb25seVxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxuXG4gIC8vIFRoaXMgYmVoYXZlcyBuZWl0aGVyIGxpa2UgU3RyaW5nIG5vciBVaW50OEFycmF5IGluIHRoYXQgd2Ugc2V0IHN0YXJ0L2VuZFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXG4gIC8vIHVuZGVmaW5lZCBpcyBoYW5kbGVkIHNwZWNpYWxseSBhcyBwZXIgRUNNQS0yNjIgNnRoIEVkaXRpb24sXG4gIC8vIFNlY3Rpb24gMTMuMy4zLjcgUnVudGltZSBTZW1hbnRpY3M6IEtleWVkQmluZGluZ0luaXRpYWxpemF0aW9uLlxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxuICAvLyBjb2VyY2lvbiBmYWlsIGJlbG93LlxuICBpZiAoc3RhcnQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChlbmQgPD0gMCkge1xuICAgIHJldHVybiAnJ1xuICB9XG5cbiAgLy8gRm9yY2UgY29lcnNpb24gdG8gdWludDMyLiBUaGlzIHdpbGwgYWxzbyBjb2VyY2UgZmFsc2V5L05hTiB2YWx1ZXMgdG8gMC5cbiAgZW5kID4+Pj0gMFxuICBzdGFydCA+Pj49IDBcblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmNvZGluZykge1xuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgICAgcmV0dXJuIGFzY2lpU2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiBsYXRpbjFTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuIHV0ZjE2bGVTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBpZiAobG93ZXJlZENhc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cblxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxuLy8gdG8gZGV0ZWN0IGEgQnVmZmVyIGluc3RhbmNlLiBJdCdzIG5vdCBwb3NzaWJsZSB0byB1c2UgYGluc3RhbmNlb2YgQnVmZmVyYFxuLy8gcmVsaWFibHkgaW4gYSBicm93c2VyaWZ5IGNvbnRleHQgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBtdWx0aXBsZSBkaWZmZXJlbnRcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxuLy8gaW5zdGFuY2VzIHRoYXQgd2VyZSBjcmVhdGVkIGZyb20gYW5vdGhlciBjb3B5IG9mIHRoZSBgYnVmZmVyYCBwYWNrYWdlLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTU0XG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcblxuZnVuY3Rpb24gc3dhcCAoYiwgbiwgbSkge1xuICB2YXIgaSA9IGJbbl1cbiAgYltuXSA9IGJbbV1cbiAgYlttXSA9IGlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMTYgPSBmdW5jdGlvbiBzd2FwMTYgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDIgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDIpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAxKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDMyID0gZnVuY3Rpb24gc3dhcDMyICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiAzMi1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgMylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgMilcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXA2NCA9IGZ1bmN0aW9uIHN3YXA2NCAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNjQtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDcpXG4gICAgc3dhcCh0aGlzLCBpICsgMSwgaSArIDYpXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXG4gICAgc3dhcCh0aGlzLCBpICsgMywgaSArIDQpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcbiAgdmFyIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW5ndGggPT09IDApIHJldHVybiAnJ1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXG4gIHJldHVybiBzbG93VG9TdHJpbmcuYXBwbHkodGhpcywgYXJndW1lbnRzKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIGVxdWFscyAoYikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihiKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxuICByZXR1cm4gQnVmZmVyLmNvbXBhcmUodGhpcywgYikgPT09IDBcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0ID0gZnVuY3Rpb24gaW5zcGVjdCAoKSB7XG4gIHZhciBzdHIgPSAnJ1xuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xuICBpZiAodGhpcy5sZW5ndGggPiAwKSB7XG4gICAgc3RyID0gdGhpcy50b1N0cmluZygnaGV4JywgMCwgbWF4KS5tYXRjaCgvLnsyfS9nKS5qb2luKCcgJylcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXG4gIH1cbiAgcmV0dXJuICc8QnVmZmVyICcgKyBzdHIgKyAnPidcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5jb21wYXJlID0gZnVuY3Rpb24gY29tcGFyZSAodGFyZ2V0LCBzdGFydCwgZW5kLCB0aGlzU3RhcnQsIHRoaXNFbmQpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXInKVxuICB9XG5cbiAgaWYgKHN0YXJ0ID09PSB1bmRlZmluZWQpIHtcbiAgICBzdGFydCA9IDBcbiAgfVxuICBpZiAoZW5kID09PSB1bmRlZmluZWQpIHtcbiAgICBlbmQgPSB0YXJnZXQgPyB0YXJnZXQubGVuZ3RoIDogMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHRoaXNTdGFydCA9IDBcbiAgfVxuICBpZiAodGhpc0VuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc0VuZCA9IHRoaXMubGVuZ3RoXG4gIH1cblxuICBpZiAoc3RhcnQgPCAwIHx8IGVuZCA+IHRhcmdldC5sZW5ndGggfHwgdGhpc1N0YXJ0IDwgMCB8fCB0aGlzRW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMFxuICB9XG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xuICAgIHJldHVybiAtMVxuICB9XG4gIGlmIChzdGFydCA+PSBlbmQpIHtcbiAgICByZXR1cm4gMVxuICB9XG5cbiAgc3RhcnQgPj4+PSAwXG4gIGVuZCA+Pj49IDBcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxuICB0aGlzRW5kID4+Pj0gMFxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXG5cbiAgdmFyIHggPSB0aGlzRW5kIC0gdGhpc1N0YXJ0XG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcbiAgdmFyIGxlbiA9IE1hdGgubWluKHgsIHkpXG5cbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXG4gIHZhciB0YXJnZXRDb3B5ID0gdGFyZ2V0LnNsaWNlKHN0YXJ0LCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIGlmICh0aGlzQ29weVtpXSAhPT0gdGFyZ2V0Q29weVtpXSkge1xuICAgICAgeCA9IHRoaXNDb3B5W2ldXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxuICBpZiAoeSA8IHgpIHJldHVybiAxXG4gIHJldHVybiAwXG59XG5cbi8vIEZpbmRzIGVpdGhlciB0aGUgZmlyc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0ID49IGBieXRlT2Zmc2V0YCxcbi8vIE9SIHRoZSBsYXN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA8PSBgYnl0ZU9mZnNldGAuXG4vL1xuLy8gQXJndW1lbnRzOlxuLy8gLSBidWZmZXIgLSBhIEJ1ZmZlciB0byBzZWFyY2hcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXG4vLyAtIGJ5dGVPZmZzZXQgLSBhbiBpbmRleCBpbnRvIGBidWZmZXJgOyB3aWxsIGJlIGNsYW1wZWQgdG8gYW4gaW50MzJcbi8vIC0gZW5jb2RpbmcgLSBhbiBvcHRpb25hbCBlbmNvZGluZywgcmVsZXZhbnQgaXMgdmFsIGlzIGEgc3RyaW5nXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxuZnVuY3Rpb24gYmlkaXJlY3Rpb25hbEluZGV4T2YgKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XG4gIC8vIEVtcHR5IGJ1ZmZlciBtZWFucyBubyBtYXRjaFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXG5cbiAgLy8gTm9ybWFsaXplIGJ5dGVPZmZzZXRcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xuICAgIGVuY29kaW5nID0gYnl0ZU9mZnNldFxuICAgIGJ5dGVPZmZzZXQgPSAwXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcbiAgICBieXRlT2Zmc2V0ID0gMHg3ZmZmZmZmZlxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAtMHg4MDAwMDAwMCkge1xuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxuICB9XG4gIGJ5dGVPZmZzZXQgPSArYnl0ZU9mZnNldCAgLy8gQ29lcmNlIHRvIE51bWJlci5cbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XG4gICAgLy8gYnl0ZU9mZnNldDogaXQgaXQncyB1bmRlZmluZWQsIG51bGwsIE5hTiwgXCJmb29cIiwgZXRjLCBzZWFyY2ggd2hvbGUgYnVmZmVyXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXG4gIH1cblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxuICBpZiAoYnl0ZU9mZnNldCA8IDApIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldFxuICBpZiAoYnl0ZU9mZnNldCA+PSBidWZmZXIubGVuZ3RoKSB7XG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXG4gICAgZWxzZSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCAtIDFcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0IDwgMCkge1xuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXG4gICAgZWxzZSByZXR1cm4gLTFcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSB2YWxcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcbiAgfVxuXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIodmFsKSkge1xuICAgIC8vIFNwZWNpYWwgY2FzZTogbG9va2luZyBmb3IgZW1wdHkgc3RyaW5nL2J1ZmZlciBhbHdheXMgZmFpbHNcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIC0xXG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAweEZGIC8vIFNlYXJjaCBmb3IgYSBieXRlIHZhbHVlIFswLTI1NV1cbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGlmIChkaXIpIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBVaW50OEFycmF5LnByb3RvdHlwZS5sYXN0SW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlJbmRleE9mKGJ1ZmZlciwgWyB2YWwgXSwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfVxuXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ3ZhbCBtdXN0IGJlIHN0cmluZywgbnVtYmVyIG9yIEJ1ZmZlcicpXG59XG5cbmZ1bmN0aW9uIGFycmF5SW5kZXhPZiAoYXJyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgdmFyIGluZGV4U2l6ZSA9IDFcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcbiAgdmFyIHZhbExlbmd0aCA9IHZhbC5sZW5ndGhcblxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gU3RyaW5nKGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgaWYgKGVuY29kaW5nID09PSAndWNzMicgfHwgZW5jb2RpbmcgPT09ICd1Y3MtMicgfHxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xuICAgICAgaWYgKGFyci5sZW5ndGggPCAyIHx8IHZhbC5sZW5ndGggPCAyKSB7XG4gICAgICAgIHJldHVybiAtMVxuICAgICAgfVxuICAgICAgaW5kZXhTaXplID0gMlxuICAgICAgYXJyTGVuZ3RoIC89IDJcbiAgICAgIHZhbExlbmd0aCAvPSAyXG4gICAgICBieXRlT2Zmc2V0IC89IDJcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFkIChidWYsIGkpIHtcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XG4gICAgICByZXR1cm4gYnVmW2ldXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXG4gICAgfVxuICB9XG5cbiAgdmFyIGlcbiAgaWYgKGRpcikge1xuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpIDwgYXJyTGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChyZWFkKGFyciwgaSkgPT09IHJlYWQodmFsLCBmb3VuZEluZGV4ID09PSAtMSA/IDAgOiBpIC0gZm91bmRJbmRleCkpIHtcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxuICAgICAgICBpZiAoaSAtIGZvdW5kSW5kZXggKyAxID09PSB2YWxMZW5ndGgpIHJldHVybiBmb3VuZEluZGV4ICogaW5kZXhTaXplXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcbiAgICAgICAgZm91bmRJbmRleCA9IC0xXG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChieXRlT2Zmc2V0ICsgdmFsTGVuZ3RoID4gYXJyTGVuZ3RoKSBieXRlT2Zmc2V0ID0gYXJyTGVuZ3RoIC0gdmFsTGVuZ3RoXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcbiAgICAgIHZhciBmb3VuZCA9IHRydWVcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdmFsTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xuICAgICAgICAgIGZvdW5kID0gZmFsc2VcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZm91bmQpIHJldHVybiBpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gdGhpcy5pbmRleE9mKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpICE9PSAtMVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluZGV4T2YgPSBmdW5jdGlvbiBpbmRleE9mICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCB0cnVlKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mID0gZnVuY3Rpb24gbGFzdEluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxufVxuXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIG9mZnNldCA9IE51bWJlcihvZmZzZXQpIHx8IDBcbiAgdmFyIHJlbWFpbmluZyA9IGJ1Zi5sZW5ndGggLSBvZmZzZXRcbiAgaWYgKCFsZW5ndGgpIHtcbiAgICBsZW5ndGggPSByZW1haW5pbmdcbiAgfSBlbHNlIHtcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxuICAgIGlmIChsZW5ndGggPiByZW1haW5pbmcpIHtcbiAgICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICAgIH1cbiAgfVxuXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXG4gIHZhciBzdHJMZW4gPSBzdHJpbmcubGVuZ3RoXG4gIGlmIChzdHJMZW4gJSAyICE9PSAwKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIGhleCBzdHJpbmcnKVxuXG4gIGlmIChsZW5ndGggPiBzdHJMZW4gLyAyKSB7XG4gICAgbGVuZ3RoID0gc3RyTGVuIC8gMlxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgcGFyc2VkID0gcGFyc2VJbnQoc3RyaW5nLnN1YnN0cihpICogMiwgMiksIDE2KVxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxuICAgIGJ1ZltvZmZzZXQgKyBpXSA9IHBhcnNlZFxuICB9XG4gIHJldHVybiBpXG59XG5cbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjhUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGFzY2lpV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gbGF0aW4xV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIoYmFzZTY0VG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiB1Y3MyV3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gd3JpdGUgKHN0cmluZywgb2Zmc2V0LCBsZW5ndGgsIGVuY29kaW5nKSB7XG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXG4gIGlmIChvZmZzZXQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgICBvZmZzZXQgPSAwXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIGVuY29kaW5nKVxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBvZmZzZXRcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgb2Zmc2V0WywgbGVuZ3RoXVssIGVuY29kaW5nXSlcbiAgfSBlbHNlIGlmIChpc0Zpbml0ZShvZmZzZXQpKSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gICAgaWYgKGlzRmluaXRlKGxlbmd0aCkpIHtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA+Pj4gMFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXG4gICAgfSBlbHNlIHtcbiAgICAgIGVuY29kaW5nID0gbGVuZ3RoXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgJ0J1ZmZlci53cml0ZShzdHJpbmcsIGVuY29kaW5nLCBvZmZzZXRbLCBsZW5ndGhdKSBpcyBubyBsb25nZXIgc3VwcG9ydGVkJ1xuICAgIClcbiAgfVxuXG4gIHZhciByZW1haW5pbmcgPSB0aGlzLmxlbmd0aCAtIG9mZnNldFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcblxuICBpZiAoKHN0cmluZy5sZW5ndGggPiAwICYmIChsZW5ndGggPCAwIHx8IG9mZnNldCA8IDApKSB8fCBvZmZzZXQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXG4gIH1cblxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xuXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG4gIGZvciAoOzspIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIC8vIFdhcm5pbmc6IG1heExlbmd0aCBub3QgdGFrZW4gaW50byBhY2NvdW50IGluIGJhc2U2NFdyaXRlXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9ICgnJyArIGVuY29kaW5nKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gIHJldHVybiB7XG4gICAgdHlwZTogJ0J1ZmZlcicsXG4gICAgZGF0YTogQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyIHx8IHRoaXMsIDApXG4gIH1cbn1cblxuZnVuY3Rpb24gYmFzZTY0U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGJhc2U2NC5mcm9tQnl0ZUFycmF5KGJ1ZilcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxuICB9XG59XG5cbmZ1bmN0aW9uIHV0ZjhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcbiAgdmFyIHJlcyA9IFtdXG5cbiAgdmFyIGkgPSBzdGFydFxuICB3aGlsZSAoaSA8IGVuZCkge1xuICAgIHZhciBmaXJzdEJ5dGUgPSBidWZbaV1cbiAgICB2YXIgY29kZVBvaW50ID0gbnVsbFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxuICAgICAgOiAoZmlyc3RCeXRlID4gMHhERikgPyAzXG4gICAgICA6IChmaXJzdEJ5dGUgPiAweEJGKSA/IDJcbiAgICAgIDogMVxuXG4gICAgaWYgKGkgKyBieXRlc1BlclNlcXVlbmNlIDw9IGVuZCkge1xuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxuXG4gICAgICBzd2l0Y2ggKGJ5dGVzUGVyU2VxdWVuY2UpIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGlmIChmaXJzdEJ5dGUgPCAweDgwKSB7XG4gICAgICAgICAgICBjb2RlUG9pbnQgPSBmaXJzdEJ5dGVcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHgxRikgPDwgMHg2IHwgKHNlY29uZEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0ZGICYmICh0ZW1wQ29kZVBvaW50IDwgMHhEODAwIHx8IHRlbXBDb2RlUG9pbnQgPiAweERGRkYpKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXG4gICAgICAgICAgdGhpcmRCeXRlID0gYnVmW2kgKyAyXVxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwICYmIChmb3VydGhCeXRlICYgMHhDMCkgPT09IDB4ODApIHtcbiAgICAgICAgICAgIHRlbXBDb2RlUG9pbnQgPSAoZmlyc3RCeXRlICYgMHhGKSA8PCAweDEyIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweEMgfCAodGhpcmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKGZvdXJ0aEJ5dGUgJiAweDNGKVxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICAgICAgICAgIGNvZGVQb2ludCA9IHRlbXBDb2RlUG9pbnRcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGNvZGVQb2ludCA9PT0gbnVsbCkge1xuICAgICAgLy8gd2UgZGlkIG5vdCBnZW5lcmF0ZSBhIHZhbGlkIGNvZGVQb2ludCBzbyBpbnNlcnQgYVxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxuICAgICAgY29kZVBvaW50ID0gMHhGRkZEXG4gICAgICBieXRlc1BlclNlcXVlbmNlID0gMVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XG4gICAgICAvLyBlbmNvZGUgdG8gdXRmMTYgKHN1cnJvZ2F0ZSBwYWlyIGRhbmNlKVxuICAgICAgY29kZVBvaW50IC09IDB4MTAwMDBcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcbiAgICAgIGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGXG4gICAgfVxuXG4gICAgcmVzLnB1c2goY29kZVBvaW50KVxuICAgIGkgKz0gYnl0ZXNQZXJTZXF1ZW5jZVxuICB9XG5cbiAgcmV0dXJuIGRlY29kZUNvZGVQb2ludHNBcnJheShyZXMpXG59XG5cbi8vIEJhc2VkIG9uIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzIyNzQ3MjcyLzY4MDc0MiwgdGhlIGJyb3dzZXIgd2l0aFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxuLy8gV2UgZ28gMSBtYWduaXR1ZGUgbGVzcywgZm9yIHNhZmV0eVxudmFyIE1BWF9BUkdVTUVOVFNfTEVOR1RIID0gMHgxMDAwXG5cbmZ1bmN0aW9uIGRlY29kZUNvZGVQb2ludHNBcnJheSAoY29kZVBvaW50cykge1xuICB2YXIgbGVuID0gY29kZVBvaW50cy5sZW5ndGhcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xuICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZywgY29kZVBvaW50cykgLy8gYXZvaWQgZXh0cmEgc2xpY2UoKVxuICB9XG5cbiAgLy8gRGVjb2RlIGluIGNodW5rcyB0byBhdm9pZCBcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFwiLlxuICB2YXIgcmVzID0gJydcbiAgdmFyIGkgPSAwXG4gIHdoaWxlIChpIDwgbGVuKSB7XG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXG4gICAgICBTdHJpbmcsXG4gICAgICBjb2RlUG9pbnRzLnNsaWNlKGksIGkgKz0gTUFYX0FSR1VNRU5UU19MRU5HVEgpXG4gICAgKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0gJiAweDdGKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgcmV0ID0gJydcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldKVxuICB9XG4gIHJldHVybiByZXRcbn1cblxuZnVuY3Rpb24gaGV4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aFxuXG4gIGlmICghc3RhcnQgfHwgc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgfHwgZW5kIDwgMCB8fCBlbmQgPiBsZW4pIGVuZCA9IGxlblxuXG4gIHZhciBvdXQgPSAnJ1xuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIG91dCArPSB0b0hleChidWZbaV0pXG4gIH1cbiAgcmV0dXJuIG91dFxufVxuXG5mdW5jdGlvbiB1dGYxNmxlU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcbiAgdmFyIHJlcyA9ICcnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpICs9IDIpIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uIHNsaWNlIChzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBzdGFydCA9IH5+c3RhcnRcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW4gOiB+fmVuZFxuXG4gIGlmIChzdGFydCA8IDApIHtcbiAgICBzdGFydCArPSBsZW5cbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcbiAgfSBlbHNlIGlmIChzdGFydCA+IGxlbikge1xuICAgIHN0YXJ0ID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgMCkge1xuICAgIGVuZCArPSBsZW5cbiAgICBpZiAoZW5kIDwgMCkgZW5kID0gMFxuICB9IGVsc2UgaWYgKGVuZCA+IGxlbikge1xuICAgIGVuZCA9IGxlblxuICB9XG5cbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIHZhciBuZXdCdWYgPSB0aGlzLnN1YmFycmF5KHN0YXJ0LCBlbmQpXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXG4gIG5ld0J1Zi5fX3Byb3RvX18gPSBCdWZmZXIucHJvdG90eXBlXG4gIHJldHVybiBuZXdCdWZcbn1cblxuLypcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxuICovXG5mdW5jdGlvbiBjaGVja09mZnNldCAob2Zmc2V0LCBleHQsIGxlbmd0aCkge1xuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gbGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignVHJ5aW5nIHRvIGFjY2VzcyBiZXlvbmQgYnVmZmVyIGxlbmd0aCcpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRSA9IGZ1bmN0aW9uIHJlYWRVSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkUgPSBmdW5jdGlvbiByZWFkVUludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcbiAgfVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0tYnl0ZUxlbmd0aF1cbiAgdmFyIG11bCA9IDFcbiAgd2hpbGUgKGJ5dGVMZW5ndGggPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXSAqIG11bFxuICB9XG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50OCA9IGZ1bmN0aW9uIHJlYWRVSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MTZMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIHRoaXNbb2Zmc2V0XSB8ICh0aGlzW29mZnNldCArIDFdIDw8IDgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkJFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCA4KSB8IHRoaXNbb2Zmc2V0ICsgMV1cbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyTEUgPSBmdW5jdGlvbiByZWFkVUludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KSB8XG4gICAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikpICtcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSAqIDB4MTAwMDAwMCkgK1xuICAgICgodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICB0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRSA9IGZ1bmN0aW9uIHJlYWRJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50QkUgPSBmdW5jdGlvbiByZWFkSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoXG4gIHZhciBtdWwgPSAxXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIC0taV1cbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgLS1pXSAqIG11bFxuICB9XG4gIG11bCAqPSAweDgwXG5cbiAgaWYgKHZhbCA+PSBtdWwpIHZhbCAtPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aClcblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDggPSBmdW5jdGlvbiByZWFkSW50OCAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcbiAgaWYgKCEodGhpc1tvZmZzZXRdICYgMHg4MCkpIHJldHVybiAodGhpc1tvZmZzZXRdKVxuICByZXR1cm4gKCgweGZmIC0gdGhpc1tvZmZzZXRdICsgMSkgKiAtMSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MTZMRSA9IGZ1bmN0aW9uIHJlYWRJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEUgPSBmdW5jdGlvbiByZWFkSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAyXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDNdIDw8IDI0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkJFID0gZnVuY3Rpb24gcmVhZEludDMyQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG5cbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAxXSA8PCAxNikgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgOCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXG59XG5cbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJidWZmZXJcIiBhcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyIGluc3RhbmNlJylcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXCJ2YWx1ZVwiIGFyZ3VtZW50IGlzIG91dCBvZiBib3VuZHMnKVxuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50TEUgPSBmdW5jdGlvbiB3cml0ZVVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgbXVsID0gMVxuICB2YXIgaSA9IDBcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxuICB9XG5cbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxuICB2YXIgbXVsID0gMVxuICB0aGlzW29mZnNldCArIGldID0gdmFsdWUgJiAweEZGXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAodmFsdWUgLyBtdWwpICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQ4ID0gZnVuY3Rpb24gd3JpdGVVSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4ZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlSW50TEUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gMFxuICB2YXIgbXVsID0gMVxuICB2YXIgc3ViID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBsaW1pdCA9IE1hdGgucG93KDIsICg4ICogYnl0ZUxlbmd0aCkgLSAxKVxuXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgaWYgKHZhbHVlIDwgMCAmJiBzdWIgPT09IDAgJiYgdGhpc1tvZmZzZXQgKyBpICsgMV0gIT09IDApIHtcbiAgICAgIHN1YiA9IDFcbiAgICB9XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICgodmFsdWUgLyBtdWwpID4+IDApIC0gc3ViICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIG9mZnNldCArIGJ5dGVMZW5ndGhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDggPSBmdW5jdGlvbiB3cml0ZUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweDdmLCAtMHg4MClcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyAxXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4N2ZmZiwgLTB4ODAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEUgPSBmdW5jdGlvbiB3cml0ZUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJCRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmZmZmZmZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXG4gIHRoaXNbb2Zmc2V0ICsgMl0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgNFxufVxuXG5mdW5jdGlvbiBjaGVja0lFRUU3NTQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAob2Zmc2V0ICsgZXh0ID4gYnVmLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0luZGV4IG91dCBvZiByYW5nZScpXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgNCwgMy40MDI4MjM0NjYzODUyODg2ZSszOCwgLTMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVGbG9hdExFID0gZnVuY3Rpb24gd3JpdGVGbG9hdExFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVGbG9hdCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0QkUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDgsIDEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4LCAtMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgpXG4gIH1cbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXG4gIHJldHVybiBvZmZzZXQgKyA4XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRSA9IGZ1bmN0aW9uIHdyaXRlRG91YmxlTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZURvdWJsZSh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCB0cnVlLCBub0Fzc2VydClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcbn1cblxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxuQnVmZmVyLnByb3RvdHlwZS5jb3B5ID0gZnVuY3Rpb24gY29weSAodGFyZ2V0LCB0YXJnZXRTdGFydCwgc3RhcnQsIGVuZCkge1xuICBpZiAoIXN0YXJ0KSBzdGFydCA9IDBcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0U3RhcnQgPj0gdGFyZ2V0Lmxlbmd0aCkgdGFyZ2V0U3RhcnQgPSB0YXJnZXQubGVuZ3RoXG4gIGlmICghdGFyZ2V0U3RhcnQpIHRhcmdldFN0YXJ0ID0gMFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcblxuICAvLyBDb3B5IDAgYnl0ZXM7IHdlJ3JlIGRvbmVcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXG4gIGlmICh0YXJnZXQubGVuZ3RoID09PSAwIHx8IHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gMFxuXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcbiAgaWYgKHRhcmdldFN0YXJ0IDwgMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCd0YXJnZXRTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgfVxuICBpZiAoc3RhcnQgPCAwIHx8IHN0YXJ0ID49IHRoaXMubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlU3RhcnQgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChlbmQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignc291cmNlRW5kIG91dCBvZiBib3VuZHMnKVxuXG4gIC8vIEFyZSB3ZSBvb2I/XG4gIGlmIChlbmQgPiB0aGlzLmxlbmd0aCkgZW5kID0gdGhpcy5sZW5ndGhcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XG4gICAgZW5kID0gdGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0ICsgc3RhcnRcbiAgfVxuXG4gIHZhciBsZW4gPSBlbmQgLSBzdGFydFxuICB2YXIgaVxuXG4gIGlmICh0aGlzID09PSB0YXJnZXQgJiYgc3RhcnQgPCB0YXJnZXRTdGFydCAmJiB0YXJnZXRTdGFydCA8IGVuZCkge1xuICAgIC8vIGRlc2NlbmRpbmcgY29weSBmcm9tIGVuZFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwKSB7XG4gICAgLy8gYXNjZW5kaW5nIGNvcHkgZnJvbSBzdGFydFxuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXG4gICAgICB0YXJnZXQsXG4gICAgICB0aGlzLnN1YmFycmF5KHN0YXJ0LCBzdGFydCArIGxlbiksXG4gICAgICB0YXJnZXRTdGFydFxuICAgIClcbiAgfVxuXG4gIHJldHVybiBsZW5cbn1cblxuLy8gVXNhZ2U6XG4vLyAgICBidWZmZXIuZmlsbChudW1iZXJbLCBvZmZzZXRbLCBlbmRdXSlcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoc3RyaW5nWywgb2Zmc2V0WywgZW5kXV1bLCBlbmNvZGluZ10pXG5CdWZmZXIucHJvdG90eXBlLmZpbGwgPSBmdW5jdGlvbiBmaWxsICh2YWwsIHN0YXJ0LCBlbmQsIGVuY29kaW5nKSB7XG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XG4gIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIGlmICh0eXBlb2Ygc3RhcnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XG4gICAgICBzdGFydCA9IDBcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xuICAgICAgZW5jb2RpbmcgPSBlbmRcbiAgICAgIGVuZCA9IHRoaXMubGVuZ3RoXG4gICAgfVxuICAgIGlmICh2YWwubGVuZ3RoID09PSAxKSB7XG4gICAgICB2YXIgY29kZSA9IHZhbC5jaGFyQ29kZUF0KDApXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xuICAgICAgICB2YWwgPSBjb2RlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiBlbmNvZGluZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VuY29kaW5nIG11c3QgYmUgYSBzdHJpbmcnKVxuICAgIH1cbiAgICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJyAmJiAhQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgdmFsID0gdmFsICYgMjU1XG4gIH1cblxuICAvLyBJbnZhbGlkIHJhbmdlcyBhcmUgbm90IHNldCB0byBhIGRlZmF1bHQsIHNvIGNhbiByYW5nZSBjaGVjayBlYXJseS5cbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ091dCBvZiByYW5nZSBpbmRleCcpXG4gIH1cblxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XG4gICAgcmV0dXJuIHRoaXNcbiAgfVxuXG4gIHN0YXJ0ID0gc3RhcnQgPj4+IDBcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxuXG4gIGlmICghdmFsKSB2YWwgPSAwXG5cbiAgdmFyIGlcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgdGhpc1tpXSA9IHZhbFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgYnl0ZXMgPSBCdWZmZXIuaXNCdWZmZXIodmFsKVxuICAgICAgPyB2YWxcbiAgICAgIDogbmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKVxuICAgIHZhciBsZW4gPSBieXRlcy5sZW5ndGhcbiAgICBmb3IgKGkgPSAwOyBpIDwgZW5kIC0gc3RhcnQ7ICsraSkge1xuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpc1xufVxuXG4vLyBIRUxQRVIgRlVOQ1RJT05TXG4vLyA9PT09PT09PT09PT09PT09XG5cbnZhciBJTlZBTElEX0JBU0U2NF9SRSA9IC9bXisvMC05QS1aYS16LV9dL2dcblxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xuICAvLyBOb2RlIHN0cmlwcyBvdXQgaW52YWxpZCBjaGFyYWN0ZXJzIGxpa2UgXFxuIGFuZCBcXHQgZnJvbSB0aGUgc3RyaW5nLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcbiAgLy8gTm9kZSBjb252ZXJ0cyBzdHJpbmdzIHdpdGggbGVuZ3RoIDwgMiB0byAnJ1xuICBpZiAoc3RyLmxlbmd0aCA8IDIpIHJldHVybiAnJ1xuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcbiAgd2hpbGUgKHN0ci5sZW5ndGggJSA0ICE9PSAwKSB7XG4gICAgc3RyID0gc3RyICsgJz0nXG4gIH1cbiAgcmV0dXJuIHN0clxufVxuXG5mdW5jdGlvbiB0b0hleCAobikge1xuICBpZiAobiA8IDE2KSByZXR1cm4gJzAnICsgbi50b1N0cmluZygxNilcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXG59XG5cbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XG4gIHVuaXRzID0gdW5pdHMgfHwgSW5maW5pdHlcbiAgdmFyIGNvZGVQb2ludFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxuICB2YXIgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcbiAgdmFyIGJ5dGVzID0gW11cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSlcblxuICAgIC8vIGlzIHN1cnJvZ2F0ZSBjb21wb25lbnRcbiAgICBpZiAoY29kZVBvaW50ID4gMHhEN0ZGICYmIGNvZGVQb2ludCA8IDB4RTAwMCkge1xuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcbiAgICAgIGlmICghbGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgICAvLyBubyBsZWFkIHlldFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XG4gICAgICAgICAgLy8gdW5leHBlY3RlZCB0cmFpbFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSBpZiAoaSArIDEgPT09IGxlbmd0aCkge1xuICAgICAgICAgIC8vIHVucGFpcmVkIGxlYWRcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gdmFsaWQgbGVhZFxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG5cbiAgICAgICAgY29udGludWVcbiAgICAgIH1cblxuICAgICAgLy8gMiBsZWFkcyBpbiBhIHJvd1xuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4REMwMCkge1xuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICAgICAgbGVhZFN1cnJvZ2F0ZSA9IGNvZGVQb2ludFxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyB2YWxpZCBzdXJyb2dhdGUgcGFpclxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxuICAgIH0gZWxzZSBpZiAobGVhZFN1cnJvZ2F0ZSkge1xuICAgICAgLy8gdmFsaWQgYm1wIGNoYXIsIGJ1dCBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgfVxuXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcblxuICAgIC8vIGVuY29kZSB1dGY4XG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMSkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChjb2RlUG9pbnQpXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAyKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gMykgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTEwMDAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDQpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDEyIHwgMHhGMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBjb2RlIHBvaW50JylcbiAgICB9XG4gIH1cblxuICByZXR1cm4gYnl0ZXNcbn1cblxuZnVuY3Rpb24gYXNjaWlUb0J5dGVzIChzdHIpIHtcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgLy8gTm9kZSdzIGNvZGUgc2VlbXMgdG8gYmUgZG9pbmcgdGhpcyBhbmQgbm90ICYgMHg3Ri4uXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxuICB9XG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMgKHN0ciwgdW5pdHMpIHtcbiAgdmFyIGMsIGhpLCBsb1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcblxuICAgIGMgPSBzdHIuY2hhckNvZGVBdChpKVxuICAgIGhpID0gYyA+PiA4XG4gICAgbG8gPSBjICUgMjU2XG4gICAgYnl0ZUFycmF5LnB1c2gobG8pXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXG4gIH1cblxuICByZXR1cm4gYnl0ZUFycmF5XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xuICByZXR1cm4gYmFzZTY0LnRvQnl0ZUFycmF5KGJhc2U2NGNsZWFuKHN0cikpXG59XG5cbmZ1bmN0aW9uIGJsaXRCdWZmZXIgKHNyYywgZHN0LCBvZmZzZXQsIGxlbmd0aCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xuICAgIGRzdFtpICsgb2Zmc2V0XSA9IHNyY1tpXVxuICB9XG4gIHJldHVybiBpXG59XG5cbi8vIEFycmF5QnVmZmVycyBmcm9tIGFub3RoZXIgY29udGV4dCAoaS5lLiBhbiBpZnJhbWUpIGRvIG5vdCBwYXNzIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2tcbi8vIGJ1dCB0aGV5IHNob3VsZCBiZSB0cmVhdGVkIGFzIHZhbGlkLiBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNjZcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIgKG9iaikge1xuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcbiAgICAob2JqICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yICE9IG51bGwgJiYgb2JqLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdBcnJheUJ1ZmZlcicgJiZcbiAgICAgIHR5cGVvZiBvYmouYnl0ZUxlbmd0aCA9PT0gJ251bWJlcicpXG59XG5cbi8vIE5vZGUgMC4xMCBzdXBwb3J0cyBgQXJyYXlCdWZmZXJgIGJ1dCBsYWNrcyBgQXJyYXlCdWZmZXIuaXNWaWV3YFxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcgKG9iaikge1xuICByZXR1cm4gKHR5cGVvZiBBcnJheUJ1ZmZlci5pc1ZpZXcgPT09ICdmdW5jdGlvbicpICYmIEFycmF5QnVmZmVyLmlzVmlldyhvYmopXG59XG5cbmZ1bmN0aW9uIG51bWJlcklzTmFOIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPT0gb2JqIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2VsZi1jb21wYXJlXG59XG4iLCIvKmdsb2JhbCBiYXNlLmNvb2tpZUhhbmRsZXIsIGNhbm55ICovXG5cbihmdW5jdGlvbiAoKSB7XG4gICAgdmFyIERFRkFVTFRfTElGRVRJTUVfQVNfREFZUyA9IDM2NSAqIDUsXG4gICAgICAgIERFRkFVTFRfUEFUSCA9ICcvJztcblxuICAgIHZhciBjb29raWVNYW5hZ2VyID0ge307XG5cbiAgICAvKipcbiAgICAgKiBBIGNvb2tpZSBtYW5hZ2VyIGZvciBoYW5kbGluZyBjb29raWVzIHdoZXJlIHRoZSBjb29raWUgdmFsdWUgaXMgYSBKU09OLXN0cmluZ2lmaWVkIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEZvciBjcmVhdGluZyBhIHNlc3Npb24gY29va2llIChpLmUuIGRlbGV0ZWQgd2hlbiBicm93c2VyIGNsb3NlcyksIGFkZCBhIG51bGwtdmFsdWVkIGRvbWFpbiBwcm9wZXJ0eSB0b1xuICAgICAqIGNvb2tpZUF0dHJpYnV0ZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29va2llTmFtZVxuICAgICAqIEBwYXJhbSBjb29raWVBdHRyaWJ1dGVzOiBhbiBvcHRpb25hbCBvYmplY3Qgd2hlcmUgdGhlIHByb3BlcnRpZXMgYXJlIGF0dHJpYnV0ZXMgb2YgdGhlIGNvb2tpZSAtIGV4cGlyZURheXMsXG4gICAgICogZG9tYWluLCBwYXRoIChpZiBhbnkgb2YgdGhvc2UgaXMgbGVmdCBvdXQgZGVmYXVsdHMgd2lsbCBiZSB1c2VkKS5cbiAgICAgKiBAcmV0dXJucyB7e2Nvb2tpZU5hbWUsIHN0b3JlOiBzdG9yZSwgc3RvcmVBbGw6IHN0b3JlQWxsLCBnZXRWYWx1ZTogZ2V0VmFsdWUsIGdldFZhbHVlczogZ2V0VmFsdWVzfX1cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKi9cbiAgICB2YXIgQ29va2llTWFuYWdlciA9IGZ1bmN0aW9uKGNvb2tpZU5hbWUsIGNvb2tpZUF0dHJpYnV0ZXMpIHtcblxuICAgICAgICB2YXIgbGlmZXRpbWVBc0RheXMgPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBpZiAoY29va2llQXR0cmlidXRlcyAmJiBjb29raWVBdHRyaWJ1dGVzLmV4cGlyZURheXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29va2llQXR0cmlidXRlcy5leHBpcmVEYXlzO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChjb29raWVBdHRyaWJ1dGVzICYmIGNvb2tpZUF0dHJpYnV0ZXMuZXhwaXJlRGF5cyA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gREVGQVVMVF9MSUZFVElNRV9BU19EQVlTO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSgpO1xuICAgICAgICB2YXIgZG9tYWluID0gY29va2llQXR0cmlidXRlcyAmJiBjb29raWVBdHRyaWJ1dGVzLmRvbWFpbiA/XG4gICAgICAgICAgICBjb29raWVBdHRyaWJ1dGVzLmRvbWFpbiA6IGNvb2tpZU1hbmFnZXIuY29tcHV0ZUNvb2tpZURvbWFpbihkb2N1bWVudC5sb2NhdGlvbi5ob3N0bmFtZSwgZmFsc2UpO1xuICAgICAgICB2YXIgcGF0aCA9IGNvb2tpZUF0dHJpYnV0ZXMgJiYgY29va2llQXR0cmlidXRlcy5wYXRoID9cbiAgICAgICAgICAgIGNvb2tpZUF0dHJpYnV0ZXMucGF0aCA6IERFRkFVTFRfUEFUSDtcblxuICAgICAgICBmdW5jdGlvbiBnZXRDb29raWVWYWx1ZXMoY29va2llTmFtZSkge1xuICAgICAgICAgICAgdmFyIGksIGN1cnJlbnROYW1lLCBjdXJyZW50VmFsdWUsIGRlY29kZWRWYWx1ZSxcbiAgICAgICAgICAgICAgICBhbGxDb29raWVzID0gd2luZG93LmRvY3VtZW50LmNvb2tpZS5zcGxpdChcIjtcIiksXG4gICAgICAgICAgICAgICAgY29va2llVmFsdWUgPSB7fTtcbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBhbGxDb29raWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE5hbWUgPSBhbGxDb29raWVzW2ldLnN1YnN0cigwLCBhbGxDb29raWVzW2ldLmluZGV4T2YoXCI9XCIpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50TmFtZSA9IGN1cnJlbnROYW1lLnJlcGxhY2UoL15cXHMrfFxccyskL2csIFwiXCIpO1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50TmFtZSA9PT0gY29va2llTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50VmFsdWUgPSBhbGxDb29raWVzW2ldLnN1YnN0cihhbGxDb29raWVzW2ldLmluZGV4T2YoXCI9XCIpICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29va2llVmFsdWUgPSBKU09OLnBhcnNlKGRlY29kZVVSSUNvbXBvbmVudChjdXJyZW50VmFsdWUpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgY29va2llVmFsdWUgPSBkZWNvZGVVUklDb21wb25lbnQoY3VycmVudFZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvb2tpZVZhbHVlO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY29tcHV0ZU5ld0V4cGlyeURhdGVTdHJpbmcoKSB7XG4gICAgICAgICAgICB2YXIgZXhwaXJ5RGF0ZSA9IG5ldyBEYXRlKCk7XG4gICAgICAgICAgICBleHBpcnlEYXRlLnNldERhdGUoZXhwaXJ5RGF0ZS5nZXREYXRlKCkgKyBsaWZldGltZUFzRGF5cyk7XG4gICAgICAgICAgICByZXR1cm4gZXhwaXJ5RGF0ZS50b1VUQ1N0cmluZygpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFVwZGF0ZSB0aGUgKmZ1bGwqIHZhbHVlIG9mIHRoZSBjb29raWUsIGluY2wuIHdyaXRpbmcgYWxsIG90aGVyIGNvb2tpZSBhdHRyaWJ1dGVzIGFjY29yZGluZyB0b1xuICAgICAgICAgKiBjb25maWd1cmF0aW9uIG9mIGNvb2tpZSBtYW5hZ2VyLlxuICAgICAgICAgKiBAcGFyYW0gY29va2llVmFsdWUgYW4gb2JqZWN0IHdoZXJlIGVhY2ggb3duIHByb3BlcnR5IGlzIGFuIGVudHJ5IGluIHRoZSBjb29raWUgdmFsdWUuXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiB1cGRhdGVDb29raWUoY29va2llVmFsdWUpIHtcbiAgICAgICAgICAgIHZhciBjb29raWVQYXJ0cyA9IFtcbiAgICAgICAgICAgICAgICBjb29raWVOYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNvb2tpZVZhbHVlKSksXG4gICAgICAgICAgICAgICAgJ3BhdGg9JyArIHBhdGgsXG4gICAgICAgICAgICAgICAgJ2RvbWFpbj0nICsgZG9tYWluXG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgaWYgKGxpZmV0aW1lQXNEYXlzKSB7XG4gICAgICAgICAgICAgICAgY29va2llUGFydHMucHVzaCgnZXhwaXJlcz0nICsgY29tcHV0ZU5ld0V4cGlyeURhdGVTdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHdpbmRvdy5kb2N1bWVudC5jb29raWUgPSBjb29raWVQYXJ0cy5qb2luKCc7Jyk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogTWVyZ2UgbmV3IHZhbHVlcyBpbnRvIGV4aXN0aW5nL29sZCB2YWx1ZXMuXG4gICAgICAgICAqIEBwYXJhbSBuZXdDb29raWVWYWx1ZXMgYW4gb2JqZWN0IGhvbGRpbmcgYWxsIG5ldyBjb29raWUgdmFsdWUgZW50cmllcyAoZW50cmllcyBtYXkgYWxyZWFkeSBleGlzdFxuICAgICAgICAgKiBpbiBleGlzdGluZ0Nvb2tpZVZhbHVlcylcbiAgICAgICAgICogQHBhcmFtIGV4aXN0aW5nQ29va2llVmFsdWVzIGFuIG9iamVjdCBob2xkaW5nIGFsbCBleGlzdGluZyBjb29raWUgdmFsdWUgZW50cmllcy5cbiAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBtZXJnZU5ld0ludG9PbGRWYWx1ZXMobmV3Q29va2llVmFsdWVzLCBleGlzdGluZ0Nvb2tpZVZhbHVlcykge1xuICAgICAgICAgICAgT2JqZWN0LmtleXMobmV3Q29va2llVmFsdWVzKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBleGlzdGluZ0Nvb2tpZVZhbHVlc1trZXldID0gbmV3Q29va2llVmFsdWVzW2tleV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiBleGlzdGluZ0Nvb2tpZVZhbHVlcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvb2tpZVZhbHVlcyhjb29raWVWYWx1ZXMpIHtcbiAgICAgICAgICAgIHZhciBvbGRDb29raWVWYWx1ZSA9IGdldENvb2tpZVZhbHVlcyhjb29raWVOYW1lKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhvbGRDb29raWVWYWx1ZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29va2llKGNvb2tpZVZhbHVlcyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvb2tpZShtZXJnZU5ld0ludG9PbGRWYWx1ZXMoY29va2llVmFsdWVzLCBvbGRDb29raWVWYWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gaXNWYWxpZENvb2tpZVZhbHVlRW50cmllcyhlbnRyaWVzKSB7XG4gICAgICAgICAgICByZXR1cm4gdHlwZW9mIGVudHJpZXMgPT09ICdvYmplY3QnICYmIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCggZW50cmllcyApICE9PSAnW29iamVjdCBBcnJheV0nO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGdldCBjb29raWVOYW1lKCkgeyByZXR1cm4gY29va2llTmFtZTsgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXkgYSBrZXkgKFN0cmluZylcbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZSBhIHZhbHVlLCBjYW4gYmUgYW55IHR5cGUgb2Ygb2JqZWN0IChpbmNsLiBuZXN0ZWQpLiB2YWx1ZSBjYW4gYmUgYSBKU09OIHN0cmluZyBidXQgd2lsbFxuICAgICAgICAgICAgICogICAgICpub3QqICBiZSBwYXJzZWQuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0b3JlIDogZnVuY3Rpb24oa2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgICAgIG5ld1ZhbHVlW2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb29raWVWYWx1ZXMobmV3VmFsdWUpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBlbnRyaWVzIGFuIG9iamVjdCB3aGVyZSBhbGwgb3duIHByb3BlcnRpZXMgd2lsbCBiZSBhZGRlZCB0byB0aGUgY29va2llIHZhbHVlIChydWxlcyBmb3IgdmFsdWVzXG4gICAgICAgICAgICAgKiBmcm9tIHN0b3JlIGZ1bmN0aW9uIGFwcGx5IGhlcmUgYXMgd2VsbCkuIEV4aXN0aW5nIGVudHJpZXMgd2lsbCBiZSBvdmVyd3JpdHRlbi4gTm8gb2JqZWN0IGVuY29kZWQgYXNcbiAgICAgICAgICAgICAqIEpzb24gc3RyaW5nIGFjY2VwdGVkLCBubyBBcnJheXMgZWl0aGVyLlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBzdG9yZUFsbCA6IGZ1bmN0aW9uKGVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzVmFsaWRDb29raWVWYWx1ZUVudHJpZXMoZW50cmllcykpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29va2llTWFuYWdlci5zdG9yZUFsbCBhY2NlcHRzIG9ubHkgb2JqZWN0cyAoaW5jbC4gbm8gYXJyYXlzKSwgcGFyYW1ldGVyIHdhcyBcIidcbiAgICAgICAgICAgICAgICAgICAgICAgICsgZW50cmllcyArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1cGRhdGVDb29raWVWYWx1ZXMoZW50cmllcyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBHZXQgdGhlIHZhbHVlIG9mIGEgc2luZ2xlIGVudHJ5IGZyb20gdGhlIGNvb2tpZS5cbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRWYWx1ZSA6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBnZXRDb29raWVWYWx1ZXMoY29va2llTmFtZSlba2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCBhbGwgZW50cmllcyAoYXMgYW4gb2JqZWN0KSBmcm9tIHRoZSBjb29raWUuXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZ2V0VmFsdWVzIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvb2tpZVZhbHVlcyhjb29raWVOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIG5lZWRlZCwgYWRkIHJlbW92ZShrZXkpIGFuZCByZW1vdmVBbGwoa2V5cykgZnVuY3Rpb25zIHRvIHRoZSBhcGlcbiAgICAgICAgfTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogRmFjdG9yeSBmdW5jdGlvbiB3aGljaCBwcm9kdWNlcyBhIGNvb2tpZSBtYW5hZ2VyIGZvciB0aGUgZ2l2ZW4gY29va2llIG5hbWUgYW5kIGNvbmZpZy5cbiAgICAgKiBAcGFyYW0gY29va2llTmFtZVxuICAgICAqIEBwYXJhbSBjb29raWVBdHRyaWJ1dGVzOiBzZWUgY29uc3RydWN0b3IgZG9jdW1lbnRhdGlvblxuICAgICAqIEByZXR1cm5zIHtDb29raWVNYW5hZ2VyfVxuICAgICAqL1xuICAgIGNvb2tpZU1hbmFnZXIuZm9yQ29va2llID0gZnVuY3Rpb24oY29va2llTmFtZSwgY29va2llQXR0cmlidXRlcykge1xuICAgICAgICByZXR1cm4gbmV3IENvb2tpZU1hbmFnZXIoY29va2llTmFtZSwgY29va2llQXR0cmlidXRlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGNvb2tpZU5hbWUgdGhlIG5hbWUgb2YgdGhlIGNvb2tpZVxuICAgICAqIEBwYXJhbSBjb29raWVBdHRyaWJ1dGVzIGF0dHJpYnV0ZXMgb2YgdGhlIGNvb2tpZSAoYnV0IG5vdGUgdGhhdCBleHBpcmVzIGF0dHJpYnV0ZXMgY2Fubm90IGJlIG92ZXJ3cml0dGVuLCBpdCB3aWxsXG4gICAgICogYmUgYWRkZWQgdG8gdGhhdCBvYmplY3QpXG4gICAgICogQHJldHVybnMge0Nvb2tpZU1hbmFnZXJ9XG4gICAgICovXG4gICAgY29va2llTWFuYWdlci5mb3JTZXNzaW9uQ29va2llID0gZnVuY3Rpb24oY29va2llTmFtZSwgY29va2llQXR0cmlidXRlcykge1xuICAgICAgICBjb29raWVBdHRyaWJ1dGVzID0gY29va2llQXR0cmlidXRlcyB8fCB7fTtcbiAgICAgICAgY29va2llQXR0cmlidXRlc1snZXhwaXJlRGF5cyddID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIG5ldyBDb29raWVNYW5hZ2VyKGNvb2tpZU5hbWUsIGNvb2tpZUF0dHJpYnV0ZXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDb252ZW5pZW5jZSBmYWN0b3J5IGZ1bmN0aW9uIHdoaWNoIHByb2R1Y2VzIGEgY29va2llIG1hbmFnZXIgZm9yIHRoZSBzdGFuZGFyZCBHRCBjb29raWUuXG4gICAgICogQHBhcmFtIGNvb2tpZUF0dHJpYnV0ZXM6IHNlZSBjb25zdHJ1Y3RvciBkb2N1bWVudGF0aW9uXG4gICAgICogQHJldHVybnMge0Nvb2tpZU1hbmFnZXJ9XG4gICAgICovXG4gICAgY29va2llTWFuYWdlci5mb3JHRFN0YW5kYXJkQ29va2llID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBUT0RPIHdoYXQgaXMgdGhlIG5hbWUgb2YgdGhlIHN0YW5kYXJkIGNvb2tpZT9cbiAgICAgICAgcmV0dXJuIG5ldyBDb29raWVNYW5hZ2VyKCdHRCcpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBFeHRyYWN0cyB0aGUgY29va2llIGRvbWFpbiBmcm9tIHRoZSBnaXZlbiBob3N0bmFtZS5cbiAgICAgKiBAcGFyYW0gaG9zdG5hbWVcbiAgICAgKiBAcGFyYW0gaW5jbHVkZVN1YkRvbWFpbnMgaWYgdHJ1ZSBhbGwgc3ViZG9tYWlucyB3aWxsIGJlIG9taXR0ZWRcbiAgICAgKi9cbiAgICBjb29raWVNYW5hZ2VyLmNvbXB1dGVDb29raWVEb21haW4gPSBmdW5jdGlvbihob3N0bmFtZSwgaW5jbHVkZVN1YkRvbWFpbnMpIHtcbiAgICAgICAgaWYgKGhvc3RuYW1lLmluZGV4T2YoJ2dhbWVkdWVsbCcpICE9PSAtMSAmJiAhaW5jbHVkZVN1YkRvbWFpbnMpIHtcbiAgICAgICAgICAgIHZhciBob3N0bmFtZVBhcnRzID0gaG9zdG5hbWUuc3BsaXQoJy4nKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdG5hbWVQYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgIGlmIChob3N0bmFtZVBhcnRzW2ldID09PSBcImdhbWVkdWVsbFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHNvbWUgaW5mb3MgYWJvdXQgdGhlIGxlYWRpbmcgZG90OlxuICAgICAgICAgICAgICAgICAgICAvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzk2MTgyMTcvd2hhdC1kb2VzLXRoZS1kb3QtcHJlZml4LWluLXRoZS1jb29raWUtZG9tYWluLW1lYW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGw7ZHI6IGFuIG9ic29sZXRlIFJGQyBkZWZpbmVkIHRoYXQgYSBkb21haW4gd2l0aCBhIGxlYWRpbmcgZG90IHdvdWxkIG1lYW4gXCJhbGxvdyBmb3JcbiAgICAgICAgICAgICAgICAgICAgLy8gc3ViZG9tYWlucywgdG9vXCIgSUU4LzkgYXJlIHN0aWxsIGFmZmVjdGVkLiBPdGhlcnMgc2hvdWxkIGp1c3QgZGlzcmVnYXJkIHRoZSBkb3QgKGFzIHBlciBuZXdlclxuICAgICAgICAgICAgICAgICAgICAvLyBSRkMpXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnLicgKyBob3N0bmFtZVBhcnRzLnNwbGljZShpKS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGhvc3RuYW1lO1xuICAgIH07XG5cbiAgICAvLyBleHBvcnQgYXMgbW9kdWxlIG9yIGJpbmQgdG8gZ2xvYmFsXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0cycpKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gY29va2llTWFuYWdlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW5ueS5hZGQoJ2Nvb2tpZU1hbmFnZXInLCBjb29raWVNYW5hZ2VyKTtcbiAgICB9XG5cbn0oKSk7XG4iLCIvKmdsb2JhbCAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG4vKipcbiAqXG4gKiBFLmcuOlxuICogIGNhbm55LW1vZD1cIm1vZHVsZU9ialwiIGNhbm55LXZhcj1cInsncHJvcGVydHlLZXknOid2YWx1ZSd9XCJcbiAqICBjYW5ueS1tb2Q9XCJtb2R1bGVTdHJpbmdcIiBjYW5ueS12YXI9XCJidXR0b25cIlxuICpcbiAqIEluc3RlYWQgb2YgY2FubnktdmFyIHlvdSBjYW4gdXNlIHRoZSBtb2R1bGUgbmFtZSB0byBhdm9pZCBjb25mbGljdHMgbGlrZTpcbiAqIEUuZy46IGNhbm55LW1vZD1cIm1vZDEgbW9kMlwiIGNhbm55LW1vZDE9eydmb28nOicxMjM0NTYnLCAnYmFyJzonNjU0MzIxJ30gY2FubnktbW9kMj1cIm1vZDJQcm9wZXJ0eVwiXG4gKlxuICogLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSBlaWdodHlmb3VyXG4gKi9cbihmdW5jdGlvbiAoZ2xvYmFsKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGNhbm55ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlYWR5UXVldWUgPSBbXSxcbiAgICAgICAgICAgIHJlYWR5UXVldWVJbml0ID0gZmFsc2UsXG4gICAgICAgICAgICBtb2R1bGVRdWV1ZSA9IFtdOyAvLyBzYXZlIG1vZHVsZXMgdG8gY2FsbCB0aGUgcmVhZHkgbWV0aG9kIG9uY2VcblxuICAgICAgICAvKipcbiAgICAgICAgICogRmluZCB0aGUgc2luZ2xlIHF1b3RlcyBhbmQgcmVwbGFjZSB0aGVtIHdpdGggZG91YmxlIHF1b3RlcyBleGNlcHQgc3RyaW5nIHdoaWNoXG4gICAgICAgICAqIGFyZSBwYXJ0IG9mIHRoZSBwcm9wZXJ0eSBzdHJpbmcuXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzdHJpbmdcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ31cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckpTT04oc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN0cmluZ1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXHtcXHMqXFwnL2csJ3tcIicpLnJlcGxhY2UoL1xcJ1xccypcXH0vZywnXCJ9JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvOlxccypcXCcvZywnOlwiJykucmVwbGFjZSgvXFwnXFxzKjovZywnXCI6JylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvLFxccypcXCcvZywnLFwiJykucmVwbGFjZSgvXFwnXFxzKiwvZywnXCIsJylcbiAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxbXFxzKlxcJy9nLCdbXCInKS5yZXBsYWNlKC9cXCdcXHMqXFxdL2csJ1wiXScpO1xuICAgICAgICAgICAgcmV0dXJuIHM7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBlc2NhcGVTdHJpbmdGb3JKU09OQXJyYXkoc3RyaW5nKSB7XG4gICAgICAgICAgICB2YXIgcyA9IHN0cmluZ1xuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8sXFxzKlxcJy9nLCcsXCInKS5yZXBsYWNlKC9cXCdcXHMqLC9nLCdcIiwnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtcXHMqXFwnL2csJ1tcIicpLnJlcGxhY2UoL1xcJ1xccypcXF0vZywnXCJdJyk7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGNhbGxNZXRob2RRdWV1ZShxdWV1ZSkge1xuICAgICAgICAgICAgKGZ1bmN0aW9uIHJlZHVjZSgpIHtcbiAgICAgICAgICAgICAgICB2YXIgZmMgPSBxdWV1ZS5wb3AoKTtcbiAgICAgICAgICAgICAgICBpZiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVkdWNlKCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCkpO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gcGFyc2VOb2RlKG5vZGUsIG5hbWUsIGNiKSB7XG4gICAgICAgICAgICB2YXIgdGhhdCA9IHRoaXMsIGdkTW9kdWxlQ2hpbGRyZW4gPSBbXS5zbGljZS5jYWxsKG5vZGUucXVlcnlTZWxlY3RvckFsbCgnWycgKyBuYW1lICsgJy1tb2RdJykpLCBwcmVwYXJlUmVhZHlRdWV1ZSA9IHt9O1xuXG4gICAgICAgICAgICBnZE1vZHVsZUNoaWxkcmVuLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSArICctbW9kJyksIGF0dHIsIHZpZXdQYXJ0LCBhdHRyaWJ1dGVzLCBjYW5ueVZhcjtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMgPSBhdHRyaWJ1dGUuc3BsaXQoJyAnKTtcblxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhhdFttb2R1bGVOYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUgKyAnLW1vZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUgKyAnLScgKyBtb2R1bGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueVZhciA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUgKyAnLScgKyBtb2R1bGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueVZhciA9IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUgKyAnLXZhcicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FubnlWYXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2ltcGxlIEpTT04gdGVzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xce1xccypcXCd8XFxcIi4qOi4qXFx9Ly50ZXN0KGNhbm55VmFyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IGVzY2FwZVN0cmluZ0ZvckpTT04oY2FubnlWYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bGQgYmUgYSBKU09OXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdQYXJ0ID0gSlNPTi5wYXJzZShhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImNhbm55IGNhbid0IHBhcnNlIHBhc3NlZCBKU09OIGZvciBtb2R1bGU6IFwiICsgbW9kdWxlTmFtZSwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoL1xcW1xccypcXCd8XFxcIi4qXFwnfFxcXCJcXF0vLnRlc3QoY2FubnlWYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gZXNjYXBlU3RyaW5nRm9ySlNPTkFycmF5KGNhbm55VmFyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1BhcnQgPSBKU09OLnBhcnNlKGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY2FubnkgY2FuJ3QgcGFyc2UgcGFzc2VkIEpTT04gZm9yIG1vZHVsZTogXCIgKyBtb2R1bGVOYW1lLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXdQYXJ0ID0gY2FubnlWYXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoYXMgbW9kdWxlIGEgcmVhZHkgZnVuY3Rpb24gdGhhbiBzYXZlIGl0IGZvciBjYWxsaW5nXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdFttb2R1bGVOYW1lXS5oYXNPd25Qcm9wZXJ0eSgncmVhZHknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gb3IgY2FsbCBpdCBpbW1lZGlhdGVseT9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVwYXJlUmVhZHlRdWV1ZVttb2R1bGVOYW1lXSA9IHRoYXRbbW9kdWxlTmFtZV0ucmVhZHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhhdC5oYXNPd25Qcm9wZXJ0eShtb2R1bGVOYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXRbbW9kdWxlTmFtZV0uYWRkKG5vZGUsIHZpZXdQYXJ0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignY2FubnkgcGFyc2U6IG1vZHVsZSB3aXRoIG5hbWUgwrQnICsgbW9kdWxlTmFtZSArICfCtCBpcyBub3QgcmVnaXN0ZXJlZCcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIGFkZCByZWFkeSBjYWxsYmFjayB0byBtb2R1bGVRdWV1ZVxuICAgICAgICAgICAgT2JqZWN0LmtleXMocHJlcGFyZVJlYWR5UXVldWUpLmZvckVhY2goZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBtb2R1bGVRdWV1ZS5wdXNoKHByZXBhcmVSZWFkeVF1ZXVlW25hbWVdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBmdW5jdGlvbiBjYW5ueURvbUxvYWQoKSB7XG4gICAgICAgICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCdET01Db250ZW50TG9hZGVkJywgY2FubnlEb21Mb2FkKTtcblxuICAgICAgICAgICAgcGFyc2VOb2RlLmFwcGx5KGNhbm55LCBbZG9jdW1lbnQsICdjYW5ueSddKTtcblxuICAgICAgICAgICAgY2FsbE1ldGhvZFF1ZXVlKG1vZHVsZVF1ZXVlKTtcbiAgICAgICAgICAgIC8vIGNhbGwgcmVnaXN0ZXJlZCByZWFkeSBmdW5jdGlvbnNcbiAgICAgICAgICAgIHJlYWR5UXVldWVJbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGNhbGxNZXRob2RRdWV1ZShyZWFkeVF1ZXVlKTtcbiAgICAgICAgfSwgZmFsc2UpO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBhZGQgOiBmdW5jdGlvbiAobmFtZSwgbW9kdWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1vZHVsZUFwaSA9IG1vZHVsZTtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZHVsZUFwaSA9IG1vZHVsZSh0aGlzKTsgLy8gaW5pdGlhbGl6ZSB0aGUgbW9kdWxlIHdpdGggdGhlIGFjdHVhbCBjYW5ueSBpbnN0YW5jZVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXNbbmFtZV0gPSBtb2R1bGVBcGk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignY2Fubnk6IFRyeSB0byByZWdpc3RlciBtb2R1bGUgd2l0aCBuYW1lICcgKyBuYW1lICsgJyB0d2ljZScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZWFkeSA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgIGlmICghcmVhZHlRdWV1ZUluaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVhZHlRdWV1ZS5wdXNoKGZjKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmYygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjYW5ueVBhcnNlIDogZnVuY3Rpb24gKG5vZGUsIG5hbWUsIGNiKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBuZWVkcyBhIGNhbGxiYWNrXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBuYW1lID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGNiID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSA9IFwiY2FubnlcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcGFyc2VOb2RlLmFwcGx5KHRoaXMgfHwgY2FubnksIFtub2RlLCBuYW1lIHx8ICdjYW5ueScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbE1ldGhvZFF1ZXVlKG1vZHVsZVF1ZXVlKTtcbiAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgICAgICB9XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSgpKTtcbiAgICAvLyBleHBvcnQgYXMgbW9kdWxlIG9yIGJpbmQgdG8gZ2xvYmFsXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0cycpKSB7IG1vZHVsZS5leHBvcnRzID0gY2Fubnk7IH0gZWxzZSB7Z2xvYmFsLmNhbm55ID0gY2Fubnk7IH1cbn0odGhpcykpOyIsIi8qZ2xvYmFsIGNhbm55ICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlKi9cblxuLyoqXG4gKiBSZXF1aXJlZDogJ2Nhbm55JyBpbiBnbG9iYWwgc2NvcGVcbiAqXG4gKiBFLmcuOlxuICogY2FubnkuYXN5bmMubG9hZChVUkwsIGZ1bmN0aW9uIChzcmMpIHtcbiAqICAgICBub2RlLmlubmVySFRNTCA9IHNyYztcbiAqICAgICAvLyB0cmlnZ2VyIGNhbm55IHBhcnNlIHRvIHJlZ2lzdGVyIGNhbm55IG9uIG91ciBuZXcgbW9kdWxlc1xuICogICAgIGNhbm55LmNhbm55UGFyc2Uobm9kZSwgZnVuY3Rpb24gKCkge1xuICogICAgICAgICBjb25zb2xlLmxvZygnQ0FOTlkgUEFSU0UgRE9ORScpO1xuICogICAgIH0pO1xuICogfSk7XG4gKlxuICogQWx0ZXJuYXRpdmUgeW91IGNhbiBqdXN0IHVzZSBsb2FkSFRNTCAoc2NyaXB0cyB3aWxsIGF1dG9tYXRpY2FsbHkgYWRkZWQgYW5kIHBhcnNlZCBieSBjYW5ueSk6XG4gKiBjYW5ueS5hc3luYy5sb2FkSFRNTChub2RlLCB7dXJsIDogVVJMfSwgZnVuY3Rpb24gKCkge1xuICogICAgIGNvbnNvbGUubG9nKCdrb2Rvc19sb2FkIFJFQURZJyk7XG4gKiB9KTtcbiAqXG4gKiBPciBkaXJlY3RseSBhcyBjYW5ueSBtb2R1bGU6XG4gKiA8ZGl2IGNhbm55LW1vZD1cImFzeW5jXCIgY2FubnktdmFyPVwieyd1cmwnOicveW91L0hUTUwvZmlsZS5odG1sJ31cIj48L2Rpdj5cbiAqXG4gKiBUT0RPIHNvbHZlIGRlcGVuZGVuY3kgcHJvYmxlbSB0byBjYW5ueS5cbiAqXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBhc3luYyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmaWxlc1RvTG9hZCA9IFtdLFxuICAgICAgICAgICAgcHVzaExvYWRDQnMgPSBbXSxcbiAgICAgICAgICAgIHJlYWR5ID0gZmFsc2U7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzY3JpcHRcbiAgICAgICAgICogQHBhcmFtIG1lZGlhVVJMXG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kU2NyaXB0KHNjcmlwdCwgbWVkaWFVUkwsIGNiKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuICAgICAgICAgICAgICAgIHNyYyA9IHNjcmlwdC5nZXRBdHRyaWJ1dGUoJ3NyYycpO1xuICAgICAgICAgICAgLy8gaGFuZGxlIG1lZGlhVVJMIGFuZCBhbGwgcmVsYXRpdmUgc2NyaXB0IGFyZSBsb2FkZWQgZnJvbSB0aGUgbWVkaWEgVVJMIHN0cmluZ1xuICAgICAgICAgICAgaWYgKG1lZGlhVVJMICYmIHNyY1swXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgaWYgKG1lZGlhVVJMW21lZGlhVVJMLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgbWVkaWFVUkwgKz0gJy8nO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzcmMgPSBtZWRpYVVSTCArIHNyYztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUudHlwZSA9IFwidGV4dC9qYXZhc2NyaXB0XCI7XG4gICAgICAgICAgICBub2RlLmFzeW5jID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCdzcmMnLCBzcmMpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdsb2FkJywgY2IsIGZhbHNlKTtcbiAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCBjYiwgdHJ1ZSk7XG4gICAgICAgICAgICBkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBzY3JpcHRzXG4gICAgICAgICAqIEBwYXJhbSBtZWRpYVVSTFxuICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGFwcGVuZFNjcmlwdHNUb0hlYWQoc2NyaXB0cywgbWVkaWFVUkwsIGNiKSB7XG4gICAgICAgICAgICB2YXIgc2NyaXB0LCBpLCBpbmNsdWRlc1NjcmlwdHMgPSBmYWxzZSxcbiAgICAgICAgICAgICAgICBzY3JpcHRDb3VudGVyID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNvdW50ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwIDogZnVuY3Rpb24gKCkge2NvdW50Kys7IH0sXG4gICAgICAgICAgICAgICAgICAgICAgICByZWFkeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb3VudCA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oKSk7XG5cbiAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBzY3JpcHRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2NyaXB0ID0gc2NyaXB0c1tpXTtcbiAgICAgICAgICAgICAgICBpZiAoc2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5jbHVkZXNTY3JpcHRzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0Q291bnRlci51cCgpO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRTY3JpcHQoc2NyaXB0LCBtZWRpYVVSTCwgc2NyaXB0Q291bnRlci5yZWFkeSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhc3luYzogZm91bmQgaW5saW5lIHNjcmlwdCB0YWchISEnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChzY3JpcHRzLmxlbmd0aCA9PT0gMCB8fCBpbmNsdWRlc1NjcmlwdHMgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIFBhcnNlIHRoZSBjb21wbGV0ZSBnaXZlbiBET00gYW5kIHByZWZpeCBhbGwgcmVsYXRpdmUgaHJlZiBVUkwncyB3aXRoIHRoZSBnaXZlbiBVUkxcbiAgICAgICAgICogQWxsIFVSTCdzIGFyZSBoYW5kbGVkIGFzIHJlbGF0aXZlIGlmIHRoZXJlIHN0YXJ0cyBub3Qgd2l0aCBhIC8gb3IgaHR0cDovLyBvciBodHRwczovL1xuICAgICAgICAgKiBUT0RPIGFkZCBzdXBwb3J0IGZvciBVUkwncyB3aXRoIGEgLi8gb3IgLi4vIGFuZCBzbyBvblxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gbm9kZSBwYXJlbnQgZWxlbWVudFxuICAgICAgICAgKiBAcGFyYW0gbWVkaWFVUkwgbWVkaWFQYXRoIHRvIGFub3RoZXIgc2VydmVyXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBoYW5kbGVMaW5rcyhub2RlLCBtZWRpYVVSTCkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdsaW5rJykpLmZvckVhY2goZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgICAgICAgICB2YXIgaHJlZiA9IGxpbmsuZ2V0QXR0cmlidXRlKCdocmVmJyk7XG4gICAgICAgICAgICAgICAgaWYgKGxpbmsuZ2V0QXR0cmlidXRlKCd0eXBlJykgPT09ICd0ZXh0L2NzcycgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmICE9PSB1bmRlZmluZWQgJiYgXG4gICAgICAgICAgICAgICAgICAgICAgICBocmVmWzBdICE9PSAnLycgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEvXmh0dHA6XFwvXFwvLiovLnRlc3QoaHJlZikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICEvXmh0dHBzOlxcL1xcLy4qLy50ZXN0KGhyZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtZWRpYVVSTFttZWRpYVVSTC5sZW5ndGggLSAxXSAhPT0gJy8nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZWRpYVVSTCArPSAnLyc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaHJlZiA9IG1lZGlhVVJMICsgaHJlZjtcbiAgICAgICAgICAgICAgICAgICAgbGluay5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAqIEBwYXJhbSBhdHRyIHt7dXJsOnN0cmluZywgbWVkaWFVUkw6IHN0cmluZ319XG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbG9hZEhUTUwobm9kZSwgYXR0ciwgY2IpIHtcbiAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RlbXBsYXRlJyksXG4gICAgICAgICAgICAgICAgZGl2ID0gKCdjb250ZW50JyBpbiB0ZW1wbGF0ZSA/IHRlbXBsYXRlIDogZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCdtYWluJykuYm9keSksXG4gICAgICAgICAgICAgICAgYm9keSxcbiAgICAgICAgICAgICAgICBzY3JpcHRzLFxuICAgICAgICAgICAgICAgIC8vIG9ubHkgcGFyc2UgaWYgaHRtbCBhbmQgc2NyaXB0cyBhcmUgbG9hZGVkIChzY3JpcHRzIGhhcyBjYWxsYmFja3MgYmVjYXVzZSB0aGVyZSBhcmUgbmVlZHMgdG8gbG9hZGVkIGFzeW5jaHJvbm91cylcbiAgICAgICAgICAgICAgICBoYW5kbGVDYW5ueVBhcnNlID0gKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgd2FpdEZvclNjcmlwdHMgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgd2FpdEZvckhUTUwgPSB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dnZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCF3YWl0Rm9yU2NyaXB0cyAmJiAhd2FpdEZvckhUTUwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FubnkuY2FubnlQYXJzZShub2RlLCBjYik7IC8vIGluaXQgb25seSBjYW5ueSBvd24gbW9kdWxlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzY3JpcHRSZWFkeSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YWl0Rm9yU2NyaXB0cyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyaWdnZ2VyKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgaHRtbFJlYWR5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRGb3JIVE1MID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dnZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB9KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IoYXR0cik7XG4gICAgICAgICAgICAgICAgfSkpO1xuXG4gICAgICAgICAgICBsb2FkKGF0dHIudXJsLCBmdW5jdGlvbiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkcztcbiAgICAgICAgICAgICAgICBpZiAoc3JjKSB7XG4gICAgICAgICAgICAgICAgICAgIGRpdi5pbm5lckhUTUwgPSBzcmM7XG4gICAgICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgdGVtcGxhdGUgd2UgbmVlZCB0aGUgY29udGVudFxuICAgICAgICAgICAgICAgICAgICBib2R5ID0gJ2NvbnRlbnQnIGluIGRpdiA/IGRpdi5jb250ZW50IDogZGl2O1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRzID0gYm9keS5xdWVyeVNlbGVjdG9yQWxsKCdzY3JpcHQnKTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGRzID0gW10uc2xpY2UuY2FsbChib2R5LmNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgICAgICAgICBhcHBlbmRTY3JpcHRzVG9IZWFkKHNjcmlwdHMsIGF0dHIubWVkaWFVUkwsIGhhbmRsZUNhbm55UGFyc2Uuc2NyaXB0UmVhZHkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLm1lZGlhVVJMKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVMaW5rcyhib2R5LCBhdHRyLm1lZGlhVVJMKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjaGlsZHMuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGNoaWxkLnRhZ05hbWUgPT09ICdTQ1JJUFQnICYmIGNoaWxkLmdldEF0dHJpYnV0ZSgnc3JjJykpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBoYW5kbGVDYW5ueVBhcnNlLmh0bWxSZWFkeSgpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYXN5bmM6IExvYWRpbmcgYXN5bmMgSFRNTCBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICogc2ltcGxlIHdyYXBwZXIgdG8gbG9hZCBIVE1MIGZpbGVzIHdpdGggR0VUXG4gICAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gbG9hZChwYXRoLCBjYikge1xuICAgICAgICAgICAgZG9BamF4KHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6ICdHRVQnLFxuICAgICAgICAgICAgICAgIHBhdGg6IHBhdGgsXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiAocmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IocmVzcG9uc2UucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHBhcmFtcyB7e1xuICAgICAgICAgKiAgIG5vQ2FjaGU6Ym9vbGVhbixcbiAgICAgICAgICogICBtZXRob2Q6c3RyaW5nfFBPU1QoZGVmYXVsdCksXG4gICAgICAgICAqICAgZGF0YTpvYmplY3R8c3RyaW5nLFxuICAgICAgICAgKiAgIHBhdGg6c3RyaW5nLFxuICAgICAgICAgKiAgIGFzeW5jOmJvb2xlYW58dHJ1ZShkZWZhdWx0KSxcbiAgICAgICAgICogICBvblJlcXVlc3Q6ZnVuY3Rpb24gKHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHhtbEhUVFBSZXF1ZXN0IG9iamVjdCBxdWl0ZSBjbG9zZSBiZWZvcmUgdGhlIHNlbmQgbWV0aG9kIGlzIGNhbGxlZCksXG4gICAgICAgICAqICAgb25GYWlsdXJlOmZ1bmN0aW9uLFxuICAgICAgICAgKiAgIG9uU3VjY2VzczpmdW5jdGlvbixcbiAgICAgICAgICogICBjb250ZW50VHlwZTpzdHJpbmd8Q29udGVudC1UeXBlKGRlZmF1bHQpLFxuICAgICAgICAgKiAgIG1pbWVUeXBlOnN0cmluZ3x0ZXh0IHBsYWluKGRlZmF1bHQpXG4gICAgICAgICAqIH19XG4gICAgICAgICAqL1xuICAgICAgICAgZnVuY3Rpb24gZG9BamF4KHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIGNhbGwgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICAgICAgICAgIHZhciB1cmwgPSBwYXJhbXMucGF0aDtcbiAgICAgICAgICAgIGlmIChwYXJhbXMubWV0aG9kID09PSAnR0VUJyAmJiB0eXBlb2YgcGFyYW1zLmRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgYXR0ciBpbiBwYXJhbXMuZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICB1cmwgPSB1cmwgKyAoKC9cXD8vKS50ZXN0KHVybCkgPyBcIiZcIiA6IFwiP1wiKSArIGF0dHIgKyBcIj1cIiArIHBhcmFtcy5kYXRhW2F0dHJdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChwYXJhbXMubm9DYWNoZSkge1xuICAgICAgICAgICAgICAgIHVybCA9IHVybCArICgoL1xcPy8pLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCIpICsgXCJ0cz1cIiArIChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwYXJhbXMubWV0aG9kID0gcGFyYW1zLm1ldGhvZCB8fCAnUE9TVCc7XG4gICAgICAgICAgICBjYWxsLm9wZW4ocGFyYW1zLm1ldGhvZCwgdXJsLCBwYXJhbXMuYXN5bmMgIT09IGZhbHNlKTtcblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5vblN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBjYWxsLmFkZEV2ZW50TGlzdGVuZXIoXCJsb2FkXCIsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5vblN1Y2Nlc3Mocy50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW1zLm9uRmFpbHVyZSkge1xuICAgICAgICAgICAgICAgIGNhbGwuYWRkRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIGZ1bmN0aW9uIChzKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5vbkZhaWx1cmUocy50YXJnZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjYWxsLnNldFJlcXVlc3RIZWFkZXIocGFyYW1zLmNvbnRlbnRUeXBlIHx8IFwiQ29udGVudC1UeXBlXCIsIHBhcmFtcy5taW1lVHlwZSB8fCBcInRleHQvcGxhaW5cIik7XG5cbiAgICAgICAgICAgIC8vIGFsbG93IHRoZSBjYWxsZXIgdG8gZG8gc29tZSBleHRyYSBzdHVmZiBvbiB0aGUgcmVxdWVzdCBvYmplY3RcbiAgICAgICAgICAgIGlmIChwYXJhbXMub25SZXF1ZXN0ICYmIHR5cGVvZiBwYXJhbXMub25SZXF1ZXN0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zLm9uUmVxdWVzdChjYWxsKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHBhcmFtcy5tZXRob2QgPT09ICdQT1NUJykge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZChwYXJhbXMuZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGwuc2VuZChudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGFkZCBhIGNhbGxiYWNrLiBTbyB5b3Ugd2lsbCBiZSBub3RpZmllZCB3aGVuIGZpbGVzIGFyZSBsb2FkZWQgYXN5bmNocm9ub3VzLlxuICAgICAgICAgICAgICogWW91IHdpbGwgYmUgY2FsbGVkIG9ubHkgb25jZSBleGNlcHQgeW91ciByZXR1cm4gdHJ1ZSB0aGVuIGFzeW5jIHdpbGwga2VlcFxuICAgICAgICAgICAgICogeW91ciBjYWxsYmFjayBpbiB0aGUgbm90aWZpZXIgbGlzdCBhbmQgeW91IHdpbGwgYmUgaW5mb3JtZWQgZm9yIGVhY2ggYXN5bmMgcmVxdWVzdC5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBUaGUgYXN5bmMgbW9kdWxlIHdpbGwgY2FsbCBlYWNoIGNhbGxiYWNrIHdpdGggdGhlIGFjdHVhbCBhdHRyLiBTbyB5b3UgaGF2ZSB0aGUgY29udHJvbFxuICAgICAgICAgICAgICogaG93IG9mdGVuIHlvdSB3aWxsIGJlIG5vdGlmaWVkLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIE1pZ2h0IGJlIGNoYW5nZWQgaW4gdGhlIGZ1dHVyZSB2ZXJzaW9uIG9mIGFzeW5jOlxuICAgICAgICAgICAgICogQ3VycmVudGx5IHRoaXMgaXMgb25seSBleGVjdXRlZCBmb3IgY2FubnkgbW9kdWxlcyB3aGljaCBhcmUgbG9hZGVkIGZyb20gdGhlIERPTSBkaXJlY3RseS5cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gZmNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcHVzaExvYWRDQiA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgIHB1c2hMb2FkQ0JzLnB1c2goZmMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRG8gYSBzaW1wbGUgYWpheCBjYWxsLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBwYXJhbXMge3tcbiAgICAgICAgICAgICAqICAgbm9DYWNoZTpib29sZWFuLFxuICAgICAgICAgICAgICogICBtZXRob2Q6c3RyaW5nfFBPU1QoZGVmYXVsdCksXG4gICAgICAgICAgICAgKiAgIGRhdGE6b2JqZWN0LHN0cmluZyxcbiAgICAgICAgICAgICAqICAgYXN5bmM6Ym9vbGVhbnx0cnVlKGRlZmF1bHQpLFxuICAgICAgICAgICAgICogICBwYXRoOnN0cmluZyxcbiAgICAgICAgICAgICAqICAgb25SZXF1ZXN0OmZ1bmN0aW9uICh3aWxsIGJlIGNhbGxlZCB3aXRoIHRoZSB4bWxIVFRQUmVxdWVzdCBvYmplY3QgcXVpdGUgY2xvc2UgYmVmb3JlIHRoZSBzZW5kIG1ldGhvZCBpcyBjYWxsZWQpLFxuICAgICAgICAgICAgICogICBvbkZhaWx1cmU6ZnVuY3Rpb24sXG4gICAgICAgICAgICAgKiAgIG9uU3VjY2VzczpmdW5jdGlvbixcbiAgICAgICAgICAgICAqICAgY29udGVudFR5cGU6c3RyaW5nfENvbnRlbnQtVHlwZShkZWZhdWx0KSxcbiAgICAgICAgICAgICAqICAgbWltZVR5cGU6c3RyaW5nfHRleHQgcGxhaW4oZGVmYXVsdClcbiAgICAgICAgICAgICAqIH19XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGRvQWpheDogZG9BamF4LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyIHt7XG4gICAgICAgICAgICAgKiAgdXJsOnN0cmluZyxcbiAgICAgICAgICAgICAqICBtZWRpYVVSTDpzdHJpbmdcbiAgICAgICAgICAgICAqIH19XG4gICAgICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbG9hZEhUTUwgOiBsb2FkSFRNTCxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogRGVwcmVjYXRlZDogdXNlIGxvYWRIVE1MIGluc3RlYWRcbiAgICAgICAgICAgICAqIEBwYXJhbSBwYXRoXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2JcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbG9hZDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignYXN5bmM6bG9hZCBmdW5jdGlvbiBsb2FkIGlzIGRlcHJlY2F0ZWQuIFVzZSBsb2FkSFRNTCBpbnN0ZWFkJyk7XG4gICAgICAgICAgICAgICAgbG9hZC5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogY2FubnkncyBhZGQgbWV0aG9kXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHsgICAgLy8gcGFydCBvZiBhcGlcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGltcGxlbWVudCBsb2dpYyBmb3IgbG9hZGluZyBpdCBkaXJlY3RseSBmcm9tIGh0bWxcbiAgICAgICAgICAgICAgICBpZiAoYXR0ci5oYXNPd25Qcm9wZXJ0eSgndXJsJykpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWFkeSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsZXNUb0xvYWQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZTogbm9kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyOiBhdHRyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvYWRIVE1MKG5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWR5OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9iaiwgY2JDb3VudCA9IGZpbGVzVG9Mb2FkLmxlbmd0aDtcbiAgICAgICAgICAgICAgICB3aGlsZSAoZmlsZXNUb0xvYWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBmaWxlc1RvTG9hZC5zcGxpY2UoMCwgMSlbMF07XG4gICAgICAgICAgICAgICAgICAgIGxvYWRIVE1MKG9iai5ub2RlLCBvYmouYXR0ciwgZnVuY3Rpb24gKGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZWVwUHVzaENCID0gW10sIHRtcENiO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2JDb3VudC0tO1xuICAgICAgICAgICAgICAgICAgICAgICAgd2hpbGUgKHB1c2hMb2FkQ0JzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBDYiA9IHB1c2hMb2FkQ0JzLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wQ2IoYXR0cikgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2VlcFB1c2hDQi5wdXNoKHRtcENiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBwdXNoTG9hZENCcyA9IGtlZXBQdXNoQ0I7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KCkpO1xuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBhc3luYztcbiAgICB9IGVsc2Uge1xuICAgICAgICBjYW5ueS5hZGQoJ2FzeW5jJywgYXN5bmMpO1xuICAgIH1cblxufSgpKTsiLCIvKmdsb2JhbCBjYW5ueSAqL1xyXG4vKmpzbGludCBicm93c2VyOiB0cnVlKi9cclxuXHJcbi8qKlxyXG4gKiBFLmcuOiBjYW5ueS1tb2Q9XCJmbG93Q29udHJvbFwiIGNhbm55LXZhcj1cInsndmlldycgOiAndmlld05hbWUnfVwiXHJcbiAqXHJcbiAqIHlvdSBjYW4gYWN0aXZhdGUgYSBpbml0aWFsIHZpZXcgd2l0aCBhIGFuY2hvciBpbiB0aGUgVVJMIGUuZy46IHlvdXJkb21haW4uaHRtbCN2aWV3VG9TaG93XHJcbiAqIE9yIHBhc3MgYSBjb21tYSBzZXBhcmF0ZWQgbW9kdWxlIGxpc3QgZm9yIGFjdGl2YXRlIG1vcmUgbW9kdWxlICN2aWV3VG9TaG93LG90aGVyVmlldy5cclxuICpcclxuICogVE9ETyBtYWRlIGl0IHBvc3NpYmxlIHRvIHN1bW1hcml6ZSB2aWV3cyB3aXRoIG9uZSBpZGVudGlmaWVyLlxyXG4gKiBJbnN0ZWFkIG9mIGNhbGw6IGNhbm55LmZsb3dDb250cm9sLnNob3coJ3ZpZXcxJywgJ3ZpZXcyJywgJ3ZpZXczJykgY2FsbCBjYW5ueS5mbG93Q29udHJvbC5zaG93KCd2aWV3JykuXHJcbiAqXHJcbiAqIFRPRE8gYWRkIGEgaGlkZSBtZXRob2QgdGhhdCBqdXN0IGhpZGUgdGhlIHNwZWNpZmljIGVsZW1lbnQuXHJcbiAqXHJcbiAqIFRPRE8gaGFuZGxlIHRoZSBmYWRlIGluIGFuZCBvdXQgdmlhIENTUyBjbGFzc2VzIC0gYW5kIHVzZSB0cmFuc2l0aW9ucyBmb3IgaXRcclxuICovXHJcbihmdW5jdGlvbiAoKSB7XHJcbiAgICBcInVzZSBzdHJpY3RcIjtcclxuXHJcbiAgICAvKipcclxuICAgICAqIHdyYXBzIHRyYW5zaXRpb25lbmQgZXZlbnQgdmVuZG9yIGltcGxlbWVudGF0aW9uXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZE9uY2Uobm9kZSwgY2IpIHtcclxuICAgICAgICB2YXIgZXZlbnQgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3R5bGUud2Via2l0VHJhbnNpdGlvbiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcclxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZS5zdHlsZS50cmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYW5zaXRpb25lbmQnO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KCkpLFxyXG4gICAgICAgICAgICBsaXN0ZW5lciA9IGZ1bmN0aW9uKGUpIHtcclxuICAgICAgICAgICAgICAgIGUudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZS50eXBlLCBsaXN0ZW5lcik7XHJcbiAgICAgICAgICAgICAgICBjYihlKTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICBpZiAoZXZlbnQpIHtcclxuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBmbG93Q29udHJvbEluc3RhbmNlID0gZnVuY3Rpb24gKGZjSW5zdGFuY2VOYW1lKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZU5hbWUgPSBmY0luc3RhbmNlTmFtZSxcclxuICAgICAgICAgICAgICAgIC8vIGZsYWcgdG8gc2F2ZSBpZiB0aGUgaW5pdGlhbCBxdWV1ZSBpcyBhbHJlYWR5IGluaXRpYWxpemVkIG9yIG5vdFxyXG4gICAgICAgICAgICAgICAgc2hvd0luaXRpYWxWaWV3Q29tcGxldGUgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgIG9uU2hvd0luaXRpYWxWaWV3Q29tcGxldGUgPSBbXSxcclxuICAgICAgICAgICAgICAgIG1vZFZpZXdzID0ge30sIC8vIHNhdmVzIG1vZHVsZSB2aWV3c1xyXG4gICAgICAgICAgICAgICAgZ2V0Vmlld0FuY2hvciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgaGFzaCA9IGxvY2F0aW9uLmhhc2ggfHwgbnVsbCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcnggPSBuZXcgUmVnRXhwKCdbXmEtekEtWi1fLF0nLCAnZycpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoU3ViO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoaGFzaCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNoU3ViID0gaGFzaC5zdWJzdHIoMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYXNoU3ViLnNlYXJjaChyeCkgPiAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFzaFN1YiA9IGhhc2hTdWIuc3Vic3RyaW5nKDAsIGhhc2hTdWIuc2VhcmNoKHJ4KSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2hTdWIuc3BsaXQoJywnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoYXNoO1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIGdldEFsbE1vZHVsZUNoaWxkcmVucyA9IGZ1bmN0aW9uIChjTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGVzdCBzZWxlY3RvciBpZiB3ZSBoYXZlIG1vcmUgdGhhbiBvbmUgbW9kdWxlIGluIGNhbm55LW1vZFxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBjaGlsZHJlbiA9IGNOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1tjYW5ueS1tb2QqPScgKyBpbnN0YW5jZU5hbWUgKyAnXScpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmY19jaGlsZE5vZGVzID0ge307XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjTm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY05vZGUuY2hpbGRyZW4pLmZvckVhY2goZmluZENoaWxkcmVuKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKG1vZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXR0clZhbHVlLCB2aWV3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlYWQgYXR0cmlidXRlcyBzaG91bGQgYmUgYSBwYXJ0IG9mIGNhbm55IGZ1bmN0aW9uYWxpdHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXR0clZhbHVlID0gbW9kLmdldEF0dHJpYnV0ZSgnY2FubnktdmFyJykuc3BsaXQoXCJcXCdcIikuam9pbignXFxcIicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoLzovLnRlc3QoYXR0clZhbHVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY291bGQgYmUgYSBKU09OXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3ID0gSlNPTi5wYXJzZShhdHRyVmFsdWUpLnZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3ID0gYXR0clZhbHVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjX2NoaWxkTm9kZXNbdmlld10gPSBtb2Q7XHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZjX2NoaWxkTm9kZXM7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgKiBFYWNoIGZsb3dDb250cm9sIG5vZGUgd2lsbCBlbmQgdXAgaW4gYSBmbG93Q29udHJvbE1vZHVsZS5cclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxyXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGF0dHJcclxuICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHt7aGFzQ2hpbGRyZW5XaXRoTmFtZTogaGFzQ2hpbGRyZW5XaXRoTmFtZSwgZ2V0Vmlld05hbWU6IGdldFZpZXdOYW1lLCBzaG93OiBzaG93LCBoaWRlOiBoaWRlLCBmYWRlT3V0OiBmYWRlT3V0LCBnZXROb2RlOiBnZXROb2RlLCBmYWRlSW46IGZhZGVJbn19XHJcbiAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgIGZsb3dDb250cm9sTW9kdWxlID0gZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmxvd0NvbnRyb2xDaGlsZE5vZGVzID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jID0gZmFsc2UsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZpZXdzID0gZmMuZ2V0UGFyZW50Tm9kZShhdHRyLnZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIHNhdmVzIGFsbCBjaGlsZHJlbiBpbiBhIG9iamVjdFxyXG4gICAgICAgICAgICAgICAgICAgIGZsb3dDb250cm9sQ2hpbGROb2RlcyA9IGdldEFsbE1vZHVsZUNoaWxkcmVucyhub2RlKTtcclxuLy8gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdmbG93Q29udHJvbENoaWxkTm9kZXM6JywgZmxvd0NvbnRyb2xDaGlsZE5vZGVzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNDaGlsZHJlbldpdGhOYW1lIDogZnVuY3Rpb24gKHZpZXdOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd0NvbnRyb2xDaGlsZE5vZGVzLmhhc093blByb3BlcnR5KHZpZXdOYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Vmlld05hbWUgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gYXR0ci52aWV3O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBkaXNwbGF5IDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG9uJ3QgY2FsbCBwYXJlbnRzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBmYWRlIGluXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdyA6IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudFZpZXdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vmlld3MuZm9yRWFjaChmdW5jdGlvbiAoZmNfbW9kdWxlKSB7XHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncGFyZW50Vmlld3MnLCBmY19tb2R1bGUuZ2V0Vmlld05hbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjX21vZHVsZS5kaXNwbGF5KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWFzeW5jICYmIGF0dHIuaGFzT3duUHJvcGVydHkoJ2FzeW5jJykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS5hc3luYy5sb2FkSFRNTChub2RlLCB7dXJsIDogYXR0ci5hc3luY30sIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIud2hpc2tlcikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbm55LndoaXNrZXIgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55LndoaXNrZXIuYWRkKG5vZGUsIGF0dHIud2hpc2tlcik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJmbG93Q29udHJvbDp0cnkgZXhlY3V0ZSB3aGlza2VyIGJ1dCBubyB3aGlza2VyIG1vZHVsZSBpcyByZWdpc3RlcmVkIG9uIGNhbm55LlwiKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGlkZSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFkZU91dCA6IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMuZmFkZU91dChub2RlLCBjYiB8fCBmdW5jdGlvbiAoKSB7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGdldE5vZGUgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZmFkZUluIDogZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Vmlld3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uIChmY19tb2R1bGUpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwYXJlbnRWaWV3cycsIGZjX21vZHVsZS5nZXRWaWV3TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmNfbW9kdWxlLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXN5bmMgJiYgYXR0ci5oYXNPd25Qcm9wZXJ0eSgnYXN5bmMnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55LmFzeW5jLmxvYWRIVE1MKG5vZGUsIHt1cmwgOiBhdHRyLmFzeW5jfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci53aGlza2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Fubnkud2hpc2tlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fubnkud2hpc2tlci5hZGQobm9kZSwgYXR0ci53aGlza2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImZsb3dDb250cm9sOnRyeSBleGVjdXRlIHdoaXNrZXIgYnV0IG5vIHdoaXNrZXIgbW9kdWxlIGlzIHJlZ2lzdGVyZWQgb24gY2FubnkuXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjLmZhZGVJbihub2RlLCAgY2IgfHwgZnVuY3Rpb24gKCkge30pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFzeW5jID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMuZmFkZUluKG5vZGUsICBjYiB8fCBmdW5jdGlvbiAoKSB7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9O1xyXG5cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBzaG93SW5pdGlhbFZpZXcgPSBnZXRWaWV3QW5jaG9yKCksXHJcbiAgICAgICAgICAgICAgICBmYyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBnZXQgYWxsIHBhcmVudCBtb2R1bGVzIGZyb20gdGhlIGdpdmVuIHZpZXdOYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgZ2V0UGFyZW50Tm9kZSA6IGZ1bmN0aW9uICh2aWV3TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcXVldWUgPSBPYmplY3Qua2V5cyhtb2RWaWV3cyksIGwsIGksIHBhcmVudHMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHF1ZXVlLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ET1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZpZXdOYW1lICE9PSBxdWV1ZVtpXSAmJiBtb2RWaWV3c1txdWV1ZVtpXV1bMF0uaGFzQ2hpbGRyZW5XaXRoTmFtZSh2aWV3TmFtZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRzLnB1c2gobW9kVmlld3NbcXVldWVbaV1dWzBdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50cy5sZW5ndGggPT09IDAgPyBudWxsIDogcGFyZW50cztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8vIHBhc3NlcyBhIHZpZXcgbGlzdCBhbmQgY29tcGxldGUgdGhlIGxpc3Qgd2l0aCBhbGwgcGFyZW50IG5vZGUgbmFtZXNcclxuICAgICAgICAgICAgICAgICAgICBhZGRQYXJlbnRzIDogZnVuY3Rpb24gKHZpZXdzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBleHRWaWV3cyA9IHZpZXdzLCBpLCBsLCBwTm9kZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hFeHRWaWV3cyA9IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV4dFZpZXdzLmluZGV4T2YobmFtZSkgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4dFZpZXdzLnB1c2gobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhcmVudFZpZXcgPSBmdW5jdGlvbiAodmlld05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNhbGwgZW5kcyBhbHdheXMgd2l0aCBudWxsIC0gdmlld05hbWUgaXMgdG9wIHBhcmVudFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwVmlld05hbWUgPSBmYy5nZXRQYXJlbnROb2RlKHZpZXdOYW1lKTtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3ZpZXdOYW1lOiAnICsgdmlld05hbWUsICdwVmlld05hbWUgJyArIHBWaWV3TmFtZSApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwVmlld05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcFZpZXdOYW1lLmZvckVhY2goZnVuY3Rpb24gKGZjX21vZHVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB3aGlsZSBoYXMgcGFyZW50IGFkZCBpdCB0byB0aGUgZXh0Vmlld3NcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hFeHRWaWV3cyhmY19tb2R1bGUuZ2V0Vmlld05hbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXJlbnRWaWV3KGZjX21vZHVsZS5nZXRWaWV3TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbCA9IHZpZXdzLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcE5vZGUgPSBmYy5nZXRQYXJlbnROb2RlKHZpZXdzW2ldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBOb2RlLmZvckVhY2goZnVuY3Rpb24gKGZjX21vZHVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwdXNoRXh0Vmlld3MoZmNfbW9kdWxlLmdldFZpZXdOYW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzbyBmYXIgd2UgaGF2ZSBwYXJlbnRzIGRvIGl0IHJlY3Vyc2l2ZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIG5vdCBuZWVkZWQgZWFjaCBwYXJlbnQgd2lsbCBkbyBpdCBieSBvd24gLVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGRQYXJlbnRWaWV3KGZjX21vZHVsZS5nZXRWaWV3TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0Vmlld3M7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmYWRlT3V0IDogZnVuY3Rpb24gKG5vZGUsIGNiKSB7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZihub2RlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnYy1mbG93Q29udHJvbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdmYWRlLW91dCcpO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2MtZmxvd0NvbnRyb2wnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2ZhZGUtb3V0Jyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDMwMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBmYWRlSW4gOiBmdW5jdGlvbiAobm9kZSwgY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETzogZmFkZSBpbiBkb2VzIG5vdCB3b3JrIHByb3Blcmx5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2MtZmxvd0NvbnRyb2wnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdmYWRlLWluJyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLWZsb3dDb250cm9sJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2ZhZGUtaW4nKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHJpZ2dlciByZWZsb3cgdG8gZml4IHRoZSBibGFjayBib3hlcyBpc3N1ZSBGVFRXTy0xMjQ5XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBjaGVjayBpZiB0aGlzIGNhbiBiZSBhdm9pZGVkIG9yXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm94ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignLnQtY2VudGVyQm94LWNvbnRlbnQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChib3gpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3guc3R5bGUub3BhY2l0eSA9IDAuOTk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYm94LnN0eWxlLm9wYWNpdHkgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIDUwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZXh0ID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gaW5uZXJOb2RlXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHJldHVybnMge3tyZW1vdmU6IHJlbW92ZX19XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3MgOiBmdW5jdGlvbiAobm9kZSwgaW5uZXJOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksIGNlbnRlck5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgdHh0Tm9kZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdyZWxhdGl2ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc3R5bGUub3BhY2l0eSA9ICcwLjYnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLmJhY2tncm91bmRDb2xvciA9ICcjNjY2JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc3R5bGUudG9wID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zdHlsZS5sZWZ0ID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zdHlsZS53aWR0aCA9IG5vZGUub2Zmc2V0V2lkdGggKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLmhlaWdodCA9IG5vZGUub2Zmc2V0SGVpZ2h0ICsgJ3B4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zdHlsZS5ib3JkZXJSYWRpdXMgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShub2RlLCBudWxsKS5ib3JkZXJSYWRpdXM7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJOb2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyTm9kZS5zdHlsZS50b3AgPSAobm9kZS5vZmZzZXRIZWlnaHQgLyAyKSAtIDMwICsgJ3B4JztcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyTm9kZS5zdHlsZS53aWR0aCA9IG5vZGUub2Zmc2V0V2lkdGggKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJOb2RlLnN0eWxlLnRleHRBbGlnbiA9ICdjZW50ZXInO1xyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlubmVyTm9kZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2VudGVyTm9kZS5hcHBlbmRDaGlsZChpbm5lck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobmV3Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoY2VudGVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmUgOiBmdW5jdGlvbiAoZGVsYXksIGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobmV3Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2VudGVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiICYmIGNiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkgfHwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFkZU91dCA6IGZ1bmN0aW9uIChkZWxheSwgY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMuZmFkZU91dChuZXdOb2RlLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKG5ld05vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChjZW50ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiICYmIGNiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sIGRlbGF5IHx8IDApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgKiBAdHlwZSB7e21vZDoge30sIGNyZWF0ZU5ld0luc3RhbmNlOiBjcmVhdGVOZXdJbnN0YW5jZSwgcmVhZHk6IHJlYWR5LCBhZGQ6IGFkZCwgc2hvdzogc2hvdywgZmFkZUluOiBmYWRlSW4sIHNob3dJbW1lZGlhdGVseTogc2hvd0ltbWVkaWF0ZWx5LCBvdmVybGF5OiBvdmVybGF5fX1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgYXBpID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIG1vZCA6IG1vZFZpZXdzLCAvLyBwYXJ0IG9mIGFwaVxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIHRoaXMgbWV0aG9kIGNvdWxkIGJlIHVzZWQgdG8gY3JlYXRlIG5ldyBpbnN0YW5jZXMgb2YgZmxvd0NvbnRyb2wgKG9ubHkgbmVlZGVkIGlmIHlvdVxyXG4gICAgICAgICAgICAgICAgICAgICAqIGxvYWQgdGhpcyBzY3JpcHQgZGlyZWN0bHkgd2l0aG91dCByZXF1aXJlKVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuYW1lICh1bmlxdWUgbW9kdWxlIG5hbWUpXHJcbiAgICAgICAgICAgICAgICAgICAgICoqL1xyXG4gICAgICAgICAgICAgICAgICAgIGNyZWF0ZU5ld0luc3RhbmNlIDogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZsb3dDb250cm9sKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgcmVhZHkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBtb2ROYW1lcyA9IE9iamVjdC5rZXlzKG1vZFZpZXdzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxJbml0aWFsVmlld0NvbXBsZXRlUXVldWUgPSB0cnVlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbCA9IG1vZE5hbWVzLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG93SW5pdGlhbFZpZXcgJiYgbCA+IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNoZWNrIGlmIHNob3dJbml0aWFsVmlldyBjb250YWlucyBhIHJlZ2lzdGVyZWQgbW9kdWxlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgZm9yIGV4aXN0aW5nIG5hbWUgaW4gc2hvd0luaXRpYWxWaWV3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dJbml0aWFsVmlldy5pbmRleE9mKG1vZE5hbWVzW2ldKSAhPT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0luaXRpYWxWaWV3LnB1c2goZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TaG93SW5pdGlhbFZpZXdDb21wbGV0ZS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd0luaXRpYWxWaWV3Q29tcGxldGUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxJbml0aWFsVmlld0NvbXBsZXRlUXVldWUgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBpLnNob3dJbW1lZGlhdGVseS5hcHBseShudWxsLCBzaG93SW5pdGlhbFZpZXcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWxsSW5pdGlhbFZpZXdDb21wbGV0ZVF1ZXVlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNob3dJbml0aWFsVmlld0NvbXBsZXRlLmZvckVhY2goZnVuY3Rpb24oZmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SW5pdGlhbFZpZXdDb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBDYWxscyB0aGUgZ2l2ZW4gZnVuY3Rpb24gYWZ0ZXIgbG9hZGluZyBhbGwgaW5pdGlhbCB2aWV3cy5cclxuICAgICAgICAgICAgICAgICAgICAgKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBmY1xyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIG9uU2hvd0luaXRpYWxWaWV3Q29tcGxldGUgOiBmdW5jdGlvbihmYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgcGFzc2VkIGZ1bmN0aW9uIHdpbGwgYmUgY2FsbGVkIGFsc28gYWZ0ZXIgaW5pdGlhbGlzYXRpb25cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFzaG93SW5pdGlhbFZpZXdDb21wbGV0ZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TaG93SW5pdGlhbFZpZXdDb21wbGV0ZS5wdXNoKGZjKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYXR0ciB7e3ZpZXc6KGlkZW50aWZpZXIpLH19XHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHsgICAgLy8gcGFydCBvZiBhcGlcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFtb2RWaWV3c1thdHRyLnZpZXddKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RWaWV3c1thdHRyLnZpZXddID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbW9kVmlld3NbYXR0ci52aWV3XS5wdXNoKGZsb3dDb250cm9sTW9kdWxlKG5vZGUsIGF0dHIpKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHdpbGwgaGFuZGxlIHNob3dJbW1lZGlhdGVseSBpbiBuZWFyIGZ1dHVyZVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHNob3cgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFwaS5mYWRlSW4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuYW1lIChhcmd1bWVudHMgbGlzdCBvZiB2aWV3cyB0byBzaG93KVxyXG4gICAgICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgICAgIGZhZGVJbiA6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaG93TW9kcyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlID0gT2JqZWN0LmtleXMobW9kVmlld3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVDb3VudCA9IDAsLy8gPSBxdWV1ZS5sZW5ndGgsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWRlSW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01vZHMuZm9yRWFjaChmdW5jdGlvbiAobW9kdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RWaWV3cy5oYXNPd25Qcm9wZXJ0eShtb2R1bGUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RWaWV3c1ttb2R1bGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5mYWRlSW4oZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlbW92ZVxyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdGQURFIElOIERPTkUnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjb3VudCBjYWxsYmFja3MgYW5kIGhhbmRsZSBpdCA/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGxhc3QgcGFyYW0gaXMgZnVuY3Rpb24gdGhhbiBoYW5kbGUgaXQgYXMgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHNob3dNb2RzW3Nob3dNb2RzLmxlbmd0aCAtIDFdID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNb2RzW3Nob3dNb2RzLmxlbmd0aCAtIDFdKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01vZHMgPSBmYy5hZGRQYXJlbnRzKHNob3dNb2RzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUuZm9yRWFjaChmdW5jdGlvbiAodmlldykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVDb3VudCArPSBtb2RWaWV3c1t2aWV3XS5sZW5ndGg7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIHJlZ2lzdGVyZWQgbW9kdWxlc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpdGVyYXRlIG92ZXIgYWxsIGluc3RhbmNlcyBvZiB0aGUgc2FtZSB2aWV3XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RWaWV3c1t2aWV3XS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIGFsbCAoZXhjZXB0IGluY29taW5nIGFuZCBwYXJlbnRzKSBUT0RPIGJ1dCBvbmx5IHRoZSBwYXJlbnRzIG9mIHRoZSBtb2R1bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01vZHMuaW5kZXhPZih2aWV3KSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmZhZGVPdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVDb3VudC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVJbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChxdWV1ZUNvdW50IDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVJbigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgdXNlIHNob3cgaW5zdGVhZFxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBuYW1lXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgc2hvd0ltbWVkaWF0ZWx5IDogZnVuY3Rpb24gKCkgeyAgICAvLyBtb2R1bGUgc3BlY2lmaWNcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNob3dNb2RzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBPYmplY3Qua2V5cyhtb2RWaWV3cyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudENiID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2IsIGxlbmd0aCA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbGFzdCBwYXJhbSBpcyBmdW5jdGlvbiB0aGFuIGhhbmRsZSBpdCBhcyBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2hvd01vZHNbc2hvd01vZHMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IgPSBzaG93TW9kc1tzaG93TW9kcy5sZW5ndGggLSAxXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRVcCA6IGZ1bmN0aW9uIChudW0pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aCArPSBudW07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZHVjZSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxlbmd0aC0tO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNiICYmIGxlbmd0aCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvdyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93TW9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZFZpZXdzLmhhc093blByb3BlcnR5KG1vZHVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Q2IuY291bnRVcChtb2RWaWV3c1ttb2R1bGVdLmxlbmd0aCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RWaWV3c1ttb2R1bGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5zaG93KGNvdW50Q2IucmVkdWNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93TW9kcyA9IGZjLmFkZFBhcmVudHMoc2hvd01vZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBoaWRlIGFsbCAoZXhjZXB0IGluY29taW5nKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RWaWV3c1t2aWV3XS5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd01vZHMuaW5kZXhPZihvYmopID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouaGlkZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdygpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmxheSA6IGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCdzIG93biBtb2R1bGU/XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtb2RWaWV3cy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IG1vZFZpZXdzW25hbWVdLmdldE5vZGUoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJ5IDogZnVuY3Rpb24gKG5hbWUsIHRleHQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZXh0W25hbWVdKG5vZGUsIHRleHQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIHJldHVybiBhcGk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBmbG93Q29udHJvbCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBpbnN0YW5jZXMgPSB7fTtcclxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChuYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgaW5zdGFuY2UsXHJcbiAgICAgICAgICAgICAgICAgICAgZGVmID0gbmFtZSB8fCAnZmxvd0NvbnRyb2wnO1xyXG4gICAgICAgICAgICAgICAgaWYgKGluc3RhbmNlcy5oYXNPd25Qcm9wZXJ0eShkZWYpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbZGVmXTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2VzW2RlZl0gPSBmbG93Q29udHJvbEluc3RhbmNlKGRlZik7XHJcbiAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UgPSBpbnN0YW5jZXNbZGVmXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KCkpO1xyXG4gICAgLy8gZXhwb3J0IGFzIG1vZHVsZSBvciBiaW5kIHRvIGdsb2JhbFxyXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0cycpKSB7IG1vZHVsZS5leHBvcnRzID0gZmxvd0NvbnRyb2w7IH0gZWxzZSB7Y2FubnkuYWRkKCdmbG93Q29udHJvbCcsIGZsb3dDb250cm9sKCdmbG93Q29udHJvbCcpKTsgfVxyXG5cclxufSgpKTsiLCIvKmdsb2JhbCBjYW5ueSAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG5cbi8qKlxuICogcmVwZWF0XG4gKlxuICogRS5nLlxuICogIDxkaXYgY2FubnktbW9kPVwicmVwZWF0XCIgY2FubnktdmFyPVwieydmb3InOidpdGVtJywgJ2luJzoncGF0aC50by5saXN0J31cIj5cbiAqICAgICA8cD5EQVRBOiB7e2l0ZW19fSk8L3A+XG4gKiAgPC9kaXY+XG4gKiAgb3I6XG4gKiAgPGRpdiBjYW5ueS1tb2Q9XCJyZXBlYXRcIiBjYW5ueS12YXI9XCJ7J2Zvcic6J29iamVjdEl0ZW0nLCAnaW4nOidwYXRoLnRvLm9iamVjdCd9XCI+XG4gKiAgICAgPHA+REFUQSBGT086IHt7b2JqZWN0SXRlbS5mb299fSk8L3A+XG4gKiAgICAgPHA+REFUQSBCQVI6IHt7b2JqZWN0SXRlbS5iYXJ9fSk8L3A+XG4gKiAgPC9kaXY+XG4gKlxuICogZm9yOlxuICogaXMgdGhlIG5hbWUgb2YgdGhlIGl0ZXJhdGluZyBpdGVtIHRvIGhhdmUgYWNjZXNzIGZyb20gdGhlIERPTS5cbiAqXG4gKiBpbjpcbiAqIGlzIHRoZSBzb3VyY2Ugd2hlcmUgcmVwZWF0IGNhbiBmaW5kIHRoZSBhcnJheS5cbiAqIEl0IGFjY2VwdHMgZnVuY3Rpb25zLCBhcnJheSwgYW5kIG9iamVjdHMgcG9pbnRlclxuICogLSBvYmplY3Q6IGtlZXAgaW4gbWluZCB0aGF0IG9iamVjdCBoYXMgbm8gc3BlY2lmaWMgc29ydGluZ1xuICogLSBhcnJheTpcbiAqIC0gZnVuY3Rpb246IHJlcGVhdCB3aWxsIGNhbGwgaXQgd2l0aCB0aGUgZm9sbG93aW5nIHBhcmFtZXRlcjpcbiAqICAqIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGJlIGNhbGxlZCB3aXRoIHRoZSBvYmplY3Qgb3IgbGlzdFxuICogICogLi4uXG4gKlxuICogIFRPRE86IGFkZCBleGFtcGxlIHRvIGdldCBkYXRhIGRpcmVjdCBmcm9tXG4gKiAgICogYSBsaXN0IG9mIGZ1bmN0aW9uXG4gKiAgICogYSBvYmplY3Qgd2hpY2ggY29udGFpbiBmdW5jdGlvbnNcbiAqXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIG9wZW5DaGFyID0gJ3snLFxuICAgICAgICBlbmRDaGFyICA9ICd9JyxcbiAgICAgICAgRVNDQVBFX1JFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZyxcbiAgICAgICAgcmVwZWF0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBCSU5ESU5HX1JFID0gZ2V0UmVnZXgoKTtcblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgUGFyc2UgYSBwaWVjZSBvZiB0ZXh0LCByZXR1cm4gYW4gYXJyYXkgb2YgdG9rZW5zXG4gICAgICAgICAgICAgKiAgVE9ETyByZWZhY3RvciBtZXRob2RcbiAgICAgICAgICAgICAqICBAcGFyYW0gdGV4dFxuICAgICAgICAgICAgICogIEByZXR1cm4gW3trZXk6U3RyaW5nLCBodG1sOmJvb2xlYW59XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFCSU5ESU5HX1JFLnRlc3QodGV4dCkpIHtyZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgICAgIHZhciBtLCBpLCB0b2tlbiwgbWF0Y2gsIHRva2VucyA9IFtdLCBvcmlnID0ge3RleHQ6IHRleHQsIGlkeCA6IDB9LCB0ZXh0T2JqZWN0O1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCBib3NzOiB0cnVlICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSB0ZXh0Lm1hdGNoKEJJTkRJTkdfUkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHtjb25jYXQgOiB0cnVlfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZy5pZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jYXQgOiBvcmlnLnRleHRbb3JpZy5pZHggLSAxXSAhPT0gJyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IHRleHQuc2xpY2UoMCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdCA6IG9yaWcudGV4dFtvcmlnLmlkeCAtIDFdICE9PSAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogdGV4dC5zbGljZSgwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGV4dE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3JpZy5pZHggKz0gaTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ua2V5ID0gbVsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbVswXTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaHRtbCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5jaGFyQXQoMikgPT09IG9wZW5DaGFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5jaGFyQXQobWF0Y2gubGVuZ3RoIC0gMykgPT09IGVuZENoYXI7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt2YWx1ZSA6IHRleHQsIHRleHQgOiB0cnVlLCBjb25jYXQ6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YU9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHRva2VucyBbe2tleTpTdHJpbmcsIG5vZGU6RE9NIG5vZGUsIGh0bWw6IGJvb2xlYW59XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gcGFyc2Uobm9kZS5ub2RlVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBkYXRhT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbCwgdG9rZW4sIGksIGwsIHRtcCwgdG9rZW5PYmplY3RQcm9wZXJ0eSwgdmFsO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5zIHx8IG9iaiA9PT0gdW5kZWZpbmVkKSB7cmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiA9PT0gJ29iamVjdCcgJiYgdG9rZW4uaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0bXAgPSB0b2tlbi5rZXkuc3BsaXQoJy4nKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcC5sZW5ndGggPiAwICYmIHRtcFswXSA9PT0gaXRlbU5hbWUpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBbMF0gIT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGVycm9yIGhhbmRsaW5nIGlmIGtleSBkb2Vzbid0IG1hdGNoIHdpdGggaXRlbU5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVwZWF0OmNvbXBpbGVUZXh0Tm9kZSBodXBzIHNvbWV0aGluZyBpcyB3cm9uZyB3aGljaCBuZWVkcyB0byBiZSBmaXhlZCEhISBUb2tlbiB3aXRoIG5hbWUnLCB0b2tlbi5rZXksICdkb2VzblxcJ3QgbWF0Y2ggd2l0aCBzY29wZSBuYW1lOiAnLCBpdGVtTmFtZSAsICcgUmVwZWF0IHdpbGwgY29udGludWUgYnV0IGJlIGNhcmVmdWxseSB0aGlzIFwiYnVnXCIgd2lsbCBiZSByZW1vdmVkIGluIG5leHQgdmVyc2lvbiBvZiByZXBlYXQhISEnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZ2V0R2xvYmFsQ2FsbCh0b2tlbk9iamVjdFByb3BlcnR5LCBvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3QgYSBzdHJpbmc/XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbC50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsKG5vZGUucGFyZW50Tm9kZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgaXMgbm90IGV4aXN0cyBidXQgaXQgaXMgdGhlIHNhbWUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgdG9rZW4uLi4gbG9va3MgbGlrZSBpcyBub3QgbWluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3t7JyArIHRva2VuLmtleSArICd9fScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZSA9IGVsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IG5vcm1hbCBzdHJpbmcgcHV0IGJhY2sgdG8gdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGFPYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21waWxlRWxlbWVudCAobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAvLyByZWN1cnNpdmVseSBjb21waWxlIGNoaWxkTm9kZXNcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChub2RlLmNoaWxkTm9kZXMpLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb21waWxlKGNoaWxkLCBkYXRhT2JqLCBpdGVtTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ29tcGlsZSBhIERPTSBub2RlIChyZWN1cnNpdmUpXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGFPYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBpbGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlVHlwZSA9PT0gMSAmJiBub2RlLnRhZ05hbWUgIT09ICdTQ1JJUFQnKSB7IC8vIGEgbm9ybWFsIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZUVsZW1lbnQobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcGlsZVRleHROb2RlKG5vZGUsIGRhdGFPYmosIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gdG8gZG8gdGhlIHJlYWQgdmFyaWFibGUgZnJvbSBzdHJpbmcgbWFnaWMuXG4gICAgICAgICAgICAgKiBUaGUgY2Igd2lsbCBjYWxsZWQgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWUgLSBpbiBjYXNlIG9mIHVuZGVmaW5lZCB0aGUgdmFyaWFibGUgZG9lcyBub3QgZXhpc3RzXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZU5hbWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBnZXRMb29wVmFsdWVGcm9tQXR0cmlidXRlKG5vZGUsIG9iaiwgaXRlbU5hbWUsIGF0dHJpYnV0ZU5hbWUsIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRtcCA9IG5vZGUuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZU5hbWUpLnNwbGl0KCcuJyksIHRva2VuT2JqZWN0UHJvcGVydHk7XG4gICAgICAgICAgICAgICAgaWYgKHRtcC5sZW5ndGggPiAwICYmIHRtcFswXSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5PYmplY3RQcm9wZXJ0eSA9IHRtcC5zbGljZSgxKS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGdldEdsb2JhbENhbGwodG9rZW5PYmplY3RQcm9wZXJ0eSwgb2JqKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgdGhpcyBjb3JyZWN0bHlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigncmVwZWF0OmdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUgaGFzIHByb2JsZW1zJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJlZ2lzdGVyIGNsaWNrIGV2ZW50c1xuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgcnAtYmluZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIGNsb25lXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbVxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUV2ZW50cyhjbG9uZSwgb2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBvbkNsaWNrID0gJ29uLWNsaWNrJztcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjaGlsZHJlbiBvZiBjbG9uZVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnWycgKyBvbkNsaWNrICsgJ10nKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRMb29wVmFsdWVGcm9tQXR0cmlidXRlKG5vZGUsIG9iaiwgaXRlbU5hbWUsIG9uQ2xpY2ssIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdyZXBlYXQ6Y2FuIG5vdCByZWdpc3RlciBjbGljayBsaXN0ZW5lciB3aXRob3V0IGEgZnVuY3Rpb24nLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVnaXN0ZXIgcnAtYmluZCBoYW5kbGVyXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIFdpdGggaGVscCBvZiB0aGlzIHRoZSBpZiBhbmQgaWYtbm90IGFuZCBvbkNsaWNrIGF0dHJpYnV0ZSBpcyBkZXByZWNhdGVkIC0geW91IGNhbiBqdXN0IHBhc3MgYSBmdW5jdGlvbiBcbiAgICAgICAgICAgICAqIHBvaW50ZXIgdG8gcnAtYmluZCBhbmQgZG8gYWxsIHRoZSByZXF1aXJlZCBsb2dpYyBieSB5b3VyIG93bi5cbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogSWYgeW91IHJldHVybiBmYWxzZSB0aGVuIHRoZSBub2RlIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2xvbmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVSUEJpbmRBdHRyaWJ1dGUoY2xvbmUsIG9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAncnAtYmluZCc7XG4gICAgICAgICAgICAgICAgLy8gY2hlY2sgY2hpbGRyZW4gb2YgY2xvbmVcbiAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGNsb25lLnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgYXR0ck5hbWUgKyAnXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUobm9kZSwgb2JqLCBpdGVtTmFtZSwgYXR0ck5hbWUsIGZ1bmN0aW9uICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbChub2RlKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGUgaWYgZnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTsgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBlYXQ6Y2FuIG5vdCByZWdpc3RlciBjb250cm9sIGZ1bmN0aW9uIHdpdGhvdXQgYSBmdW5jdGlvbiBwb2ludGVyJywgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlcGxhY2VzIGV4cHJlc3Npb25zIGZvciBhbGwgdGFnIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2xvbmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZSAoY3VycmVudGx5IG5vdCBpbiB1c2VkIGJ1dCBuZWVkcyB0byBiZSBjaGVja2VkKVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGVzKGNvbnRhaW5lck5vZGUsIG9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmV0dXJuVG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgKGZ1bmN0aW9uIHNlYXJjaEZvckV4cHJlc3Npb25zKGNoaWxkcmVuKSB7XG4gICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBpLCBhdHRyLCByVG9rZW5zO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUuY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvIGl0IHJlY3Vyc2l2ZSBmb3IgYWxsIGNoaWxkcmVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoRm9yRXhwcmVzc2lvbnMobm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBsb29wIHRocm91Z2ggZWFjaCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBub2RlLmF0dHJpYnV0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFx7XFx7Ly50ZXN0KGF0dHIudGV4dENvbnRlbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLm5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJUb2tlbnMgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB0b2tlbiA9IHBhcnNlKGF0dHIudGV4dENvbnRlbnQpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRhID0gW10sIHRtcFRva2VuLCBqLCB0bXBUb2tlblNwbGl0LCB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdG9rZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4gPSB0b2tlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdG9rZW4gbm90IGl0ZW1OYW1lIHNraXBwIGFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wVG9rZW4ua2V5ICE9PSB1bmRlZmluZWQgJiYgdG1wVG9rZW4ua2V5LnNwbGl0KCcuJylbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLmF0dHIgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC4vLnRlc3QodG1wVG9rZW4ua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuU3BsaXQgPSB0bXBUb2tlbi5rZXkuc3BsaXQoJy4nKS5zbGljZSgxKS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuU3BsaXQgPSB0bXBUb2tlbi5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUb2tlbi52YWx1ZSA9IGdldEdsb2JhbENhbGwodG1wVG9rZW5TcGxpdCwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRtcFRva2VuLnZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG1wVG9rZW4udmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRtcFRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wVG9rZW4uaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBleHByZXNzaW9uIC0gbWlnaHQgYmUgYW5vdGhlciB3aGlza2VyIGluc3RhbmNlIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ3t7JyArIHRtcFRva2VuLmtleSArICd9fSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRtcFRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGEucHVzaCh7dmFsdWUgOiB2YWx1ZSwgY29uY2F0IDogdG1wVG9rZW4uY29uY2F0fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIudGV4dENvbnRlbnQgPSBlbmREYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb25jYXQgPyBkLnZhbHVlIDogJyAnICsgZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVG9rZW5zID0gcmV0dXJuVG9rZW5zLmNvbmNhdChyVG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfShjb250YWluZXJOb2RlLmNoaWxkcmVuKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblRva2VucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBoYW5kbGUgdGhlIGlmIGNvbmRpdGlvbnMgaWYgYW5kIGlmLW5vdFxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2UgcnAtYmluZCBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIGNsb25lXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbU5hbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlSWZDb25kaXRpb24oY2xvbmUsIG9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXR0cmlidXRlTmFtZV9pZiA9ICdpZicsXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZU5hbWVfaWZfbm90ID0gJ2lmLW5vdCc7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBjaGVja0lmKHZhbCwgbm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrSWZOb3QodmFsLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjaGlsZHJlbiBvZiBjbG9uZVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnWycgK2F0dHJpYnV0ZU5hbWVfaWYgKyAnXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUobm9kZSwgb2JqLCBpdGVtTmFtZSwgYXR0cmlidXRlTmFtZV9pZiwgZnVuY3Rpb24gKHZhbCkge2NoZWNrSWYodmFsLCBub2RlKTt9KTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnWycgK2F0dHJpYnV0ZU5hbWVfaWZfbm90ICsgJ10nKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBnZXRMb29wVmFsdWVGcm9tQXR0cmlidXRlKG5vZGUsIG9iaiwgaXRlbU5hbWUsIGF0dHJpYnV0ZU5hbWVfaWZfbm90LCBmdW5jdGlvbiAodmFsKSB7Y2hlY2tJZk5vdCh2YWwsIG5vZGUpO30pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIExvb3BlZCB0aHJvdWdoIHRoZSBjb2xsZWN0aW9uIGFuZCBkbyB0aGUgbG9naWMgZm9yIGVhY2ggY2xvbmUgaW5zdGFuY2UuXG4gICAgICAgICAgICAgKiBBY3R1YWxseSBpdCBzdXBwb3J0cyBvbmx5IGNvbGxlY3Rpb24gLSBubyBvYmplY3RzLlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIGNvbGxlY3Rpb25cbiAgICAgICAgICAgICAqIEBwYXJhbSB0ZW1wbGF0ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiByZWdpc3RlclRlbXBsYXRlKG5vZGUsIGl0ZW1OYW1lLCBjb2xsZWN0aW9uLCB0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgICAgIHZhciBtYWluRnJhZztcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbGxlY3Rpb24gPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoY29sbGVjdGlvbikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0IGlzIGFuIGFycmF5XG4gICAgICAgICAgICAgICAgICAgICAgICBtYWluRnJhZyA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbGxlY3Rpb24uZm9yRWFjaChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gY291bGQgYmUgYW4gb2JqZWN0IG9yIGp1c3QgYSBwcm9wZXJ0eSBsaWtlIGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzdHJpbmcgKGluIGNhc2Ugb2YgaXQgaXMgZGlyZWN0IGEgbGlzdCBvZiBzdHJpbmdzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRlbXBsYXRlLmZvckVhY2goZnVuY3Rpb24gKGNoaWxkVHBsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gd29ya3MgYWxzbyB3aXRoIGZyYWdtZW50IGJ1dCB0aGVuIHRoZSBxdW5pdCB0ZXN0IGZhaWxzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIC0gdGhlcmUgaXMgYSBwcm9ibGVtIHdpdGggdGhlIHBoYW50b21qc1xuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZyYWdtZW50LmFwcGVuZENoaWxkKGNoaWxkVHBsLmNsb25lTm9kZSh0cnVlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVJZkNvbmRpdGlvbihmcmFnbWVudCwgaXRlbSwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBjb25kaXRpb25zIGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSBjbG9uZSAtIGl0J3MgaW1wb3J0YW50IHRoYXQgdGhpcyBpcyBleGVjdXRlZCBmaXJzdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuY2hpbGRyZW4gJiYgZnJhZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVSUEJpbmRBdHRyaWJ1dGUoZnJhZ21lbnQsIGl0ZW0sIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBycC1iaW5kIGF0dHJpYnV0ZSBjYW4gYWxzbyByZW1vdmUgZWxlbWVudHMgc28gbmVlZCB0byBjaGVjayBhZ2FpbiBpZiBub2RlIGV4aXN0c1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZnJhZ21lbnQuY2hpbGRyZW4gJiYgZnJhZ21lbnQuY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVFdmVudHMoZnJhZ21lbnQsIGl0ZW0sIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUF0dHJpYnV0ZXMoZnJhZ21lbnQsIGl0ZW0sIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlcGxhY2UgdGV4dHM6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluRnJhZy5hcHBlbmRDaGlsZChjb21waWxlKGZyYWdtZW50LmNoaWxkcmVuWzBdLCBpdGVtLCBpdGVtTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb25zb2xlLmxvZygncmVwZWF0OmVsZW1lbnQgaGFzIGJlZW4gcmVtb3ZlZCBmcm9tIERPTScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQobWFpbkZyYWcpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgYW4gb2JqZWN0XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBlYXQgZGV0ZWN0IG9iamVjdCBidXQgb2JqZWN0IGN1cnJlbnRseSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3aGF0IHJlbmRlcj8gLSBwcm9wZXJ0eSBuYW1lIG9yIHZhbHVlPyAtIEJvdGg/XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBlYXQ6cmVnaXN0ZXJUZW1wbGF0ZSBkZXRlY3Qgbm9uZSBhY2NlcHRhYmxlIGRhdGEgYXJndW1lbnQnLCBjb2xsZWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQ3JlYXRlIGEgbmV3IHJlcGVhdCBpbnN0YW5jZSBhbmQgZG8gdGhlIFwibWFnaWNcIi5cbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2NvcGVOYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YSB7W10sIGZ1bmN0aW9ufVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjUmVwZWF0KG5vZGUsIHNjb3BlTmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciB0ZW1wbGF0ZSA9IFtdO1xuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUucHVzaChub2RlLnJlbW92ZUNoaWxkKGNoaWxkKSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YShmdW5jdGlvbiAobmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY29wZU5hbWUgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gbmFtZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGJldHRlciB3b3VsZCBiZSBhIHVwZGF0ZSBjaGlsZHJlbiBidXQgdGhpcyBpcyBtdWNoIGVmZm9ydCB0byBkZXRlY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJUZW1wbGF0ZShub2RlLCBzY29wZU5hbWUsIGRhdGEsIHRlbXBsYXRlKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVnaXN0ZXJUZW1wbGF0ZShub2RlLCBzY29wZU5hbWUsIGRhdGEsIHRlbXBsYXRlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAgICAgKiB0aGUgYXR0cmlidXRlIHJlcXVpcmVzOlxuICAgICAgICAgICAgICAgICAqICBmb3I6IG5hbWUgb2YgdGhlIGl0ZXJhdG9yXG4gICAgICAgICAgICAgICAgICogIGluOiBwb2ludGVyIHRvOiBmdW5jdGlvbiwgYXJyYXkgb3Igb2JqZWN0XG4gICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyIHt7Zm9yOnN0cmluZyxpbjpzdHJpbmd9fVxuICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBpblBvaW50ZXI7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYXR0ciA9PT0gJ29iamVjdCcgJiYgYXR0ci5pbiAmJiBhdHRyLmZvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyLmluID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVwbGFjZSB3aW5kb3cgd2l0aCB0aGlzIGFuZCBhbHNvIG90aGVyIGluc3RhbmNlcyBjb3VsZCB1c2UgdGhlIG1hZ2ljIGFzIGNsb3N1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBvaW50ZXIgPSBnZXRHbG9iYWxDYWxsKGF0dHIuaW4sIHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUG9pbnRlciA9IGF0dHIuaW47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjUmVwZWF0KG5vZGUsIGF0dHIuZm9yIHx8ICdpdGVtJywgaW5Qb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXR0cikgPT09ICdbb2JqZWN0IEFycmF5XScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXBlYXQobm9kZSwgJ2l0ZW0nLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXR0ciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1JlcGVhdChub2RlLCAnaXRlbScsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5Qb2ludGVyID0gZ2V0R2xvYmFsQ2FsbChhdHRyLCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1JlcGVhdChub2RlLCAnaXRlbScsIGluUG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3JlcGVhdDphZGQgbm9uZSBhY2NlcHRhYmxlIGF0dHJpYnV0ZXMnLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0oKSk7XG5cbiAgICBmdW5jdGlvbiBlc2NhcGVSZWdleChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci5yZXBsYWNlKEVTQ0FQRV9SRSwgJ1xcXFwkJicpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldFJlZ2V4KCkge1xuICAgICAgICB2YXIgb3BlbiA9IGVzY2FwZVJlZ2V4KG9wZW5DaGFyKSxcbiAgICAgICAgICAgIGVuZCAgPSBlc2NhcGVSZWdleChlbmRDaGFyKTtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWdFeHAob3BlbiArIG9wZW4gKyBvcGVuICsgJz8oLis/KScgKyBlbmQgKyAnPycgKyBlbmQgKyBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlYWQgYSBwcm9wZXJ0eSBmcm9tIGEgZ2l2ZW4gc3RyaW5nIGFuZCBvYmplY3QuXG4gICAgICogUmV0dXJucyB0aGUgZm91bmRlZCBwcm9wZXJ0eSBwb2ludGVyIG9yIHVuZGVmaW5lZC5cbiAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgKiBAcGFyYW0gb2JqXG4gICAgICogQHJldHVybnMgeyp9IG9yIHVuZGVmaW5lZFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEdsb2JhbENhbGwgKHZhbHVlLCBvYmopIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gdmFsdWUuc3BsaXQoJy4nKSxcbiAgICAgICAgICAgIHJlYyA9IGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgICAgICAgICAgICBpZiAob2JqW2N1cl0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSBvYmpbY3VyXTtcbiAgICAgICAgICAgICAgICAgICAgcmVjKHNwbGl0LnNoaWZ0KCkpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY3VyID09PSB2YWx1ZSApIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIHJlYyhzcGxpdC5zaGlmdCgpKTtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG5cbiAgICAvLyBleHBvcnQgYXMgbW9kdWxlIG9yIGJpbmQgdG8gZ2xvYmFsXG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5oYXNPd25Qcm9wZXJ0eSgnZXhwb3J0cycpKSB7XG4gICAgICAgIG1vZHVsZS5leHBvcnRzID0gcmVwZWF0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbm55LmFkZCgncmVwZWF0JywgcmVwZWF0KTtcbiAgICB9XG5cbn0oKSk7XG4iLCIvKmdsb2JhbCBjYW5ueSAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSovXG4vKipcbiAqXG4gKiBFLmcuIHt7d2hpc2tlcn19OlxuICogIDxkaXYgY2FubnktbW9kPVwid2hpc2tlclwiIGNhbm55LXZhcj1cInsnYmluZCc6J3Njb3BlJywndG8nOnsnbWVzc2FnZSc6J015IHRleHQnfX1cIj5cbiAqICAgICA8cD5EQVRBOiB7e3Njb3BlLm1lc3NhZ2V9fSk8L3A+XG4gKiAgPC9kaXY+XG4gKiAgT3IganVzdCBwYXNzIHRoZSBmdW5jdGlvbiBwb2ludGVyIHRoZSBkZWZhdWx0IHNjb3BlIGlzICdzY29wZScuXG4gKiAgPGRpdiBjYW5ueS1tb2Q9XCJ3aGlza2VyXCIgY2FubnktdmFyPVwibXltb2R1bGUuZnVuY3Rpb25Qb2ludGVyXCI+XG4gKiAgICAgPHA+REFUQToge3tzY29wZS5tZXNzYWdlfX0pPC9wPlxuICogIDwvZGl2PlxuICpcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcblxuICAgIHZhciBvcGVuQ2hhciA9ICd7JyxcbiAgICAgICAgZW5kQ2hhciAgPSAnfScsXG4gICAgICAgIEVTQ0FQRV9SRSA9IC9bLS4qKz9eJHt9KCl8W1xcXVxcL1xcXFxdL2csXG4gICAgICAgIHdoaXNrZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIEJJTkRJTkdfUkUgPSBnZXRSZWdleCgpO1xuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgUGFyc2UgYSBwaWVjZSBvZiB0ZXh0LCByZXR1cm4gYW4gYXJyYXkgb2YgdG9rZW5zXG4gICAgICAgICAgICAgKiAgVE9ETyByZWZhY3RvciBtZXRob2RcbiAgICAgICAgICAgICAqICBAcGFyYW0gdGV4dFxuICAgICAgICAgICAgICogIEByZXR1cm4gW3trZXk6U3RyaW5nLCBodG1sOmJvb2xlYW59XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBwYXJzZSh0ZXh0KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFCSU5ESU5HX1JFLnRlc3QodGV4dCkpIHtyZXR1cm4gbnVsbDsgfVxuICAgICAgICAgICAgICAgIHZhciBtLCBpLCB0b2tlbiwgbWF0Y2gsIHRva2VucyA9IFtdLCBvcmlnID0ge3RleHQ6IHRleHQsIGlkeCA6IDB9LCB0ZXh0T2JqZWN0O1xuICAgICAgICAgICAgICAgIC8qIGpzaGludCBib3NzOiB0cnVlICovXG4gICAgICAgICAgICAgICAgd2hpbGUgKG0gPSB0ZXh0Lm1hdGNoKEJJTkRJTkdfUkUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGkgPSBtLmluZGV4O1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHtjb25jYXQgOiB0cnVlfTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3JpZy5pZHggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0T2JqZWN0ID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25jYXQgOiBvcmlnLnRleHRbb3JpZy5pZHggLSAxXSAhPT0gJyAnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA6IHRleHQuc2xpY2UoMCwgaSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHQgOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdCA6IG9yaWcudGV4dFtvcmlnLmlkeCAtIDFdICE9PSAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogdGV4dC5zbGljZSgwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godGV4dE9iamVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3JpZy5pZHggKz0gaTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ua2V5ID0gbVsxXS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoID0gbVswXTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4uaHRtbCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5jaGFyQXQoMikgPT09IG9wZW5DaGFyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaC5jaGFyQXQobWF0Y2gubGVuZ3RoIC0gMykgPT09IGVuZENoYXI7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dCA9IHRleHQuc2xpY2UoaSArIG1bMF0ubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHt2YWx1ZSA6IHRleHQsIHRleHQgOiB0cnVlLCBjb25jYXQ6IHRydWV9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YU9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHRva2VucyBbe2tleTpTdHJpbmcsIG5vZGU6RE9NIG5vZGUsIGh0bWw6IGJvb2xlYW59XVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21waWxlVGV4dE5vZGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gcGFyc2Uobm9kZS5ub2RlVmFsdWUpLFxuICAgICAgICAgICAgICAgICAgICBvYmogPSBkYXRhT2JqLFxuICAgICAgICAgICAgICAgICAgICBlbCwgdG9rZW4sIGksIGwsIHRtcCwgdG9rZW5PYmplY3RQcm9wZXJ0eSwgdmFsLCB2YWxVbmtub3duO1xuICAgICAgICAgICAgICAgIGlmICghdG9rZW5zIHx8IG9iaiA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7cmV0dXJuOyB9XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwLCBsID0gdG9rZW5zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IHRva2Vuc1tpXTtcblxuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnb2JqZWN0JyAmJiB0b2tlbi5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRva2VuLmtleS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcC5sZW5ndGggPiAwICYmIHRtcFswXSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsVW5rbm93biA9IGdldEdsb2JhbENhbGwodG9rZW5PYmplY3RQcm9wZXJ0eSwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxVbmtub3duID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBhIHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxVbmtub3duID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbFVua25vd24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWxVbmtub3duKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWxVbmtub3duO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh2YWwgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcHJvcGVydHkgaXMgbm90IGV4aXN0cyBidXQgaXQgaXMgdGhlIHNhbWUgc2NvcGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgdG9rZW4uLi4gbG9va3MgbGlrZSBpcyBub3QgbWluZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJ3t7JyArIHRva2VuLmtleSArICd9fScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZSA9IGVsO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0b2tlbi52YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IG5vcm1hbCBzdHJpbmcgcHV0IGJhY2sgdG8gdmlld1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnM7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGFPYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBjb21waWxlRWxlbWVudCAobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gW10sXG4gICAgICAgICAgICAgICAgICAgIHRva2VuO1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBpbGUgY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0gY29tcGlsZShjaGlsZCwgZGF0YU9iaiwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zLmxlbmd0aCA+IDAgPyB0b2tlbnMgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG5cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gdG8gZG8gdGhlIHJlYWQgdmFyaWFibGUgZnJvbSBzdHJpbmcgbWFnaWMuXG4gICAgICAgICAgICAgKiBUaGUgY2Igd2lsbCBjYWxsZWQgd2l0aCB0aGUgcHJvcGVydHkgdmFsdWUgLSBpbiBjYXNlIG9mIHVuZGVmaW5lZCB0aGUgdmFyaWFibGUgZG9lcyBub3QgZXhpc3RzXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbU5hbWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyaWJ1dGVOYW1lXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEByZXR1cm4ge2Z1bmN0aW9ufSB8IGZhbHNlIGlmIGl0IGlzIG5vdCBhIGZ1bmN0aW9uIG9yIG5vdCBhdmFpbGFibGUgXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldFdrQmluZFZhbHVlKG5vZGUsIG9iaiwgaXRlbU5hbWUsIGF0dHJpYnV0ZU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkuc3BsaXQoJy4nKSwgdG9rZW5PYmplY3RQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICBpZiAodG1wLmxlbmd0aCA+IDAgJiYgdG1wWzBdID09PSBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGdldEdsb2JhbENhbGwodG9rZW5PYmplY3RQcm9wZXJ0eSwgb2JqKSB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJlZ2lzdGVyIHJwLWJpbmQgaGFuZGxlclxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFdpdGggaGVscCBvZiB0aGlzIHRoZSBpZiBhbmQgaWYtbm90IGFuZCBvbkNsaWNrIGF0dHJpYnV0ZSBpcyBkZXByZWNhdGVkIC0geW91IGNhbiBqdXN0IHBhc3MgYSBmdW5jdGlvbiBwb2ludGVyIHRvIHJwLWJpbmQgYW5kXG4gICAgICAgICAgICAgKiBkbyBhbGwgdGhlIHJlcXVpcmVkIGxvZ2ljIGJ5IHlvdXIgb3duLlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIElmIHlvdSByZXR1cm4gZmFsc2UgdGhlbiB0aGUgbm9kZSB3aWxsIGJlIHJlbW92ZWQgZnJvbSB0aGUgRE9NXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBzY29wZU5hbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlV0tCaW5kQXR0cmlidXRlKG5vZGUsIG9iaiwgc2NvcGVOYW1lKSB7XG5cbiAgICAgICAgICAgICAgICBmdW5jdGlvbiBwYXJzZUNoaWxkQXR0cmlidXRlKGNoaWxkLCBkYXRhLCBzY29wZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gJ3drLWJpbmQnLFxuICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gY2hpbGQuZ2V0QXR0cmlidXRlKCd3ay1iaW5kJyksXG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbixcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjID0gZ2V0V2tCaW5kVmFsdWUoY2hpbGQsIGRhdGEsIHNjb3BlTmFtZSwgYXR0ck5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hhZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZjID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvdyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3cuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZjKGNoaWxkKSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlIGlmIGZ1bmN0aW9uIHJldHVybnMgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkID0gY2hpbGQucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQoc2hhZG93LCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGlkZGVuIDogaGlkZGVuLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA6IGNoaWxkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93Tm9kZSA6IHNoYWRvdyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlzV2tCaW5kVG9rZW4gOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYga2V5IGlzIG5lZWRlZCBiZWNhdXNlIGl0IGhhcyB0aGUgd2tCaW5kIGZ1bmN0aW9uIHBvaW50ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA6IGNoaWxkLmdldEF0dHJpYnV0ZSgnd2stYmluZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3doaXNrZXI6Y2FuIG5vdCByZWdpc3RlciBjb250cm9sIGZ1bmN0aW9uIHdpdGhvdXQgYSBmdW5jdGlvbiBwb2ludGVyJywgY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0oZmMpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHZhbGlkIGluIGNhc2Ugb2YgdGhlcmUgaXMgYSBkaWZmZXJlbnQgc2NvcGUgdmFyaWFibGUgb3JcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdmFyIGF0dHJOYW1lID0gJ3drLWJpbmQnLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjaGlsZHJlbiBvZiBjbG9uZVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbJyArIGF0dHJOYW1lICsgJ10nKSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHRtcFRva2VuID0gcGFyc2VDaGlsZEF0dHJpYnV0ZShjaGlsZCwgb2JqLCBzY29wZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG1wVG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2Vucy5wdXNoKHRtcFRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnNcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiAgQ29tcGlsZSBhIERPTSBub2RlIChyZWN1cnNpdmUpXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGFPYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBpbGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZVR5cGUgPSBub2RlLm5vZGVUeXBlLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW47XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSAxICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcpIHsgLy8gYSBub3JtYWwgbm9kZVxuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGNvbXBpbGVFbGVtZW50KG5vZGUsIGRhdGFPYmosIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAobm9kZVR5cGUgPT09IDMpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBjb21waWxlVGV4dE5vZGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnMubGVuZ3RoID4gMCA/IHRva2VucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZXBsYWNlcyBleHByZXNzaW9ucyBmb3IgYWxsIHRhZyBhdHRyaWJ1dGVzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogbG9vcCB0aG91Z2ggYWxsIGNoaWxkcmVuIGFuZCBjaGVjayBpZiBhIGF0dHJpYnV0ZSBoYXMgYSBleHByZXNzaW9ucyBpbnNpZGVcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gY29udGFpbmVyTm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJuIHJldHVyblRva2VucyBbe2tleTpTdHJpbmcsIGF0dHI6IG5vZGUgYXR0cmlidXRlIHJlZmVyZW5jZSwgaHRtbDogYm9vbGVhbn1dXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUF0dHJpYnV0ZXMoY29udGFpbmVyTm9kZSwgb2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5Ub2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gc2VhcmNoRm9yRXhwcmVzc2lvbnMoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGF0dHIsIHJUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gaXQgcmVjdXJzaXZlIGZvciBhbGwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hGb3JFeHByZXNzaW9ucyhub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXHtcXHsvLnRlc3QoYXR0ci50ZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgclRva2VucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gcGFyc2UoYXR0ci50ZXh0Q29udGVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGEgPSBbXSwgdG1wVG9rZW4sIGosIHRtcFRva2VuU3BsaXQsIHZhbHVlLCB0bXBWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgdG9rZW4ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4gPSB0b2tlbltqXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgdG9rZW4gbm90IGl0ZW1OYW1lIHNraXBwIGFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wVG9rZW4ua2V5ICE9PSB1bmRlZmluZWQgJiYgdG1wVG9rZW4ua2V5LnNwbGl0KCcuJylbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzYXZlIHRoZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLmF0dHIgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXC4vLnRlc3QodG1wVG9rZW4ua2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuU3BsaXQgPSB0bXBUb2tlbi5rZXkuc3BsaXQoJy4nKS5zbGljZSgxKS5qb2luKCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuU3BsaXQgPSB0bXBUb2tlbi5rZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBWYWx1ZSA9IGdldEdsb2JhbENhbGwodG1wVG9rZW5TcGxpdCwgb2JqKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRtcFZhbHVlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLnZhbHVlID0gdG1wVmFsdWUobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLm5vZGUgPSBub2RlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLnZhbHVlID0gdG1wVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG1wVG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iaihub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcFRva2VuLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVzdG9yZSB0aGUgZXhwcmVzc2lvbiAtIG1pZ2h0IGJlIGFub3RoZXIgd2hpc2tlciBpbnN0YW5jZSB3aWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBuZWVkcyB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9ICd7eycgKyB0bXBUb2tlbi5rZXkgKyAnfX0nO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0bXBUb2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbmREYXRhLnB1c2goe3ZhbHVlIDogdmFsdWUsIGNvbmNhdCA6IHRtcFRva2VuLmNvbmNhdH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyLnRleHRDb250ZW50ID0gZW5kRGF0YS5tYXAoZnVuY3Rpb24gKGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGQuY29uY2F0ID8gZC52YWx1ZSA6ICcgJyArIGQudmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkuam9pbignJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVyblRva2VucyA9IHJldHVyblRva2Vucy5jb25jYXQoclRva2Vucyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0oY29udGFpbmVyTm9kZS5jaGlsZHJlbikpO1xuICAgICAgICAgICAgICAgIHJldHVybiByZXR1cm5Ub2tlbnM7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogZG8gdGhlIG1hZ2ljIGZvciBhdHRyaWJ1dGVzIG9yIHRleHQgbm9kZXNcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogVE9ETzogYnVnIGlmIHByb3BlcnR5IGRvZXNuJ3QgZXhpc3RzIGluIGZpcnN0IGV4ZWN1dGlvbiBpdCB3YW50IHdvcmsgYW55bW9yZSBmb3IgYXR0cmlidXRlcyBhbmQgd2stYmluZFxuICAgICAgICAgICAgICogIFNlZTogd2hpc2tlclNwZWNzLmpzID4gZHluYW1pY2FsbHlDaGFuZ2VEYXRhV2l0aEluaXRpYWxNaXNzaW5nUHJvcGVydGllc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2NvcGVOYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBmaWxsRGF0YShub2RlLCBzY29wZU5hbWUsIGRhdGEpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG9rZW5zID0gW107XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAvLyBoYW5kbGVFdmVudHMobm9kZSwgZGF0YSwgc2NvcGVOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChoYW5kbGVBdHRyaWJ1dGVzKG5vZGUsIGRhdGEsIHNjb3BlTmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAvLyBtYWtlIHN1cmUgdGhhdCB0aGUgY29tcGlsZXIgYWxzbyB1cGRhdGVzIHRoZSBoaWRkZW4gZWxlbWVudFxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KGNvbXBpbGUobm9kZSwgZGF0YSwgc2NvcGVOYW1lKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdChoYW5kbGVXS0JpbmRBdHRyaWJ1dGUobm9kZSwgZGF0YSwgc2NvcGVOYW1lKSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0ZXh0czpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd3aGlza2VyOmhhbmRsZUF0dHJpYnV0ZXMgZGV0ZWN0IG5vbmUgYWNjZXB0YWJsZSBkYXRhIGFyZ3VtZW50JywgZGF0YSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiBmb3IgdXBkYXRlRGF0YSB0byB1cGRhdGUgdGhlIERPTSBFbGVtZW50c1xuICAgICAgICAgICAgICogQHBhcmFtIHRva2VuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZG9tRWxlbWVudCBET01FbGVtZW50XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZURPTUVsZW1lbnQodG9rZW4sIGRvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0b2tlbi5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGRvbUVsZW1lbnQsIHRva2VuLm5vZGUpO1xuICAgICAgICAgICAgICAgIHRva2VuLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICB0b2tlbi5ub2RlID0gZG9tRWxlbWVudDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uIGZvciB1cGRhdGVEYXRhIHRvIHVwZGF0ZSB0aGUgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICogQHBhcmFtIHRva2VuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVRleHQodG9rZW4sIHZhbCkge1xuICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZTtcbiAgICAgICAgICAgICAgICBpZiAodG9rZW4ubm9kZSBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGNvbnZlcnQgYmFjayB0byB0ZXh0Tm9kZVxuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZSh0ZXh0Tm9kZSwgdG9rZW4ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLm5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZSA9IHRleHROb2RlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZS5ub2RlVmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0ZXN0XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLm5vZGUubm9kZVZhbHVlID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiBmb3IgdXBkYXRlRGF0YSB0byB1cGRhdGUgdGhlIGF0dHJpYnV0ZXMgZm9yIGEgbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIHRva2VuXG4gICAgICAgICAgICAgKiBAcGFyYW0gdmFsdWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlQXR0cmlidXRlcyh0b2tlbiwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgdmFsO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWUodG9rZW4ubm9kZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVwbGFjZVRleHQgPSB0b2tlbi5hdHRyLnRleHRDb250ZW50O1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwbGFjZVRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmF0dHIudGV4dENvbnRlbnQgPSByZXBsYWNlVGV4dC5yZXBsYWNlKHRva2VuLnZhbHVlLCB2YWwpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uYXR0ci50ZXh0Q29udGVudCA9IHJlcGxhY2VUZXh0ICsgdmFsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRva2VuLnZhbHVlID0gdmFsO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gdGVzdCAobWFrZXMgbm8gc2Vuc2UgZm9yIGFuIGF0dHJpYnV0ZSBidXQgbmVlZHMgdG8gYmUgaGFuZGxlZCBjb3JyZWN0bHkgKHRoaW5rIGFib3V0IHdoYXQgdG8gZG8gaW4gdGhpcyBjYXNlKVxuICAgICAgICAgICAgICAgICAgICB0b2tlbi5ub2RlLm5vZGVWYWx1ZSA9IHZhbC50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIENhbGwgdGhpcyB0byB1cGRhdGUgdGhlIGV4aXN0aW5nIGRhdGEnc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRPRE8gdGVzdCBhbHNvIGJvb2xlYW4gYW5kIGZ1bmN0aW9uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHRva2VuT2JqTGlzdCBbe2tleSA6IFwic2NvcGVOYW1lLnByb3BlcnR5XCIsIG5vZGV9XVxuICAgICAgICAgICAgICogQHBhcmFtIHNjb3BlTmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVEYXRhKHRva2VuT2JqTGlzdCwgc2NvcGVOYW1lLCBvYmopIHtcbiAgICAgICAgICAgICAgICB0b2tlbk9iakxpc3QuZm9yRWFjaChmdW5jdGlvbiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuICYmIHRva2VuLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRtcCA9IHRva2VuLmtleS5zcGxpdCgnLicpLCB0b2tlbk9iamVjdFByb3BlcnR5LCB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wLmxlbmd0aCA+IDAgJiYgdG1wWzBdID09PSBzY29wZU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gZ2V0R2xvYmFsQ2FsbCh0b2tlbk9iamVjdFByb3BlcnR5LCBvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRva2VuLmhhc093blByb3BlcnR5KCdhdHRyJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZSBhdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZUF0dHJpYnV0ZXModG9rZW4sIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG9rZW4uaXNXa0JpbmRUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVtb3ZlTWVJZkltRmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVNZUlmSW1GYWxzZSA9IHZhbCh0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlbW92ZU1lSWZJbUZhbHNlID09PSBmYWxzZSAmJiB0b2tlbi5oaWRkZW4gPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlbW92ZSBub2RlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLm5vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodG9rZW4uc2hhZG93Tm9kZSwgdG9rZW4ubm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChyZW1vdmVNZUlmSW1GYWxzZSAhPT0gZmFsc2UgJiYgdG9rZW4uaGlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLmhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5zaGFkb3dOb2RlLnBhcmVudE5vZGUucmVwbGFjZUNoaWxkKHRva2VuLm5vZGUsIHRva2VuLnNoYWRvd05vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhIHJldHVybiByZXN1bHQgY291bGQgYWxzbyBiZSBhIEhUTUxFbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcyA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicgPyB2YWwodG9rZW4ubm9kZSkgOiB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcyBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZURPTUVsZW1lbnQodG9rZW4sIHJlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlVGV4dCh0b2tlbiwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KHZhbCkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBUT0RPIGRlc2NyaXB0aW9uXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSBuZXcgd2hpc2tlciBpbnN0YW5jZSBhbmQgZG8gdGhlIFwibWFnaWNcIi5cbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2NvcGVOYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBleGVjKG5vZGUsIGRhdGEsIHNjb3BlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBjdXJyZW50U2NvcGUgPSBzY29wZU5hbWUgfHwgJ2l0ZW0nLFxuICAgICAgICAgICAgICAgICAgICBrZXlWYWx1ZWhvbGRlciA9IHt9O1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhKGZ1bmN0aW9uIChzY29wZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlbmRlclNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclNjb3BlID0gY3VycmVudFNjb3BlID0gc2NvcGUgfHwgY3VycmVudFNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gc2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIHVzZSB0aGUgc2NvcGUgZnJvbSB0aGUgaW5pdGlhbGlzYXRpb25cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJTY29wZSA9IGN1cnJlbnRTY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChrZXlWYWx1ZWhvbGRlci5oYXNPd25Qcm9wZXJ0eShyZW5kZXJTY29wZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVEYXRhKGtleVZhbHVlaG9sZGVyW3JlbmRlclNjb3BlXSwgcmVuZGVyU2NvcGUsIGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlWYWx1ZWhvbGRlcltyZW5kZXJTY29wZV0gPSBmaWxsRGF0YShub2RlLCByZW5kZXJTY29wZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpbGxEYXRhKG5vZGUsIGN1cnJlbnRTY29wZSwgZGF0YSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluUG9pbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIudG8gJiYgYXR0ci5iaW5kKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyLnRvID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlcGxhY2Ugd2luZG93IHdpdGggdGhpcyBhbmQgYWxzbyBvdGhlciBpbnN0YW5jZXMgY291bGQgdXNlIHRoZSBtYWdpYyBhcyBjbG9zdXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUG9pbnRlciA9IGdldEdsb2JhbENhbGwoYXR0ci50bywgd2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBvaW50ZXIgPSBhdHRyLnRvO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Qb2ludGVyID0gYXR0cjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWMobm9kZSwgaW5Qb2ludGVyLCBhdHRyLmJpbmQgfHwgJ2l0ZW0nKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgYXR0ciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluUG9pbnRlciA9IGdldEdsb2JhbENhbGwoYXR0ciwgd2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgaW5Qb2ludGVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXhlYyhub2RlLCBpblBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ3doaXNrZXI6YWRkIG5vbmUgYWNjZXB0YWJsZSBhdHRyaWJ1dGVzJywgYXR0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjKG5vZGUsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcblxuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVnZXgoKSB7XG4gICAgICAgIHZhciBvcGVuID0gZXNjYXBlUmVnZXgob3BlbkNoYXIpLFxuICAgICAgICAgICAgZW5kICA9IGVzY2FwZVJlZ2V4KGVuZENoYXIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgb3BlbiArIG9wZW4gKyAnPyguKz8pJyArIGVuZCArICc/JyArIGVuZCArIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHByb3BlcnR5IGZyb20gYSBnaXZlbiBzdHJpbmcgYW5kIG9iamVjdC5cbiAgICAgKiBSZXR1cm5zIHRoZSBmb3VuZGVkIHByb3BlcnR5IHBvaW50ZXIgb3IgdW5kZWZpbmVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvYmpcbiAgICAgKiBAcmV0dXJucyB7Kn0gb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0R2xvYmFsQ2FsbCAodmFsdWUsIG9iaikge1xuICAgICAgICB2YXIgc3BsaXQgPSB2YWx1ZS5zcGxpdCgnLicpLFxuICAgICAgICAgICAgcmVjID0gZnVuY3Rpb24gKGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChvYmpbY3VyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtjdXJdO1xuICAgICAgICAgICAgICAgICAgICByZWMoc3BsaXQuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09IHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgcmVjKHNwbGl0LnNoaWZ0KCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSB3aGlza2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbm55LmFkZCgnd2hpc2tlcicsIHdoaXNrZXIpO1xuICAgIH1cblxufSgpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxuXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xuICBpZiAoQXJyYXkuaXNBcnJheSkge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KGFyZyk7XG4gIH1cbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59XG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xuXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XG59XG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcblxuZnVuY3Rpb24gaXNOdWxsKGFyZykge1xuICByZXR1cm4gYXJnID09PSBudWxsO1xufVxuZXhwb3J0cy5pc051bGwgPSBpc051bGw7XG5cbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG5cbmZ1bmN0aW9uIGlzU3RyaW5nKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XG59XG5leHBvcnRzLmlzU3RyaW5nID0gaXNTdHJpbmc7XG5cbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCc7XG59XG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGlzUmVnRXhwKHJlKSB7XG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhyZSkgPT09ICdbb2JqZWN0IFJlZ0V4cF0nO1xufVxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcblxuZnVuY3Rpb24gaXNEYXRlKGQpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XG59XG5leHBvcnRzLmlzRGF0ZSA9IGlzRGF0ZTtcblxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XG4gIHJldHVybiAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcbn1cbmV4cG9ydHMuaXNFcnJvciA9IGlzRXJyb3I7XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcblxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3ltYm9sJyB8fCAgLy8gRVM2IHN5bWJvbFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XG59XG5leHBvcnRzLmlzUHJpbWl0aXZlID0gaXNQcmltaXRpdmU7XG5cbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XG5cbmZ1bmN0aW9uIG9iamVjdFRvU3RyaW5nKG8pIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcbn1cbiIsInZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG52YXIgc2NydWJiZXIgPSByZXF1aXJlKCcuL2xpYi9zY3J1YicpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2xpYi9rZXlzJyk7XG52YXIgZm9yRWFjaCA9IHJlcXVpcmUoJy4vbGliL2ZvcmVhY2gnKTtcbnZhciBpc0VudW1lcmFibGUgPSByZXF1aXJlKCcuL2xpYi9pc19lbnVtJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnMsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IFByb3RvKGNvbnMsIG9wdHMpO1xufTtcblxuKGZ1bmN0aW9uICgpIHsgLy8gYnJvd3NlcnMgYmxlaFxuICAgIGZvciAodmFyIGtleSBpbiBFdmVudEVtaXR0ZXIucHJvdG90eXBlKSB7XG4gICAgICAgIFByb3RvLnByb3RvdHlwZVtrZXldID0gRXZlbnRFbWl0dGVyLnByb3RvdHlwZVtrZXldO1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIFByb3RvIChjb25zLCBvcHRzKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIEV2ZW50RW1pdHRlci5jYWxsKHNlbGYpO1xuICAgIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAgIFxuICAgIHNlbGYucmVtb3RlID0ge307XG4gICAgc2VsZi5jYWxsYmFja3MgPSB7IGxvY2FsIDogW10sIHJlbW90ZSA6IFtdIH07XG4gICAgc2VsZi53cmFwID0gb3B0cy53cmFwO1xuICAgIHNlbGYudW53cmFwID0gb3B0cy51bndyYXA7XG4gICAgXG4gICAgc2VsZi5zY3J1YmJlciA9IHNjcnViYmVyKHNlbGYuY2FsbGJhY2tzLmxvY2FsKTtcbiAgICBcbiAgICBpZiAodHlwZW9mIGNvbnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgc2VsZi5pbnN0YW5jZSA9IG5ldyBjb25zKHNlbGYucmVtb3RlLCBzZWxmKTtcbiAgICB9XG4gICAgZWxzZSBzZWxmLmluc3RhbmNlID0gY29ucyB8fCB7fTtcbn1cblxuUHJvdG8ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMucmVxdWVzdCgnbWV0aG9kcycsIFsgdGhpcy5pbnN0YW5jZSBdKTtcbn07XG5cblByb3RvLnByb3RvdHlwZS5jdWxsID0gZnVuY3Rpb24gKGlkKSB7XG4gICAgZGVsZXRlIHRoaXMuY2FsbGJhY2tzLnJlbW90ZVtpZF07XG4gICAgdGhpcy5lbWl0KCdyZXF1ZXN0Jywge1xuICAgICAgICBtZXRob2QgOiAnY3VsbCcsXG4gICAgICAgIGFyZ3VtZW50cyA6IFsgaWQgXVxuICAgIH0pO1xufTtcblxuUHJvdG8ucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBhcmdzKSB7XG4gICAgdmFyIHNjcnViID0gdGhpcy5zY3J1YmJlci5zY3J1YihhcmdzKTtcbiAgICBcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB7XG4gICAgICAgIG1ldGhvZCA6IG1ldGhvZCxcbiAgICAgICAgYXJndW1lbnRzIDogc2NydWIuYXJndW1lbnRzLFxuICAgICAgICBjYWxsYmFja3MgOiBzY3J1Yi5jYWxsYmFja3MsXG4gICAgICAgIGxpbmtzIDogc2NydWIubGlua3NcbiAgICB9KTtcbn07XG5cblByb3RvLnByb3RvdHlwZS5oYW5kbGUgPSBmdW5jdGlvbiAocmVxKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gc2VsZi5zY3J1YmJlci51bnNjcnViKHJlcSwgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGlmIChzZWxmLmNhbGxiYWNrcy5yZW1vdGVbaWRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIGNyZWF0ZSBhIG5ldyBmdW5jdGlvbiBvbmx5IGlmIG9uZSBoYXNuJ3QgYWxyZWFkeSBiZWVuIGNyZWF0ZWRcbiAgICAgICAgICAgIC8vIGZvciBhIHBhcnRpY3VsYXIgaWRcbiAgICAgICAgICAgIHZhciBjYiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnJlcXVlc3QoaWQsIFtdLnNsaWNlLmFwcGx5KGFyZ3VtZW50cykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYuY2FsbGJhY2tzLnJlbW90ZVtpZF0gPSBzZWxmLndyYXAgPyBzZWxmLndyYXAoY2IsIGlkKSA6IGNiO1xuICAgICAgICAgICAgcmV0dXJuIGNiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzZWxmLnVud3JhcFxuICAgICAgICAgICAgPyBzZWxmLnVud3JhcChzZWxmLmNhbGxiYWNrcy5yZW1vdGVbaWRdLCBpZClcbiAgICAgICAgICAgIDogc2VsZi5jYWxsYmFja3MucmVtb3RlW2lkXVxuICAgICAgICA7XG4gICAgfSk7XG4gICAgXG4gICAgaWYgKHJlcS5tZXRob2QgPT09ICdtZXRob2RzJykge1xuICAgICAgICBzZWxmLmhhbmRsZU1ldGhvZHMoYXJnc1swXSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHJlcS5tZXRob2QgPT09ICdjdWxsJykge1xuICAgICAgICBmb3JFYWNoKGFyZ3MsIGZ1bmN0aW9uIChpZCkge1xuICAgICAgICAgICAgZGVsZXRlIHNlbGYuY2FsbGJhY2tzLmxvY2FsW2lkXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXEubWV0aG9kID09PSAnc3RyaW5nJykge1xuICAgICAgICBpZiAoaXNFbnVtZXJhYmxlKHNlbGYuaW5zdGFuY2UsIHJlcS5tZXRob2QpKSB7XG4gICAgICAgICAgICBzZWxmLmFwcGx5KHNlbGYuaW5zdGFuY2VbcmVxLm1ldGhvZF0sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdmYWlsJywgbmV3IEVycm9yKFxuICAgICAgICAgICAgICAgICdyZXF1ZXN0IGZvciBub24tZW51bWVyYWJsZSBtZXRob2Q6ICcgKyByZXEubWV0aG9kXG4gICAgICAgICAgICApKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgcmVxLm1ldGhvZCA9PSAnbnVtYmVyJykge1xuICAgICAgICB2YXIgZm4gPSBzZWxmLmNhbGxiYWNrcy5sb2NhbFtyZXEubWV0aG9kXTtcbiAgICAgICAgaWYgKCFmbikge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdmYWlsJywgbmV3IEVycm9yKCdubyBzdWNoIG1ldGhvZCcpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHNlbGYuYXBwbHkoZm4sIGFyZ3MpO1xuICAgIH1cbn07XG5cblByb3RvLnByb3RvdHlwZS5oYW5kbGVNZXRob2RzID0gZnVuY3Rpb24gKG1ldGhvZHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBtZXRob2RzICE9ICdvYmplY3QnKSB7XG4gICAgICAgIG1ldGhvZHMgPSB7fTtcbiAgICB9XG4gICAgXG4gICAgLy8gY29weSBzaW5jZSBhc3NpZ25tZW50IGRpc2NhcmRzIHRoZSBwcmV2aW91cyByZWZzXG4gICAgZm9yRWFjaChvYmplY3RLZXlzKHNlbGYucmVtb3RlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBkZWxldGUgc2VsZi5yZW1vdGVba2V5XTtcbiAgICB9KTtcbiAgICBcbiAgICBmb3JFYWNoKG9iamVjdEtleXMobWV0aG9kcyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgc2VsZi5yZW1vdGVba2V5XSA9IG1ldGhvZHNba2V5XTtcbiAgICB9KTtcbiAgICBcbiAgICBzZWxmLmVtaXQoJ3JlbW90ZScsIHNlbGYucmVtb3RlKTtcbiAgICBzZWxmLmVtaXQoJ3JlYWR5Jyk7XG59O1xuXG5Qcm90by5wcm90b3R5cGUuYXBwbHkgPSBmdW5jdGlvbiAoZiwgYXJncykge1xuICAgIHRyeSB7IGYuYXBwbHkodW5kZWZpbmVkLCBhcmdzKSB9XG4gICAgY2F0Y2ggKGVycikgeyB0aGlzLmVtaXQoJ2Vycm9yJywgZXJyKSB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmb3JFYWNoICh4cywgZikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmKVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZi5jYWxsKHhzLCB4c1tpXSwgaSk7XG4gICAgfVxufVxuIiwidmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZSkge1xuICAgICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iaiwga2V5KTtcbiAgICB9XG4gICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKG9iaik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChrZXkgPT09IGtleXNbaV0pIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICByZXR1cm4ga2V5cztcbn07XG4iLCJ2YXIgdHJhdmVyc2UgPSByZXF1aXJlKCd0cmF2ZXJzZScpO1xudmFyIG9iamVjdEtleXMgPSByZXF1aXJlKCcuL2tleXMnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi9mb3JlYWNoJyk7XG5cbmZ1bmN0aW9uIGluZGV4T2YgKHhzLCB4KSB7XG4gICAgaWYgKHhzLmluZGV4T2YpIHJldHVybiB4cy5pbmRleE9mKHgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBzY3J1YiBjYWxsYmFja3Mgb3V0IG9mIHJlcXVlc3RzIGluIG9yZGVyIHRvIGNhbGwgdGhlbSBhZ2FpbiBsYXRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY2FsbGJhY2tzKSB7XG4gICAgcmV0dXJuIG5ldyBTY3J1YmJlcihjYWxsYmFja3MpO1xufTtcblxuZnVuY3Rpb24gU2NydWJiZXIgKGNhbGxiYWNrcykge1xuICAgIHRoaXMuY2FsbGJhY2tzID0gY2FsbGJhY2tzO1xufVxuXG4vLyBUYWtlIHRoZSBmdW5jdGlvbnMgb3V0IGFuZCBub3RlIHRoZW0gZm9yIGZ1dHVyZSB1c2VcblNjcnViYmVyLnByb3RvdHlwZS5zY3J1YiA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHBhdGhzID0ge307XG4gICAgdmFyIGxpbmtzID0gW107XG4gICAgXG4gICAgdmFyIGFyZ3MgPSB0cmF2ZXJzZShvYmopLm1hcChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBpID0gaW5kZXhPZihzZWxmLmNhbGxiYWNrcywgbm9kZSk7XG4gICAgICAgICAgICBpZiAoaSA+PSAwICYmICEoaSBpbiBwYXRocykpIHtcbiAgICAgICAgICAgICAgICAvLyBLZWVwIHByZXZpb3VzIGZ1bmN0aW9uIElEcyBvbmx5IGZvciB0aGUgZmlyc3QgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBmb3VuZC4gVGhpcyBpcyBzb21ld2hhdCBzdWJvcHRpbWFsIGJ1dCB0aGUgYWx0ZXJuYXRpdmVzXG4gICAgICAgICAgICAgICAgLy8gYXJlIHdvcnNlLlxuICAgICAgICAgICAgICAgIHBhdGhzW2ldID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGlkID0gc2VsZi5jYWxsYmFja3MubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHNlbGYuY2FsbGJhY2tzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgcGF0aHNbaWRdID0gdGhpcy5wYXRoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZSgnW0Z1bmN0aW9uXScpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2lyY3VsYXIpIHtcbiAgICAgICAgICAgIGxpbmtzLnB1c2goeyBmcm9tIDogdGhpcy5jaXJjdWxhci5wYXRoLCB0byA6IHRoaXMucGF0aCB9KTtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCdbQ2lyY3VsYXJdJyk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4ge1xuICAgICAgICBhcmd1bWVudHMgOiBhcmdzLFxuICAgICAgICBjYWxsYmFja3MgOiBwYXRocyxcbiAgICAgICAgbGlua3MgOiBsaW5rc1xuICAgIH07XG59O1xuIFxuLy8gUmVwbGFjZSBjYWxsYmFja3MuIFRoZSBzdXBwbGllZCBmdW5jdGlvbiBzaG91bGQgdGFrZSBhIGNhbGxiYWNrIGlkIGFuZFxuLy8gcmV0dXJuIGEgY2FsbGJhY2sgb2YgaXRzIG93bi5cblNjcnViYmVyLnByb3RvdHlwZS51bnNjcnViID0gZnVuY3Rpb24gKG1zZywgZikge1xuICAgIHZhciBhcmdzID0gbXNnLmFyZ3VtZW50cyB8fCBbXTtcbiAgICBmb3JFYWNoKG9iamVjdEtleXMobXNnLmNhbGxiYWNrcyB8fCB7fSksIGZ1bmN0aW9uIChzaWQpIHtcbiAgICAgICAgdmFyIGlkID0gcGFyc2VJbnQoc2lkLCAxMCk7XG4gICAgICAgIHZhciBwYXRoID0gbXNnLmNhbGxiYWNrc1tpZF07XG4gICAgICAgIHRyYXZlcnNlLnNldChhcmdzLCBwYXRoLCBmKGlkKSk7XG4gICAgfSk7XG4gICAgXG4gICAgZm9yRWFjaChtc2cubGlua3MgfHwgW10sIGZ1bmN0aW9uIChsaW5rKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRyYXZlcnNlLmdldChhcmdzLCBsaW5rLmZyb20pO1xuICAgICAgICB0cmF2ZXJzZS5zZXQoYXJncywgbGluay50bywgdmFsdWUpO1xuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiBhcmdzO1xufTtcbiIsInZhciBkbm9kZSA9IHJlcXVpcmUoJy4vbGliL2Rub2RlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNvbnMsIG9wdHMpIHtcbiAgICByZXR1cm4gbmV3IGRub2RlKGNvbnMsIG9wdHMpO1xufTtcbiIsInZhciBwcm90b2NvbCA9IHJlcXVpcmUoJ2Rub2RlLXByb3RvY29sJyk7XG52YXIgU3RyZWFtID0gcmVxdWlyZSgnc3RyZWFtJyk7XG52YXIganNvbiA9IHR5cGVvZiBKU09OID09PSAnb2JqZWN0JyA/IEpTT04gOiByZXF1aXJlKCdqc29uaWZ5Jyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZG5vZGU7XG5kbm9kZS5wcm90b3R5cGUgPSB7fTtcbihmdW5jdGlvbiAoKSB7IC8vIGJyb3dzZXJzIGV0Y1xuICAgIGZvciAodmFyIGtleSBpbiBTdHJlYW0ucHJvdG90eXBlKSB7XG4gICAgICAgIGRub2RlLnByb3RvdHlwZVtrZXldID0gU3RyZWFtLnByb3RvdHlwZVtrZXldO1xuICAgIH1cbn0pKCk7XG5cbmZ1bmN0aW9uIGRub2RlIChjb25zLCBvcHRzKSB7XG4gICAgU3RyZWFtLmNhbGwodGhpcyk7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIFxuICAgIHNlbGYub3B0cyA9IG9wdHMgfHwge307XG4gICAgXG4gICAgc2VsZi5jb25zID0gdHlwZW9mIGNvbnMgPT09ICdmdW5jdGlvbidcbiAgICAgICAgPyBjb25zXG4gICAgICAgIDogZnVuY3Rpb24gKCkgeyByZXR1cm4gY29ucyB8fCB7fSB9XG4gICAgO1xuICAgIFxuICAgIHNlbGYucmVhZGFibGUgPSB0cnVlO1xuICAgIHNlbGYud3JpdGFibGUgPSB0cnVlO1xuICAgIFxuICAgIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoc2VsZi5fZW5kZWQpIHJldHVybjtcbiAgICAgICAgc2VsZi5wcm90byA9IHNlbGYuX2NyZWF0ZVByb3RvKCk7XG4gICAgICAgIHNlbGYucHJvdG8uc3RhcnQoKTtcbiAgICAgICAgXG4gICAgICAgIGlmICghc2VsZi5faGFuZGxlUXVldWUpIHJldHVybjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWxmLl9oYW5kbGVRdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc2VsZi5oYW5kbGUoc2VsZi5faGFuZGxlUXVldWVbaV0pO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmRub2RlLnByb3RvdHlwZS5fY3JlYXRlUHJvdG8gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBwcm90byA9IHByb3RvY29sKGZ1bmN0aW9uIChyZW1vdGUpIHtcbiAgICAgICAgaWYgKHNlbGYuX2VuZGVkKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICB2YXIgcmVmID0gc2VsZi5jb25zLmNhbGwodGhpcywgcmVtb3RlLCBzZWxmKTtcbiAgICAgICAgaWYgKHR5cGVvZiByZWYgIT09ICdvYmplY3QnKSByZWYgPSB0aGlzO1xuICAgICAgICBcbiAgICAgICAgc2VsZi5lbWl0KCdsb2NhbCcsIHJlZiwgc2VsZik7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gcmVmO1xuICAgIH0sIHNlbGYub3B0cy5wcm90byk7XG4gICAgXG4gICAgcHJvdG8ub24oJ3JlbW90ZScsIGZ1bmN0aW9uIChyZW1vdGUpIHtcbiAgICAgICAgc2VsZi5lbWl0KCdyZW1vdGUnLCByZW1vdGUsIHNlbGYpO1xuICAgICAgICBzZWxmLmVtaXQoJ3JlYWR5Jyk7IC8vIGJhY2t3YXJkcyBjb21wYXRhYmlsaXR5LCBkZXByZWNhdGVkXG4gICAgfSk7XG4gICAgXG4gICAgcHJvdG8ub24oJ3JlcXVlc3QnLCBmdW5jdGlvbiAocmVxKSB7XG4gICAgICAgIGlmICghc2VsZi5yZWFkYWJsZSkgcmV0dXJuO1xuICAgICAgICBcbiAgICAgICAgaWYgKHNlbGYub3B0cy5lbWl0ID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgc2VsZi5lbWl0KCdkYXRhJywgcmVxKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHNlbGYuZW1pdCgnZGF0YScsIGpzb24uc3RyaW5naWZ5KHJlcSkgKyAnXFxuJyk7XG4gICAgfSk7XG4gICAgXG4gICAgcHJvdG8ub24oJ2ZhaWwnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIGVycm9ycyB0aGF0IHRoZSByZW1vdGUgZW5kIHdhcyByZXNwb25zaWJsZSBmb3JcbiAgICAgICAgc2VsZi5lbWl0KCdmYWlsJywgZXJyKTtcbiAgICB9KTtcbiAgICBcbiAgICBwcm90by5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIC8vIGVycm9ycyB0aGF0IHRoZSBsb2NhbCBjb2RlIHdhcyByZXNwb25zaWJsZSBmb3JcbiAgICAgICAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIHByb3RvO1xufTtcblxuZG5vZGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICAgIGlmICh0aGlzLl9lbmRlZCkgcmV0dXJuO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcm93O1xuICAgIFxuICAgIGlmIChidWYgJiYgdHlwZW9mIGJ1ZiA9PT0gJ29iamVjdCdcbiAgICAmJiBidWYuY29uc3RydWN0b3IgJiYgYnVmLmNvbnN0cnVjdG9yLm5hbWUgPT09ICdCdWZmZXInXG4gICAgJiYgYnVmLmxlbmd0aFxuICAgICYmIHR5cGVvZiBidWYuc2xpY2UgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gdHJlYXQgbGlrZSBhIGJ1ZmZlclxuICAgICAgICBpZiAoIXNlbGYuX2J1ZnMpIHNlbGYuX2J1ZnMgPSBbXTtcbiAgICAgICAgXG4gICAgICAgIC8vIHRyZWF0IGxpa2UgYSBidWZmZXJcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGogPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYnVmW2ldID09PSAweDBhKSB7XG4gICAgICAgICAgICAgICAgc2VsZi5fYnVmcy5wdXNoKGJ1Zi5zbGljZShqLCBpKSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGxpbmUgPSAnJztcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHNlbGYuX2J1ZnMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgbGluZSArPSBTdHJpbmcoc2VsZi5fYnVmc1trXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHRyeSB7IHJvdyA9IGpzb24ucGFyc2UobGluZSkgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIpIHsgcmV0dXJuIHNlbGYuZW5kKCkgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGogPSBpICsgMTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzZWxmLmhhbmRsZShyb3cpO1xuICAgICAgICAgICAgICAgIHNlbGYuX2J1ZnMgPSBbXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKGogPCBidWYubGVuZ3RoKSBzZWxmLl9idWZzLnB1c2goYnVmLnNsaWNlKGosIGJ1Zi5sZW5ndGgpKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnVmICYmIHR5cGVvZiBidWYgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIC8vIC5pc0J1ZmZlcigpIHdpdGhvdXQgdGhlIEJ1ZmZlclxuICAgICAgICAvLyBVc2Ugc2VsZiB0byBwaXBlIEpTT05TdHJlYW0ucGFyc2UoKSBzdHJlYW1zLlxuICAgICAgICBzZWxmLmhhbmRsZShidWYpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgaWYgKHR5cGVvZiBidWYgIT09ICdzdHJpbmcnKSBidWYgPSBTdHJpbmcoYnVmKTtcbiAgICAgICAgaWYgKCFzZWxmLl9saW5lKSBzZWxmLl9saW5lID0gJyc7XG4gICAgICAgIFxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1Zi5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGJ1Zi5jaGFyQ29kZUF0KGkpID09PSAweDBhKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHsgcm93ID0ganNvbi5wYXJzZShzZWxmLl9saW5lKSB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikgeyByZXR1cm4gc2VsZi5lbmQoKSB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc2VsZi5fbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlKHJvdyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHNlbGYuX2xpbmUgKz0gYnVmLmNoYXJBdChpKVxuICAgICAgICB9XG4gICAgfVxufTtcblxuZG5vZGUucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyb3cpIHtcbiAgICBpZiAoIXRoaXMucHJvdG8pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9oYW5kbGVRdWV1ZSkgdGhpcy5faGFuZGxlUXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5faGFuZGxlUXVldWUucHVzaChyb3cpO1xuICAgIH1cbiAgICBlbHNlIHRoaXMucHJvdG8uaGFuZGxlKHJvdyk7XG59O1xuXG5kbm9kZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9lbmRlZCkgcmV0dXJuO1xuICAgIHRoaXMuX2VuZGVkID0gdHJ1ZTtcbiAgICB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgnZW5kJyk7XG59O1xuXG5kbm9kZS5wcm90b3R5cGUuZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuZCgpO1xufTtcbiIsIi8qZ2xvYmFsIEhUTUxFbGVtZW50ICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlICovXG5cbnZhciBkb21PcHRzID0ge307XG5cbmRvbU9wdHMucGFyYW1zID0gKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcGFyYW1zID0ge30sIGksIG52LCBwYXJ0cztcbiAgICBpZiAobG9jYXRpb24uc2VhcmNoKSB7XG4gICAgICAgIHBhcnRzID0gbG9jYXRpb24uc2VhcmNoLnN1YnN0cmluZygxKS5zcGxpdCgnJicpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIG52ID0gcGFydHNbaV0uc3BsaXQoJz0nKTtcbiAgICAgICAgICAgIGlmIChudlswXSkge1xuICAgICAgICAgICAgICAgIHBhcmFtc1tudlswXV0gPSBudlsxXSB8fCB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59KCkpO1xuXG5kb21PcHRzLmNyZWF0ZUVsZW1lbnQgPSBmdW5jdGlvbiAodGFnLCBpZCwgY2xhc3Nlcykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBuZXdOb2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICAgIGlmIChpZCkge25ld05vZGUuc2V0QXR0cmlidXRlKCdpZCcsIGlkKTsgfVxuICAgIGlmIChjbGFzc2VzKSB7bmV3Tm9kZS5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY2xhc3Nlcyk7IH1cbiAgICByZXR1cm4gbmV3Tm9kZTtcbn07XG5tb2R1bGUuZXhwb3J0cyA9ICBkb21PcHRzO1xuXG4vLyBkb20gb3BlcmF0aW9uczpcbkhUTUxFbGVtZW50LnByb3RvdHlwZS5kb21BZGRDbGFzcyA9IGZ1bmN0aW9uIChhZGRDbGFzc2VzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIGF0dHJDbGFzcyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjbGFzcycpLFxuICAgICAgICBhZGRDbGFzc2VzTGlzdCA9IGFkZENsYXNzZXMuc3BsaXQoJyAnKSwgbmV3Q2xhc3NlcyA9IFtdLCBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhZGRDbGFzc2VzTGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoIXRoaXMuZG9tSGFzQ2xhc3MoYWRkQ2xhc3Nlc0xpc3RbaV0pKSB7XG4gICAgICAgICAgICBuZXdDbGFzc2VzLnB1c2goYWRkQ2xhc3Nlc0xpc3RbaV0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoaXMuc2V0QXR0cmlidXRlKCdjbGFzcycsIGF0dHJDbGFzcyAhPT0gbnVsbCA/IGF0dHJDbGFzcyArICcgJyArIG5ld0NsYXNzZXMuam9pbignICcpIDogbmV3Q2xhc3Nlcy5qb2luKCcgJykpO1xuICAgIHJldHVybiB0aGlzO1xufTtcbi8vIFRPRE8gcmVtb3ZlIGFsbCBjbGFzc2VzIHdpdGggc2FtZSBuYW1lXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZG9tUmVtb3ZlQ2xhc3MgPSBmdW5jdGlvbiAocmVtb3ZlYWJsZUNsYXNzZXMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgcmVtb3ZlQ2xhc3NlcyA9IChyZW1vdmVhYmxlQ2xhc3NlcyAmJiByZW1vdmVhYmxlQ2xhc3Nlcy5zcGxpdCgnICcpKSB8fCB0aGlzLmdldEF0dHJpYnV0ZSgnY2xhc3MnKS5zcGxpdCgnICcpLFxuICAgICAgICBhdHRyQ2xhc3MgPSB0aGlzLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSxcbiAgICAgICAgY3VycmVudENsYXNzZXMsXG4gICAgICAgIGksXG4gICAgICAgIGlkeDtcbiAgICBpZiAoYXR0ckNsYXNzICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRDbGFzc2VzID0gYXR0ckNsYXNzLnNwbGl0KCcgJyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByZW1vdmVDbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZHggPSBjdXJyZW50Q2xhc3Nlcy5pbmRleE9mKHJlbW92ZUNsYXNzZXNbaV0pO1xuICAgICAgICAgICAgaWYgKGlkeCA+PSAwKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudENsYXNzZXMgPSBjdXJyZW50Q2xhc3Nlcy5zbGljZSgwLCBpZHgpLmNvbmNhdChjdXJyZW50Q2xhc3Nlcy5zbGljZShpZHggKyAxLCBjdXJyZW50Q2xhc3Nlcy5sZW5ndGggLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgY3VycmVudENsYXNzZXMuam9pbignICcpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBkb20gb3BlcmF0aW9uczpcbkhUTUxFbGVtZW50LnByb3RvdHlwZS5kb21IYXNDbGFzcyA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgY2xhc3NlcyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjbGFzcycpLCBjdXJyZW50Q2xhc3NlcywgaTtcbiAgICBpZiAoY2xhc3NlcyAhPT0gbnVsbCkge1xuICAgICAgICBjdXJyZW50Q2xhc3NlcyA9IGNsYXNzZXMuc3BsaXQoJyAnKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGN1cnJlbnRDbGFzc2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudENsYXNzZXNbaV0gPT09IGNsYXNzTmFtZSkge3JldHVybiB0cnVlOyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufTtcblxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRvbVJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB0aGlzLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQodGhpcyk7XG59O1xuLyoqXG4gKiByZW1vdmUgYWxsIGNoaWxkIGVsZW1lbnRzIGZyb20gbm9kZVxuICovXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZG9tRW1wdHkgPSBmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgY2hpbGQuZG9tUmVtb3ZlKHRoaXMpO1xuICAgIH0pO1xufTtcblxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRvbUFwcGVuZFRvID0gZnVuY3Rpb24gKGVsZW0pIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgbm9kZSA9IGVsZW07XG4gICAgaWYgKHR5cGVvZiBub2RlID09PSAnc3RyaW5nJykge1xuICAgICAgICBub2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQobm9kZSk7XG4gICAgfVxuICAgIG5vZGUuYXBwZW5kQ2hpbGQodGhpcyk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZG9tQXBwZW5kQ2hpbGQgPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBub2RlID0gZWxlbTtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlKTtcbiAgICB9XG4gICAgdGhpcy5hcHBlbmRDaGlsZChub2RlKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5kb21DaGlsZFRhZ3MgPSBmdW5jdGlvbiAodGFnKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIHRhZ3MgPSBbXTtcbiAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIGlmIChlLnRhZ05hbWUudG9Mb3dlckNhc2UoKSA9PT0gdGFnLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgICAgIHRhZ3MucHVzaChlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiB0YWdzO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICB0aGlzLl9ldmVudHMgPSB0aGlzLl9ldmVudHMgfHwge307XG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbi8vIE9idmlvdXNseSBub3QgYWxsIEVtaXR0ZXJzIHNob3VsZCBiZSBsaW1pdGVkIHRvIDEwLiBUaGlzIGZ1bmN0aW9uIGFsbG93c1xuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnNldE1heExpc3RlbmVycyA9IGZ1bmN0aW9uKG4pIHtcbiAgaWYgKCFpc051bWJlcihuKSB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xuICB0aGlzLl9tYXhMaXN0ZW5lcnMgPSBuO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBJZiB0aGVyZSBpcyBubyAnZXJyb3InIGV2ZW50IGxpc3RlbmVyIHRoZW4gdGhyb3cuXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XG4gICAgaWYgKCF0aGlzLl9ldmVudHMuZXJyb3IgfHxcbiAgICAgICAgKGlzT2JqZWN0KHRoaXMuX2V2ZW50cy5lcnJvcikgJiYgIXRoaXMuX2V2ZW50cy5lcnJvci5sZW5ndGgpKSB7XG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICAgIGlmIChlciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgJ2Vycm9yJyBldmVudFxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQXQgbGVhc3QgZ2l2ZSBzb21lIGtpbmQgb2YgY29udGV4dCB0byB0aGUgdXNlclxuICAgICAgICB2YXIgZXJyID0gbmV3IEVycm9yKCdVbmNhdWdodCwgdW5zcGVjaWZpZWQgXCJlcnJvclwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcbiAgICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxuICAgIHJldHVybiBmYWxzZTtcblxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xuICAgIHN3aXRjaCAoYXJndW1lbnRzLmxlbmd0aCkge1xuICAgICAgLy8gZmFzdCBjYXNlc1xuICAgICAgY2FzZSAxOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyOlxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgICBkZWZhdWx0OlxuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNPYmplY3QoaGFuZGxlcikpIHtcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBsaXN0ZW5lcnMgPSBoYW5kbGVyLnNsaWNlKCk7XG4gICAgbGVuID0gbGlzdGVuZXJzLmxlbmd0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgICBsaXN0ZW5lcnNbaV0uYXBwbHkodGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICB2YXIgbTtcblxuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgdGhpcy5fZXZlbnRzID0ge307XG5cbiAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXCJuZXdMaXN0ZW5lclwiLlxuICBpZiAodGhpcy5fZXZlbnRzLm5ld0xpc3RlbmVyKVxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxuICAgICAgICAgICAgICBpc0Z1bmN0aW9uKGxpc3RlbmVyLmxpc3RlbmVyKSA/XG4gICAgICAgICAgICAgIGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIC8vIE9wdGltaXplIHRoZSBjYXNlIG9mIG9uZSBsaXN0ZW5lci4gRG9uJ3QgbmVlZCB0aGUgZXh0cmEgYXJyYXkgb2JqZWN0LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xuICBlbHNlIGlmIChpc09iamVjdCh0aGlzLl9ldmVudHNbdHlwZV0pKVxuICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gIGVsc2VcbiAgICAvLyBBZGRpbmcgdGhlIHNlY29uZCBlbGVtZW50LCBuZWVkIHRvIGNoYW5nZSB0byBhcnJheS5cbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XG5cbiAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcbiAgICBpZiAoIWlzVW5kZWZpbmVkKHRoaXMuX21heExpc3RlbmVycykpIHtcbiAgICAgIG0gPSB0aGlzLl9tYXhMaXN0ZW5lcnM7XG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSBFdmVudEVtaXR0ZXIuZGVmYXVsdE1heExpc3RlbmVycztcbiAgICB9XG5cbiAgICBpZiAobSAmJiBtID4gMCAmJiB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoID4gbSkge1xuICAgICAgdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCA9IHRydWU7XG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcbiAgICAgICAgICAgICAgICAgICAgJ2xlYWsgZGV0ZWN0ZWQuICVkIGxpc3RlbmVycyBhZGRlZC4gJyArXG4gICAgICAgICAgICAgICAgICAgICdVc2UgZW1pdHRlci5zZXRNYXhMaXN0ZW5lcnMoKSB0byBpbmNyZWFzZSBsaW1pdC4nLFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcbiAgICAgIGlmICh0eXBlb2YgY29uc29sZS50cmFjZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBub3Qgc3VwcG9ydGVkIGluIElFIDEwXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbih0eXBlLCBsaXN0ZW5lcikge1xuICBpZiAoIWlzRnVuY3Rpb24obGlzdGVuZXIpKVxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgdmFyIGZpcmVkID0gZmFsc2U7XG5cbiAgZnVuY3Rpb24gZygpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGcpO1xuXG4gICAgaWYgKCFmaXJlZCkge1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cblxuICBnLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHRoaXMub24odHlwZSwgZyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBlbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWZmIHRoZSBsaXN0ZW5lciB3YXMgcmVtb3ZlZFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIGxpc3QgPSB0aGlzLl9ldmVudHNbdHlwZV07XG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xuICBwb3NpdGlvbiA9IC0xO1xuXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxuICAgICAgKGlzRnVuY3Rpb24obGlzdC5saXN0ZW5lcikgJiYgbGlzdC5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcblxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XG4gICAgZm9yIChpID0gbGVuZ3RoOyBpLS0gPiAwOykge1xuICAgICAgaWYgKGxpc3RbaV0gPT09IGxpc3RlbmVyIHx8XG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XG4gICAgICAgIHBvc2l0aW9uID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgIHJldHVybiB0aGlzO1xuXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XG4gICAgICBsaXN0Lmxlbmd0aCA9IDA7XG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsaXN0LnNwbGljZShwb3NpdGlvbiwgMSk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XG4gIH1cblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucmVtb3ZlQWxsTGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIga2V5LCBsaXN0ZW5lcnM7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHMpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKVxuICAgICAgdGhpcy5fZXZlbnRzID0ge307XG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgICAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgIGZvciAoa2V5IGluIHRoaXMuX2V2ZW50cykge1xuICAgICAgaWYgKGtleSA9PT0gJ3JlbW92ZUxpc3RlbmVyJykgY29udGludWU7XG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgIH1cbiAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycygncmVtb3ZlTGlzdGVuZXInKTtcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGxpc3RlbmVycyA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XG4gICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICB9IGVsc2UgaWYgKGxpc3RlbmVycykge1xuICAgIC8vIExJRk8gb3JkZXJcbiAgICB3aGlsZSAobGlzdGVuZXJzLmxlbmd0aClcbiAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzW2xpc3RlbmVycy5sZW5ndGggLSAxXSk7XG4gIH1cbiAgZGVsZXRlIHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgcmV0O1xuICBpZiAoIXRoaXMuX2V2ZW50cyB8fCAhdGhpcy5fZXZlbnRzW3R5cGVdKVxuICAgIHJldCA9IFtdO1xuICBlbHNlIGlmIChpc0Z1bmN0aW9uKHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgcmV0ID0gW3RoaXMuX2V2ZW50c1t0eXBlXV07XG4gIGVsc2VcbiAgICByZXQgPSB0aGlzLl9ldmVudHNbdHlwZV0uc2xpY2UoKTtcbiAgcmV0dXJuIHJldDtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKHR5cGUpIHtcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xuICAgIHZhciBldmxpc3RlbmVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXG4gICAgICByZXR1cm4gMTtcbiAgICBlbHNlIGlmIChldmxpc3RlbmVyKVxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICB9XG4gIHJldHVybiAwO1xufTtcblxuRXZlbnRFbWl0dGVyLmxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbihlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XG59O1xuXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcbn1cblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cblxuZnVuY3Rpb24gaXNPYmplY3QoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG59XG5cbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XG59XG4iLCJleHBvcnRzLnJlYWQgPSBmdW5jdGlvbiAoYnVmZmVyLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbVxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIG5CaXRzID0gLTdcbiAgdmFyIGkgPSBpc0xFID8gKG5CeXRlcyAtIDEpIDogMFxuICB2YXIgZCA9IGlzTEUgPyAtMSA6IDFcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cblxuICBpICs9IGRcblxuICBlID0gcyAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBzID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBlTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IGUgPSBlICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcbiAgZSA+Pj0gKC1uQml0cylcbiAgbkJpdHMgKz0gbUxlblxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxuXG4gIGlmIChlID09PSAwKSB7XG4gICAgZSA9IDEgLSBlQmlhc1xuICB9IGVsc2UgaWYgKGUgPT09IGVNYXgpIHtcbiAgICByZXR1cm4gbSA/IE5hTiA6ICgocyA/IC0xIDogMSkgKiBJbmZpbml0eSlcbiAgfSBlbHNlIHtcbiAgICBtID0gbSArIE1hdGgucG93KDIsIG1MZW4pXG4gICAgZSA9IGUgLSBlQmlhc1xuICB9XG4gIHJldHVybiAocyA/IC0xIDogMSkgKiBtICogTWF0aC5wb3coMiwgZSAtIG1MZW4pXG59XG5cbmV4cG9ydHMud3JpdGUgPSBmdW5jdGlvbiAoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcbiAgdmFyIGUsIG0sIGNcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcbiAgdmFyIGVCaWFzID0gZU1heCA+PiAxXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcbiAgdmFyIGkgPSBpc0xFID8gMCA6IChuQnl0ZXMgLSAxKVxuICB2YXIgZCA9IGlzTEUgPyAxIDogLTFcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcblxuICB2YWx1ZSA9IE1hdGguYWJzKHZhbHVlKVxuXG4gIGlmIChpc05hTih2YWx1ZSkgfHwgdmFsdWUgPT09IEluZmluaXR5KSB7XG4gICAgbSA9IGlzTmFOKHZhbHVlKSA/IDEgOiAwXG4gICAgZSA9IGVNYXhcbiAgfSBlbHNlIHtcbiAgICBlID0gTWF0aC5mbG9vcihNYXRoLmxvZyh2YWx1ZSkgLyBNYXRoLkxOMilcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XG4gICAgICBlLS1cbiAgICAgIGMgKj0gMlxuICAgIH1cbiAgICBpZiAoZSArIGVCaWFzID49IDEpIHtcbiAgICAgIHZhbHVlICs9IHJ0IC8gY1xuICAgIH0gZWxzZSB7XG4gICAgICB2YWx1ZSArPSBydCAqIE1hdGgucG93KDIsIDEgLSBlQmlhcylcbiAgICB9XG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XG4gICAgICBlKytcbiAgICAgIGMgLz0gMlxuICAgIH1cblxuICAgIGlmIChlICsgZUJpYXMgPj0gZU1heCkge1xuICAgICAgbSA9IDBcbiAgICAgIGUgPSBlTWF4XG4gICAgfSBlbHNlIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gZSArIGVCaWFzXG4gICAgfSBlbHNlIHtcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxuICAgICAgZSA9IDBcbiAgICB9XG4gIH1cblxuICBmb3IgKDsgbUxlbiA+PSA4OyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBtICYgMHhmZiwgaSArPSBkLCBtIC89IDI1NiwgbUxlbiAtPSA4KSB7fVxuXG4gIGUgPSAoZSA8PCBtTGVuKSB8IG1cbiAgZUxlbiArPSBtTGVuXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cblxuICBidWZmZXJbb2Zmc2V0ICsgaSAtIGRdIHw9IHMgKiAxMjhcbn1cbiIsImlmICh0eXBlb2YgT2JqZWN0LmNyZWF0ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcbiAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgIHZhbHVlOiBjdG9yLFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pO1xuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgIHZhciBUZW1wQ3RvciA9IGZ1bmN0aW9uICgpIHt9XG4gICAgVGVtcEN0b3IucHJvdG90eXBlID0gc3VwZXJDdG9yLnByb3RvdHlwZVxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICBjdG9yLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGN0b3JcbiAgfVxufVxuIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XG4gKiBAbGljZW5zZSAgTUlUXG4gKi9cblxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xuLy8gT2JqZWN0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvci4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseVxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXG59XG5cbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcbiAgcmV0dXJuICEhb2JqLmNvbnN0cnVjdG9yICYmIHR5cGVvZiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyKG9iailcbn1cblxuLy8gRm9yIE5vZGUgdjAuMTAgc3VwcG9ydC4gUmVtb3ZlIHRoaXMgZXZlbnR1YWxseS5cbmZ1bmN0aW9uIGlzU2xvd0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxufVxuIiwiZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlJyk7XG5leHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vbGliL3N0cmluZ2lmeScpO1xuIiwidmFyIGF0LCAvLyBUaGUgaW5kZXggb2YgdGhlIGN1cnJlbnQgY2hhcmFjdGVyXG4gICAgY2gsIC8vIFRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGVzY2FwZWUgPSB7XG4gICAgICAgICdcIic6ICAnXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICAgICAgJy8nOiAgJy8nLFxuICAgICAgICBiOiAgICAnXFxiJyxcbiAgICAgICAgZjogICAgJ1xcZicsXG4gICAgICAgIG46ICAgICdcXG4nLFxuICAgICAgICByOiAgICAnXFxyJyxcbiAgICAgICAgdDogICAgJ1xcdCdcbiAgICB9LFxuICAgIHRleHQsXG5cbiAgICBlcnJvciA9IGZ1bmN0aW9uIChtKSB7XG4gICAgICAgIC8vIENhbGwgZXJyb3Igd2hlbiBzb21ldGhpbmcgaXMgd3JvbmcuXG4gICAgICAgIHRocm93IHtcbiAgICAgICAgICAgIG5hbWU6ICAgICdTeW50YXhFcnJvcicsXG4gICAgICAgICAgICBtZXNzYWdlOiBtLFxuICAgICAgICAgICAgYXQ6ICAgICAgYXQsXG4gICAgICAgICAgICB0ZXh0OiAgICB0ZXh0XG4gICAgICAgIH07XG4gICAgfSxcbiAgICBcbiAgICBuZXh0ID0gZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgLy8gSWYgYSBjIHBhcmFtZXRlciBpcyBwcm92aWRlZCwgdmVyaWZ5IHRoYXQgaXQgbWF0Y2hlcyB0aGUgY3VycmVudCBjaGFyYWN0ZXIuXG4gICAgICAgIGlmIChjICYmIGMgIT09IGNoKSB7XG4gICAgICAgICAgICBlcnJvcihcIkV4cGVjdGVkICdcIiArIGMgKyBcIicgaW5zdGVhZCBvZiAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgLy8gR2V0IHRoZSBuZXh0IGNoYXJhY3Rlci4gV2hlbiB0aGVyZSBhcmUgbm8gbW9yZSBjaGFyYWN0ZXJzLFxuICAgICAgICAvLyByZXR1cm4gdGhlIGVtcHR5IHN0cmluZy5cbiAgICAgICAgXG4gICAgICAgIGNoID0gdGV4dC5jaGFyQXQoYXQpO1xuICAgICAgICBhdCArPSAxO1xuICAgICAgICByZXR1cm4gY2g7XG4gICAgfSxcbiAgICBcbiAgICBudW1iZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgbnVtYmVyIHZhbHVlLlxuICAgICAgICB2YXIgbnVtYmVyLFxuICAgICAgICAgICAgc3RyaW5nID0gJyc7XG4gICAgICAgIFxuICAgICAgICBpZiAoY2ggPT09ICctJykge1xuICAgICAgICAgICAgc3RyaW5nID0gJy0nO1xuICAgICAgICAgICAgbmV4dCgnLScpO1xuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnLicpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSAnLic7XG4gICAgICAgICAgICB3aGlsZSAobmV4dCgpICYmIGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNoID09PSAnZScgfHwgY2ggPT09ICdFJykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnLScgfHwgY2ggPT09ICcrJykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbnVtYmVyID0gK3N0cmluZztcbiAgICAgICAgaWYgKCFpc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgICBlcnJvcihcIkJhZCBudW1iZXJcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbnVtYmVyO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBcbiAgICBzdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFBhcnNlIGEgc3RyaW5nIHZhbHVlLlxuICAgICAgICB2YXIgaGV4LFxuICAgICAgICAgICAgaSxcbiAgICAgICAgICAgIHN0cmluZyA9ICcnLFxuICAgICAgICAgICAgdWZmZmY7XG4gICAgICAgIFxuICAgICAgICAvLyBXaGVuIHBhcnNpbmcgZm9yIHN0cmluZyB2YWx1ZXMsIHdlIG11c3QgbG9vayBmb3IgXCIgYW5kIFxcIGNoYXJhY3RlcnMuXG4gICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSkge1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ1wiJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gJ1xcXFwnKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNoID09PSAndScpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA0OyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoZXggPSBwYXJzZUludChuZXh0KCksIDE2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWlzRmluaXRlKGhleCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVmZmZmID0gdWZmZmYgKiAxNiArIGhleDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKHVmZmZmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZXNjYXBlZVtjaF0gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gZXNjYXBlZVtjaF07XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgc3RyaW5nXCIpO1xuICAgIH0sXG5cbiAgICB3aGl0ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gU2tpcCB3aGl0ZXNwYWNlLlxuXG4gICAgICAgIHdoaWxlIChjaCAmJiBjaCA8PSAnICcpIHtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbiAgICB3b3JkID0gZnVuY3Rpb24gKCkge1xuXG4vLyB0cnVlLCBmYWxzZSwgb3IgbnVsbC5cblxuICAgICAgICBzd2l0Y2ggKGNoKSB7XG4gICAgICAgIGNhc2UgJ3QnOlxuICAgICAgICAgICAgbmV4dCgndCcpO1xuICAgICAgICAgICAgbmV4dCgncicpO1xuICAgICAgICAgICAgbmV4dCgndScpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIGNhc2UgJ2YnOlxuICAgICAgICAgICAgbmV4dCgnZicpO1xuICAgICAgICAgICAgbmV4dCgnYScpO1xuICAgICAgICAgICAgbmV4dCgnbCcpO1xuICAgICAgICAgICAgbmV4dCgncycpO1xuICAgICAgICAgICAgbmV4dCgnZScpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjYXNlICduJzpcbiAgICAgICAgICAgIG5leHQoJ24nKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiVW5leHBlY3RlZCAnXCIgKyBjaCArIFwiJ1wiKTtcbiAgICB9LFxuXG4gICAgdmFsdWUsICAvLyBQbGFjZSBob2xkZXIgZm9yIHRoZSB2YWx1ZSBmdW5jdGlvbi5cblxuICAgIGFycmF5ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBhcnJheSB2YWx1ZS5cblxuICAgICAgICB2YXIgYXJyYXkgPSBbXTtcblxuICAgICAgICBpZiAoY2ggPT09ICdbJykge1xuICAgICAgICAgICAgbmV4dCgnWycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnXScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTsgICAvLyBlbXB0eSBhcnJheVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoKSB7XG4gICAgICAgICAgICAgICAgYXJyYXkucHVzaCh2YWx1ZSgpKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ10nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFycmF5O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBuZXh0KCcsJyk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIkJhZCBhcnJheVwiKTtcbiAgICB9LFxuXG4gICAgb2JqZWN0ID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhbiBvYmplY3QgdmFsdWUuXG5cbiAgICAgICAgdmFyIGtleSxcbiAgICAgICAgICAgIG9iamVjdCA9IHt9O1xuXG4gICAgICAgIGlmIChjaCA9PT0gJ3snKSB7XG4gICAgICAgICAgICBuZXh0KCd7Jyk7XG4gICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgaWYgKGNoID09PSAnfScpIHtcbiAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDsgICAvLyBlbXB0eSBvYmplY3RcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGtleSA9IHN0cmluZygpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICAgICAgbmV4dCgnOicpO1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IoJ0R1cGxpY2F0ZSBrZXkgXCInICsga2V5ICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG9iamVjdFtrZXldID0gdmFsdWUoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgICAgIG5leHQoJ30nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgb2JqZWN0XCIpO1xuICAgIH07XG5cbnZhbHVlID0gZnVuY3Rpb24gKCkge1xuXG4vLyBQYXJzZSBhIEpTT04gdmFsdWUuIEl0IGNvdWxkIGJlIGFuIG9iamVjdCwgYW4gYXJyYXksIGEgc3RyaW5nLCBhIG51bWJlcixcbi8vIG9yIGEgd29yZC5cblxuICAgIHdoaXRlKCk7XG4gICAgc3dpdGNoIChjaCkge1xuICAgIGNhc2UgJ3snOlxuICAgICAgICByZXR1cm4gb2JqZWN0KCk7XG4gICAgY2FzZSAnWyc6XG4gICAgICAgIHJldHVybiBhcnJheSgpO1xuICAgIGNhc2UgJ1wiJzpcbiAgICAgICAgcmV0dXJuIHN0cmluZygpO1xuICAgIGNhc2UgJy0nOlxuICAgICAgICByZXR1cm4gbnVtYmVyKCk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGNoID49ICcwJyAmJiBjaCA8PSAnOScgPyBudW1iZXIoKSA6IHdvcmQoKTtcbiAgICB9XG59O1xuXG4vLyBSZXR1cm4gdGhlIGpzb25fcGFyc2UgZnVuY3Rpb24uIEl0IHdpbGwgaGF2ZSBhY2Nlc3MgdG8gYWxsIG9mIHRoZSBhYm92ZVxuLy8gZnVuY3Rpb25zIGFuZCB2YXJpYWJsZXMuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuICAgIHZhciByZXN1bHQ7XG4gICAgXG4gICAgdGV4dCA9IHNvdXJjZTtcbiAgICBhdCA9IDA7XG4gICAgY2ggPSAnICc7XG4gICAgcmVzdWx0ID0gdmFsdWUoKTtcbiAgICB3aGl0ZSgpO1xuICAgIGlmIChjaCkge1xuICAgICAgICBlcnJvcihcIlN5bnRheCBlcnJvclwiKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHJlY3Vyc2l2ZWx5IHdhbGsgdGhlIG5ldyBzdHJ1Y3R1cmUsXG4gICAgLy8gcGFzc2luZyBlYWNoIG5hbWUvdmFsdWUgcGFpciB0byB0aGUgcmV2aXZlciBmdW5jdGlvbiBmb3IgcG9zc2libGVcbiAgICAvLyB0cmFuc2Zvcm1hdGlvbiwgc3RhcnRpbmcgd2l0aCBhIHRlbXBvcmFyeSByb290IG9iamVjdCB0aGF0IGhvbGRzIHRoZSByZXN1bHRcbiAgICAvLyBpbiBhbiBlbXB0eSBrZXkuIElmIHRoZXJlIGlzIG5vdCBhIHJldml2ZXIgZnVuY3Rpb24sIHdlIHNpbXBseSByZXR1cm4gdGhlXG4gICAgLy8gcmVzdWx0LlxuXG4gICAgcmV0dXJuIHR5cGVvZiByZXZpdmVyID09PSAnZnVuY3Rpb24nID8gKGZ1bmN0aW9uIHdhbGsoaG9sZGVyLCBrZXkpIHtcbiAgICAgICAgdmFyIGssIHYsIHZhbHVlID0gaG9sZGVyW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCBrKSkge1xuICAgICAgICAgICAgICAgICAgICB2ID0gd2Fsayh2YWx1ZSwgayk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlW2tdID0gdjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB2YWx1ZVtrXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmV2aXZlci5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfSh7Jyc6IHJlc3VsdH0sICcnKSkgOiByZXN1bHQ7XG59O1xuIiwidmFyIGN4ID0gL1tcXHUwMDAwXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBnYXAsXG4gICAgaW5kZW50LFxuICAgIG1ldGEgPSB7ICAgIC8vIHRhYmxlIG9mIGNoYXJhY3RlciBzdWJzdGl0dXRpb25zXG4gICAgICAgICdcXGInOiAnXFxcXGInLFxuICAgICAgICAnXFx0JzogJ1xcXFx0JyxcbiAgICAgICAgJ1xcbic6ICdcXFxcbicsXG4gICAgICAgICdcXGYnOiAnXFxcXGYnLFxuICAgICAgICAnXFxyJzogJ1xcXFxyJyxcbiAgICAgICAgJ1wiJyA6ICdcXFxcXCInLFxuICAgICAgICAnXFxcXCc6ICdcXFxcXFxcXCdcbiAgICB9LFxuICAgIHJlcDtcblxuZnVuY3Rpb24gcXVvdGUoc3RyaW5nKSB7XG4gICAgLy8gSWYgdGhlIHN0cmluZyBjb250YWlucyBubyBjb250cm9sIGNoYXJhY3RlcnMsIG5vIHF1b3RlIGNoYXJhY3RlcnMsIGFuZCBub1xuICAgIC8vIGJhY2tzbGFzaCBjaGFyYWN0ZXJzLCB0aGVuIHdlIGNhbiBzYWZlbHkgc2xhcCBzb21lIHF1b3RlcyBhcm91bmQgaXQuXG4gICAgLy8gT3RoZXJ3aXNlIHdlIG11c3QgYWxzbyByZXBsYWNlIHRoZSBvZmZlbmRpbmcgY2hhcmFjdGVycyB3aXRoIHNhZmUgZXNjYXBlXG4gICAgLy8gc2VxdWVuY2VzLlxuICAgIFxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiBlc2NhcGFibGUudGVzdChzdHJpbmcpID8gJ1wiJyArIHN0cmluZy5yZXBsYWNlKGVzY2FwYWJsZSwgZnVuY3Rpb24gKGEpIHtcbiAgICAgICAgdmFyIGMgPSBtZXRhW2FdO1xuICAgICAgICByZXR1cm4gdHlwZW9mIGMgPT09ICdzdHJpbmcnID8gYyA6XG4gICAgICAgICAgICAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICB9KSArICdcIicgOiAnXCInICsgc3RyaW5nICsgJ1wiJztcbn1cblxuZnVuY3Rpb24gc3RyKGtleSwgaG9sZGVyKSB7XG4gICAgLy8gUHJvZHVjZSBhIHN0cmluZyBmcm9tIGhvbGRlcltrZXldLlxuICAgIHZhciBpLCAgICAgICAgICAvLyBUaGUgbG9vcCBjb3VudGVyLlxuICAgICAgICBrLCAgICAgICAgICAvLyBUaGUgbWVtYmVyIGtleS5cbiAgICAgICAgdiwgICAgICAgICAgLy8gVGhlIG1lbWJlciB2YWx1ZS5cbiAgICAgICAgbGVuZ3RoLFxuICAgICAgICBtaW5kID0gZ2FwLFxuICAgICAgICBwYXJ0aWFsLFxuICAgICAgICB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgIFxuICAgIC8vIElmIHRoZSB2YWx1ZSBoYXMgYSB0b0pTT04gbWV0aG9kLCBjYWxsIGl0IHRvIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gICAgICAgICAgICB0eXBlb2YgdmFsdWUudG9KU09OID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudG9KU09OKGtleSk7XG4gICAgfVxuICAgIFxuICAgIC8vIElmIHdlIHdlcmUgY2FsbGVkIHdpdGggYSByZXBsYWNlciBmdW5jdGlvbiwgdGhlbiBjYWxsIHRoZSByZXBsYWNlciB0b1xuICAgIC8vIG9idGFpbiBhIHJlcGxhY2VtZW50IHZhbHVlLlxuICAgIGlmICh0eXBlb2YgcmVwID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHZhbHVlID0gcmVwLmNhbGwoaG9sZGVyLCBrZXksIHZhbHVlKTtcbiAgICB9XG4gICAgXG4gICAgLy8gV2hhdCBoYXBwZW5zIG5leHQgZGVwZW5kcyBvbiB0aGUgdmFsdWUncyB0eXBlLlxuICAgIHN3aXRjaCAodHlwZW9mIHZhbHVlKSB7XG4gICAgICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICAgICAgICByZXR1cm4gcXVvdGUodmFsdWUpO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnbnVtYmVyJzpcbiAgICAgICAgICAgIC8vIEpTT04gbnVtYmVycyBtdXN0IGJlIGZpbml0ZS4gRW5jb2RlIG5vbi1maW5pdGUgbnVtYmVycyBhcyBudWxsLlxuICAgICAgICAgICAgcmV0dXJuIGlzRmluaXRlKHZhbHVlKSA/IFN0cmluZyh2YWx1ZSkgOiAnbnVsbCc7XG4gICAgICAgIFxuICAgICAgICBjYXNlICdib29sZWFuJzpcbiAgICAgICAgY2FzZSAnbnVsbCc6XG4gICAgICAgICAgICAvLyBJZiB0aGUgdmFsdWUgaXMgYSBib29sZWFuIG9yIG51bGwsIGNvbnZlcnQgaXQgdG8gYSBzdHJpbmcuIE5vdGU6XG4gICAgICAgICAgICAvLyB0eXBlb2YgbnVsbCBkb2VzIG5vdCBwcm9kdWNlICdudWxsJy4gVGhlIGNhc2UgaXMgaW5jbHVkZWQgaGVyZSBpblxuICAgICAgICAgICAgLy8gdGhlIHJlbW90ZSBjaGFuY2UgdGhhdCB0aGlzIGdldHMgZml4ZWQgc29tZWRheS5cbiAgICAgICAgICAgIHJldHVybiBTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgXG4gICAgICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgICAgICBpZiAoIXZhbHVlKSByZXR1cm4gJ251bGwnO1xuICAgICAgICAgICAgZ2FwICs9IGluZGVudDtcbiAgICAgICAgICAgIHBhcnRpYWwgPSBbXTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gQXJyYXkuaXNBcnJheVxuICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkodmFsdWUpID09PSAnW29iamVjdCBBcnJheV0nKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsW2ldID0gc3RyKGksIHZhbHVlKSB8fCAnbnVsbCc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIC8vIEpvaW4gYWxsIG9mIHRoZSBlbGVtZW50cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLCBhbmRcbiAgICAgICAgICAgICAgICAvLyB3cmFwIHRoZW0gaW4gYnJhY2tldHMuXG4gICAgICAgICAgICAgICAgdiA9IHBhcnRpYWwubGVuZ3RoID09PSAwID8gJ1tdJyA6IGdhcCA/XG4gICAgICAgICAgICAgICAgICAgICdbXFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ10nIDpcbiAgICAgICAgICAgICAgICAgICAgJ1snICsgcGFydGlhbC5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgICAgICAgICAgZ2FwID0gbWluZDtcbiAgICAgICAgICAgICAgICByZXR1cm4gdjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAgICAgLy8gSWYgdGhlIHJlcGxhY2VyIGlzIGFuIGFycmF5LCB1c2UgaXQgdG8gc2VsZWN0IHRoZSBtZW1iZXJzIHRvIGJlXG4gICAgICAgICAgICAvLyBzdHJpbmdpZmllZC5cbiAgICAgICAgICAgIGlmIChyZXAgJiYgdHlwZW9mIHJlcCA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSByZXAubGVuZ3RoO1xuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xuICAgICAgICAgICAgICAgICAgICBrID0gcmVwW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGsgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGl0ZXJhdGUgdGhyb3VnaCBhbGwgb2YgdGhlIGtleXMgaW4gdGhlIG9iamVjdC5cbiAgICAgICAgICAgICAgICBmb3IgKGsgaW4gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHYgPSBzdHIoaywgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHYpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJ0aWFsLnB1c2gocXVvdGUoaykgKyAoZ2FwID8gJzogJyA6ICc6JykgKyB2KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIFxuICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgbWVtYmVyIHRleHRzIHRvZ2V0aGVyLCBzZXBhcmF0ZWQgd2l0aCBjb21tYXMsXG4gICAgICAgIC8vIGFuZCB3cmFwIHRoZW0gaW4gYnJhY2VzLlxuXG4gICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICd7fScgOiBnYXAgP1xuICAgICAgICAgICAgJ3tcXG4nICsgZ2FwICsgcGFydGlhbC5qb2luKCcsXFxuJyArIGdhcCkgKyAnXFxuJyArIG1pbmQgKyAnfScgOlxuICAgICAgICAgICAgJ3snICsgcGFydGlhbC5qb2luKCcsJykgKyAnfSc7XG4gICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgIHJldHVybiB2O1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodmFsdWUsIHJlcGxhY2VyLCBzcGFjZSkge1xuICAgIHZhciBpO1xuICAgIGdhcCA9ICcnO1xuICAgIGluZGVudCA9ICcnO1xuICAgIFxuICAgIC8vIElmIHRoZSBzcGFjZSBwYXJhbWV0ZXIgaXMgYSBudW1iZXIsIG1ha2UgYW4gaW5kZW50IHN0cmluZyBjb250YWluaW5nIHRoYXRcbiAgICAvLyBtYW55IHNwYWNlcy5cbiAgICBpZiAodHlwZW9mIHNwYWNlID09PSAnbnVtYmVyJykge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgc3BhY2U7IGkgKz0gMSkge1xuICAgICAgICAgICAgaW5kZW50ICs9ICcgJztcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgc3RyaW5nLCBpdCB3aWxsIGJlIHVzZWQgYXMgdGhlIGluZGVudCBzdHJpbmcuXG4gICAgZWxzZSBpZiAodHlwZW9mIHNwYWNlID09PSAnc3RyaW5nJykge1xuICAgICAgICBpbmRlbnQgPSBzcGFjZTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGVyZSBpcyBhIHJlcGxhY2VyLCBpdCBtdXN0IGJlIGEgZnVuY3Rpb24gb3IgYW4gYXJyYXkuXG4gICAgLy8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvci5cbiAgICByZXAgPSByZXBsYWNlcjtcbiAgICBpZiAocmVwbGFjZXIgJiYgdHlwZW9mIHJlcGxhY2VyICE9PSAnZnVuY3Rpb24nXG4gICAgJiYgKHR5cGVvZiByZXBsYWNlciAhPT0gJ29iamVjdCcgfHwgdHlwZW9mIHJlcGxhY2VyLmxlbmd0aCAhPT0gJ251bWJlcicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSlNPTi5zdHJpbmdpZnknKTtcbiAgICB9XG4gICAgXG4gICAgLy8gTWFrZSBhIGZha2Ugcm9vdCBvYmplY3QgY29udGFpbmluZyBvdXIgdmFsdWUgdW5kZXIgdGhlIGtleSBvZiAnJy5cbiAgICAvLyBSZXR1cm4gdGhlIHJlc3VsdCBvZiBzdHJpbmdpZnlpbmcgdGhlIHZhbHVlLlxuICAgIHJldHVybiBzdHIoJycsIHsnJzogdmFsdWV9KTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbmlmICghcHJvY2Vzcy52ZXJzaW9uIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YxLicpID09PSAwICYmIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS44LicpICE9PSAwKSB7XG4gIG1vZHVsZS5leHBvcnRzID0gbmV4dFRpY2s7XG59IGVsc2Uge1xuICBtb2R1bGUuZXhwb3J0cyA9IHByb2Nlc3MubmV4dFRpY2s7XG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrKGZuLCBhcmcxLCBhcmcyLCBhcmczKSB7XG4gIGlmICh0eXBlb2YgZm4gIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImNhbGxiYWNrXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG4gIH1cbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciBhcmdzLCBpO1xuICBzd2l0Y2ggKGxlbikge1xuICBjYXNlIDA6XG4gIGNhc2UgMTpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmbik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tPbmUoKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIGFyZzEpO1xuICAgIH0pO1xuICBjYXNlIDM6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrVHdvKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcbiAgICB9KTtcbiAgY2FzZSA0OlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICB9KTtcbiAgZGVmYXVsdDpcbiAgICBhcmdzID0gbmV3IEFycmF5KGxlbiAtIDEpO1xuICAgIGkgPSAwO1xuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcbiAgICAgIGFyZ3NbaSsrXSA9IGFyZ3VtZW50c1tpXTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xuICAgICAgZm4uYXBwbHkobnVsbCwgYXJncyk7XG4gICAgfSk7XG4gIH1cbn1cbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiEgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlIHYxLjQuMSBieSBAbWF0aGlhcyAqL1xuOyhmdW5jdGlvbihyb290KSB7XG5cblx0LyoqIERldGVjdCBmcmVlIHZhcmlhYmxlcyAqL1xuXHR2YXIgZnJlZUV4cG9ydHMgPSB0eXBlb2YgZXhwb3J0cyA9PSAnb2JqZWN0JyAmJiBleHBvcnRzICYmXG5cdFx0IWV4cG9ydHMubm9kZVR5cGUgJiYgZXhwb3J0cztcblx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxuXHRcdCFtb2R1bGUubm9kZVR5cGUgJiYgbW9kdWxlO1xuXHR2YXIgZnJlZUdsb2JhbCA9IHR5cGVvZiBnbG9iYWwgPT0gJ29iamVjdCcgJiYgZ2xvYmFsO1xuXHRpZiAoXG5cdFx0ZnJlZUdsb2JhbC5nbG9iYWwgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLndpbmRvdyA9PT0gZnJlZUdsb2JhbCB8fFxuXHRcdGZyZWVHbG9iYWwuc2VsZiA9PT0gZnJlZUdsb2JhbFxuXHQpIHtcblx0XHRyb290ID0gZnJlZUdsb2JhbDtcblx0fVxuXG5cdC8qKlxuXHQgKiBUaGUgYHB1bnljb2RlYCBvYmplY3QuXG5cdCAqIEBuYW1lIHB1bnljb2RlXG5cdCAqIEB0eXBlIE9iamVjdFxuXHQgKi9cblx0dmFyIHB1bnljb2RlLFxuXG5cdC8qKiBIaWdoZXN0IHBvc2l0aXZlIHNpZ25lZCAzMi1iaXQgZmxvYXQgdmFsdWUgKi9cblx0bWF4SW50ID0gMjE0NzQ4MzY0NywgLy8gYWthLiAweDdGRkZGRkZGIG9yIDJeMzEtMVxuXG5cdC8qKiBCb290c3RyaW5nIHBhcmFtZXRlcnMgKi9cblx0YmFzZSA9IDM2LFxuXHR0TWluID0gMSxcblx0dE1heCA9IDI2LFxuXHRza2V3ID0gMzgsXG5cdGRhbXAgPSA3MDAsXG5cdGluaXRpYWxCaWFzID0gNzIsXG5cdGluaXRpYWxOID0gMTI4LCAvLyAweDgwXG5cdGRlbGltaXRlciA9ICctJywgLy8gJ1xceDJEJ1xuXG5cdC8qKiBSZWd1bGFyIGV4cHJlc3Npb25zICovXG5cdHJlZ2V4UHVueWNvZGUgPSAvXnhuLS0vLFxuXHRyZWdleE5vbkFTQ0lJID0gL1teXFx4MjAtXFx4N0VdLywgLy8gdW5wcmludGFibGUgQVNDSUkgY2hhcnMgKyBub24tQVNDSUkgY2hhcnNcblx0cmVnZXhTZXBhcmF0b3JzID0gL1tcXHgyRVxcdTMwMDJcXHVGRjBFXFx1RkY2MV0vZywgLy8gUkZDIDM0OTAgc2VwYXJhdG9yc1xuXG5cdC8qKiBFcnJvciBtZXNzYWdlcyAqL1xuXHRlcnJvcnMgPSB7XG5cdFx0J292ZXJmbG93JzogJ092ZXJmbG93OiBpbnB1dCBuZWVkcyB3aWRlciBpbnRlZ2VycyB0byBwcm9jZXNzJyxcblx0XHQnbm90LWJhc2ljJzogJ0lsbGVnYWwgaW5wdXQgPj0gMHg4MCAobm90IGEgYmFzaWMgY29kZSBwb2ludCknLFxuXHRcdCdpbnZhbGlkLWlucHV0JzogJ0ludmFsaWQgaW5wdXQnXG5cdH0sXG5cblx0LyoqIENvbnZlbmllbmNlIHNob3J0Y3V0cyAqL1xuXHRiYXNlTWludXNUTWluID0gYmFzZSAtIHRNaW4sXG5cdGZsb29yID0gTWF0aC5mbG9vcixcblx0c3RyaW5nRnJvbUNoYXJDb2RlID0gU3RyaW5nLmZyb21DaGFyQ29kZSxcblxuXHQvKiogVGVtcG9yYXJ5IHZhcmlhYmxlICovXG5cdGtleTtcblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGVycm9yIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlIFRoZSBlcnJvciB0eXBlLlxuXHQgKiBAcmV0dXJucyB7RXJyb3J9IFRocm93cyBhIGBSYW5nZUVycm9yYCB3aXRoIHRoZSBhcHBsaWNhYmxlIGVycm9yIG1lc3NhZ2UuXG5cdCAqL1xuXHRmdW5jdGlvbiBlcnJvcih0eXBlKSB7XG5cdFx0dGhyb3cgbmV3IFJhbmdlRXJyb3IoZXJyb3JzW3R5cGVdKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBBIGdlbmVyaWMgYEFycmF5I21hcGAgdXRpbGl0eSBmdW5jdGlvbi5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5IGFycmF5XG5cdCAqIGl0ZW0uXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgYXJyYXkgb2YgdmFsdWVzIHJldHVybmVkIGJ5IHRoZSBjYWxsYmFjayBmdW5jdGlvbi5cblx0ICovXG5cdGZ1bmN0aW9uIG1hcChhcnJheSwgZm4pIHtcblx0XHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXHRcdHZhciByZXN1bHQgPSBbXTtcblx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdHJlc3VsdFtsZW5ndGhdID0gZm4oYXJyYXlbbGVuZ3RoXSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHQvKipcblx0ICogQSBzaW1wbGUgYEFycmF5I21hcGAtbGlrZSB3cmFwcGVyIHRvIHdvcmsgd2l0aCBkb21haW4gbmFtZSBzdHJpbmdzIG9yIGVtYWlsXG5cdCAqIGFkZHJlc3Nlcy5cblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGRvbWFpbiBUaGUgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcy5cblx0ICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIHRoYXQgZ2V0cyBjYWxsZWQgZm9yIGV2ZXJ5XG5cdCAqIGNoYXJhY3Rlci5cblx0ICogQHJldHVybnMge0FycmF5fSBBIG5ldyBzdHJpbmcgb2YgY2hhcmFjdGVycyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2tcblx0ICogZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXBEb21haW4oc3RyaW5nLCBmbikge1xuXHRcdHZhciBwYXJ0cyA9IHN0cmluZy5zcGxpdCgnQCcpO1xuXHRcdHZhciByZXN1bHQgPSAnJztcblx0XHRpZiAocGFydHMubGVuZ3RoID4gMSkge1xuXHRcdFx0Ly8gSW4gZW1haWwgYWRkcmVzc2VzLCBvbmx5IHRoZSBkb21haW4gbmFtZSBzaG91bGQgYmUgcHVueWNvZGVkLiBMZWF2ZVxuXHRcdFx0Ly8gdGhlIGxvY2FsIHBhcnQgKGkuZS4gZXZlcnl0aGluZyB1cCB0byBgQGApIGludGFjdC5cblx0XHRcdHJlc3VsdCA9IHBhcnRzWzBdICsgJ0AnO1xuXHRcdFx0c3RyaW5nID0gcGFydHNbMV07XG5cdFx0fVxuXHRcdC8vIEF2b2lkIGBzcGxpdChyZWdleClgIGZvciBJRTggY29tcGF0aWJpbGl0eS4gU2VlICMxNy5cblx0XHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleFNlcGFyYXRvcnMsICdcXHgyRScpO1xuXHRcdHZhciBsYWJlbHMgPSBzdHJpbmcuc3BsaXQoJy4nKTtcblx0XHR2YXIgZW5jb2RlZCA9IG1hcChsYWJlbHMsIGZuKS5qb2luKCcuJyk7XG5cdFx0cmV0dXJuIHJlc3VsdCArIGVuY29kZWQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhbiBhcnJheSBjb250YWluaW5nIHRoZSBudW1lcmljIGNvZGUgcG9pbnRzIG9mIGVhY2ggVW5pY29kZVxuXHQgKiBjaGFyYWN0ZXIgaW4gdGhlIHN0cmluZy4gV2hpbGUgSmF2YVNjcmlwdCB1c2VzIFVDUy0yIGludGVybmFsbHksXG5cdCAqIHRoaXMgZnVuY3Rpb24gd2lsbCBjb252ZXJ0IGEgcGFpciBvZiBzdXJyb2dhdGUgaGFsdmVzIChlYWNoIG9mIHdoaWNoXG5cdCAqIFVDUy0yIGV4cG9zZXMgYXMgc2VwYXJhdGUgY2hhcmFjdGVycykgaW50byBhIHNpbmdsZSBjb2RlIHBvaW50LFxuXHQgKiBtYXRjaGluZyBVVEYtMTYuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZW5jb2RlYFxuXHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZGVjb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBzdHJpbmcgVGhlIFVuaWNvZGUgaW5wdXQgc3RyaW5nIChVQ1MtMikuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gVGhlIG5ldyBhcnJheSBvZiBjb2RlIHBvaW50cy5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJkZWNvZGUoc3RyaW5nKSB7XG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBjb3VudGVyID0gMCxcblx0XHQgICAgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aCxcblx0XHQgICAgdmFsdWUsXG5cdFx0ICAgIGV4dHJhO1xuXHRcdHdoaWxlIChjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHR2YWx1ZSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRpZiAodmFsdWUgPj0gMHhEODAwICYmIHZhbHVlIDw9IDB4REJGRiAmJiBjb3VudGVyIDwgbGVuZ3RoKSB7XG5cdFx0XHRcdC8vIGhpZ2ggc3Vycm9nYXRlLCBhbmQgdGhlcmUgaXMgYSBuZXh0IGNoYXJhY3RlclxuXHRcdFx0XHRleHRyYSA9IHN0cmluZy5jaGFyQ29kZUF0KGNvdW50ZXIrKyk7XG5cdFx0XHRcdGlmICgoZXh0cmEgJiAweEZDMDApID09IDB4REMwMCkgeyAvLyBsb3cgc3Vycm9nYXRlXG5cdFx0XHRcdFx0b3V0cHV0LnB1c2goKCh2YWx1ZSAmIDB4M0ZGKSA8PCAxMCkgKyAoZXh0cmEgJiAweDNGRikgKyAweDEwMDAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQvLyB1bm1hdGNoZWQgc3Vycm9nYXRlOyBvbmx5IGFwcGVuZCB0aGlzIGNvZGUgdW5pdCwgaW4gY2FzZSB0aGUgbmV4dFxuXHRcdFx0XHRcdC8vIGNvZGUgdW5pdCBpcyB0aGUgaGlnaCBzdXJyb2dhdGUgb2YgYSBzdXJyb2dhdGUgcGFpclxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdFx0XHRjb3VudGVyLS07XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG91dHB1dC5wdXNoKHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dDtcblx0fVxuXG5cdC8qKlxuXHQgKiBDcmVhdGVzIGEgc3RyaW5nIGJhc2VkIG9uIGFuIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEBzZWUgYHB1bnljb2RlLnVjczIuZGVjb2RlYFxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGUudWNzMlxuXHQgKiBAbmFtZSBlbmNvZGVcblx0ICogQHBhcmFtIHtBcnJheX0gY29kZVBvaW50cyBUaGUgYXJyYXkgb2YgbnVtZXJpYyBjb2RlIHBvaW50cy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIG5ldyBVbmljb2RlIHN0cmluZyAoVUNTLTIpLlxuXHQgKi9cblx0ZnVuY3Rpb24gdWNzMmVuY29kZShhcnJheSkge1xuXHRcdHJldHVybiBtYXAoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3V0cHV0ID0gJyc7XG5cdFx0XHRpZiAodmFsdWUgPiAweEZGRkYpIHtcblx0XHRcdFx0dmFsdWUgLT0gMHgxMDAwMDtcblx0XHRcdFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZSh2YWx1ZSA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMCk7XG5cdFx0XHRcdHZhbHVlID0gMHhEQzAwIHwgdmFsdWUgJiAweDNGRjtcblx0XHRcdH1cblx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUpO1xuXHRcdFx0cmV0dXJuIG91dHB1dDtcblx0XHR9KS5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGJhc2ljIGNvZGUgcG9pbnQgaW50byBhIGRpZ2l0L2ludGVnZXIuXG5cdCAqIEBzZWUgYGRpZ2l0VG9CYXNpYygpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gY29kZVBvaW50IFRoZSBiYXNpYyBudW1lcmljIGNvZGUgcG9pbnQgdmFsdWUuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBudW1lcmljIHZhbHVlIG9mIGEgYmFzaWMgY29kZSBwb2ludCAoZm9yIHVzZSBpblxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGluIHRoZSByYW5nZSBgMGAgdG8gYGJhc2UgLSAxYCwgb3IgYGJhc2VgIGlmXG5cdCAqIHRoZSBjb2RlIHBvaW50IGRvZXMgbm90IHJlcHJlc2VudCBhIHZhbHVlLlxuXHQgKi9cblx0ZnVuY3Rpb24gYmFzaWNUb0RpZ2l0KGNvZGVQb2ludCkge1xuXHRcdGlmIChjb2RlUG9pbnQgLSA0OCA8IDEwKSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gMjI7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA2NSA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gNjU7XG5cdFx0fVxuXHRcdGlmIChjb2RlUG9pbnQgLSA5NyA8IDI2KSB7XG5cdFx0XHRyZXR1cm4gY29kZVBvaW50IC0gOTc7XG5cdFx0fVxuXHRcdHJldHVybiBiYXNlO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgZGlnaXQvaW50ZWdlciBpbnRvIGEgYmFzaWMgY29kZSBwb2ludC5cblx0ICogQHNlZSBgYmFzaWNUb0RpZ2l0KClgXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7TnVtYmVyfSBkaWdpdCBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEByZXR1cm5zIHtOdW1iZXJ9IFRoZSBiYXNpYyBjb2RlIHBvaW50IHdob3NlIHZhbHVlICh3aGVuIHVzZWQgZm9yXG5cdCAqIHJlcHJlc2VudGluZyBpbnRlZ2VycykgaXMgYGRpZ2l0YCwgd2hpY2ggbmVlZHMgdG8gYmUgaW4gdGhlIHJhbmdlXG5cdCAqIGAwYCB0byBgYmFzZSAtIDFgLiBJZiBgZmxhZ2AgaXMgbm9uLXplcm8sIHRoZSB1cHBlcmNhc2UgZm9ybSBpc1xuXHQgKiB1c2VkOyBlbHNlLCB0aGUgbG93ZXJjYXNlIGZvcm0gaXMgdXNlZC4gVGhlIGJlaGF2aW9yIGlzIHVuZGVmaW5lZFxuXHQgKiBpZiBgZmxhZ2AgaXMgbm9uLXplcm8gYW5kIGBkaWdpdGAgaGFzIG5vIHVwcGVyY2FzZSBmb3JtLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGlnaXRUb0Jhc2ljKGRpZ2l0LCBmbGFnKSB7XG5cdFx0Ly8gIDAuLjI1IG1hcCB0byBBU0NJSSBhLi56IG9yIEEuLlpcblx0XHQvLyAyNi4uMzUgbWFwIHRvIEFTQ0lJIDAuLjlcblx0XHRyZXR1cm4gZGlnaXQgKyAyMiArIDc1ICogKGRpZ2l0IDwgMjYpIC0gKChmbGFnICE9IDApIDw8IDUpO1xuXHR9XG5cblx0LyoqXG5cdCAqIEJpYXMgYWRhcHRhdGlvbiBmdW5jdGlvbiBhcyBwZXIgc2VjdGlvbiAzLjQgb2YgUkZDIDM0OTIuXG5cdCAqIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMzNDkyI3NlY3Rpb24tMy40XG5cdCAqIEBwcml2YXRlXG5cdCAqL1xuXHRmdW5jdGlvbiBhZGFwdChkZWx0YSwgbnVtUG9pbnRzLCBmaXJzdFRpbWUpIHtcblx0XHR2YXIgayA9IDA7XG5cdFx0ZGVsdGEgPSBmaXJzdFRpbWUgPyBmbG9vcihkZWx0YSAvIGRhbXApIDogZGVsdGEgPj4gMTtcblx0XHRkZWx0YSArPSBmbG9vcihkZWx0YSAvIG51bVBvaW50cyk7XG5cdFx0Zm9yICgvKiBubyBpbml0aWFsaXphdGlvbiAqLzsgZGVsdGEgPiBiYXNlTWludXNUTWluICogdE1heCA+PiAxOyBrICs9IGJhc2UpIHtcblx0XHRcdGRlbHRhID0gZmxvb3IoZGVsdGEgLyBiYXNlTWludXNUTWluKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZsb29yKGsgKyAoYmFzZU1pbnVzVE1pbiArIDEpICogZGVsdGEgLyAoZGVsdGEgKyBza2V3KSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzIHRvIGEgc3RyaW5nIG9mIFVuaWNvZGVcblx0ICogc3ltYm9scy5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIHJlc3VsdGluZyBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKi9cblx0ZnVuY3Rpb24gZGVjb2RlKGlucHV0KSB7XG5cdFx0Ly8gRG9uJ3QgdXNlIFVDUy0yXG5cdFx0dmFyIG91dHB1dCA9IFtdLFxuXHRcdCAgICBpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aCxcblx0XHQgICAgb3V0LFxuXHRcdCAgICBpID0gMCxcblx0XHQgICAgbiA9IGluaXRpYWxOLFxuXHRcdCAgICBiaWFzID0gaW5pdGlhbEJpYXMsXG5cdFx0ICAgIGJhc2ljLFxuXHRcdCAgICBqLFxuXHRcdCAgICBpbmRleCxcblx0XHQgICAgb2xkaSxcblx0XHQgICAgdyxcblx0XHQgICAgayxcblx0XHQgICAgZGlnaXQsXG5cdFx0ICAgIHQsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBiYXNlTWludXNUO1xuXG5cdFx0Ly8gSGFuZGxlIHRoZSBiYXNpYyBjb2RlIHBvaW50czogbGV0IGBiYXNpY2AgYmUgdGhlIG51bWJlciBvZiBpbnB1dCBjb2RlXG5cdFx0Ly8gcG9pbnRzIGJlZm9yZSB0aGUgbGFzdCBkZWxpbWl0ZXIsIG9yIGAwYCBpZiB0aGVyZSBpcyBub25lLCB0aGVuIGNvcHlcblx0XHQvLyB0aGUgZmlyc3QgYmFzaWMgY29kZSBwb2ludHMgdG8gdGhlIG91dHB1dC5cblxuXHRcdGJhc2ljID0gaW5wdXQubGFzdEluZGV4T2YoZGVsaW1pdGVyKTtcblx0XHRpZiAoYmFzaWMgPCAwKSB7XG5cdFx0XHRiYXNpYyA9IDA7XG5cdFx0fVxuXG5cdFx0Zm9yIChqID0gMDsgaiA8IGJhc2ljOyArK2opIHtcblx0XHRcdC8vIGlmIGl0J3Mgbm90IGEgYmFzaWMgY29kZSBwb2ludFxuXHRcdFx0aWYgKGlucHV0LmNoYXJDb2RlQXQoaikgPj0gMHg4MCkge1xuXHRcdFx0XHRlcnJvcignbm90LWJhc2ljJyk7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQucHVzaChpbnB1dC5jaGFyQ29kZUF0KGopKTtcblx0XHR9XG5cblx0XHQvLyBNYWluIGRlY29kaW5nIGxvb3A6IHN0YXJ0IGp1c3QgYWZ0ZXIgdGhlIGxhc3QgZGVsaW1pdGVyIGlmIGFueSBiYXNpYyBjb2RlXG5cdFx0Ly8gcG9pbnRzIHdlcmUgY29waWVkOyBzdGFydCBhdCB0aGUgYmVnaW5uaW5nIG90aGVyd2lzZS5cblxuXHRcdGZvciAoaW5kZXggPSBiYXNpYyA+IDAgPyBiYXNpYyArIDEgOiAwOyBpbmRleCA8IGlucHV0TGVuZ3RoOyAvKiBubyBmaW5hbCBleHByZXNzaW9uICovKSB7XG5cblx0XHRcdC8vIGBpbmRleGAgaXMgdGhlIGluZGV4IG9mIHRoZSBuZXh0IGNoYXJhY3RlciB0byBiZSBjb25zdW1lZC5cblx0XHRcdC8vIERlY29kZSBhIGdlbmVyYWxpemVkIHZhcmlhYmxlLWxlbmd0aCBpbnRlZ2VyIGludG8gYGRlbHRhYCxcblx0XHRcdC8vIHdoaWNoIGdldHMgYWRkZWQgdG8gYGlgLiBUaGUgb3ZlcmZsb3cgY2hlY2tpbmcgaXMgZWFzaWVyXG5cdFx0XHQvLyBpZiB3ZSBpbmNyZWFzZSBgaWAgYXMgd2UgZ28sIHRoZW4gc3VidHJhY3Qgb2ZmIGl0cyBzdGFydGluZ1xuXHRcdFx0Ly8gdmFsdWUgYXQgdGhlIGVuZCB0byBvYnRhaW4gYGRlbHRhYC5cblx0XHRcdGZvciAob2xkaSA9IGksIHcgPSAxLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblxuXHRcdFx0XHRpZiAoaW5kZXggPj0gaW5wdXRMZW5ndGgpIHtcblx0XHRcdFx0XHRlcnJvcignaW52YWxpZC1pbnB1dCcpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZGlnaXQgPSBiYXNpY1RvRGlnaXQoaW5wdXQuY2hhckNvZGVBdChpbmRleCsrKSk7XG5cblx0XHRcdFx0aWYgKGRpZ2l0ID49IGJhc2UgfHwgZGlnaXQgPiBmbG9vcigobWF4SW50IC0gaSkgLyB3KSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aSArPSBkaWdpdCAqIHc7XG5cdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA8IHQpIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0aWYgKHcgPiBmbG9vcihtYXhJbnQgLyBiYXNlTWludXNUKSkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0dyAqPSBiYXNlTWludXNUO1xuXG5cdFx0XHR9XG5cblx0XHRcdG91dCA9IG91dHB1dC5sZW5ndGggKyAxO1xuXHRcdFx0YmlhcyA9IGFkYXB0KGkgLSBvbGRpLCBvdXQsIG9sZGkgPT0gMCk7XG5cblx0XHRcdC8vIGBpYCB3YXMgc3VwcG9zZWQgdG8gd3JhcCBhcm91bmQgZnJvbSBgb3V0YCB0byBgMGAsXG5cdFx0XHQvLyBpbmNyZW1lbnRpbmcgYG5gIGVhY2ggdGltZSwgc28gd2UnbGwgZml4IHRoYXQgbm93OlxuXHRcdFx0aWYgKGZsb29yKGkgLyBvdXQpID4gbWF4SW50IC0gbikge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0biArPSBmbG9vcihpIC8gb3V0KTtcblx0XHRcdGkgJT0gb3V0O1xuXG5cdFx0XHQvLyBJbnNlcnQgYG5gIGF0IHBvc2l0aW9uIGBpYCBvZiB0aGUgb3V0cHV0XG5cdFx0XHRvdXRwdXQuc3BsaWNlKGkrKywgMCwgbik7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gdWNzMmVuY29kZShvdXRwdXQpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scyAoZS5nLiBhIGRvbWFpbiBuYW1lIGxhYmVsKSB0byBhXG5cdCAqIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGVuY29kZShpbnB1dCkge1xuXHRcdHZhciBuLFxuXHRcdCAgICBkZWx0YSxcblx0XHQgICAgaGFuZGxlZENQQ291bnQsXG5cdFx0ICAgIGJhc2ljTGVuZ3RoLFxuXHRcdCAgICBiaWFzLFxuXHRcdCAgICBqLFxuXHRcdCAgICBtLFxuXHRcdCAgICBxLFxuXHRcdCAgICBrLFxuXHRcdCAgICB0LFxuXHRcdCAgICBjdXJyZW50VmFsdWUsXG5cdFx0ICAgIG91dHB1dCA9IFtdLFxuXHRcdCAgICAvKiogYGlucHV0TGVuZ3RoYCB3aWxsIGhvbGQgdGhlIG51bWJlciBvZiBjb2RlIHBvaW50cyBpbiBgaW5wdXRgLiAqL1xuXHRcdCAgICBpbnB1dExlbmd0aCxcblx0XHQgICAgLyoqIENhY2hlZCBjYWxjdWxhdGlvbiByZXN1bHRzICovXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50UGx1c09uZSxcblx0XHQgICAgYmFzZU1pbnVzVCxcblx0XHQgICAgcU1pbnVzVDtcblxuXHRcdC8vIENvbnZlcnQgdGhlIGlucHV0IGluIFVDUy0yIHRvIFVuaWNvZGVcblx0XHRpbnB1dCA9IHVjczJkZWNvZGUoaW5wdXQpO1xuXG5cdFx0Ly8gQ2FjaGUgdGhlIGxlbmd0aFxuXHRcdGlucHV0TGVuZ3RoID0gaW5wdXQubGVuZ3RoO1xuXG5cdFx0Ly8gSW5pdGlhbGl6ZSB0aGUgc3RhdGVcblx0XHRuID0gaW5pdGlhbE47XG5cdFx0ZGVsdGEgPSAwO1xuXHRcdGJpYXMgPSBpbml0aWFsQmlhcztcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHNcblx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgMHg4MCkge1xuXHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoY3VycmVudFZhbHVlKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aGFuZGxlZENQQ291bnQgPSBiYXNpY0xlbmd0aCA9IG91dHB1dC5sZW5ndGg7XG5cblx0XHQvLyBgaGFuZGxlZENQQ291bnRgIGlzIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgdGhhdCBoYXZlIGJlZW4gaGFuZGxlZDtcblx0XHQvLyBgYmFzaWNMZW5ndGhgIGlzIHRoZSBudW1iZXIgb2YgYmFzaWMgY29kZSBwb2ludHMuXG5cblx0XHQvLyBGaW5pc2ggdGhlIGJhc2ljIHN0cmluZyAtIGlmIGl0IGlzIG5vdCBlbXB0eSAtIHdpdGggYSBkZWxpbWl0ZXJcblx0XHRpZiAoYmFzaWNMZW5ndGgpIHtcblx0XHRcdG91dHB1dC5wdXNoKGRlbGltaXRlcik7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBlbmNvZGluZyBsb29wOlxuXHRcdHdoaWxlIChoYW5kbGVkQ1BDb3VudCA8IGlucHV0TGVuZ3RoKSB7XG5cblx0XHRcdC8vIEFsbCBub24tYmFzaWMgY29kZSBwb2ludHMgPCBuIGhhdmUgYmVlbiBoYW5kbGVkIGFscmVhZHkuIEZpbmQgdGhlIG5leHRcblx0XHRcdC8vIGxhcmdlciBvbmU6XG5cdFx0XHRmb3IgKG0gPSBtYXhJbnQsIGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA+PSBuICYmIGN1cnJlbnRWYWx1ZSA8IG0pIHtcblx0XHRcdFx0XHRtID0gY3VycmVudFZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEluY3JlYXNlIGBkZWx0YWAgZW5vdWdoIHRvIGFkdmFuY2UgdGhlIGRlY29kZXIncyA8bixpPiBzdGF0ZSB0byA8bSwwPixcblx0XHRcdC8vIGJ1dCBndWFyZCBhZ2FpbnN0IG92ZXJmbG93XG5cdFx0XHRoYW5kbGVkQ1BDb3VudFBsdXNPbmUgPSBoYW5kbGVkQ1BDb3VudCArIDE7XG5cdFx0XHRpZiAobSAtIG4gPiBmbG9vcigobWF4SW50IC0gZGVsdGEpIC8gaGFuZGxlZENQQ291bnRQbHVzT25lKSkge1xuXHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVsdGEgKz0gKG0gLSBuKSAqIGhhbmRsZWRDUENvdW50UGx1c09uZTtcblx0XHRcdG4gPSBtO1xuXG5cdFx0XHRmb3IgKGogPSAwOyBqIDwgaW5wdXRMZW5ndGg7ICsraikge1xuXHRcdFx0XHRjdXJyZW50VmFsdWUgPSBpbnB1dFtqXTtcblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlIDwgbiAmJiArK2RlbHRhID4gbWF4SW50KSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoY3VycmVudFZhbHVlID09IG4pIHtcblx0XHRcdFx0XHQvLyBSZXByZXNlbnQgZGVsdGEgYXMgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlclxuXHRcdFx0XHRcdGZvciAocSA9IGRlbHRhLCBrID0gYmFzZTsgLyogbm8gY29uZGl0aW9uICovOyBrICs9IGJhc2UpIHtcblx0XHRcdFx0XHRcdHQgPSBrIDw9IGJpYXMgPyB0TWluIDogKGsgPj0gYmlhcyArIHRNYXggPyB0TWF4IDogayAtIGJpYXMpO1xuXHRcdFx0XHRcdFx0aWYgKHEgPCB0KSB7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cU1pbnVzVCA9IHEgLSB0O1xuXHRcdFx0XHRcdFx0YmFzZU1pbnVzVCA9IGJhc2UgLSB0O1xuXHRcdFx0XHRcdFx0b3V0cHV0LnB1c2goXG5cdFx0XHRcdFx0XHRcdHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWModCArIHFNaW51c1QgJSBiYXNlTWludXNULCAwKSlcblx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRxID0gZmxvb3IocU1pbnVzVCAvIGJhc2VNaW51c1QpO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKHN0cmluZ0Zyb21DaGFyQ29kZShkaWdpdFRvQmFzaWMocSwgMCkpKTtcblx0XHRcdFx0XHRiaWFzID0gYWRhcHQoZGVsdGEsIGhhbmRsZWRDUENvdW50UGx1c09uZSwgaGFuZGxlZENQQ291bnQgPT0gYmFzaWNMZW5ndGgpO1xuXHRcdFx0XHRcdGRlbHRhID0gMDtcblx0XHRcdFx0XHQrK2hhbmRsZWRDUENvdW50O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdCsrZGVsdGE7XG5cdFx0XHQrK247XG5cblx0XHR9XG5cdFx0cmV0dXJuIG91dHB1dC5qb2luKCcnKTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIFB1bnljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzXG5cdCAqIHRvIFVuaWNvZGUuIE9ubHkgdGhlIFB1bnljb2RlZCBwYXJ0cyBvZiB0aGUgaW5wdXQgd2lsbCBiZSBjb252ZXJ0ZWQsIGkuZS5cblx0ICogaXQgZG9lc24ndCBtYXR0ZXIgaWYgeW91IGNhbGwgaXQgb24gYSBzdHJpbmcgdGhhdCBoYXMgYWxyZWFkeSBiZWVuXG5cdCAqIGNvbnZlcnRlZCB0byBVbmljb2RlLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBQdW55Y29kZWQgZG9tYWluIG5hbWUgb3IgZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBjb252ZXJ0IHRvIFVuaWNvZGUuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBVbmljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBQdW55Y29kZVxuXHQgKiBzdHJpbmcuXG5cdCAqL1xuXHRmdW5jdGlvbiB0b1VuaWNvZGUoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleFB1bnljb2RlLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/IGRlY29kZShzdHJpbmcuc2xpY2UoNCkudG9Mb3dlckNhc2UoKSlcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBVbmljb2RlIHN0cmluZyByZXByZXNlbnRpbmcgYSBkb21haW4gbmFtZSBvciBhbiBlbWFpbCBhZGRyZXNzIHRvXG5cdCAqIFB1bnljb2RlLiBPbmx5IHRoZSBub24tQVNDSUkgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHdpbGwgYmUgY29udmVydGVkLFxuXHQgKiBpLmUuIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCdzIGFscmVhZHkgaW5cblx0ICogQVNDSUkuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG8gY29udmVydCwgYXMgYVxuXHQgKiBVbmljb2RlIHN0cmluZy5cblx0ICogQHJldHVybnMge1N0cmluZ30gVGhlIFB1bnljb2RlIHJlcHJlc2VudGF0aW9uIG9mIHRoZSBnaXZlbiBkb21haW4gbmFtZSBvclxuXHQgKiBlbWFpbCBhZGRyZXNzLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9BU0NJSShpbnB1dCkge1xuXHRcdHJldHVybiBtYXBEb21haW4oaW5wdXQsIGZ1bmN0aW9uKHN0cmluZykge1xuXHRcdFx0cmV0dXJuIHJlZ2V4Tm9uQVNDSUkudGVzdChzdHJpbmcpXG5cdFx0XHRcdD8gJ3huLS0nICsgZW5jb2RlKHN0cmluZylcblx0XHRcdFx0OiBzdHJpbmc7XG5cdFx0fSk7XG5cdH1cblxuXHQvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuXHQvKiogRGVmaW5lIHRoZSBwdWJsaWMgQVBJICovXG5cdHB1bnljb2RlID0ge1xuXHRcdC8qKlxuXHRcdCAqIEEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgY3VycmVudCBQdW55Y29kZS5qcyB2ZXJzaW9uIG51bWJlci5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBTdHJpbmdcblx0XHQgKi9cblx0XHQndmVyc2lvbic6ICcxLjQuMScsXG5cdFx0LyoqXG5cdFx0ICogQW4gb2JqZWN0IG9mIG1ldGhvZHMgdG8gY29udmVydCBmcm9tIEphdmFTY3JpcHQncyBpbnRlcm5hbCBjaGFyYWN0ZXJcblx0XHQgKiByZXByZXNlbnRhdGlvbiAoVUNTLTIpIHRvIFVuaWNvZGUgY29kZSBwb2ludHMsIGFuZCBiYWNrLlxuXHRcdCAqIEBzZWUgPGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LWVuY29kaW5nPlxuXHRcdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHRcdCAqIEB0eXBlIE9iamVjdFxuXHRcdCAqL1xuXHRcdCd1Y3MyJzoge1xuXHRcdFx0J2RlY29kZSc6IHVjczJkZWNvZGUsXG5cdFx0XHQnZW5jb2RlJzogdWNzMmVuY29kZVxuXHRcdH0sXG5cdFx0J2RlY29kZSc6IGRlY29kZSxcblx0XHQnZW5jb2RlJzogZW5jb2RlLFxuXHRcdCd0b0FTQ0lJJzogdG9BU0NJSSxcblx0XHQndG9Vbmljb2RlJzogdG9Vbmljb2RlXG5cdH07XG5cblx0LyoqIEV4cG9zZSBgcHVueWNvZGVgICovXG5cdC8vIFNvbWUgQU1EIGJ1aWxkIG9wdGltaXplcnMsIGxpa2Ugci5qcywgY2hlY2sgZm9yIHNwZWNpZmljIGNvbmRpdGlvbiBwYXR0ZXJuc1xuXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XG5cdGlmIChcblx0XHR0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiZcblx0XHR0eXBlb2YgZGVmaW5lLmFtZCA9PSAnb2JqZWN0JyAmJlxuXHRcdGRlZmluZS5hbWRcblx0KSB7XG5cdFx0ZGVmaW5lKCdwdW55Y29kZScsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHB1bnljb2RlO1xuXHRcdH0pO1xuXHR9IGVsc2UgaWYgKGZyZWVFeHBvcnRzICYmIGZyZWVNb2R1bGUpIHtcblx0XHRpZiAobW9kdWxlLmV4cG9ydHMgPT0gZnJlZUV4cG9ydHMpIHtcblx0XHRcdC8vIGluIE5vZGUuanMsIGlvLmpzLCBvciBSaW5nb0pTIHYwLjguMCtcblx0XHRcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IHB1bnljb2RlO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuXHRcdFx0Zm9yIChrZXkgaW4gcHVueWNvZGUpIHtcblx0XHRcdFx0cHVueWNvZGUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAoZnJlZUV4cG9ydHNba2V5XSA9IHB1bnljb2RlW2tleV0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIHtcblx0XHQvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXG5cdFx0cm9vdC5wdW55Y29kZSA9IHB1bnljb2RlO1xuXHR9XG5cbn0odGhpcykpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gSWYgb2JqLmhhc093blByb3BlcnR5IGhhcyBiZWVuIG92ZXJyaWRkZW4sIHRoZW4gY2FsbGluZ1xuLy8gb2JqLmhhc093blByb3BlcnR5KHByb3ApIHdpbGwgYnJlYWsuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9qb3llbnQvbm9kZS9pc3N1ZXMvMTcwN1xuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihxcywgc2VwLCBlcSwgb3B0aW9ucykge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgdmFyIG9iaiA9IHt9O1xuXG4gIGlmICh0eXBlb2YgcXMgIT09ICdzdHJpbmcnIHx8IHFzLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICB2YXIgcmVnZXhwID0gL1xcKy9nO1xuICBxcyA9IHFzLnNwbGl0KHNlcCk7XG5cbiAgdmFyIG1heEtleXMgPSAxMDAwO1xuICBpZiAob3B0aW9ucyAmJiB0eXBlb2Ygb3B0aW9ucy5tYXhLZXlzID09PSAnbnVtYmVyJykge1xuICAgIG1heEtleXMgPSBvcHRpb25zLm1heEtleXM7XG4gIH1cblxuICB2YXIgbGVuID0gcXMubGVuZ3RoO1xuICAvLyBtYXhLZXlzIDw9IDAgbWVhbnMgdGhhdCB3ZSBzaG91bGQgbm90IGxpbWl0IGtleXMgY291bnRcbiAgaWYgKG1heEtleXMgPiAwICYmIGxlbiA+IG1heEtleXMpIHtcbiAgICBsZW4gPSBtYXhLZXlzO1xuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xuICAgIHZhciB4ID0gcXNbaV0ucmVwbGFjZShyZWdleHAsICclMjAnKSxcbiAgICAgICAgaWR4ID0geC5pbmRleE9mKGVxKSxcbiAgICAgICAga3N0ciwgdnN0ciwgaywgdjtcblxuICAgIGlmIChpZHggPj0gMCkge1xuICAgICAga3N0ciA9IHguc3Vic3RyKDAsIGlkeCk7XG4gICAgICB2c3RyID0geC5zdWJzdHIoaWR4ICsgMSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtzdHIgPSB4O1xuICAgICAgdnN0ciA9ICcnO1xuICAgIH1cblxuICAgIGsgPSBkZWNvZGVVUklDb21wb25lbnQoa3N0cik7XG4gICAgdiA9IGRlY29kZVVSSUNvbXBvbmVudCh2c3RyKTtcblxuICAgIGlmICghaGFzT3duUHJvcGVydHkob2JqLCBrKSkge1xuICAgICAgb2JqW2tdID0gdjtcbiAgICB9IGVsc2UgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgb2JqW2tdLnB1c2godik7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9ialtrXSA9IFtvYmpba10sIHZdO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBzdHJpbmdpZnlQcmltaXRpdmUgPSBmdW5jdGlvbih2KSB7XG4gIHN3aXRjaCAodHlwZW9mIHYpIHtcbiAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgcmV0dXJuIHY7XG5cbiAgICBjYXNlICdib29sZWFuJzpcbiAgICAgIHJldHVybiB2ID8gJ3RydWUnIDogJ2ZhbHNlJztcblxuICAgIGNhc2UgJ251bWJlcic6XG4gICAgICByZXR1cm4gaXNGaW5pdGUodikgPyB2IDogJyc7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICcnO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKG9iaiwgc2VwLCBlcSwgbmFtZSkge1xuICBzZXAgPSBzZXAgfHwgJyYnO1xuICBlcSA9IGVxIHx8ICc9JztcbiAgaWYgKG9iaiA9PT0gbnVsbCkge1xuICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgfVxuXG4gIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBtYXAob2JqZWN0S2V5cyhvYmopLCBmdW5jdGlvbihrKSB7XG4gICAgICB2YXIga3MgPSBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKGspKSArIGVxO1xuICAgICAgaWYgKGlzQXJyYXkob2JqW2tdKSkge1xuICAgICAgICByZXR1cm4gbWFwKG9ialtrXSwgZnVuY3Rpb24odikge1xuICAgICAgICAgIHJldHVybiBrcyArIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUodikpO1xuICAgICAgICB9KS5qb2luKHNlcCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9ialtrXSkpO1xuICAgICAgfVxuICAgIH0pLmpvaW4oc2VwKTtcblxuICB9XG5cbiAgaWYgKCFuYW1lKSByZXR1cm4gJyc7XG4gIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG5hbWUpKSArIGVxICtcbiAgICAgICAgIGVuY29kZVVSSUNvbXBvbmVudChzdHJpbmdpZnlQcmltaXRpdmUob2JqKSk7XG59O1xuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKHhzKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoeHMpID09PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxuZnVuY3Rpb24gbWFwICh4cywgZikge1xuICBpZiAoeHMubWFwKSByZXR1cm4geHMubWFwKGYpO1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICByZXMucHVzaChmKHhzW2ldLCBpKSk7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cblxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciByZXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpKSByZXMucHVzaChrZXkpO1xuICB9XG4gIHJldHVybiByZXM7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLmRlY29kZSA9IGV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2RlY29kZScpO1xuZXhwb3J0cy5lbmNvZGUgPSBleHBvcnRzLnN0cmluZ2lmeSA9IHJlcXVpcmUoJy4vZW5jb2RlJyk7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBub2RlL25vLWRlcHJlY2F0ZWQtYXBpICovXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcbnZhciBCdWZmZXIgPSBidWZmZXIuQnVmZmVyXG5cbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcbmZ1bmN0aW9uIGNvcHlQcm9wcyAoc3JjLCBkc3QpIHtcbiAgZm9yICh2YXIga2V5IGluIHNyYykge1xuICAgIGRzdFtrZXldID0gc3JjW2tleV1cbiAgfVxufVxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xuICBtb2R1bGUuZXhwb3J0cyA9IGJ1ZmZlclxufSBlbHNlIHtcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcbiAgY29weVByb3BzKGJ1ZmZlciwgZXhwb3J0cylcbiAgZXhwb3J0cy5CdWZmZXIgPSBTYWZlQnVmZmVyXG59XG5cbmZ1bmN0aW9uIFNhZmVCdWZmZXIgKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcbmNvcHlQcm9wcyhCdWZmZXIsIFNhZmVCdWZmZXIpXG5cblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuU2FmZUJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgdmFyIGJ1ZiA9IEJ1ZmZlcihzaXplKVxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGJ1Zi5maWxsKGZpbGwsIGVuY29kaW5nKVxuICAgIH0gZWxzZSB7XG4gICAgICBidWYuZmlsbChmaWxsKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBidWYuZmlsbCgwKVxuICB9XG4gIHJldHVybiBidWZcbn1cblxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gQnVmZmVyKHNpemUpXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBidWZmZXIuU2xvd0J1ZmZlcihzaXplKVxufVxuIiwidmFyIFN0cmVhbSA9IHJlcXVpcmUoJ3N0cmVhbScpO1xudmFyIHNvY2tqcyA9IHJlcXVpcmUoJ3NvY2tqcy1jbGllbnQnKTtcbnZhciByZXNvbHZlID0gcmVxdWlyZSgndXJsJykucmVzb2x2ZTtcbnZhciBwYXJzZSA9IHJlcXVpcmUoJ3VybCcpLnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh1LCBjYikge1xuICAgIHZhciB1cmkgPSBwYXJzZSh1KS5wcm90b2NvbCA/IHUgOiByZXNvbHZlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB1KTtcbiAgICBcbiAgICB2YXIgc3RyZWFtID0gbmV3IFN0cmVhbTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSB0cnVlO1xuICAgIHN0cmVhbS53cml0YWJsZSA9IHRydWU7XG4gICAgXG4gICAgdmFyIHJlYWR5ID0gZmFsc2U7XG4gICAgdmFyIGJ1ZmZlciA9IFtdO1xuICAgIFxuICAgIHZhciBzb2NrID0gc29ja2pzKHVyaSk7XG4gICAgc3RyZWFtLnNvY2sgPSBzb2NrO1xuICAgIFxuICAgIHN0cmVhbS53cml0ZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgaWYgKCFyZWFkeSB8fCBidWZmZXIubGVuZ3RoKSBidWZmZXIucHVzaChtc2cpXG4gICAgICAgIGVsc2Ugc29jay5zZW5kKG1zZylcbiAgICB9O1xuICAgIFxuICAgIHN0cmVhbS5lbmQgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmIChtc2cgIT09IHVuZGVmaW5lZCkgc3RyZWFtLndyaXRlKG1zZyk7XG4gICAgICAgIGlmICghcmVhZHkpIHtcbiAgICAgICAgICAgIHN0cmVhbS5fZW5kZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICBzb2NrLmNsb3NlKCk7XG4gICAgfTtcbiAgICBcbiAgICBzdHJlYW0uZGVzdHJveSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RyZWFtLl9lbmRlZCA9IHRydWU7XG4gICAgICAgIHN0cmVhbS53cml0YWJsZSA9IHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgICAgICBidWZmZXIubGVuZ3RoID0gMFxuICAgICAgICBzb2NrLmNsb3NlKCk7XG4gICAgfTtcbiAgICBcbiAgICBzb2NrLm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYiA9PT0gJ2Z1bmN0aW9uJykgY2IoKTtcbiAgICAgICAgcmVhZHkgPSB0cnVlO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJ1ZmZlci5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgc29jay5zZW5kKGJ1ZmZlcltpXSk7XG4gICAgICAgIH1cbiAgICAgICAgYnVmZmVyID0gW107XG4gICAgICAgIHN0cmVhbS5lbWl0KCdjb25uZWN0Jyk7XG4gICAgICAgIGlmIChzdHJlYW0uX2VuZGVkKSBzdHJlYW0uZW5kKCk7XG4gICAgfTtcbiAgICBcbiAgICBzb2NrLm9ubWVzc2FnZSA9IGZ1bmN0aW9uIChlKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgZS5kYXRhKTtcbiAgICB9O1xuICAgIFxuICAgIHNvY2sub25jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2VuZCcpO1xuICAgICAgICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgc3RyZWFtLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgfTtcbiAgICBcbiAgICByZXR1cm4gc3RyZWFtO1xufTtcbiIsIi8qIFNvY2tKUyBjbGllbnQsIHZlcnNpb24gMC4zLjEuNy5nYTY3Zi5kaXJ0eSwgaHR0cDovL3NvY2tqcy5vcmcsIE1JVCBMaWNlbnNlXG5cbkNvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuXG5QZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG5vZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZSBcIlNvZnR3YXJlXCIpLCB0byBkZWFsXG5pbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG50byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG5jb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0IHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXNcbmZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG5cblRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluXG5hbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cblxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG5GSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbkFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbkxJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1IgT1RIRVJXSVNFLCBBUklTSU5HIEZST00sXG5PVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOXG5USEUgU09GVFdBUkUuXG4qL1xuXG4vLyBKU09OMiBieSBEb3VnbGFzIENyb2NrZm9yZCAobWluaWZpZWQpLlxudmFyIEpTT047SlNPTnx8KEpTT049e30pLGZ1bmN0aW9uKCl7ZnVuY3Rpb24gc3RyKGEsYil7dmFyIGMsZCxlLGYsZz1nYXAsaCxpPWJbYV07aSYmdHlwZW9mIGk9PVwib2JqZWN0XCImJnR5cGVvZiBpLnRvSlNPTj09XCJmdW5jdGlvblwiJiYoaT1pLnRvSlNPTihhKSksdHlwZW9mIHJlcD09XCJmdW5jdGlvblwiJiYoaT1yZXAuY2FsbChiLGEsaSkpO3N3aXRjaCh0eXBlb2YgaSl7Y2FzZVwic3RyaW5nXCI6cmV0dXJuIHF1b3RlKGkpO2Nhc2VcIm51bWJlclwiOnJldHVybiBpc0Zpbml0ZShpKT9TdHJpbmcoaSk6XCJudWxsXCI7Y2FzZVwiYm9vbGVhblwiOmNhc2VcIm51bGxcIjpyZXR1cm4gU3RyaW5nKGkpO2Nhc2VcIm9iamVjdFwiOmlmKCFpKXJldHVyblwibnVsbFwiO2dhcCs9aW5kZW50LGg9W107aWYoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5hcHBseShpKT09PVwiW29iamVjdCBBcnJheV1cIil7Zj1pLmxlbmd0aDtmb3IoYz0wO2M8ZjtjKz0xKWhbY109c3RyKGMsaSl8fFwibnVsbFwiO2U9aC5sZW5ndGg9PT0wP1wiW11cIjpnYXA/XCJbXFxuXCIrZ2FwK2guam9pbihcIixcXG5cIitnYXApK1wiXFxuXCIrZytcIl1cIjpcIltcIitoLmpvaW4oXCIsXCIpK1wiXVwiLGdhcD1nO3JldHVybiBlfWlmKHJlcCYmdHlwZW9mIHJlcD09XCJvYmplY3RcIil7Zj1yZXAubGVuZ3RoO2ZvcihjPTA7YzxmO2MrPTEpdHlwZW9mIHJlcFtjXT09XCJzdHJpbmdcIiYmKGQ9cmVwW2NdLGU9c3RyKGQsaSksZSYmaC5wdXNoKHF1b3RlKGQpKyhnYXA/XCI6IFwiOlwiOlwiKStlKSl9ZWxzZSBmb3IoZCBpbiBpKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChpLGQpJiYoZT1zdHIoZCxpKSxlJiZoLnB1c2gocXVvdGUoZCkrKGdhcD9cIjogXCI6XCI6XCIpK2UpKTtlPWgubGVuZ3RoPT09MD9cInt9XCI6Z2FwP1wie1xcblwiK2dhcCtoLmpvaW4oXCIsXFxuXCIrZ2FwKStcIlxcblwiK2crXCJ9XCI6XCJ7XCIraC5qb2luKFwiLFwiKStcIn1cIixnYXA9ZztyZXR1cm4gZX19ZnVuY3Rpb24gcXVvdGUoYSl7ZXNjYXBhYmxlLmxhc3RJbmRleD0wO3JldHVybiBlc2NhcGFibGUudGVzdChhKT8nXCInK2EucmVwbGFjZShlc2NhcGFibGUsZnVuY3Rpb24oYSl7dmFyIGI9bWV0YVthXTtyZXR1cm4gdHlwZW9mIGI9PVwic3RyaW5nXCI/YjpcIlxcXFx1XCIrKFwiMDAwMFwiK2EuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KX0pKydcIic6J1wiJythKydcIid9ZnVuY3Rpb24gZihhKXtyZXR1cm4gYTwxMD9cIjBcIithOmF9XCJ1c2Ugc3RyaWN0XCIsdHlwZW9mIERhdGUucHJvdG90eXBlLnRvSlNPTiE9XCJmdW5jdGlvblwiJiYoRGF0ZS5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKGEpe3JldHVybiBpc0Zpbml0ZSh0aGlzLnZhbHVlT2YoKSk/dGhpcy5nZXRVVENGdWxsWWVhcigpK1wiLVwiK2YodGhpcy5nZXRVVENNb250aCgpKzEpK1wiLVwiK2YodGhpcy5nZXRVVENEYXRlKCkpK1wiVFwiK2YodGhpcy5nZXRVVENIb3VycygpKStcIjpcIitmKHRoaXMuZ2V0VVRDTWludXRlcygpKStcIjpcIitmKHRoaXMuZ2V0VVRDU2Vjb25kcygpKStcIlpcIjpudWxsfSxTdHJpbmcucHJvdG90eXBlLnRvSlNPTj1OdW1iZXIucHJvdG90eXBlLnRvSlNPTj1Cb29sZWFuLnByb3RvdHlwZS50b0pTT049ZnVuY3Rpb24oYSl7cmV0dXJuIHRoaXMudmFsdWVPZigpfSk7dmFyIGN4PS9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLGVzY2FwYWJsZT0vW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLGdhcCxpbmRlbnQsbWV0YT17XCJcXGJcIjpcIlxcXFxiXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXGZcIjpcIlxcXFxmXCIsXCJcXHJcIjpcIlxcXFxyXCIsJ1wiJzonXFxcXFwiJyxcIlxcXFxcIjpcIlxcXFxcXFxcXCJ9LHJlcDt0eXBlb2YgSlNPTi5zdHJpbmdpZnkhPVwiZnVuY3Rpb25cIiYmKEpTT04uc3RyaW5naWZ5PWZ1bmN0aW9uKGEsYixjKXt2YXIgZDtnYXA9XCJcIixpbmRlbnQ9XCJcIjtpZih0eXBlb2YgYz09XCJudW1iZXJcIilmb3IoZD0wO2Q8YztkKz0xKWluZGVudCs9XCIgXCI7ZWxzZSB0eXBlb2YgYz09XCJzdHJpbmdcIiYmKGluZGVudD1jKTtyZXA9YjtpZighYnx8dHlwZW9mIGI9PVwiZnVuY3Rpb25cInx8dHlwZW9mIGI9PVwib2JqZWN0XCImJnR5cGVvZiBiLmxlbmd0aD09XCJudW1iZXJcIilyZXR1cm4gc3RyKFwiXCIse1wiXCI6YX0pO3Rocm93IG5ldyBFcnJvcihcIkpTT04uc3RyaW5naWZ5XCIpfSksdHlwZW9mIEpTT04ucGFyc2UhPVwiZnVuY3Rpb25cIiYmKEpTT04ucGFyc2U9ZnVuY3Rpb24odGV4dCxyZXZpdmVyKXtmdW5jdGlvbiB3YWxrKGEsYil7dmFyIGMsZCxlPWFbYl07aWYoZSYmdHlwZW9mIGU9PVwib2JqZWN0XCIpZm9yKGMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxjKSYmKGQ9d2FsayhlLGMpLGQhPT11bmRlZmluZWQ/ZVtjXT1kOmRlbGV0ZSBlW2NdKTtyZXR1cm4gcmV2aXZlci5jYWxsKGEsYixlKX12YXIgajt0ZXh0PVN0cmluZyh0ZXh0KSxjeC5sYXN0SW5kZXg9MCxjeC50ZXN0KHRleHQpJiYodGV4dD10ZXh0LnJlcGxhY2UoY3gsZnVuY3Rpb24oYSl7cmV0dXJuXCJcXFxcdVwiKyhcIjAwMDBcIithLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCl9KSk7aWYoL15bXFxdLDp7fVxcc10qJC8udGVzdCh0ZXh0LnJlcGxhY2UoL1xcXFwoPzpbXCJcXFxcXFwvYmZucnRdfHVbMC05YS1mQS1GXXs0fSkvZyxcIkBcIikucmVwbGFjZSgvXCJbXlwiXFxcXFxcblxccl0qXCJ8dHJ1ZXxmYWxzZXxudWxsfC0/XFxkKyg/OlxcLlxcZCopPyg/OltlRV1bK1xcLV0/XFxkKyk/L2csXCJdXCIpLnJlcGxhY2UoLyg/Ol58OnwsKSg/OlxccypcXFspKy9nLFwiXCIpKSl7aj1ldmFsKFwiKFwiK3RleHQrXCIpXCIpO3JldHVybiB0eXBlb2YgcmV2aXZlcj09XCJmdW5jdGlvblwiP3dhbGsoe1wiXCI6an0sXCJcIik6an10aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJKU09OLnBhcnNlXCIpfSl9KClcblxuXG4vLyAgICAgWypdIEluY2x1ZGluZyBsaWIvaW5kZXguanNcbi8vIFB1YmxpYyBvYmplY3RcbnZhciBTb2NrSlMgPSAoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgdmFyIF9kb2N1bWVudCA9IGRvY3VtZW50O1xuICAgICAgICAgICAgICB2YXIgX3dpbmRvdyA9IHdpbmRvdztcbiAgICAgICAgICAgICAgdmFyIHV0aWxzID0ge307XG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9yZXZlbnR0YXJnZXQuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8qIFNpbXBsaWZpZWQgaW1wbGVtZW50YXRpb24gb2YgRE9NMiBFdmVudFRhcmdldC5cbiAqICAgaHR0cDovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTItRXZlbnRzL2V2ZW50cy5odG1sI0V2ZW50cy1FdmVudFRhcmdldFxuICovXG52YXIgUkV2ZW50VGFyZ2V0ID0gZnVuY3Rpb24oKSB7fTtcblJFdmVudFRhcmdldC5wcm90b3R5cGUuYWRkRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYoIXRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0ge307XG4gICAgfVxuICAgIGlmKCEoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpIHtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBbXTtcbiAgICB9XG4gICAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgIGlmKHV0aWxzLmFyckluZGV4T2YoYXJyLCBsaXN0ZW5lcikgPT09IC0xKSB7XG4gICAgICAgIGFyci5wdXNoKGxpc3RlbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuO1xufTtcblxuUkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5yZW1vdmVFdmVudExpc3RlbmVyID0gZnVuY3Rpb24gKGV2ZW50VHlwZSwgbGlzdGVuZXIpIHtcbiAgICBpZighKHRoaXMuX2xpc3RlbmVycyAmJiAoZXZlbnRUeXBlIGluIHRoaXMuX2xpc3RlbmVycykpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIGFyciA9IHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgIHZhciBpZHggPSB1dGlscy5hcnJJbmRleE9mKGFyciwgbGlzdGVuZXIpO1xuICAgIGlmIChpZHggIT09IC0xKSB7XG4gICAgICAgIGlmKGFyci5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXSA9IGFyci5zbGljZSgwLCBpZHgpLmNvbmNhdCggYXJyLnNsaWNlKGlkeCsxKSApO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcmV0dXJuO1xufTtcblxuUkV2ZW50VGFyZ2V0LnByb3RvdHlwZS5kaXNwYXRjaEV2ZW50ID0gZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgdmFyIHQgPSBldmVudC50eXBlO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAwKTtcbiAgICBpZiAodGhpc1snb24nK3RdKSB7XG4gICAgICAgIHRoaXNbJ29uJyt0XS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2xpc3RlbmVycyAmJiB0IGluIHRoaXMuX2xpc3RlbmVycykge1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IHRoaXMuX2xpc3RlbmVyc1t0XS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW3RdW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgICB9XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvcmV2ZW50dGFyZ2V0LmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9zaW1wbGVldmVudC5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIFNpbXBsZUV2ZW50ID0gZnVuY3Rpb24odHlwZSwgb2JqKSB7XG4gICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgZm9yKHZhciBrIGluIG9iaikge1xuICAgICAgICAgICAgaWYgKCFvYmouaGFzT3duUHJvcGVydHkoaykpIGNvbnRpbnVlO1xuICAgICAgICAgICAgdGhpc1trXSA9IG9ialtrXTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNpbXBsZUV2ZW50LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciByID0gW107XG4gICAgZm9yKHZhciBrIGluIHRoaXMpIHtcbiAgICAgICAgaWYgKCF0aGlzLmhhc093blByb3BlcnR5KGspKSBjb250aW51ZTtcbiAgICAgICAgdmFyIHYgPSB0aGlzW2tdO1xuICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdmdW5jdGlvbicpIHYgPSAnW2Z1bmN0aW9uXSc7XG4gICAgICAgIHIucHVzaChrICsgJz0nICsgdik7XG4gICAgfVxuICAgIHJldHVybiAnU2ltcGxlRXZlbnQoJyArIHIuam9pbignLCAnKSArICcpJztcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3NpbXBsZWV2ZW50LmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9ldmVudGVtaXR0ZXIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBFdmVudEVtaXR0ZXIgPSBmdW5jdGlvbihldmVudHMpIHtcbiAgICB0aGlzLmV2ZW50cyA9IGV2ZW50cyB8fCBbXTtcbn07XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICBpZiAoIXRoYXQubnVrZWQgJiYgdGhhdFsnb24nK3R5cGVdKSB7XG4gICAgICAgIHRoYXRbJ29uJyt0eXBlXS5hcHBseSh0aGF0LCBhcmdzKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmFyckluZGV4T2YodGhhdC5ldmVudHMsIHR5cGUpID09PSAtMSkge1xuICAgICAgICB1dGlscy5sb2coJ0V2ZW50ICcgKyBKU09OLnN0cmluZ2lmeSh0eXBlKSArXG4gICAgICAgICAgICAgICAgICAnIG5vdCBsaXN0ZWQgJyArIEpTT04uc3RyaW5naWZ5KHRoYXQuZXZlbnRzKSArXG4gICAgICAgICAgICAgICAgICAnIGluICcgKyB0aGF0KTtcbiAgICB9XG59O1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm51a2UgPSBmdW5jdGlvbih0eXBlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQubnVrZWQgPSB0cnVlO1xuICAgIGZvcih2YXIgaT0wOyBpPHRoYXQuZXZlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGRlbGV0ZSB0aGF0W3RoYXQuZXZlbnRzW2ldXTtcbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9ldmVudGVtaXR0ZXIuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3V0aWxzLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgcmFuZG9tX3N0cmluZ19jaGFycyA9ICdhYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlfJztcbnV0aWxzLnJhbmRvbV9zdHJpbmcgPSBmdW5jdGlvbihsZW5ndGgsIG1heCkge1xuICAgIG1heCA9IG1heCB8fCByYW5kb21fc3RyaW5nX2NoYXJzLmxlbmd0aDtcbiAgICB2YXIgaSwgcmV0ID0gW107XG4gICAgZm9yKGk9MDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJldC5wdXNoKCByYW5kb21fc3RyaW5nX2NoYXJzLnN1YnN0cihNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpLDEpICk7XG4gICAgfVxuICAgIHJldHVybiByZXQuam9pbignJyk7XG59O1xudXRpbHMucmFuZG9tX251bWJlciA9IGZ1bmN0aW9uKG1heCkge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBtYXgpO1xufTtcbnV0aWxzLnJhbmRvbV9udW1iZXJfc3RyaW5nID0gZnVuY3Rpb24obWF4KSB7XG4gICAgdmFyIHQgPSAoJycrKG1heCAtIDEpKS5sZW5ndGg7XG4gICAgdmFyIHAgPSBBcnJheSh0KzEpLmpvaW4oJzAnKTtcbiAgICByZXR1cm4gKHAgKyB1dGlscy5yYW5kb21fbnVtYmVyKG1heCkpLnNsaWNlKC10KTtcbn07XG5cbi8vIEFzc3VtaW5nIHRoYXQgdXJsIGxvb2tzIGxpa2U6IGh0dHA6Ly9hc2Rhc2Q6MTExL2FzZFxudXRpbHMuZ2V0T3JpZ2luID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdXJsICs9ICcvJztcbiAgICB2YXIgcGFydHMgPSB1cmwuc3BsaXQoJy8nKS5zbGljZSgwLCAzKTtcbiAgICByZXR1cm4gcGFydHMuam9pbignLycpO1xufTtcblxudXRpbHMuaXNTYW1lT3JpZ2luVXJsID0gZnVuY3Rpb24odXJsX2EsIHVybF9iKSB7XG4gICAgLy8gbG9jYXRpb24ub3JpZ2luIHdvdWxkIGRvLCBidXQgaXQncyBub3QgYWx3YXlzIGF2YWlsYWJsZS5cbiAgICBpZiAoIXVybF9iKSB1cmxfYiA9IF93aW5kb3cubG9jYXRpb24uaHJlZjtcblxuICAgIHJldHVybiAodXJsX2Euc3BsaXQoJy8nKS5zbGljZSgwLDMpLmpvaW4oJy8nKVxuICAgICAgICAgICAgICAgID09PVxuICAgICAgICAgICAgdXJsX2Iuc3BsaXQoJy8nKS5zbGljZSgwLDMpLmpvaW4oJy8nKSk7XG59O1xuXG51dGlscy5nZXRQYXJlbnREb21haW4gPSBmdW5jdGlvbih1cmwpIHtcbiAgICAvLyBpcHY0IGlwIGFkZHJlc3NcbiAgICBpZiAoL15bMC05Ll0qJC8udGVzdCh1cmwpKSByZXR1cm4gdXJsO1xuICAgIC8vIGlwdjYgaXAgYWRkcmVzc1xuICAgIGlmICgvXlxcWy8udGVzdCh1cmwpKSByZXR1cm4gdXJsO1xuICAgIC8vIG5vIGRvdHNcbiAgICBpZiAoISgvWy5dLy50ZXN0KHVybCkpKSByZXR1cm4gdXJsO1xuXG4gICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCcuJykuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy4nKTtcbn07XG5cbnV0aWxzLm9iamVjdEV4dGVuZCA9IGZ1bmN0aW9uKGRzdCwgc3JjKSB7XG4gICAgZm9yKHZhciBrIGluIHNyYykge1xuICAgICAgICBpZiAoc3JjLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICAgICAgICBkc3Rba10gPSBzcmNba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGRzdDtcbn07XG5cbnZhciBXUHJlZml4ID0gJ19qcCc7XG5cbnV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoIShXUHJlZml4IGluIF93aW5kb3cpKSB7XG4gICAgICAgIF93aW5kb3dbV1ByZWZpeF0gPSB7fTtcbiAgICB9XG59O1xuXG51dGlscy5jbG9zZUZyYW1lID0gZnVuY3Rpb24gKGNvZGUsIHJlYXNvbikge1xuICAgIHJldHVybiAnYycrSlNPTi5zdHJpbmdpZnkoW2NvZGUsIHJlYXNvbl0pO1xufTtcblxudXRpbHMudXNlclNldENvZGUgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHJldHVybiBjb2RlID09PSAxMDAwIHx8IChjb2RlID49IDMwMDAgJiYgY29kZSA8PSA0OTk5KTtcbn07XG5cbi8vIFNlZTogaHR0cDovL3d3dy5lcmcuYWJkbi5hYy51ay9+Z2Vycml0L2RjY3Avbm90ZXMvY2NpZDIvcnRvX2VzdGltYXRvci9cbi8vIGFuZCBSRkMgMjk4OC5cbnV0aWxzLmNvdW50UlRPID0gZnVuY3Rpb24gKHJ0dCkge1xuICAgIHZhciBydG87XG4gICAgaWYgKHJ0dCA+IDEwMCkge1xuICAgICAgICBydG8gPSAzICogcnR0OyAvLyBydG8gPiAzMDBtc2VjXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcnRvID0gcnR0ICsgMjAwOyAvLyAyMDBtc2VjIDwgcnRvIDw9IDMwMG1zZWNcbiAgICB9XG4gICAgcmV0dXJuIHJ0bztcbn1cblxudXRpbHMubG9nID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKF93aW5kb3cuY29uc29sZSAmJiBjb25zb2xlLmxvZyAmJiBjb25zb2xlLmxvZy5hcHBseSkge1xuICAgICAgICBjb25zb2xlLmxvZy5hcHBseShjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgIH1cbn07XG5cbnV0aWxzLmJpbmQgPSBmdW5jdGlvbihmdW4sIHRoYXQpIHtcbiAgICBpZiAoZnVuLmJpbmQpIHtcbiAgICAgICAgcmV0dXJuIGZ1bi5iaW5kKHRoYXQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIHJldHVybiBmdW4uYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICB9XG59O1xuXG51dGlscy5mbGF0VXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgcmV0dXJuIHVybC5pbmRleE9mKCc/JykgPT09IC0xICYmIHVybC5pbmRleE9mKCcjJykgPT09IC0xO1xufTtcblxudXRpbHMuYW1lbmRVcmwgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgZGwgPSBfZG9jdW1lbnQubG9jYXRpb247XG4gICAgaWYgKCF1cmwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdXcm9uZyB1cmwgZm9yIFNvY2tKUycpO1xuICAgIH1cbiAgICBpZiAoIXV0aWxzLmZsYXRVcmwodXJsKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ09ubHkgYmFzaWMgdXJscyBhcmUgc3VwcG9ydGVkIGluIFNvY2tKUycpO1xuICAgIH1cblxuICAgIC8vICAnLy9hYmMnIC0tPiAnaHR0cDovL2FiYydcbiAgICBpZiAodXJsLmluZGV4T2YoJy8vJykgPT09IDApIHtcbiAgICAgICAgdXJsID0gZGwucHJvdG9jb2wgKyB1cmw7XG4gICAgfVxuICAgIC8vICcvYWJjJyAtLT4gJ2h0dHA6Ly9sb2NhbGhvc3Q6ODAvYWJjJ1xuICAgIGlmICh1cmwuaW5kZXhPZignLycpID09PSAwKSB7XG4gICAgICAgIHVybCA9IGRsLnByb3RvY29sICsgJy8vJyArIGRsLmhvc3QgKyB1cmw7XG4gICAgfVxuICAgIC8vIHN0cmlwIHRyYWlsaW5nIHNsYXNoZXNcbiAgICB1cmwgPSB1cmwucmVwbGFjZSgvWy9dKyQvLCcnKTtcbiAgICByZXR1cm4gdXJsO1xufTtcblxuLy8gSUUgZG9lc24ndCBzdXBwb3J0IFtdLmluZGV4T2YuXG51dGlscy5hcnJJbmRleE9mID0gZnVuY3Rpb24oYXJyLCBvYmope1xuICAgIGZvcih2YXIgaT0wOyBpIDwgYXJyLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgaWYoYXJyW2ldID09PSBvYmope1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufTtcblxudXRpbHMuYXJyU2tpcCA9IGZ1bmN0aW9uKGFyciwgb2JqKSB7XG4gICAgdmFyIGlkeCA9IHV0aWxzLmFyckluZGV4T2YoYXJyLCBvYmopO1xuICAgIGlmIChpZHggPT09IC0xKSB7XG4gICAgICAgIHJldHVybiBhcnIuc2xpY2UoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgZHN0ID0gYXJyLnNsaWNlKDAsIGlkeCk7XG4gICAgICAgIHJldHVybiBkc3QuY29uY2F0KGFyci5zbGljZShpZHgrMSkpO1xuICAgIH1cbn07XG5cbi8vIFZpYTogaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vMTEzMzEyMi8yMTIxYzYwMWM1NTQ5MTU1NDgzZjUwYmUzZGE1MzA1ZTgzYjhjNWRmXG51dGlscy5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB7fS50b1N0cmluZy5jYWxsKHZhbHVlKS5pbmRleE9mKCdBcnJheScpID49IDBcbn07XG5cbnV0aWxzLmRlbGF5ID0gZnVuY3Rpb24odCwgZnVuKSB7XG4gICAgaWYodHlwZW9mIHQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgZnVuID0gdDtcbiAgICAgICAgdCA9IDA7XG4gICAgfVxuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgdCk7XG59O1xuXG5cbi8vIENoYXJzIHdvcnRoIGVzY2FwaW5nLCBhcyBkZWZpbmVkIGJ5IERvdWdsYXMgQ3JvY2tmb3JkOlxuLy8gICBodHRwczovL2dpdGh1Yi5jb20vZG91Z2xhc2Nyb2NrZm9yZC9KU09OLWpzL2Jsb2IvNDdhOTg4MmNkZGViMWU4NTI5ZTA3YWY5NzM2MjE4MDc1MzcyYjhhYy9qc29uMi5qcyNMMTk2XG52YXIganNvbl9lc2NhcGFibGUgPSAvW1xcXFxcXFwiXFx4MDAtXFx4MWZcXHg3Zi1cXHg5ZlxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGpzb25fbG9va3VwID0ge1xuXCJcXHUwMDAwXCI6XCJcXFxcdTAwMDBcIixcIlxcdTAwMDFcIjpcIlxcXFx1MDAwMVwiLFwiXFx1MDAwMlwiOlwiXFxcXHUwMDAyXCIsXCJcXHUwMDAzXCI6XCJcXFxcdTAwMDNcIixcblwiXFx1MDAwNFwiOlwiXFxcXHUwMDA0XCIsXCJcXHUwMDA1XCI6XCJcXFxcdTAwMDVcIixcIlxcdTAwMDZcIjpcIlxcXFx1MDAwNlwiLFwiXFx1MDAwN1wiOlwiXFxcXHUwMDA3XCIsXG5cIlxcYlwiOlwiXFxcXGJcIixcIlxcdFwiOlwiXFxcXHRcIixcIlxcblwiOlwiXFxcXG5cIixcIlxcdTAwMGJcIjpcIlxcXFx1MDAwYlwiLFwiXFxmXCI6XCJcXFxcZlwiLFwiXFxyXCI6XCJcXFxcclwiLFxuXCJcXHUwMDBlXCI6XCJcXFxcdTAwMGVcIixcIlxcdTAwMGZcIjpcIlxcXFx1MDAwZlwiLFwiXFx1MDAxMFwiOlwiXFxcXHUwMDEwXCIsXCJcXHUwMDExXCI6XCJcXFxcdTAwMTFcIixcblwiXFx1MDAxMlwiOlwiXFxcXHUwMDEyXCIsXCJcXHUwMDEzXCI6XCJcXFxcdTAwMTNcIixcIlxcdTAwMTRcIjpcIlxcXFx1MDAxNFwiLFwiXFx1MDAxNVwiOlwiXFxcXHUwMDE1XCIsXG5cIlxcdTAwMTZcIjpcIlxcXFx1MDAxNlwiLFwiXFx1MDAxN1wiOlwiXFxcXHUwMDE3XCIsXCJcXHUwMDE4XCI6XCJcXFxcdTAwMThcIixcIlxcdTAwMTlcIjpcIlxcXFx1MDAxOVwiLFxuXCJcXHUwMDFhXCI6XCJcXFxcdTAwMWFcIixcIlxcdTAwMWJcIjpcIlxcXFx1MDAxYlwiLFwiXFx1MDAxY1wiOlwiXFxcXHUwMDFjXCIsXCJcXHUwMDFkXCI6XCJcXFxcdTAwMWRcIixcblwiXFx1MDAxZVwiOlwiXFxcXHUwMDFlXCIsXCJcXHUwMDFmXCI6XCJcXFxcdTAwMWZcIixcIlxcXCJcIjpcIlxcXFxcXFwiXCIsXCJcXFxcXCI6XCJcXFxcXFxcXFwiLFxuXCJcXHUwMDdmXCI6XCJcXFxcdTAwN2ZcIixcIlxcdTAwODBcIjpcIlxcXFx1MDA4MFwiLFwiXFx1MDA4MVwiOlwiXFxcXHUwMDgxXCIsXCJcXHUwMDgyXCI6XCJcXFxcdTAwODJcIixcblwiXFx1MDA4M1wiOlwiXFxcXHUwMDgzXCIsXCJcXHUwMDg0XCI6XCJcXFxcdTAwODRcIixcIlxcdTAwODVcIjpcIlxcXFx1MDA4NVwiLFwiXFx1MDA4NlwiOlwiXFxcXHUwMDg2XCIsXG5cIlxcdTAwODdcIjpcIlxcXFx1MDA4N1wiLFwiXFx1MDA4OFwiOlwiXFxcXHUwMDg4XCIsXCJcXHUwMDg5XCI6XCJcXFxcdTAwODlcIixcIlxcdTAwOGFcIjpcIlxcXFx1MDA4YVwiLFxuXCJcXHUwMDhiXCI6XCJcXFxcdTAwOGJcIixcIlxcdTAwOGNcIjpcIlxcXFx1MDA4Y1wiLFwiXFx1MDA4ZFwiOlwiXFxcXHUwMDhkXCIsXCJcXHUwMDhlXCI6XCJcXFxcdTAwOGVcIixcblwiXFx1MDA4ZlwiOlwiXFxcXHUwMDhmXCIsXCJcXHUwMDkwXCI6XCJcXFxcdTAwOTBcIixcIlxcdTAwOTFcIjpcIlxcXFx1MDA5MVwiLFwiXFx1MDA5MlwiOlwiXFxcXHUwMDkyXCIsXG5cIlxcdTAwOTNcIjpcIlxcXFx1MDA5M1wiLFwiXFx1MDA5NFwiOlwiXFxcXHUwMDk0XCIsXCJcXHUwMDk1XCI6XCJcXFxcdTAwOTVcIixcIlxcdTAwOTZcIjpcIlxcXFx1MDA5NlwiLFxuXCJcXHUwMDk3XCI6XCJcXFxcdTAwOTdcIixcIlxcdTAwOThcIjpcIlxcXFx1MDA5OFwiLFwiXFx1MDA5OVwiOlwiXFxcXHUwMDk5XCIsXCJcXHUwMDlhXCI6XCJcXFxcdTAwOWFcIixcblwiXFx1MDA5YlwiOlwiXFxcXHUwMDliXCIsXCJcXHUwMDljXCI6XCJcXFxcdTAwOWNcIixcIlxcdTAwOWRcIjpcIlxcXFx1MDA5ZFwiLFwiXFx1MDA5ZVwiOlwiXFxcXHUwMDllXCIsXG5cIlxcdTAwOWZcIjpcIlxcXFx1MDA5ZlwiLFwiXFx1MDBhZFwiOlwiXFxcXHUwMGFkXCIsXCJcXHUwNjAwXCI6XCJcXFxcdTA2MDBcIixcIlxcdTA2MDFcIjpcIlxcXFx1MDYwMVwiLFxuXCJcXHUwNjAyXCI6XCJcXFxcdTA2MDJcIixcIlxcdTA2MDNcIjpcIlxcXFx1MDYwM1wiLFwiXFx1MDYwNFwiOlwiXFxcXHUwNjA0XCIsXCJcXHUwNzBmXCI6XCJcXFxcdTA3MGZcIixcblwiXFx1MTdiNFwiOlwiXFxcXHUxN2I0XCIsXCJcXHUxN2I1XCI6XCJcXFxcdTE3YjVcIixcIlxcdTIwMGNcIjpcIlxcXFx1MjAwY1wiLFwiXFx1MjAwZFwiOlwiXFxcXHUyMDBkXCIsXG5cIlxcdTIwMGVcIjpcIlxcXFx1MjAwZVwiLFwiXFx1MjAwZlwiOlwiXFxcXHUyMDBmXCIsXCJcXHUyMDI4XCI6XCJcXFxcdTIwMjhcIixcIlxcdTIwMjlcIjpcIlxcXFx1MjAyOVwiLFxuXCJcXHUyMDJhXCI6XCJcXFxcdTIwMmFcIixcIlxcdTIwMmJcIjpcIlxcXFx1MjAyYlwiLFwiXFx1MjAyY1wiOlwiXFxcXHUyMDJjXCIsXCJcXHUyMDJkXCI6XCJcXFxcdTIwMmRcIixcblwiXFx1MjAyZVwiOlwiXFxcXHUyMDJlXCIsXCJcXHUyMDJmXCI6XCJcXFxcdTIwMmZcIixcIlxcdTIwNjBcIjpcIlxcXFx1MjA2MFwiLFwiXFx1MjA2MVwiOlwiXFxcXHUyMDYxXCIsXG5cIlxcdTIwNjJcIjpcIlxcXFx1MjA2MlwiLFwiXFx1MjA2M1wiOlwiXFxcXHUyMDYzXCIsXCJcXHUyMDY0XCI6XCJcXFxcdTIwNjRcIixcIlxcdTIwNjVcIjpcIlxcXFx1MjA2NVwiLFxuXCJcXHUyMDY2XCI6XCJcXFxcdTIwNjZcIixcIlxcdTIwNjdcIjpcIlxcXFx1MjA2N1wiLFwiXFx1MjA2OFwiOlwiXFxcXHUyMDY4XCIsXCJcXHUyMDY5XCI6XCJcXFxcdTIwNjlcIixcblwiXFx1MjA2YVwiOlwiXFxcXHUyMDZhXCIsXCJcXHUyMDZiXCI6XCJcXFxcdTIwNmJcIixcIlxcdTIwNmNcIjpcIlxcXFx1MjA2Y1wiLFwiXFx1MjA2ZFwiOlwiXFxcXHUyMDZkXCIsXG5cIlxcdTIwNmVcIjpcIlxcXFx1MjA2ZVwiLFwiXFx1MjA2ZlwiOlwiXFxcXHUyMDZmXCIsXCJcXHVmZWZmXCI6XCJcXFxcdWZlZmZcIixcIlxcdWZmZjBcIjpcIlxcXFx1ZmZmMFwiLFxuXCJcXHVmZmYxXCI6XCJcXFxcdWZmZjFcIixcIlxcdWZmZjJcIjpcIlxcXFx1ZmZmMlwiLFwiXFx1ZmZmM1wiOlwiXFxcXHVmZmYzXCIsXCJcXHVmZmY0XCI6XCJcXFxcdWZmZjRcIixcblwiXFx1ZmZmNVwiOlwiXFxcXHVmZmY1XCIsXCJcXHVmZmY2XCI6XCJcXFxcdWZmZjZcIixcIlxcdWZmZjdcIjpcIlxcXFx1ZmZmN1wiLFwiXFx1ZmZmOFwiOlwiXFxcXHVmZmY4XCIsXG5cIlxcdWZmZjlcIjpcIlxcXFx1ZmZmOVwiLFwiXFx1ZmZmYVwiOlwiXFxcXHVmZmZhXCIsXCJcXHVmZmZiXCI6XCJcXFxcdWZmZmJcIixcIlxcdWZmZmNcIjpcIlxcXFx1ZmZmY1wiLFxuXCJcXHVmZmZkXCI6XCJcXFxcdWZmZmRcIixcIlxcdWZmZmVcIjpcIlxcXFx1ZmZmZVwiLFwiXFx1ZmZmZlwiOlwiXFxcXHVmZmZmXCJ9O1xuXG4vLyBTb21lIGV4dHJhIGNoYXJhY3RlcnMgdGhhdCBDaHJvbWUgZ2V0cyB3cm9uZywgYW5kIHN1YnN0aXR1dGVzIHdpdGhcbi8vIHNvbWV0aGluZyBlbHNlIG9uIHRoZSB3aXJlLlxudmFyIGV4dHJhX2VzY2FwYWJsZSA9IC9bXFx4MDAtXFx4MWZcXHVkODAwLVxcdWRmZmZcXHVmZmZlXFx1ZmZmZlxcdTAzMDAtXFx1MDMzM1xcdTAzM2QtXFx1MDM0NlxcdTAzNGEtXFx1MDM0Y1xcdTAzNTAtXFx1MDM1MlxcdTAzNTctXFx1MDM1OFxcdTAzNWMtXFx1MDM2MlxcdTAzNzRcXHUwMzdlXFx1MDM4N1xcdTA1OTEtXFx1MDVhZlxcdTA1YzRcXHUwNjEwLVxcdTA2MTdcXHUwNjUzLVxcdTA2NTRcXHUwNjU3LVxcdTA2NWJcXHUwNjVkLVxcdTA2NWVcXHUwNmRmLVxcdTA2ZTJcXHUwNmViLVxcdTA2ZWNcXHUwNzMwXFx1MDczMi1cXHUwNzMzXFx1MDczNS1cXHUwNzM2XFx1MDczYVxcdTA3M2RcXHUwNzNmLVxcdTA3NDFcXHUwNzQzXFx1MDc0NVxcdTA3NDdcXHUwN2ViLVxcdTA3ZjFcXHUwOTUxXFx1MDk1OC1cXHUwOTVmXFx1MDlkYy1cXHUwOWRkXFx1MDlkZlxcdTBhMzNcXHUwYTM2XFx1MGE1OS1cXHUwYTViXFx1MGE1ZVxcdTBiNWMtXFx1MGI1ZFxcdTBlMzgtXFx1MGUzOVxcdTBmNDNcXHUwZjRkXFx1MGY1MlxcdTBmNTdcXHUwZjVjXFx1MGY2OVxcdTBmNzItXFx1MGY3NlxcdTBmNzhcXHUwZjgwLVxcdTBmODNcXHUwZjkzXFx1MGY5ZFxcdTBmYTJcXHUwZmE3XFx1MGZhY1xcdTBmYjlcXHUxOTM5LVxcdTE5M2FcXHUxYTE3XFx1MWI2YlxcdTFjZGEtXFx1MWNkYlxcdTFkYzAtXFx1MWRjZlxcdTFkZmNcXHUxZGZlXFx1MWY3MVxcdTFmNzNcXHUxZjc1XFx1MWY3N1xcdTFmNzlcXHUxZjdiXFx1MWY3ZFxcdTFmYmJcXHUxZmJlXFx1MWZjOVxcdTFmY2JcXHUxZmQzXFx1MWZkYlxcdTFmZTNcXHUxZmViXFx1MWZlZS1cXHUxZmVmXFx1MWZmOVxcdTFmZmJcXHUxZmZkXFx1MjAwMC1cXHUyMDAxXFx1MjBkMC1cXHUyMGQxXFx1MjBkNC1cXHUyMGQ3XFx1MjBlNy1cXHUyMGU5XFx1MjEyNlxcdTIxMmEtXFx1MjEyYlxcdTIzMjktXFx1MjMyYVxcdTJhZGNcXHUzMDJiLVxcdTMwMmNcXHVhYWIyLVxcdWFhYjNcXHVmOTAwLVxcdWZhMGRcXHVmYTEwXFx1ZmExMlxcdWZhMTUtXFx1ZmExZVxcdWZhMjBcXHVmYTIyXFx1ZmEyNS1cXHVmYTI2XFx1ZmEyYS1cXHVmYTJkXFx1ZmEzMC1cXHVmYTZkXFx1ZmE3MC1cXHVmYWQ5XFx1ZmIxZFxcdWZiMWZcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MC1cXHVmYjQxXFx1ZmI0My1cXHVmYjQ0XFx1ZmI0Ni1cXHVmYjRlXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGV4dHJhX2xvb2t1cDtcblxuLy8gSlNPTiBRdW90ZSBzdHJpbmcuIFVzZSBuYXRpdmUgaW1wbGVtZW50YXRpb24gd2hlbiBwb3NzaWJsZS5cbnZhciBKU09OUXVvdGUgPSAoSlNPTiAmJiBKU09OLnN0cmluZ2lmeSkgfHwgZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAganNvbl9lc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZiAoanNvbl9lc2NhcGFibGUudGVzdChzdHJpbmcpKSB7XG4gICAgICAgIHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKGpzb25fZXNjYXBhYmxlLCBmdW5jdGlvbihhKSB7XG4gICAgICAgICAgICByZXR1cm4ganNvbl9sb29rdXBbYV07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gJ1wiJyArIHN0cmluZyArICdcIic7XG59O1xuXG4vLyBUaGlzIG1heSBiZSBxdWl0ZSBzbG93LCBzbyBsZXQncyBkZWxheSB1bnRpbCB1c2VyIGFjdHVhbGx5IHVzZXMgYmFkXG4vLyBjaGFyYWN0ZXJzLlxudmFyIHVucm9sbF9sb29rdXAgPSBmdW5jdGlvbihlc2NhcGFibGUpIHtcbiAgICB2YXIgaTtcbiAgICB2YXIgdW5yb2xsZWQgPSB7fVxuICAgIHZhciBjID0gW11cbiAgICBmb3IoaT0wOyBpPDY1NTM2OyBpKyspIHtcbiAgICAgICAgYy5wdXNoKCBTdHJpbmcuZnJvbUNoYXJDb2RlKGkpICk7XG4gICAgfVxuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGMuam9pbignJykucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHVucm9sbGVkWyBhIF0gPSAnXFxcXHUnICsgKCcwMDAwJyArIGEuY2hhckNvZGVBdCgwKS50b1N0cmluZygxNikpLnNsaWNlKC00KTtcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIH0pO1xuICAgIGVzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIHJldHVybiB1bnJvbGxlZDtcbn07XG5cbi8vIFF1b3RlIHN0cmluZywgYWxzbyB0YWtpbmcgY2FyZSBvZiB1bmljb2RlIGNoYXJhY3RlcnMgdGhhdCBicm93c2Vyc1xuLy8gb2Z0ZW4gYnJlYWsuIEVzcGVjaWFsbHksIHRha2UgY2FyZSBvZiB1bmljb2RlIHN1cnJvZ2F0ZXM6XG4vLyAgICBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL01hcHBpbmdfb2ZfVW5pY29kZV9jaGFyYWN0ZXJzI1N1cnJvZ2F0ZXNcbnV0aWxzLnF1b3RlID0gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgdmFyIHF1b3RlZCA9IEpTT05RdW90ZShzdHJpbmcpO1xuXG4gICAgLy8gSW4gbW9zdCBjYXNlcyB0aGlzIHNob3VsZCBiZSB2ZXJ5IGZhc3QgYW5kIGdvb2QgZW5vdWdoLlxuICAgIGV4dHJhX2VzY2FwYWJsZS5sYXN0SW5kZXggPSAwO1xuICAgIGlmKCFleHRyYV9lc2NhcGFibGUudGVzdChxdW90ZWQpKSB7XG4gICAgICAgIHJldHVybiBxdW90ZWQ7XG4gICAgfVxuXG4gICAgaWYoIWV4dHJhX2xvb2t1cCkgZXh0cmFfbG9va3VwID0gdW5yb2xsX2xvb2t1cChleHRyYV9lc2NhcGFibGUpO1xuXG4gICAgcmV0dXJuIHF1b3RlZC5yZXBsYWNlKGV4dHJhX2VzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgICByZXR1cm4gZXh0cmFfbG9va3VwW2FdO1xuICAgIH0pO1xufVxuXG52YXIgX2FsbF9wcm90b2NvbHMgPSBbJ3dlYnNvY2tldCcsXG4gICAgICAgICAgICAgICAgICAgICAgJ3hkci1zdHJlYW1pbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICd4aHItc3RyZWFtaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLWV2ZW50c291cmNlJyxcbiAgICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLWh0bWxmaWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAneGRyLXBvbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICd4aHItcG9sbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS14aHItcG9sbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ2pzb25wLXBvbGxpbmcnXTtcblxudXRpbHMucHJvYmVQcm90b2NvbHMgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvYmVkID0ge307XG4gICAgZm9yKHZhciBpPTA7IGk8X2FsbF9wcm90b2NvbHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHByb3RvY29sID0gX2FsbF9wcm90b2NvbHNbaV07XG4gICAgICAgIC8vIFVzZXIgY2FuIGhhdmUgYSB0eXBvIGluIHByb3RvY29sIG5hbWUuXG4gICAgICAgIHByb2JlZFtwcm90b2NvbF0gPSBTb2NrSlNbcHJvdG9jb2xdICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBTb2NrSlNbcHJvdG9jb2xdLmVuYWJsZWQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHByb2JlZDtcbn07XG5cbnV0aWxzLmRldGVjdFByb3RvY29scyA9IGZ1bmN0aW9uKHByb2JlZCwgcHJvdG9jb2xzX3doaXRlbGlzdCwgaW5mbykge1xuICAgIHZhciBwZSA9IHt9LFxuICAgICAgICBwcm90b2NvbHMgPSBbXTtcbiAgICBpZiAoIXByb3RvY29sc193aGl0ZWxpc3QpIHByb3RvY29sc193aGl0ZWxpc3QgPSBfYWxsX3Byb3RvY29scztcbiAgICBmb3IodmFyIGk9MDsgaTxwcm90b2NvbHNfd2hpdGVsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm90b2NvbCA9IHByb3RvY29sc193aGl0ZWxpc3RbaV07XG4gICAgICAgIHBlW3Byb3RvY29sXSA9IHByb2JlZFtwcm90b2NvbF07XG4gICAgfVxuICAgIHZhciBtYXliZV9wdXNoID0gZnVuY3Rpb24ocHJvdG9zKSB7XG4gICAgICAgIHZhciBwcm90byA9IHByb3Rvcy5zaGlmdCgpO1xuICAgICAgICBpZiAocGVbcHJvdG9dKSB7XG4gICAgICAgICAgICBwcm90b2NvbHMucHVzaChwcm90byk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBpZiAocHJvdG9zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBtYXliZV9wdXNoKHByb3Rvcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyAxLiBXZWJzb2NrZXRcbiAgICBpZiAoaW5mby53ZWJzb2NrZXQgIT09IGZhbHNlKSB7XG4gICAgICAgIG1heWJlX3B1c2goWyd3ZWJzb2NrZXQnXSk7XG4gICAgfVxuXG4gICAgLy8gMi4gU3RyZWFtaW5nXG4gICAgaWYgKHBlWyd4aHItc3RyZWFtaW5nJ10gJiYgIWluZm8ubnVsbF9vcmlnaW4pIHtcbiAgICAgICAgcHJvdG9jb2xzLnB1c2goJ3hoci1zdHJlYW1pbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGVbJ3hkci1zdHJlYW1pbmcnXSAmJiAhaW5mby5jb29raWVfbmVlZGVkICYmICFpbmZvLm51bGxfb3JpZ2luKSB7XG4gICAgICAgICAgICBwcm90b2NvbHMucHVzaCgneGRyLXN0cmVhbWluZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF5YmVfcHVzaChbJ2lmcmFtZS1ldmVudHNvdXJjZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnaWZyYW1lLWh0bWxmaWxlJ10pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gMy4gUG9sbGluZ1xuICAgIGlmIChwZVsneGhyLXBvbGxpbmcnXSAmJiAhaW5mby5udWxsX29yaWdpbikge1xuICAgICAgICBwcm90b2NvbHMucHVzaCgneGhyLXBvbGxpbmcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocGVbJ3hkci1wb2xsaW5nJ10gJiYgIWluZm8uY29va2llX25lZWRlZCAmJiAhaW5mby5udWxsX29yaWdpbikge1xuICAgICAgICAgICAgcHJvdG9jb2xzLnB1c2goJ3hkci1wb2xsaW5nJyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBtYXliZV9wdXNoKFsnaWZyYW1lLXhoci1wb2xsaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdqc29ucC1wb2xsaW5nJ10pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm90b2NvbHM7XG59XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3V0aWxzLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9kb20uanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIE1heSBiZSB1c2VkIGJ5IGh0bWxmaWxlIGpzb25wIGFuZCB0cmFuc3BvcnRzLlxudmFyIE1QcmVmaXggPSAnX3NvY2tqc19nbG9iYWwnO1xudXRpbHMuY3JlYXRlSG9vayA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB3aW5kb3dfaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIGlmICghKE1QcmVmaXggaW4gX3dpbmRvdykpIHtcbiAgICAgICAgdmFyIG1hcCA9IHt9O1xuICAgICAgICBfd2luZG93W01QcmVmaXhdID0gZnVuY3Rpb24od2luZG93X2lkKSB7XG4gICAgICAgICAgICBpZiAoISh3aW5kb3dfaWQgaW4gbWFwKSkge1xuICAgICAgICAgICAgICAgIG1hcFt3aW5kb3dfaWRdID0ge1xuICAgICAgICAgICAgICAgICAgICBpZDogd2luZG93X2lkLFxuICAgICAgICAgICAgICAgICAgICBkZWw6IGZ1bmN0aW9uKCkge2RlbGV0ZSBtYXBbd2luZG93X2lkXTt9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBtYXBbd2luZG93X2lkXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX3dpbmRvd1tNUHJlZml4XSh3aW5kb3dfaWQpO1xufTtcblxuXG5cbnV0aWxzLmF0dGFjaE1lc3NhZ2UgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdtZXNzYWdlJywgbGlzdGVuZXIpO1xufTtcbnV0aWxzLmF0dGFjaEV2ZW50ID0gZnVuY3Rpb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgaWYgKHR5cGVvZiBfd2luZG93LmFkZEV2ZW50TGlzdGVuZXIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIF93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBJRSBxdWlya3MuXG4gICAgICAgIC8vIEFjY29yZGluZyB0bzogaHR0cDovL3N0ZXZlc291ZGVycy5jb20vbWlzYy90ZXN0LXBvc3RtZXNzYWdlLnBocFxuICAgICAgICAvLyB0aGUgbWVzc2FnZSBnZXRzIGRlbGl2ZXJlZCBvbmx5IHRvICdkb2N1bWVudCcsIG5vdCAnd2luZG93Jy5cbiAgICAgICAgX2RvY3VtZW50LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIC8vIEkgZ2V0ICd3aW5kb3cnIGZvciBpZTguXG4gICAgICAgIF93aW5kb3cuYXR0YWNoRXZlbnQoXCJvblwiICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG59O1xuXG51dGlscy5kZXRhY2hNZXNzYWdlID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB1dGlscy5kZXRhY2hFdmVudCgnbWVzc2FnZScsIGxpc3RlbmVyKTtcbn07XG51dGlscy5kZXRhY2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgX3dpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgX2RvY3VtZW50LmRldGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIF93aW5kb3cuZGV0YWNoRXZlbnQoXCJvblwiICsgZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9XG59O1xuXG5cbnZhciBvbl91bmxvYWQgPSB7fTtcbi8vIFRoaW5ncyByZWdpc3RlcmVkIGFmdGVyIGJlZm9yZXVubG9hZCBhcmUgdG8gYmUgY2FsbGVkIGltbWVkaWF0ZWx5LlxudmFyIGFmdGVyX3VubG9hZCA9IGZhbHNlO1xuXG52YXIgdHJpZ2dlcl91bmxvYWRfY2FsbGJhY2tzID0gZnVuY3Rpb24oKSB7XG4gICAgZm9yKHZhciByZWYgaW4gb25fdW5sb2FkKSB7XG4gICAgICAgIG9uX3VubG9hZFtyZWZdKCk7XG4gICAgICAgIGRlbGV0ZSBvbl91bmxvYWRbcmVmXTtcbiAgICB9O1xufTtcblxudmFyIHVubG9hZF90cmlnZ2VyZWQgPSBmdW5jdGlvbigpIHtcbiAgICBpZihhZnRlcl91bmxvYWQpIHJldHVybjtcbiAgICBhZnRlcl91bmxvYWQgPSB0cnVlO1xuICAgIHRyaWdnZXJfdW5sb2FkX2NhbGxiYWNrcygpO1xufTtcblxuLy8gT25iZWZvcmV1bmxvYWQgYWxvbmUgaXMgbm90IHJlbGlhYmxlLiBXZSBjb3VsZCB1c2Ugb25seSAndW5sb2FkJ1xuLy8gYnV0IGl0J3Mgbm90IHdvcmtpbmcgaW4gb3BlcmEgd2l0aGluIGFuIGlmcmFtZS4gTGV0J3MgdXNlIGJvdGguXG51dGlscy5hdHRhY2hFdmVudCgnYmVmb3JldW5sb2FkJywgdW5sb2FkX3RyaWdnZXJlZCk7XG51dGlscy5hdHRhY2hFdmVudCgndW5sb2FkJywgdW5sb2FkX3RyaWdnZXJlZCk7XG5cbnV0aWxzLnVubG9hZF9hZGQgPSBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgIHZhciByZWYgPSB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIG9uX3VubG9hZFtyZWZdID0gbGlzdGVuZXI7XG4gICAgaWYgKGFmdGVyX3VubG9hZCkge1xuICAgICAgICB1dGlscy5kZWxheSh0cmlnZ2VyX3VubG9hZF9jYWxsYmFja3MpO1xuICAgIH1cbiAgICByZXR1cm4gcmVmO1xufTtcbnV0aWxzLnVubG9hZF9kZWwgPSBmdW5jdGlvbihyZWYpIHtcbiAgICBpZiAocmVmIGluIG9uX3VubG9hZClcbiAgICAgICAgZGVsZXRlIG9uX3VubG9hZFtyZWZdO1xufTtcblxuXG51dGlscy5jcmVhdGVJZnJhbWUgPSBmdW5jdGlvbiAoaWZyYW1lX3VybCwgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgaWZyYW1lID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRfcmVmO1xuICAgIHZhciB1bmF0dGFjaCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIC8vIEV4cGxvcmVyIGhhZCBwcm9ibGVtcyB3aXRoIHRoYXQuXG4gICAgICAgIHRyeSB7aWZyYW1lLm9ubG9hZCA9IG51bGw7fSBjYXRjaCAoeCkge31cbiAgICAgICAgaWZyYW1lLm9uZXJyb3IgPSBudWxsO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgICAgIC8vIFRoaXMgdGltZW91dCBtYWtlcyBjaHJvbWUgZmlyZSBvbmJlZm9yZXVubG9hZCBldmVudFxuICAgICAgICAgICAgLy8gd2l0aGluIGlmcmFtZS4gV2l0aG91dCB0aGUgdGltZW91dCBpdCBnb2VzIHN0cmFpZ2h0IHRvXG4gICAgICAgICAgICAvLyBvbnVubG9hZC5cbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYoaWZyYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmcmFtZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKGlmcmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmcmFtZSA9IG51bGw7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIHV0aWxzLnVubG9hZF9kZWwodW5sb2FkX3JlZik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikge1xuICAgICAgICBpZiAoaWZyYW1lKSB7XG4gICAgICAgICAgICBjbGVhbnVwKCk7XG4gICAgICAgICAgICBlcnJvcl9jYWxsYmFjayhyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdmFyIHBvc3QgPSBmdW5jdGlvbihtc2csIG9yaWdpbikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICAgIGlmIChpZnJhbWUgJiYgaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICBpZnJhbWUuY29udGVudFdpbmRvdy5wb3N0TWVzc2FnZShtc2csIG9yaWdpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHt9O1xuICAgIH07XG5cbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lX3VybDtcbiAgICBpZnJhbWUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICBpZnJhbWUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgIGlmcmFtZS5vbmVycm9yID0gZnVuY3Rpb24oKXtvbmVycm9yKCdvbmVycm9yJyk7fTtcbiAgICBpZnJhbWUub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIGBvbmxvYWRgIGlzIHRyaWdnZXJlZCBiZWZvcmUgc2NyaXB0cyBvbiB0aGUgaWZyYW1lIGFyZVxuICAgICAgICAvLyBleGVjdXRlZC4gR2l2ZSBpdCBmZXcgc2Vjb25kcyB0byBhY3R1YWxseSBsb2FkIHN0dWZmLlxuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25lcnJvcignb25sb2FkIHRpbWVvdXQnKTt9LCAyMDAwKTtcbiAgICB9O1xuICAgIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKXtvbmVycm9yKCd0aW1lb3V0Jyk7fSwgMTUwMDApO1xuICAgIHVubG9hZF9yZWYgPSB1dGlscy51bmxvYWRfYWRkKGNsZWFudXApO1xuICAgIHJldHVybiB7XG4gICAgICAgIHBvc3Q6IHBvc3QsXG4gICAgICAgIGNsZWFudXA6IGNsZWFudXAsXG4gICAgICAgIGxvYWRlZDogdW5hdHRhY2hcbiAgICB9O1xufTtcblxudXRpbHMuY3JlYXRlSHRtbGZpbGUgPSBmdW5jdGlvbiAoaWZyYW1lX3VybCwgZXJyb3JfY2FsbGJhY2spIHtcbiAgICB2YXIgZG9jID0gbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgdmFyIHRyZWYsIHVubG9hZF9yZWY7XG4gICAgdmFyIGlmcmFtZTtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgIH07XG4gICAgdmFyIGNsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgdW5hdHRhY2goKTtcbiAgICAgICAgICAgIHV0aWxzLnVubG9hZF9kZWwodW5sb2FkX3JlZik7XG4gICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgaWZyYW1lID0gZG9jID0gbnVsbDtcbiAgICAgICAgICAgIENvbGxlY3RHYXJiYWdlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBvbmVycm9yID0gZnVuY3Rpb24ocikgIHtcbiAgICAgICAgaWYgKGRvYykge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZXJyb3JfY2FsbGJhY2socik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh4KSB7fTtcbiAgICB9O1xuXG4gICAgZG9jLm9wZW4oKTtcbiAgICBkb2Mud3JpdGUoJzxodG1sPjxzJyArICdjcmlwdD4nICtcbiAgICAgICAgICAgICAgJ2RvY3VtZW50LmRvbWFpbj1cIicgKyBkb2N1bWVudC5kb21haW4gKyAnXCI7JyArXG4gICAgICAgICAgICAgICc8L3MnICsgJ2NyaXB0PjwvaHRtbD4nKTtcbiAgICBkb2MuY2xvc2UoKTtcbiAgICBkb2MucGFyZW50V2luZG93W1dQcmVmaXhdID0gX3dpbmRvd1tXUHJlZml4XTtcbiAgICB2YXIgYyA9IGRvYy5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBkb2MuYm9keS5hcHBlbmRDaGlsZChjKTtcbiAgICBpZnJhbWUgPSBkb2MuY3JlYXRlRWxlbWVudCgnaWZyYW1lJyk7XG4gICAgYy5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zcmMgPSBpZnJhbWVfdXJsO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25lcnJvcigndGltZW91dCcpO30sIDE1MDAwKTtcbiAgICB1bmxvYWRfcmVmID0gdXRpbHMudW5sb2FkX2FkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3N0OiBwb3N0LFxuICAgICAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgICAgICBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL2RvbS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvZG9tMi5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEFic3RyYWN0WEhST2JqZWN0ID0gZnVuY3Rpb24oKXt9O1xuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2NodW5rJywgJ2ZpbmlzaCddKTtcblxuQWJzdHJhY3RYSFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkLCBvcHRzKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgdGhhdC54aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB9IGNhdGNoKHgpIHt9O1xuXG4gICAgaWYgKCF0aGF0Lnhocikge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhhdC54aHIgPSBuZXcgX3dpbmRvdy5BY3RpdmVYT2JqZWN0KCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuICAgICAgICB9IGNhdGNoKHgpIHt9O1xuICAgIH1cbiAgICBpZiAoX3dpbmRvdy5BY3RpdmVYT2JqZWN0IHx8IF93aW5kb3cuWERvbWFpblJlcXVlc3QpIHtcbiAgICAgICAgLy8gSUU4IGNhY2hlcyBldmVuIFBPU1RzXG4gICAgICAgIHVybCArPSAoKHVybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyAndD0nKygrbmV3IERhdGUpO1xuICAgIH1cblxuICAgIC8vIEV4cGxvcmVyIHRlbmRzIHRvIGtlZXAgY29ubmVjdGlvbiBvcGVuLCBldmVuIGFmdGVyIHRoZVxuICAgIC8vIHRhYiBnZXRzIGNsb3NlZDogaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNTI4MFxuICAgIHRoYXQudW5sb2FkX3JlZiA9IHV0aWxzLnVubG9hZF9hZGQoZnVuY3Rpb24oKXt0aGF0Ll9jbGVhbnVwKHRydWUpO30pO1xuICAgIHRyeSB7XG4gICAgICAgIHRoYXQueGhyLm9wZW4obWV0aG9kLCB1cmwsIHRydWUpO1xuICAgIH0gY2F0Y2goZSkge1xuICAgICAgICAvLyBJRSByYWlzZXMgYW4gZXhjZXB0aW9uIG9uIHdyb25nIHBvcnQuXG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICB0aGF0Ll9jbGVhbnVwKCk7XG4gICAgICAgIHJldHVybjtcbiAgICB9O1xuXG4gICAgaWYgKCFvcHRzIHx8ICFvcHRzLm5vX2NyZWRlbnRpYWxzKSB7XG4gICAgICAgIC8vIE1vemlsbGEgZG9jcyBzYXlzIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL1hNTEh0dHBSZXF1ZXN0IDpcbiAgICAgICAgLy8gXCJUaGlzIG5ldmVyIGFmZmVjdHMgc2FtZS1zaXRlIHJlcXVlc3RzLlwiXG4gICAgICAgIHRoYXQueGhyLndpdGhDcmVkZW50aWFscyA9ICd0cnVlJztcbiAgICB9XG4gICAgaWYgKG9wdHMgJiYgb3B0cy5oZWFkZXJzKSB7XG4gICAgICAgIGZvcih2YXIga2V5IGluIG9wdHMuaGVhZGVycykge1xuICAgICAgICAgICAgdGhhdC54aHIuc2V0UmVxdWVzdEhlYWRlcihrZXksIG9wdHMuaGVhZGVyc1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHRoYXQueGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAodGhhdC54aHIpIHtcbiAgICAgICAgICAgIHZhciB4ID0gdGhhdC54aHI7XG4gICAgICAgICAgICBzd2l0Y2ggKHgucmVhZHlTdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgICAgIC8vIElFIGRvZXNuJ3QgbGlrZSBwZWVraW5nIGludG8gcmVzcG9uc2VUZXh0IG9yIHN0YXR1c1xuICAgICAgICAgICAgICAgIC8vIG9uIE1pY3Jvc29mdC5YTUxIVFRQIGFuZCByZWFkeXN0YXRlPTNcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3RhdHVzID0geC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIHZhciB0ZXh0ID0geC5yZXNwb25zZVRleHQ7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoeCkge307XG4gICAgICAgICAgICAgICAgLy8gSUUgZG9lcyByZXR1cm4gcmVhZHlzdGF0ZSA9PSAzIGZvciA0MDQgYW5zd2Vycy5cbiAgICAgICAgICAgICAgICBpZiAodGV4dCAmJiB0ZXh0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhhdC5lbWl0KCdjaHVuaycsIHN0YXR1cywgdGV4dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0OlxuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgeC5zdGF0dXMsIHgucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICB0aGF0Ll9jbGVhbnVwKGZhbHNlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC54aHIuc2VuZChwYXlsb2FkKTtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fY2xlYW51cCA9IGZ1bmN0aW9uKGFib3J0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICghdGhhdC54aHIpIHJldHVybjtcbiAgICB1dGlscy51bmxvYWRfZGVsKHRoYXQudW5sb2FkX3JlZik7XG5cbiAgICAvLyBJRSBuZWVkcyB0aGlzIGZpZWxkIHRvIGJlIGEgZnVuY3Rpb25cbiAgICB0aGF0Lnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpe307XG5cbiAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoYXQueGhyLmFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2goeCkge307XG4gICAgfVxuICAgIHRoYXQudW5sb2FkX3JlZiA9IHRoYXQueGhyID0gbnVsbDtcbn07XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lm51a2UoKTtcbiAgICB0aGF0Ll9jbGVhbnVwKHRydWUpO1xufTtcblxudmFyIFhIUkNvcnNPYmplY3QgPSB1dGlscy5YSFJDb3JzT2JqZWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzLCBhcmdzID0gYXJndW1lbnRzO1xuICAgIHV0aWxzLmRlbGF5KGZ1bmN0aW9uKCl7dGhhdC5fc3RhcnQuYXBwbHkodGhhdCwgYXJncyk7fSk7XG59O1xuWEhSQ29yc09iamVjdC5wcm90b3R5cGUgPSBuZXcgQWJzdHJhY3RYSFJPYmplY3QoKTtcblxudmFyIFhIUkxvY2FsT2JqZWN0ID0gdXRpbHMuWEhSTG9jYWxPYmplY3QgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB1dGlscy5kZWxheShmdW5jdGlvbigpe1xuICAgICAgICB0aGF0Ll9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCwge1xuICAgICAgICAgICAgbm9fY3JlZGVudGlhbHM6IHRydWVcbiAgICAgICAgfSk7XG4gICAgfSk7XG59O1xuWEhSTG9jYWxPYmplY3QucHJvdG90eXBlID0gbmV3IEFic3RyYWN0WEhST2JqZWN0KCk7XG5cblxuXG4vLyBSZWZlcmVuY2VzOlxuLy8gICBodHRwOi8vYWpheGlhbi5jb20vYXJjaGl2ZXMvMTAwLWxpbmUtYWpheC13cmFwcGVyXG4vLyAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzI4ODA2MCh2PVZTLjg1KS5hc3B4XG52YXIgWERST2JqZWN0ID0gdXRpbHMuWERST2JqZWN0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKXt0aGF0Ll9zdGFydChtZXRob2QsIHVybCwgcGF5bG9hZCk7fSk7XG59O1xuWERST2JqZWN0LnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoWydjaHVuaycsICdmaW5pc2gnXSk7XG5YRFJPYmplY3QucHJvdG90eXBlLl9zdGFydCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB4ZHIgPSBuZXcgWERvbWFpblJlcXVlc3QoKTtcbiAgICAvLyBJRSBjYWNoZXMgZXZlbiBQT1NUc1xuICAgIHVybCArPSAoKHVybC5pbmRleE9mKCc/JykgPT09IC0xKSA/ICc/JyA6ICcmJykgKyAndD0nKygrbmV3IERhdGUpO1xuXG4gICAgdmFyIG9uZXJyb3IgPSB4ZHIub250aW1lb3V0ID0geGRyLm9uZXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnLCAwLCAnJyk7XG4gICAgICAgIHRoYXQuX2NsZWFudXAoZmFsc2UpO1xuICAgIH07XG4gICAgeGRyLm9ucHJvZ3Jlc3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5lbWl0KCdjaHVuaycsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgfTtcbiAgICB4ZHIub25sb2FkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgMjAwLCB4ZHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgdGhhdC5fY2xlYW51cChmYWxzZSk7XG4gICAgfTtcbiAgICB0aGF0LnhkciA9IHhkcjtcbiAgICB0aGF0LnVubG9hZF9yZWYgPSB1dGlscy51bmxvYWRfYWRkKGZ1bmN0aW9uKCl7dGhhdC5fY2xlYW51cCh0cnVlKTt9KTtcbiAgICB0cnkge1xuICAgICAgICAvLyBGYWlscyB3aXRoIEFjY2Vzc0RlbmllZCBpZiBwb3J0IG51bWJlciBpcyBib2d1c1xuICAgICAgICB0aGF0Lnhkci5vcGVuKG1ldGhvZCwgdXJsKTtcbiAgICAgICAgdGhhdC54ZHIuc2VuZChwYXlsb2FkKTtcbiAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgb25lcnJvcigpO1xuICAgIH1cbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAoIXRoYXQueGRyKSByZXR1cm47XG4gICAgdXRpbHMudW5sb2FkX2RlbCh0aGF0LnVubG9hZF9yZWYpO1xuXG4gICAgdGhhdC54ZHIub250aW1lb3V0ID0gdGhhdC54ZHIub25lcnJvciA9IHRoYXQueGRyLm9ucHJvZ3Jlc3MgPVxuICAgICAgICB0aGF0Lnhkci5vbmxvYWQgPSBudWxsO1xuICAgIGlmIChhYm9ydCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhhdC54ZHIuYWJvcnQoKTtcbiAgICAgICAgfSBjYXRjaCh4KSB7fTtcbiAgICB9XG4gICAgdGhhdC51bmxvYWRfcmVmID0gdGhhdC54ZHIgPSBudWxsO1xufTtcblxuWERST2JqZWN0LnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lm51a2UoKTtcbiAgICB0aGF0Ll9jbGVhbnVwKHRydWUpO1xufTtcblxuLy8gMS4gSXMgbmF0aXZlbHkgdmlhIFhIUlxuLy8gMi4gSXMgbmF0aXZlbHkgdmlhIFhEUlxuLy8gMy4gTm9wZSwgYnV0IHBvc3RNZXNzYWdlIGlzIHRoZXJlIHNvIGl0IHNob3VsZCB3b3JrIHZpYSB0aGUgSWZyYW1lLlxuLy8gNC4gTm9wZSwgc29ycnkuXG51dGlscy5pc1hIUkNvcnNDYXBhYmxlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKF93aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCkpIHtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIFhEb21haW5SZXF1ZXN0IGRvZXNuJ3Qgd29yayBpZiBwYWdlIGlzIHNlcnZlZCBmcm9tIGZpbGU6Ly9cbiAgICBpZiAoX3dpbmRvdy5YRG9tYWluUmVxdWVzdCAmJiBfZG9jdW1lbnQuZG9tYWluKSB7XG4gICAgICAgIHJldHVybiAyO1xuICAgIH1cbiAgICBpZiAoSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKSkge1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgcmV0dXJuIDQ7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9kb20yLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9zb2NranMuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBTb2NrSlMgPSBmdW5jdGlvbih1cmwsIGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0LCBvcHRpb25zKSB7XG4gICAgaWYgKHRoaXMgPT09IHdpbmRvdykge1xuICAgICAgICAvLyBtYWtlcyBgbmV3YCBvcHRpb25hbFxuICAgICAgICByZXR1cm4gbmV3IFNvY2tKUyh1cmwsIGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0LCBvcHRpb25zKTtcbiAgICB9XG4gICAgXG4gICAgdmFyIHRoYXQgPSB0aGlzLCBwcm90b2NvbHNfd2hpdGVsaXN0O1xuICAgIHRoYXQuX29wdGlvbnMgPSB7ZGV2ZWw6IGZhbHNlLCBkZWJ1ZzogZmFsc2UsIHByb3RvY29sc193aGl0ZWxpc3Q6IFtdLFxuICAgICAgICAgICAgICAgICAgICAgaW5mbzogdW5kZWZpbmVkLCBydHQ6IHVuZGVmaW5lZH07XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgICAgdXRpbHMub2JqZWN0RXh0ZW5kKHRoYXQuX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aGF0Ll9iYXNlX3VybCA9IHV0aWxzLmFtZW5kVXJsKHVybCk7XG4gICAgdGhhdC5fc2VydmVyID0gdGhhdC5fb3B0aW9ucy5zZXJ2ZXIgfHwgdXRpbHMucmFuZG9tX251bWJlcl9zdHJpbmcoMTAwMCk7XG4gICAgaWYgKHRoYXQuX29wdGlvbnMucHJvdG9jb2xzX3doaXRlbGlzdCAmJlxuICAgICAgICB0aGF0Ll9vcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QubGVuZ3RoKSB7XG4gICAgICAgIHByb3RvY29sc193aGl0ZWxpc3QgPSB0aGF0Ll9vcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3Q7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVwcmVjYXRlZCBBUElcbiAgICAgICAgaWYgKHR5cGVvZiBkZXBfcHJvdG9jb2xzX3doaXRlbGlzdCA9PT0gJ3N0cmluZycgJiZcbiAgICAgICAgICAgIGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0Lmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHByb3RvY29sc193aGl0ZWxpc3QgPSBbZGVwX3Byb3RvY29sc193aGl0ZWxpc3RdO1xuICAgICAgICB9IGVsc2UgaWYgKHV0aWxzLmlzQXJyYXkoZGVwX3Byb3RvY29sc193aGl0ZWxpc3QpKSB7XG4gICAgICAgICAgICBwcm90b2NvbHNfd2hpdGVsaXN0ID0gZGVwX3Byb3RvY29sc193aGl0ZWxpc3RcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHByb3RvY29sc193aGl0ZWxpc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgICAgICAgICB0aGF0Ll9kZWJ1ZygnRGVwcmVjYXRlZCBBUEk6IFVzZSBcInByb3RvY29sc193aGl0ZWxpc3RcIiBvcHRpb24gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaW5zdGVhZCBvZiBzdXBwbHlpbmcgcHJvdG9jb2wgbGlzdCBhcyBhIHNlY29uZCAnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdwYXJhbWV0ZXIgdG8gU29ja0pTIGNvbnN0cnVjdG9yLicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHRoYXQuX3Byb3RvY29scyA9IFtdO1xuICAgIHRoYXQucHJvdG9jb2wgPSBudWxsO1xuICAgIHRoYXQucmVhZHlTdGF0ZSA9IFNvY2tKUy5DT05ORUNUSU5HO1xuICAgIHRoYXQuX2lyID0gY3JlYXRlSW5mb1JlY2VpdmVyKHRoYXQuX2Jhc2VfdXJsKTtcbiAgICB0aGF0Ll9pci5vbmZpbmlzaCA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgICAgICB0aGF0Ll9pciA9IG51bGw7XG4gICAgICAgIGlmIChpbmZvKSB7XG4gICAgICAgICAgICBpZiAodGhhdC5fb3B0aW9ucy5pbmZvKSB7XG4gICAgICAgICAgICAgICAgLy8gT3ZlcnJpZGUgaWYgdXNlciBzdXBwbGllcyB0aGUgb3B0aW9uXG4gICAgICAgICAgICAgICAgaW5mbyA9IHV0aWxzLm9iamVjdEV4dGVuZChpbmZvLCB0aGF0Ll9vcHRpb25zLmluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoYXQuX29wdGlvbnMucnR0KSB7XG4gICAgICAgICAgICAgICAgcnR0ID0gdGhhdC5fb3B0aW9ucy5ydHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGF0Ll9hcHBseUluZm8oaW5mbywgcnR0LCBwcm90b2NvbHNfd2hpdGVsaXN0KTtcbiAgICAgICAgICAgIHRoYXQuX2RpZENsb3NlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0Ll9kaWRDbG9zZSgxMDAyLCAnQ2FuXFwndCBjb25uZWN0IHRvIHNlcnZlcicsIHRydWUpO1xuICAgICAgICB9XG4gICAgfTtcbn07XG4vLyBJbmhlcml0YW5jZVxuU29ja0pTLnByb3RvdHlwZSA9IG5ldyBSRXZlbnRUYXJnZXQoKTtcblxuU29ja0pTLnZlcnNpb24gPSBcIjAuMy4xLjcuZ2E2N2YuZGlydHlcIjtcblxuU29ja0pTLkNPTk5FQ1RJTkcgPSAwO1xuU29ja0pTLk9QRU4gPSAxO1xuU29ja0pTLkNMT1NJTkcgPSAyO1xuU29ja0pTLkNMT1NFRCA9IDM7XG5cblNvY2tKUy5wcm90b3R5cGUuX2RlYnVnID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZGVidWcpXG4gICAgICAgIHV0aWxzLmxvZy5hcHBseSh1dGlscywgYXJndW1lbnRzKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Rpc3BhdGNoT3BlbiA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORykge1xuICAgICAgICBpZiAodGhhdC5fdHJhbnNwb3J0X3RyZWYpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGF0Ll90cmFuc3BvcnRfdHJlZik7XG4gICAgICAgICAgICB0aGF0Ll90cmFuc3BvcnRfdHJlZiA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlID0gU29ja0pTLk9QRU47XG4gICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoXCJvcGVuXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBUaGUgc2VydmVyIG1pZ2h0IGhhdmUgYmVlbiByZXN0YXJ0ZWQsIGFuZCBsb3N0IHRyYWNrIG9mIG91clxuICAgICAgICAvLyBjb25uZWN0aW9uLlxuICAgICAgICB0aGF0Ll9kaWRDbG9zZSgxMDA2LCBcIlNlcnZlciBsb3N0IHNlc3Npb25cIik7XG4gICAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fZGlzcGF0Y2hNZXNzYWdlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTilcbiAgICAgICAgICAgIHJldHVybjtcbiAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KFwibWVzc2FnZVwiLCB7ZGF0YTogZGF0YX0pKTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Rpc3BhdGNoSGVhcnRiZWF0ID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTilcbiAgICAgICAgcmV0dXJuO1xuICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ2hlYXJ0YmVhdCcsIHt9KSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9kaWRDbG9zZSA9IGZ1bmN0aW9uKGNvZGUsIHJlYXNvbiwgZm9yY2UpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLkNPTk5FQ1RJTkcgJiZcbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuT1BFTiAmJlxuICAgICAgICB0aGF0LnJlYWR5U3RhdGUgIT09IFNvY2tKUy5DTE9TSU5HKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJTlZBTElEX1NUQVRFX0VSUicpO1xuICAgIGlmICh0aGF0Ll9pcikge1xuICAgICAgICB0aGF0Ll9pci5udWtlKCk7XG4gICAgICAgIHRoYXQuX2lyID0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAodGhhdC5fdHJhbnNwb3J0KSB7XG4gICAgICAgIHRoYXQuX3RyYW5zcG9ydC5kb0NsZWFudXAoKTtcbiAgICAgICAgdGhhdC5fdHJhbnNwb3J0ID0gbnVsbDtcbiAgICB9XG5cbiAgICB2YXIgY2xvc2VfZXZlbnQgPSBuZXcgU2ltcGxlRXZlbnQoXCJjbG9zZVwiLCB7XG4gICAgICAgIGNvZGU6IGNvZGUsXG4gICAgICAgIHJlYXNvbjogcmVhc29uLFxuICAgICAgICB3YXNDbGVhbjogdXRpbHMudXNlclNldENvZGUoY29kZSl9KTtcblxuICAgIGlmICghdXRpbHMudXNlclNldENvZGUoY29kZSkgJiZcbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORyAmJiAhZm9yY2UpIHtcbiAgICAgICAgaWYgKHRoYXQuX3RyeV9uZXh0X3Byb3RvY29sKGNsb3NlX2V2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNsb3NlX2V2ZW50ID0gbmV3IFNpbXBsZUV2ZW50KFwiY2xvc2VcIiwge2NvZGU6IDIwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb246IFwiQWxsIHRyYW5zcG9ydHMgZmFpbGVkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB3YXNDbGVhbjogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0X2V2ZW50OiBjbG9zZV9ldmVudH0pO1xuICAgIH1cbiAgICB0aGF0LnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0VEO1xuXG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KGNsb3NlX2V2ZW50KTtcbiAgICAgICAgICAgICAgICB9KTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2RpZE1lc3NhZ2UgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB0eXBlID0gZGF0YS5zbGljZSgwLCAxKTtcbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgJ28nOlxuICAgICAgICB0aGF0Ll9kaXNwYXRjaE9wZW4oKTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYSc6XG4gICAgICAgIHZhciBwYXlsb2FkID0gSlNPTi5wYXJzZShkYXRhLnNsaWNlKDEpIHx8ICdbXScpO1xuICAgICAgICBmb3IodmFyIGk9MDsgaSA8IHBheWxvYWQubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgdGhhdC5fZGlzcGF0Y2hNZXNzYWdlKHBheWxvYWRbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ20nOlxuICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04ucGFyc2UoZGF0YS5zbGljZSgxKSB8fCAnbnVsbCcpO1xuICAgICAgICB0aGF0Ll9kaXNwYXRjaE1lc3NhZ2UocGF5bG9hZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2MnOlxuICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04ucGFyc2UoZGF0YS5zbGljZSgxKSB8fCAnW10nKTtcbiAgICAgICAgdGhhdC5fZGlkQ2xvc2UocGF5bG9hZFswXSwgcGF5bG9hZFsxXSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2gnOlxuICAgICAgICB0aGF0Ll9kaXNwYXRjaEhlYXJ0YmVhdCgpO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl90cnlfbmV4dF9wcm90b2NvbCA9IGZ1bmN0aW9uKGNsb3NlX2V2ZW50KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnByb3RvY29sKSB7XG4gICAgICAgIHRoYXQuX2RlYnVnKCdDbG9zZWQgdHJhbnNwb3J0OicsIHRoYXQucHJvdG9jb2wsICcnK2Nsb3NlX2V2ZW50KTtcbiAgICAgICAgdGhhdC5wcm90b2NvbCA9IG51bGw7XG4gICAgfVxuICAgIGlmICh0aGF0Ll90cmFuc3BvcnRfdHJlZikge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhhdC5fdHJhbnNwb3J0X3RyZWYpO1xuICAgICAgICB0aGF0Ll90cmFuc3BvcnRfdHJlZiA9IG51bGw7XG4gICAgfVxuXG4gICAgd2hpbGUoMSkge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSB0aGF0LnByb3RvY29sID0gdGhhdC5fcHJvdG9jb2xzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghcHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIHByb3RvY29scyByZXF1aXJlIGFjY2VzcyB0byBgYm9keWAsIHdoYXQgaWYgd2VyZSBpblxuICAgICAgICAvLyB0aGUgYGhlYWRgP1xuICAgICAgICBpZiAoU29ja0pTW3Byb3RvY29sXSAmJlxuICAgICAgICAgICAgU29ja0pTW3Byb3RvY29sXS5uZWVkX2JvZHkgPT09IHRydWUgJiZcbiAgICAgICAgICAgICghX2RvY3VtZW50LmJvZHkgfHxcbiAgICAgICAgICAgICAodHlwZW9mIF9kb2N1bWVudC5yZWFkeVN0YXRlICE9PSAndW5kZWZpbmVkJ1xuICAgICAgICAgICAgICAmJiBfZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ2NvbXBsZXRlJykpKSB7XG4gICAgICAgICAgICB0aGF0Ll9wcm90b2NvbHMudW5zaGlmdChwcm90b2NvbCk7XG4gICAgICAgICAgICB0aGF0LnByb3RvY29sID0gJ3dhaXRpbmctZm9yLWxvYWQnO1xuICAgICAgICAgICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgIHRoYXQuX3RyeV9uZXh0X3Byb3RvY29sKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFTb2NrSlNbcHJvdG9jb2xdIHx8XG4gICAgICAgICAgICAgICFTb2NrSlNbcHJvdG9jb2xdLmVuYWJsZWQodGhhdC5fb3B0aW9ucykpIHtcbiAgICAgICAgICAgIHRoYXQuX2RlYnVnKCdTa2lwcGluZyB0cmFuc3BvcnQ6JywgcHJvdG9jb2wpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHJvdW5kVHJpcHMgPSBTb2NrSlNbcHJvdG9jb2xdLnJvdW5kVHJpcHMgfHwgMTtcbiAgICAgICAgICAgIHZhciB0byA9ICgodGhhdC5fb3B0aW9ucy5ydG8gfHwgMCkgKiByb3VuZFRyaXBzKSB8fCA1MDAwO1xuICAgICAgICAgICAgdGhhdC5fdHJhbnNwb3J0X3RyZWYgPSB1dGlscy5kZWxheSh0bywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoYXQucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSSBjYW4ndCB1bmRlcnN0YW5kIGhvdyBpdCBpcyBwb3NzaWJsZSB0byBydW5cbiAgICAgICAgICAgICAgICAgICAgLy8gdGhpcyB0aW1lciwgd2hlbiB0aGUgc3RhdGUgaXMgQ0xPU0VELCBidXRcbiAgICAgICAgICAgICAgICAgICAgLy8gYXBwYXJlbnRseSBpbiBJRSBldmVyeXRoaW4gaXMgcG9zc2libGUuXG4gICAgICAgICAgICAgICAgICAgIHRoYXQuX2RpZENsb3NlKDIwMDcsIFwiVHJhbnNwb3J0IHRpbWVvdXRlZFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgdmFyIGNvbm5pZCA9IHV0aWxzLnJhbmRvbV9zdHJpbmcoOCk7XG4gICAgICAgICAgICB2YXIgdHJhbnNfdXJsID0gdGhhdC5fYmFzZV91cmwgKyAnLycgKyB0aGF0Ll9zZXJ2ZXIgKyAnLycgKyBjb25uaWQ7XG4gICAgICAgICAgICB0aGF0Ll9kZWJ1ZygnT3BlbmluZyB0cmFuc3BvcnQ6JywgcHJvdG9jb2wsICcgdXJsOicrdHJhbnNfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgJyBSVE86Jyt0aGF0Ll9vcHRpb25zLnJ0byk7XG4gICAgICAgICAgICB0aGF0Ll90cmFuc3BvcnQgPSBuZXcgU29ja0pTW3Byb3RvY29sXSh0aGF0LCB0cmFuc191cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0Ll9iYXNlX3VybCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24pIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKGNvZGUgJiYgIXV0aWxzLnVzZXJTZXRDb2RlKGNvZGUpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJTlZBTElEX0FDQ0VTU19FUlJcIik7XG4gICAgaWYodGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuQ09OTkVDVElORyAmJlxuICAgICAgIHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGF0LnJlYWR5U3RhdGUgPSBTb2NrSlMuQ0xPU0lORztcbiAgICB0aGF0Ll9kaWRDbG9zZShjb2RlIHx8IDEwMDAsIHJlYXNvbiB8fCBcIk5vcm1hbCBjbG9zdXJlXCIpO1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5zZW5kID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlID09PSBTb2NrSlMuQ09OTkVDVElORylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJTlZBTElEX1NUQVRFX0VSUicpO1xuICAgIGlmICh0aGF0LnJlYWR5U3RhdGUgPT09IFNvY2tKUy5PUEVOKSB7XG4gICAgICAgIHRoYXQuX3RyYW5zcG9ydC5kb1NlbmQodXRpbHMucXVvdGUoJycgKyBkYXRhKSk7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fYXBwbHlJbmZvID0gZnVuY3Rpb24oaW5mbywgcnR0LCBwcm90b2NvbHNfd2hpdGVsaXN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuX29wdGlvbnMuaW5mbyA9IGluZm87XG4gICAgdGhhdC5fb3B0aW9ucy5ydHQgPSBydHQ7XG4gICAgdGhhdC5fb3B0aW9ucy5ydG8gPSB1dGlscy5jb3VudFJUTyhydHQpO1xuICAgIHRoYXQuX29wdGlvbnMuaW5mby5udWxsX29yaWdpbiA9ICFfZG9jdW1lbnQuZG9tYWluO1xuICAgIHZhciBwcm9iZWQgPSB1dGlscy5wcm9iZVByb3RvY29scygpO1xuICAgIHRoYXQuX3Byb3RvY29scyA9IHV0aWxzLmRldGVjdFByb3RvY29scyhwcm9iZWQsIHByb3RvY29sc193aGl0ZWxpc3QsIGluZm8pO1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvc29ja2pzLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy13ZWJzb2NrZXQuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBXZWJTb2NrZXRUcmFuc3BvcnQgPSBTb2NrSlMud2Vic29ja2V0ID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgdXJsID0gdHJhbnNfdXJsICsgJy93ZWJzb2NrZXQnO1xuICAgIGlmICh1cmwuc2xpY2UoMCwgNSkgPT09ICdodHRwcycpIHtcbiAgICAgICAgdXJsID0gJ3dzcycgKyB1cmwuc2xpY2UoNSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdXJsID0gJ3dzJyArIHVybC5zbGljZSg0KTtcbiAgICB9XG4gICAgdGhhdC5yaSA9IHJpO1xuICAgIHRoYXQudXJsID0gdXJsO1xuICAgIHZhciBDb25zdHJ1Y3RvciA9IF93aW5kb3cuV2ViU29ja2V0IHx8IF93aW5kb3cuTW96V2ViU29ja2V0O1xuXG4gICAgdGhhdC53cyA9IG5ldyBDb25zdHJ1Y3Rvcih0aGF0LnVybCk7XG4gICAgdGhhdC53cy5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoYXQucmkuX2RpZE1lc3NhZ2UoZS5kYXRhKTtcbiAgICB9O1xuICAgIC8vIEZpcmVmb3ggaGFzIGFuIGludGVyZXN0aW5nIGJ1Zy4gSWYgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbiBpc1xuICAgIC8vIGNyZWF0ZWQgYWZ0ZXIgb25iZWZvcmV1bmxvYWQsIGl0IHN0YXlzIGFsaXZlIGV2ZW4gd2hlbiB1c2VyXG4gICAgLy8gbmF2aWdhdGVzIGF3YXkgZnJvbSB0aGUgcGFnZS4gSW4gc3VjaCBzaXR1YXRpb24gbGV0J3MgbGllIC1cbiAgICAvLyBsZXQncyBub3Qgb3BlbiB0aGUgd3MgY29ubmVjdGlvbiBhdCBhbGwuIFNlZTpcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vc29ja2pzL3NvY2tqcy1jbGllbnQvaXNzdWVzLzI4XG4gICAgLy8gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9Njk2MDg1XG4gICAgdGhhdC51bmxvYWRfcmVmID0gdXRpbHMudW5sb2FkX2FkZChmdW5jdGlvbigpe3RoYXQud3MuY2xvc2UoKX0pO1xuICAgIHRoYXQud3Mub25jbG9zZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LnJpLl9kaWRNZXNzYWdlKHV0aWxzLmNsb3NlRnJhbWUoMTAwNiwgXCJXZWJTb2NrZXQgY29ubmVjdGlvbiBicm9rZW5cIikpO1xuICAgIH07XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmRvU2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB0aGlzLndzLnNlbmQoJ1snICsgZGF0YSArICddJyk7XG59O1xuXG5XZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmRvQ2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgd3MgPSB0aGF0LndzO1xuICAgIGlmICh3cykge1xuICAgICAgICB3cy5vbm1lc3NhZ2UgPSB3cy5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgd3MuY2xvc2UoKTtcbiAgICAgICAgdXRpbHMudW5sb2FkX2RlbCh0aGF0LnVubG9hZF9yZWYpO1xuICAgICAgICB0aGF0LnVubG9hZF9yZWYgPSB0aGF0LnJpID0gdGhhdC53cyA9IG51bGw7XG4gICAgfVxufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gISEoX3dpbmRvdy5XZWJTb2NrZXQgfHwgX3dpbmRvdy5Nb3pXZWJTb2NrZXQpO1xufTtcblxuLy8gSW4gdGhlb3J5LCB3cyBzaG91bGQgcmVxdWlyZSAxIHJvdW5kIHRyaXAuIEJ1dCBpbiBjaHJvbWUsIHRoaXMgaXNcbi8vIG5vdCB2ZXJ5IHN0YWJsZSBvdmVyIFNTTC4gTW9zdCBsaWtlbHkgYSB3cyBjb25uZWN0aW9uIHJlcXVpcmVzIGFcbi8vIHNlcGFyYXRlIFNTTCBjb25uZWN0aW9uLCBpbiB3aGljaCBjYXNlIDIgcm91bmQgdHJpcHMgYXJlIGFuXG4vLyBhYnNvbHV0ZSBtaW51bXVtLlxuV2ViU29ja2V0VHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyO1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy13ZWJzb2NrZXQuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXNlbmRlci5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEJ1ZmZlcmVkU2VuZGVyID0gZnVuY3Rpb24oKSB7fTtcbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kX2NvbnN0cnVjdG9yID0gZnVuY3Rpb24oc2VuZGVyKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuc2VuZF9idWZmZXIgPSBbXTtcbiAgICB0aGF0LnNlbmRlciA9IHNlbmRlcjtcbn07XG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuZG9TZW5kID0gZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnNlbmRfYnVmZmVyLnB1c2gobWVzc2FnZSk7XG4gICAgaWYgKCF0aGF0LnNlbmRfc3RvcCkge1xuICAgICAgICB0aGF0LnNlbmRfc2NoZWR1bGUoKTtcbiAgICB9XG59O1xuXG4vLyBGb3IgcG9sbGluZyB0cmFuc3BvcnRzIGluIGEgc2l0dWF0aW9uIHdoZW4gaW4gdGhlIG1lc3NhZ2UgY2FsbGJhY2ssXG4vLyBuZXcgbWVzc2FnZSBpcyBiZWluZyBzZW5kLiBJZiB0aGUgc2VuZGluZyBjb25uZWN0aW9uIHdhcyBzdGFydGVkXG4vLyBiZWZvcmUgcmVjZWl2aW5nIG9uZSwgaXQgaXMgcG9zc2libGUgdG8gc2F0dXJhdGUgdGhlIG5ldHdvcmsgYW5kXG4vLyB0aW1lb3V0IGR1ZSB0byB0aGUgbGFjayBvZiByZWNlaXZpbmcgc29ja2V0LiBUbyBhdm9pZCB0aGF0IHdlIGRlbGF5XG4vLyBzZW5kaW5nIG1lc3NhZ2VzIGJ5IHNvbWUgc21hbGwgdGltZSwgaW4gb3JkZXIgdG8gbGV0IHJlY2VpdmluZ1xuLy8gY29ubmVjdGlvbiBiZSBzdGFydGVkIGJlZm9yZWhhbmQuIFRoaXMgaXMgb25seSBhIGhhbGZtZWFzdXJlIGFuZFxuLy8gZG9lcyBub3QgZml4IHRoZSBiaWcgcHJvYmxlbSwgYnV0IGl0IGRvZXMgbWFrZSB0aGUgdGVzdHMgZ28gbW9yZVxuLy8gc3RhYmxlIG9uIHNsb3cgbmV0d29ya3MuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZF9zY2hlZHVsZV93YWl0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB0cmVmO1xuICAgIHRoYXQuc2VuZF9zdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuc2VuZF9zdG9wID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgIH07XG4gICAgdHJlZiA9IHV0aWxzLmRlbGF5KDI1LCBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5zZW5kX3N0b3AgPSBudWxsO1xuICAgICAgICB0aGF0LnNlbmRfc2NoZWR1bGUoKTtcbiAgICB9KTtcbn07XG5cbkJ1ZmZlcmVkU2VuZGVyLnByb3RvdHlwZS5zZW5kX3NjaGVkdWxlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnNlbmRfYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHBheWxvYWQgPSAnWycgKyB0aGF0LnNlbmRfYnVmZmVyLmpvaW4oJywnKSArICddJztcbiAgICAgICAgdGhhdC5zZW5kX3N0b3AgPSB0aGF0LnNlbmRlcih0aGF0LnRyYW5zX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbmRfc3RvcCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuc2VuZF9zY2hlZHVsZV93YWl0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIHRoYXQuc2VuZF9idWZmZXIgPSBbXTtcbiAgICB9XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZF9kZXN0cnVjdG9yID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0Ll9zZW5kX3N0b3ApIHtcbiAgICAgICAgdGhhdC5fc2VuZF9zdG9wKCk7XG4gICAgfVxuICAgIHRoYXQuX3NlbmRfc3RvcCA9IG51bGw7XG59O1xuXG52YXIganNvblBHZW5lcmljU2VuZGVyID0gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIGlmICghKCdfc2VuZF9mb3JtJyBpbiB0aGF0KSkge1xuICAgICAgICB2YXIgZm9ybSA9IHRoYXQuX3NlbmRfZm9ybSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdmb3JtJyk7XG4gICAgICAgIHZhciBhcmVhID0gdGhhdC5fc2VuZF9hcmVhID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgIGFyZWEubmFtZSA9ICdkJztcbiAgICAgICAgZm9ybS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICBmb3JtLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICAgICAgZm9ybS5tZXRob2QgPSAnUE9TVCc7XG4gICAgICAgIGZvcm0uZW5jdHlwZSA9ICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQnO1xuICAgICAgICBmb3JtLmFjY2VwdENoYXJzZXQgPSBcIlVURi04XCI7XG4gICAgICAgIGZvcm0uYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgICAgIF9kb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZvcm0pO1xuICAgIH1cbiAgICB2YXIgZm9ybSA9IHRoYXQuX3NlbmRfZm9ybTtcbiAgICB2YXIgYXJlYSA9IHRoYXQuX3NlbmRfYXJlYTtcbiAgICB2YXIgaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIGZvcm0udGFyZ2V0ID0gaWQ7XG4gICAgZm9ybS5hY3Rpb24gPSB1cmwgKyAnL2pzb25wX3NlbmQ/aT0nICsgaWQ7XG5cbiAgICB2YXIgaWZyYW1lO1xuICAgIHRyeSB7XG4gICAgICAgIC8vIGllNiBkeW5hbWljIGlmcmFtZXMgd2l0aCB0YXJnZXQ9XCJcIiBzdXBwb3J0ICh0aGFua3MgQ2hyaXMgTGFtYmFjaGVyKVxuICAgICAgICBpZnJhbWUgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnPGlmcmFtZSBuYW1lPVwiJysgaWQgKydcIj4nKTtcbiAgICB9IGNhdGNoKHgpIHtcbiAgICAgICAgaWZyYW1lID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgICAgICBpZnJhbWUubmFtZSA9IGlkO1xuICAgIH1cbiAgICBpZnJhbWUuaWQgPSBpZDtcbiAgICBmb3JtLmFwcGVuZENoaWxkKGlmcmFtZSk7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG5cbiAgICB0cnkge1xuICAgICAgICBhcmVhLnZhbHVlID0gcGF5bG9hZDtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgdXRpbHMubG9nKCdZb3VyIGJyb3dzZXIgaXMgc2VyaW91c2x5IGJyb2tlbi4gR28gaG9tZSEgJyArIGUubWVzc2FnZSk7XG4gICAgfVxuICAgIGZvcm0uc3VibWl0KCk7XG5cbiAgICB2YXIgY29tcGxldGVkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBpZiAoIWlmcmFtZS5vbmVycm9yKSByZXR1cm47XG4gICAgICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBudWxsO1xuICAgICAgICAvLyBPcGVyYSBtaW5pIGRvZXNuJ3QgbGlrZSBpZiB3ZSBHQyBpZnJhbWVcbiAgICAgICAgLy8gaW1tZWRpYXRlbHksIHRodXMgdGhpcyB0aW1lb3V0LlxuICAgICAgICB1dGlscy5kZWxheSg1MDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICBhcmVhLnZhbHVlID0gJyc7XG4gICAgICAgIGNhbGxiYWNrKCk7XG4gICAgfTtcbiAgICBpZnJhbWUub25lcnJvciA9IGlmcmFtZS5vbmxvYWQgPSBjb21wbGV0ZWQ7XG4gICAgaWZyYW1lLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKGlmcmFtZS5yZWFkeVN0YXRlID09ICdjb21wbGV0ZScpIGNvbXBsZXRlZCgpO1xuICAgIH07XG4gICAgcmV0dXJuIGNvbXBsZXRlZDtcbn07XG5cbnZhciBjcmVhdGVBamF4U2VuZGVyID0gZnVuY3Rpb24oQWpheE9iamVjdCkge1xuICAgIHJldHVybiBmdW5jdGlvbih1cmwsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB4byA9IG5ldyBBamF4T2JqZWN0KCdQT1NUJywgdXJsICsgJy94aHJfc2VuZCcsIHBheWxvYWQpO1xuICAgICAgICB4by5vbmZpbmlzaCA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICAgICAgY2FsbGJhY2soc3RhdHVzKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uKGFib3J0X3JlYXNvbikge1xuICAgICAgICAgICAgY2FsbGJhY2soMCwgYWJvcnRfcmVhc29uKTtcbiAgICAgICAgfTtcbiAgICB9O1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtc2VuZGVyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1qc29ucC1yZWNlaXZlci5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxuLy8gUGFydHMgZGVyaXZlZCBmcm9tIFNvY2tldC5pbzpcbi8vICAgIGh0dHBzOi8vZ2l0aHViLmNvbS9MZWFybkJvb3N0L3NvY2tldC5pby9ibG9iLzAuNi4xNy9saWIvc29ja2V0LmlvL3RyYW5zcG9ydHMvanNvbnAtcG9sbGluZy5qc1xuLy8gYW5kIGpRdWVyeS1KU09OUDpcbi8vICAgIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvanF1ZXJ5LWpzb25wL3NvdXJjZS9icm93c2UvdHJ1bmsvY29yZS9qcXVlcnkuanNvbnAuanNcbnZhciBqc29uUEdlbmVyaWNSZWNlaXZlciA9IGZ1bmN0aW9uKHVybCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdHJlZjtcbiAgICB2YXIgc2NyaXB0ID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgIHZhciBzY3JpcHQyOyAgLy8gT3BlcmEgc3luY2hyb25vdXMgbG9hZCB0cmljay5cbiAgICB2YXIgY2xvc2Vfc2NyaXB0ID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgaWYgKHNjcmlwdDIpIHtcbiAgICAgICAgICAgIHNjcmlwdDIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQyKTtcbiAgICAgICAgICAgIHNjcmlwdDIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzY3JpcHQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICAgICAgICAgIHNjcmlwdC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gc2NyaXB0Lm9uZXJyb3IgPVxuICAgICAgICAgICAgICAgIHNjcmlwdC5vbmxvYWQgPSBzY3JpcHQub25jbGljayA9IG51bGw7XG4gICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgY2FsbGJhY2soZnJhbWUpO1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBudWxsO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIElFOSBmaXJlcyAnZXJyb3InIGV2ZW50IGFmdGVyIG9yc2Mgb3IgYmVmb3JlLCBpbiByYW5kb20gb3JkZXIuXG4gICAgdmFyIGxvYWRlZF9va2F5ID0gZmFsc2U7XG4gICAgdmFyIGVycm9yX3RpbWVyID0gbnVsbDtcblxuICAgIHNjcmlwdC5pZCA9ICdhJyArIHV0aWxzLnJhbmRvbV9zdHJpbmcoOCk7XG4gICAgc2NyaXB0LnNyYyA9IHVybDtcbiAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgIHNjcmlwdC5jaGFyc2V0ID0gJ1VURi04JztcbiAgICBzY3JpcHQub25lcnJvciA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFlcnJvcl90aW1lcikge1xuICAgICAgICAgICAgLy8gRGVsYXkgZmlyaW5nIGNsb3NlX3NjcmlwdC5cbiAgICAgICAgICAgIGVycm9yX3RpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWxvYWRlZF9va2F5KSB7XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlX3NjcmlwdCh1dGlscy5jbG9zZUZyYW1lKFxuICAgICAgICAgICAgICAgICAgICAgICAgMTAwNixcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmVycm9yKVwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHNjcmlwdC5vbmxvYWQgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGNsb3NlX3NjcmlwdCh1dGlscy5jbG9zZUZyYW1lKDEwMDYsIFwiSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbmxvYWQpXCIpKTtcbiAgICB9O1xuXG4gICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKC9sb2FkZWR8Y2xvc2VkLy50ZXN0KHNjcmlwdC5yZWFkeVN0YXRlKSkge1xuICAgICAgICAgICAgaWYgKHNjcmlwdCAmJiBzY3JpcHQuaHRtbEZvciAmJiBzY3JpcHQub25jbGljaykge1xuICAgICAgICAgICAgICAgIGxvYWRlZF9va2F5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBJbiBJRSwgYWN0dWFsbHkgZXhlY3V0ZSB0aGUgc2NyaXB0LlxuICAgICAgICAgICAgICAgICAgICBzY3JpcHQub25jbGljaygpO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICAgICAgY2xvc2Vfc2NyaXB0KHV0aWxzLmNsb3NlRnJhbWUoMTAwNiwgXCJKU09OUCBzY3JpcHQgbG9hZGVkIGFibm9ybWFsbHkgKG9ucmVhZHlzdGF0ZWNoYW5nZSlcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvLyBJRTogZXZlbnQvaHRtbEZvci9vbmNsaWNrIHRyaWNrLlxuICAgIC8vIE9uZSBjYW4ndCByZWx5IG9uIHByb3BlciBvcmRlciBmb3Igb25yZWFkeXN0YXRlY2hhbmdlLiBJbiBvcmRlciB0b1xuICAgIC8vIG1ha2Ugc3VyZSwgc2V0IGEgJ2h0bWxGb3InIGFuZCAnZXZlbnQnIHByb3BlcnRpZXMsIHNvIHRoYXRcbiAgICAvLyBzY3JpcHQgY29kZSB3aWxsIGJlIGluc3RhbGxlZCBhcyAnb25jbGljaycgaGFuZGxlciBmb3IgdGhlXG4gICAgLy8gc2NyaXB0IG9iamVjdC4gTGF0ZXIsIG9ucmVhZHlzdGF0ZWNoYW5nZSwgbWFudWFsbHkgZXhlY3V0ZSB0aGlzXG4gICAgLy8gY29kZS4gRkYgYW5kIENocm9tZSBkb2Vzbid0IHdvcmsgd2l0aCAnZXZlbnQnIGFuZCAnaHRtbEZvcidcbiAgICAvLyBzZXQuIEZvciByZWZlcmVuY2Ugc2VlOlxuICAgIC8vICAgaHR0cDovL2phdWJvdXJnLm5ldC8yMDEwLzA3L2xvYWRpbmctc2NyaXB0LWFzLW9uY2xpY2staGFuZGxlci1vZi5odG1sXG4gICAgLy8gQWxzbywgcmVhZCBvbiB0aGF0IGFib3V0IHNjcmlwdCBvcmRlcmluZzpcbiAgICAvLyAgIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9EeW5hbWljX1NjcmlwdF9FeGVjdXRpb25fT3JkZXJcbiAgICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyA9PT0gJ3VuZGVmaW5lZCcgJiYgX2RvY3VtZW50LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgIC8vIEFjY29yZGluZyB0byBtb3ppbGxhIGRvY3MsIGluIHJlY2VudCBicm93c2VycyBzY3JpcHQuYXN5bmMgZGVmYXVsdHNcbiAgICAgICAgLy8gdG8gJ3RydWUnLCBzbyB3ZSBtYXkgdXNlIGl0IHRvIGRldGVjdCBhIGdvb2QgYnJvd3NlcjpcbiAgICAgICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4vSFRNTC9FbGVtZW50L3NjcmlwdFxuICAgICAgICBpZiAoIS9vcGVyYS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpIHtcbiAgICAgICAgICAgIC8vIE5haXZlbHkgYXNzdW1lIHdlJ3JlIGluIElFXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHNjcmlwdC5odG1sRm9yID0gc2NyaXB0LmlkO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5ldmVudCA9IFwib25jbGlja1wiO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBPcGVyYSwgc2Vjb25kIHN5bmMgc2NyaXB0IGhhY2tcbiAgICAgICAgICAgIHNjcmlwdDIgPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7XG4gICAgICAgICAgICBzY3JpcHQyLnRleHQgPSBcInRyeXt2YXIgYSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdcIitzY3JpcHQuaWQrXCInKTsgaWYoYSlhLm9uZXJyb3IoKTt9Y2F0Y2goeCl7fTtcIjtcbiAgICAgICAgICAgIHNjcmlwdC5hc3luYyA9IHNjcmlwdDIuYXN5bmMgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZW9mIHNjcmlwdC5hc3luYyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgc2NyaXB0LmFzeW5jID0gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBGYWxsYmFjayBtb3N0bHkgZm9yIEtvbnF1ZXJvciAtIHN0dXBpZCB0aW1lciwgMzUgc2Vjb25kcyBzaGFsbCBiZSBwbGVudHkuXG4gICAgdHJlZiA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlX3NjcmlwdCh1dGlscy5jbG9zZUZyYW1lKDEwMDYsIFwiSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5ICh0aW1lb3V0KVwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgfSwgMzUwMDApO1xuXG4gICAgdmFyIGhlYWQgPSBfZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcbiAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgaWYgKHNjcmlwdDIpIHtcbiAgICAgICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0MiwgaGVhZC5maXJzdENoaWxkKTtcbiAgICB9XG4gICAgcmV0dXJuIGNsb3NlX3NjcmlwdDtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWpzb25wLXJlY2VpdmVyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1qc29ucC1wb2xsaW5nLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG4vLyBUaGUgc2ltcGxlc3QgYW5kIG1vc3Qgcm9idXN0IHRyYW5zcG9ydCwgdXNpbmcgdGhlIHdlbGwta25vdyBjcm9zc1xuLy8gZG9tYWluIGhhY2sgLSBKU09OUC4gVGhpcyB0cmFuc3BvcnQgaXMgcXVpdGUgaW5lZmZpY2llbnQgLSBvbmVcbi8vIG1zc2FnZSBjb3VsZCB1c2UgdXAgdG8gb25lIGh0dHAgcmVxdWVzdC4gQnV0IGF0IGxlYXN0IGl0IHdvcmtzIGFsbW9zdFxuLy8gZXZlcnl3aGVyZS5cbi8vIEtub3duIGxpbWl0YXRpb25zOlxuLy8gICBvIHlvdSB3aWxsIGdldCBhIHNwaW5uaW5nIGN1cnNvclxuLy8gICBvIGZvciBLb25xdWVyb3IgYSBkdW1iIHRpbWVyIGlzIG5lZWRlZCB0byBkZXRlY3QgZXJyb3JzXG5cblxudmFyIEpzb25QVHJhbnNwb3J0ID0gU29ja0pTWydqc29ucC1wb2xsaW5nJ10gPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsKSB7XG4gICAgdXRpbHMucG9sbHV0ZUdsb2JhbE5hbWVzcGFjZSgpO1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnJpID0gcmk7XG4gICAgdGhhdC50cmFuc191cmwgPSB0cmFuc191cmw7XG4gICAgdGhhdC5zZW5kX2NvbnN0cnVjdG9yKGpzb25QR2VuZXJpY1NlbmRlcik7XG4gICAgdGhhdC5fc2NoZWR1bGVfcmVjdigpO1xufTtcblxuLy8gSW5oZXJpdG5hY2Vcbkpzb25QVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBCdWZmZXJlZFNlbmRlcigpO1xuXG5Kc29uUFRyYW5zcG9ydC5wcm90b3R5cGUuX3NjaGVkdWxlX3JlY3YgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICB0aGF0Ll9yZWN2X3N0b3AgPSBudWxsO1xuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgLy8gbm8gZGF0YSAtIGhlYXJ0YmVhdDtcbiAgICAgICAgICAgIGlmICghdGhhdC5faXNfY2xvc2luZykge1xuICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZE1lc3NhZ2UoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVGhlIG1lc3NhZ2UgY2FuIGJlIGEgY2xvc2UgbWVzc2FnZSwgYW5kIGNoYW5nZSBpc19jbG9zaW5nIHN0YXRlLlxuICAgICAgICBpZiAoIXRoYXQuX2lzX2Nsb3NpbmcpIHtcbiAgICAgICAgICAgIHRoYXQuX3NjaGVkdWxlX3JlY3YoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC5fcmVjdl9zdG9wID0ganNvblBSZWNlaXZlcldyYXBwZXIodGhhdC50cmFuc191cmwgKyAnL2pzb25wJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBqc29uUEdlbmVyaWNSZWNlaXZlciwgY2FsbGJhY2spO1xufTtcblxuSnNvblBUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0cnVlO1xufTtcblxuSnNvblBUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcblxuXG5Kc29uUFRyYW5zcG9ydC5wcm90b3R5cGUuZG9DbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQuX2lzX2Nsb3NpbmcgPSB0cnVlO1xuICAgIGlmICh0aGF0Ll9yZWN2X3N0b3ApIHtcbiAgICAgICAgdGhhdC5fcmVjdl9zdG9wKCk7XG4gICAgfVxuICAgIHRoYXQucmkgPSB0aGF0Ll9yZWN2X3N0b3AgPSBudWxsO1xuICAgIHRoYXQuc2VuZF9kZXN0cnVjdG9yKCk7XG59O1xuXG5cbi8vIEFic3RyYWN0IGF3YXkgY29kZSB0aGF0IGhhbmRsZXMgZ2xvYmFsIG5hbWVzcGFjZSBwb2xsdXRpb24uXG52YXIganNvblBSZWNlaXZlcldyYXBwZXIgPSBmdW5jdGlvbih1cmwsIGNvbnN0cnVjdFJlY2VpdmVyLCB1c2VyX2NhbGxiYWNrKSB7XG4gICAgdmFyIGlkID0gJ2EnICsgdXRpbHMucmFuZG9tX3N0cmluZyg2KTtcbiAgICB2YXIgdXJsX2lkID0gdXJsICsgJz9jPScgKyBlc2NhcGUoV1ByZWZpeCArICcuJyArIGlkKTtcbiAgICAvLyBDYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBleGFjdGx5IG9uY2UuXG4gICAgdmFyIGNhbGxiYWNrID0gZnVuY3Rpb24oZnJhbWUpIHtcbiAgICAgICAgZGVsZXRlIF93aW5kb3dbV1ByZWZpeF1baWRdO1xuICAgICAgICB1c2VyX2NhbGxiYWNrKGZyYW1lKTtcbiAgICB9O1xuXG4gICAgdmFyIGNsb3NlX3NjcmlwdCA9IGNvbnN0cnVjdFJlY2VpdmVyKHVybF9pZCwgY2FsbGJhY2spO1xuICAgIF93aW5kb3dbV1ByZWZpeF1baWRdID0gY2xvc2Vfc2NyaXB0O1xuICAgIHZhciBzdG9wID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChfd2luZG93W1dQcmVmaXhdW2lkXSkge1xuICAgICAgICAgICAgX3dpbmRvd1tXUHJlZml4XVtpZF0odXRpbHMuY2xvc2VGcmFtZSgxMDAwLCBcIkpTT05QIHVzZXIgYWJvcnRlZCByZWFkXCIpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHN0b3A7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1qc29ucC1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy14aHIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBBamF4QmFzZWRUcmFuc3BvcnQgPSBmdW5jdGlvbigpIHt9O1xuQWpheEJhc2VkVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBCdWZmZXJlZFNlbmRlcigpO1xuXG5BamF4QmFzZWRUcmFuc3BvcnQucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybF9zdWZmaXgsIFJlY2VpdmVyLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0LnRyYW5zX3VybCA9IHRyYW5zX3VybDtcbiAgICB0aGF0LnNlbmRfY29uc3RydWN0b3IoY3JlYXRlQWpheFNlbmRlcihBamF4T2JqZWN0KSk7XG4gICAgdGhhdC5wb2xsID0gbmV3IFBvbGxpbmcocmksIFJlY2VpdmVyLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyYW5zX3VybCArIHVybF9zdWZmaXgsIEFqYXhPYmplY3QpO1xufTtcblxuQWpheEJhc2VkVHJhbnNwb3J0LnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucG9sbCkge1xuICAgICAgICB0aGF0LnBvbGwuYWJvcnQoKTtcbiAgICAgICAgdGhhdC5wb2xsID0gbnVsbDtcbiAgICB9XG59O1xuXG4vLyB4aHItc3RyZWFtaW5nXG52YXIgWGhyU3RyZWFtaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4aHItc3RyZWFtaW5nJ10gPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsKSB7XG4gICAgdGhpcy5ydW4ocmksIHRyYW5zX3VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkNvcnNPYmplY3QpO1xufTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcblxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBTdXBwb3J0IGZvciBDT1JTIEFqYXggYWthIEFqYXgyPyBPcGVyYSAxMiBjbGFpbXMgQ09SUyBidXRcbiAgICAvLyBkb2Vzbid0IGRvIHN0cmVhbWluZy5cbiAgICByZXR1cm4gKF93aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiZcbiAgICAgICAgICAgICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpICYmXG4gICAgICAgICAgICAoIS9vcGVyYS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkpKTtcbn07XG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG4vLyBTYWZhcmkgZ2V0cyBjb25mdXNlZCB3aGVuIGEgc3RyZWFtaW5nIGFqYXggcmVxdWVzdCBpcyBzdGFydGVkXG4vLyBiZWZvcmUgb25sb2FkLiBUaGlzIGNhdXNlcyB0aGUgbG9hZCBpbmRpY2F0b3IgdG8gc3BpbiBpbmRlZmluZXRlbHkuXG5YaHJTdHJlYW1pbmdUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcblxuXG4vLyBBY2NvcmRpbmcgdG86XG4vLyAgIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTY0MTUwNy9kZXRlY3QtYnJvd3Nlci1zdXBwb3J0LWZvci1jcm9zcy1kb21haW4teG1saHR0cHJlcXVlc3RzXG4vLyAgIGh0dHA6Ly9oYWNrcy5tb3ppbGxhLm9yZy8yMDA5LzA3L2Nyb3NzLXNpdGUteG1saHR0cHJlcXVlc3Qtd2l0aC1jb3JzL1xuXG5cbi8vIHhkci1zdHJlYW1pbmdcbnZhciBYZHJTdHJlYW1pbmdUcmFuc3BvcnQgPSBTb2NrSlNbJ3hkci1zdHJlYW1pbmcnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL3hocl9zdHJlYW1pbmcnLCBYaHJSZWNlaXZlciwgdXRpbHMuWERST2JqZWN0KTtcbn07XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG5cblhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhX3dpbmRvdy5YRG9tYWluUmVxdWVzdDtcbn07XG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5cblxuLy8geGhyLXBvbGxpbmdcbnZhciBYaHJQb2xsaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4aHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkNvcnNPYmplY3QpO1xufTtcblxuWGhyUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG5cblhoclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGhyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG5cblxuLy8geGRyLXBvbGxpbmdcbnZhciBYZHJQb2xsaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4ZHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhEUk9iamVjdCk7XG59O1xuXG5YZHJQb2xsaW5nVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5lbmFibGVkID0gWGRyU3RyZWFtaW5nVHJhbnNwb3J0LmVuYWJsZWQ7XG5YZHJQb2xsaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMteGhyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1pZnJhbWUuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIEZldyBjb29sIHRyYW5zcG9ydHMgZG8gd29yayBvbmx5IGZvciBzYW1lLW9yaWdpbi4gSW4gb3JkZXIgdG8gbWFrZVxuLy8gdGhlbSB3b3JraW5nIGNyb3NzLWRvbWFpbiB3ZSBzaGFsbCB1c2UgaWZyYW1lLCBzZXJ2ZWQgZm9ybSB0aGVcbi8vIHJlbW90ZSBkb21haW4uIE5ldyBicm93c2VycywgaGF2ZSBjYXBhYmlsaXRpZXMgdG8gY29tbXVuaWNhdGUgd2l0aFxuLy8gY3Jvc3MgZG9tYWluIGlmcmFtZSwgdXNpbmcgcG9zdE1lc3NhZ2UoKS4gSW4gSUUgaXQgd2FzIGltcGxlbWVudGVkXG4vLyBmcm9tIElFIDgrLCBidXQgb2YgY291cnNlLCBJRSBnb3Qgc29tZSBkZXRhaWxzIHdyb25nOlxuLy8gICAgaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2NjMTk3MDE1KHY9VlMuODUpLmFzcHhcbi8vICAgIGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcblxudmFyIElmcmFtZVRyYW5zcG9ydCA9IGZ1bmN0aW9uKCkge307XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuaV9jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwsIGJhc2VfdXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0Lm9yaWdpbiA9IHV0aWxzLmdldE9yaWdpbihiYXNlX3VybCk7XG4gICAgdGhhdC5iYXNlX3VybCA9IGJhc2VfdXJsO1xuICAgIHRoYXQudHJhbnNfdXJsID0gdHJhbnNfdXJsO1xuXG4gICAgdmFyIGlmcmFtZV91cmwgPSBiYXNlX3VybCArICcvaWZyYW1lLmh0bWwnO1xuICAgIGlmICh0aGF0LnJpLl9vcHRpb25zLmRldmVsKSB7XG4gICAgICAgIGlmcmFtZV91cmwgKz0gJz90PScgKyAoK25ldyBEYXRlKTtcbiAgICB9XG4gICAgdGhhdC53aW5kb3dfaWQgPSB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIGlmcmFtZV91cmwgKz0gJyMnICsgdGhhdC53aW5kb3dfaWQ7XG5cbiAgICB0aGF0LmlmcmFtZU9iaiA9IHV0aWxzLmNyZWF0ZUlmcmFtZShpZnJhbWVfdXJsLCBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZENsb3NlKDEwMDYsIFwiVW5hYmxlIHRvIGxvYWQgYW4gaWZyYW1lIChcIiArIHIgKyBcIilcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICB0aGF0Lm9ubWVzc2FnZV9jYiA9IHV0aWxzLmJpbmQodGhhdC5vbm1lc3NhZ2UsIHRoYXQpO1xuICAgIHV0aWxzLmF0dGFjaE1lc3NhZ2UodGhhdC5vbm1lc3NhZ2VfY2IpO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuaWZyYW1lT2JqKSB7XG4gICAgICAgIHV0aWxzLmRldGFjaE1lc3NhZ2UodGhhdC5vbm1lc3NhZ2VfY2IpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB0aGUgaWZyYW1lIGlzIG5vdCBsb2FkZWQsIElFIHJhaXNlcyBhbiBleGNlcHRpb25cbiAgICAgICAgICAgIC8vIG9uICdjb250ZW50V2luZG93Jy5cbiAgICAgICAgICAgIGlmICh0aGF0LmlmcmFtZU9iai5pZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICAgIHRoYXQucG9zdE1lc3NhZ2UoJ2MnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgdGhhdC5pZnJhbWVPYmouY2xlYW51cCgpO1xuICAgICAgICB0aGF0LmlmcmFtZU9iaiA9IG51bGw7XG4gICAgICAgIHRoYXQub25tZXNzYWdlX2NiID0gdGhhdC5pZnJhbWVPYmogPSBudWxsO1xuICAgIH1cbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAoZS5vcmlnaW4gIT09IHRoYXQub3JpZ2luKSByZXR1cm47XG4gICAgdmFyIHdpbmRvd19pZCA9IGUuZGF0YS5zbGljZSgwLCA4KTtcbiAgICB2YXIgdHlwZSA9IGUuZGF0YS5zbGljZSg4LCA5KTtcbiAgICB2YXIgZGF0YSA9IGUuZGF0YS5zbGljZSg5KTtcblxuICAgIGlmICh3aW5kb3dfaWQgIT09IHRoYXQud2luZG93X2lkKSByZXR1cm47XG5cbiAgICBzd2l0Y2godHlwZSkge1xuICAgIGNhc2UgJ3MnOlxuICAgICAgICB0aGF0LmlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAgICAgdGhhdC5wb3N0TWVzc2FnZSgncycsIEpTT04uc3RyaW5naWZ5KFtTb2NrSlMudmVyc2lvbiwgdGhhdC5wcm90b2NvbCwgdGhhdC50cmFuc191cmwsIHRoYXQuYmFzZV91cmxdKSk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3QnOlxuICAgICAgICB0aGF0LnJpLl9kaWRNZXNzYWdlKGRhdGEpO1xuICAgICAgICBicmVhaztcbiAgICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLnBvc3RNZXNzYWdlID0gZnVuY3Rpb24odHlwZSwgZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LmlmcmFtZU9iai5wb3N0KHRoYXQud2luZG93X2lkICsgdHlwZSArIChkYXRhIHx8ICcnKSwgdGhhdC5vcmlnaW4pO1xufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5kb1NlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgIHRoaXMucG9zdE1lc3NhZ2UoJ20nLCBtZXNzYWdlKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gcG9zdE1lc3NhZ2UgbWlzYmVoYXZlcyBpbiBrb25xdWVyb3IgNC42LjUgLSB0aGUgbWVzc2FnZXMgYXJlIGRlbGl2ZXJlZCB3aXRoXG4gICAgLy8gaHVnZSBkZWxheSwgb3Igbm90IGF0IGFsbC5cbiAgICB2YXIga29ucXVlcm9yID0gbmF2aWdhdG9yICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5pbmRleE9mKCdLb25xdWVyb3InKSAhPT0gLTE7XG4gICAgcmV0dXJuICgodHlwZW9mIF93aW5kb3cucG9zdE1lc3NhZ2UgPT09ICdmdW5jdGlvbicgfHxcbiAgICAgICAgICAgIHR5cGVvZiBfd2luZG93LnBvc3RNZXNzYWdlID09PSAnb2JqZWN0JykgJiYgKCFrb25xdWVyb3IpKTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWlmcmFtZS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtaWZyYW1lLXdpdGhpbi5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIGN1cnJfd2luZG93X2lkO1xuXG52YXIgcG9zdE1lc3NhZ2UgPSBmdW5jdGlvbiAodHlwZSwgZGF0YSkge1xuICAgIGlmKHBhcmVudCAhPT0gX3dpbmRvdykge1xuICAgICAgICBwYXJlbnQucG9zdE1lc3NhZ2UoY3Vycl93aW5kb3dfaWQgKyB0eXBlICsgKGRhdGEgfHwgJycpLCAnKicpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHV0aWxzLmxvZyhcIkNhbid0IHBvc3RNZXNzYWdlLCBubyBwYXJlbnQgd2luZG93LlwiLCB0eXBlLCBkYXRhKTtcbiAgICB9XG59O1xuXG52YXIgRmFjYWRlSlMgPSBmdW5jdGlvbigpIHt9O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kaWRDbG9zZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICBwb3N0TWVzc2FnZSgndCcsIHV0aWxzLmNsb3NlRnJhbWUoY29kZSwgcmVhc29uKSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kaWRNZXNzYWdlID0gZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgcG9zdE1lc3NhZ2UoJ3QnLCBmcmFtZSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kb1NlbmQgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5kb1NlbmQoZGF0YSk7XG59O1xuRmFjYWRlSlMucHJvdG90eXBlLl9kb0NsZWFudXAgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5fdHJhbnNwb3J0LmRvQ2xlYW51cCgpO1xufTtcblxudXRpbHMucGFyZW50X29yaWdpbiA9IHVuZGVmaW5lZDtcblxuU29ja0pTLmJvb3RzdHJhcF9pZnJhbWUgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgZmFjYWRlO1xuICAgIGN1cnJfd2luZG93X2lkID0gX2RvY3VtZW50LmxvY2F0aW9uLmhhc2guc2xpY2UoMSk7XG4gICAgdmFyIG9uTWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYoZS5zb3VyY2UgIT09IHBhcmVudCkgcmV0dXJuO1xuICAgICAgICBpZih0eXBlb2YgdXRpbHMucGFyZW50X29yaWdpbiA9PT0gJ3VuZGVmaW5lZCcpXG4gICAgICAgICAgICB1dGlscy5wYXJlbnRfb3JpZ2luID0gZS5vcmlnaW47XG4gICAgICAgIGlmIChlLm9yaWdpbiAhPT0gdXRpbHMucGFyZW50X29yaWdpbikgcmV0dXJuO1xuXG4gICAgICAgIHZhciB3aW5kb3dfaWQgPSBlLmRhdGEuc2xpY2UoMCwgOCk7XG4gICAgICAgIHZhciB0eXBlID0gZS5kYXRhLnNsaWNlKDgsIDkpO1xuICAgICAgICB2YXIgZGF0YSA9IGUuZGF0YS5zbGljZSg5KTtcbiAgICAgICAgaWYgKHdpbmRvd19pZCAhPT0gY3Vycl93aW5kb3dfaWQpIHJldHVybjtcbiAgICAgICAgc3dpdGNoKHR5cGUpIHtcbiAgICAgICAgY2FzZSAncyc6XG4gICAgICAgICAgICB2YXIgcCA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICAgICAgICB2YXIgdmVyc2lvbiA9IHBbMF07XG4gICAgICAgICAgICB2YXIgcHJvdG9jb2wgPSBwWzFdO1xuICAgICAgICAgICAgdmFyIHRyYW5zX3VybCA9IHBbMl07XG4gICAgICAgICAgICB2YXIgYmFzZV91cmwgPSBwWzNdO1xuICAgICAgICAgICAgaWYgKHZlcnNpb24gIT09IFNvY2tKUy52ZXJzaW9uKSB7XG4gICAgICAgICAgICAgICAgdXRpbHMubG9nKFwiSW5jb21wYXRpYmlsZSBTb2NrSlMhIE1haW4gc2l0ZSB1c2VzOlwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIgXFxcIlwiICsgdmVyc2lvbiArIFwiXFxcIiwgdGhlIGlmcmFtZTpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFxcXCJcIiArIFNvY2tKUy52ZXJzaW9uICsgXCJcXFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdXRpbHMuZmxhdFVybCh0cmFuc191cmwpIHx8ICF1dGlscy5mbGF0VXJsKGJhc2VfdXJsKSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvZyhcIk9ubHkgYmFzaWMgdXJscyBhcmUgc3VwcG9ydGVkIGluIFNvY2tKU1wiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdXRpbHMuaXNTYW1lT3JpZ2luVXJsKHRyYW5zX3VybCkgfHxcbiAgICAgICAgICAgICAgICAhdXRpbHMuaXNTYW1lT3JpZ2luVXJsKGJhc2VfdXJsKSkge1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvZyhcIkNhbid0IGNvbm5lY3QgdG8gZGlmZmVyZW50IGRvbWFpbiBmcm9tIHdpdGhpbiBhbiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiaWZyYW1lLiAoXCIgKyBKU09OLnN0cmluZ2lmeShbX3dpbmRvdy5sb2NhdGlvbi5ocmVmLCB0cmFuc191cmwsIGJhc2VfdXJsXSkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIilcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmFjYWRlID0gbmV3IEZhY2FkZUpTKCk7XG4gICAgICAgICAgICBmYWNhZGUuX3RyYW5zcG9ydCA9IG5ldyBGYWNhZGVKU1twcm90b2NvbF0oZmFjYWRlLCB0cmFuc191cmwsIGJhc2VfdXJsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICAgIGZhY2FkZS5fZG9TZW5kKGRhdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2MnOlxuICAgICAgICAgICAgaWYgKGZhY2FkZSlcbiAgICAgICAgICAgICAgICBmYWNhZGUuX2RvQ2xlYW51cCgpO1xuICAgICAgICAgICAgZmFjYWRlID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfTtcblxuICAgIC8vIGFsZXJ0KCd0ZXN0IHRpY2tlcicpO1xuICAgIC8vIGZhY2FkZSA9IG5ldyBGYWNhZGVKUygpO1xuICAgIC8vIGZhY2FkZS5fdHJhbnNwb3J0ID0gbmV3IEZhY2FkZUpTWyd3LWlmcmFtZS14aHItcG9sbGluZyddKGZhY2FkZSwgJ2h0dHA6Ly9ob3N0LmNvbTo5OTk5L3RpY2tlci8xMi9iYXNkJyk7XG5cbiAgICB1dGlscy5hdHRhY2hNZXNzYWdlKG9uTWVzc2FnZSk7XG5cbiAgICAvLyBTdGFydFxuICAgIHBvc3RNZXNzYWdlKCdzJyk7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1pZnJhbWUtd2l0aGluLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi9pbmZvLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgSW5mb1JlY2VpdmVyID0gZnVuY3Rpb24oYmFzZV91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKXt0aGF0LmRvWGhyKGJhc2VfdXJsLCBBamF4T2JqZWN0KTt9KTtcbn07XG5cbkluZm9SZWNlaXZlci5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKFsnZmluaXNoJ10pO1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlLmRvWGhyID0gZnVuY3Rpb24oYmFzZV91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHQwID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnR0VUJywgYmFzZV91cmwgKyAnL2luZm8nKTtcblxuICAgIHZhciB0cmVmID0gdXRpbHMuZGVsYXkoODAwMCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uKCl7eG8ub250aW1lb3V0KCk7fSk7XG5cbiAgICB4by5vbmZpbmlzaCA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgIHRyZWYgPSBudWxsO1xuICAgICAgICBpZiAoc3RhdHVzID09PSAyMDApIHtcbiAgICAgICAgICAgIHZhciBydHQgPSAobmV3IERhdGUoKSkuZ2V0VGltZSgpIC0gdDA7XG4gICAgICAgICAgICB2YXIgaW5mbyA9IEpTT04ucGFyc2UodGV4dCk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGluZm8gIT09ICdvYmplY3QnKSBpbmZvID0ge307XG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB4by5vbnRpbWVvdXQgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgeG8uY2xvc2UoKTtcbiAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnKTtcbiAgICB9O1xufTtcblxudmFyIEluZm9SZWNlaXZlcklmcmFtZSA9IGZ1bmN0aW9uKGJhc2VfdXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBnbyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgaWZyID0gbmV3IElmcmFtZVRyYW5zcG9ydCgpO1xuICAgICAgICBpZnIucHJvdG9jb2wgPSAndy1pZnJhbWUtaW5mby1yZWNlaXZlcic7XG4gICAgICAgIHZhciBmdW4gPSBmdW5jdGlvbihyKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgPT09ICdzdHJpbmcnICYmIHIuc3Vic3RyKDAsMSkgPT09ICdtJykge1xuICAgICAgICAgICAgICAgIHZhciBkID0gSlNPTi5wYXJzZShyLnN1YnN0cigxKSk7XG4gICAgICAgICAgICAgICAgdmFyIGluZm8gPSBkWzBdLCBydHQgPSBkWzFdO1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgaW5mbywgcnR0KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmci5kb0NsZWFudXAoKTtcbiAgICAgICAgICAgIGlmciA9IG51bGw7XG4gICAgICAgIH07XG4gICAgICAgIHZhciBtb2NrX3JpID0ge1xuICAgICAgICAgICAgX29wdGlvbnM6IHt9LFxuICAgICAgICAgICAgX2RpZENsb3NlOiBmdW4sXG4gICAgICAgICAgICBfZGlkTWVzc2FnZTogZnVuXG4gICAgICAgIH07XG4gICAgICAgIGlmci5pX2NvbnN0cnVjdG9yKG1vY2tfcmksIGJhc2VfdXJsLCBiYXNlX3VybCk7XG4gICAgfVxuICAgIGlmKCFfZG9jdW1lbnQuYm9keSkge1xuICAgICAgICB1dGlscy5hdHRhY2hFdmVudCgnbG9hZCcsIGdvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBnbygpO1xuICAgIH1cbn07XG5JbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2ZpbmlzaCddKTtcblxuXG52YXIgSW5mb1JlY2VpdmVyRmFrZSA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIEl0IG1heSBub3QgYmUgcG9zc2libGUgdG8gZG8gY3Jvc3MgZG9tYWluIEFKQVggdG8gZ2V0IHRoZSBpbmZvXG4gICAgLy8gZGF0YSwgZm9yIGV4YW1wbGUgZm9yIElFNy4gQnV0IHdlIHdhbnQgdG8gcnVuIEpTT05QLCBzbyBsZXQnc1xuICAgIC8vIGZha2UgdGhlIHJlc3BvbnNlLCB3aXRoIHJ0dD0ycyAocnRvPTZzKS5cbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywge30sIDIwMDApO1xuICAgIH0pO1xufTtcbkluZm9SZWNlaXZlckZha2UucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2ZpbmlzaCddKTtcblxudmFyIGNyZWF0ZUluZm9SZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VfdXJsKSB7XG4gICAgaWYgKHV0aWxzLmlzU2FtZU9yaWdpblVybChiYXNlX3VybCkpIHtcbiAgICAgICAgLy8gSWYsIGZvciBzb21lIHJlYXNvbiwgd2UgaGF2ZSBTb2NrSlMgbG9jYWxseSAtIHRoZXJlJ3Mgbm9cbiAgICAgICAgLy8gbmVlZCB0byBzdGFydCB1cCB0aGUgY29tcGxleCBtYWNoaW5lcnkuIEp1c3QgdXNlIGFqYXguXG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVyKGJhc2VfdXJsLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG4gICAgfVxuICAgIHN3aXRjaCAodXRpbHMuaXNYSFJDb3JzQ2FwYWJsZSgpKSB7XG4gICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gbmV3IEluZm9SZWNlaXZlcihiYXNlX3VybCwgdXRpbHMuWEhSQ29yc09iamVjdCk7XG4gICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gbmV3IEluZm9SZWNlaXZlcihiYXNlX3VybCwgdXRpbHMuWERST2JqZWN0KTtcbiAgICBjYXNlIDM6XG4gICAgICAgIC8vIE9wZXJhXG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVySWZyYW1lKGJhc2VfdXJsKTtcbiAgICBkZWZhdWx0OlxuICAgICAgICAvLyBJRSA3XG4gICAgICAgIHJldHVybiBuZXcgSW5mb1JlY2VpdmVyRmFrZSgpO1xuICAgIH07XG59O1xuXG5cbnZhciBXSW5mb1JlY2VpdmVySWZyYW1lID0gRmFjYWRlSlNbJ3ctaWZyYW1lLWluZm8tcmVjZWl2ZXInXSA9IGZ1bmN0aW9uKHJpLCBfdHJhbnNfdXJsLCBiYXNlX3VybCkge1xuICAgIHZhciBpciA9IG5ldyBJbmZvUmVjZWl2ZXIoYmFzZV91cmwsIHV0aWxzLlhIUkxvY2FsT2JqZWN0KTtcbiAgICBpci5vbmZpbmlzaCA9IGZ1bmN0aW9uKGluZm8sIHJ0dCkge1xuICAgICAgICByaS5fZGlkTWVzc2FnZSgnbScrSlNPTi5zdHJpbmdpZnkoW2luZm8sIHJ0dF0pKTtcbiAgICAgICAgcmkuX2RpZENsb3NlKCk7XG4gICAgfVxufTtcbldJbmZvUmVjZWl2ZXJJZnJhbWUucHJvdG90eXBlLmRvQ2xlYW51cCA9IGZ1bmN0aW9uKCkge307XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL2luZm8uanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLWlmcmFtZS1ldmVudHNvdXJjZS5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEV2ZW50U291cmNlSWZyYW1lVHJhbnNwb3J0ID0gU29ja0pTWydpZnJhbWUtZXZlbnRzb3VyY2UnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5wcm90b2NvbCA9ICd3LWlmcmFtZS1ldmVudHNvdXJjZSc7XG4gICAgdGhhdC5pX2NvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG59O1xuXG5FdmVudFNvdXJjZUlmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KCk7XG5cbkV2ZW50U291cmNlSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICgnRXZlbnRTb3VyY2UnIGluIF93aW5kb3cpICYmIElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCk7XG59O1xuXG5FdmVudFNvdXJjZUlmcmFtZVRyYW5zcG9ydC5uZWVkX2JvZHkgPSB0cnVlO1xuRXZlbnRTb3VyY2VJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDM7IC8vIGh0bWwsIGphdmFzY3JpcHQsIGV2ZW50c291cmNlXG5cblxuLy8gdy1pZnJhbWUtZXZlbnRzb3VyY2VcbnZhciBFdmVudFNvdXJjZVRyYW5zcG9ydCA9IEZhY2FkZUpTWyd3LWlmcmFtZS1ldmVudHNvdXJjZSddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcvZXZlbnRzb3VyY2UnLCBFdmVudFNvdXJjZVJlY2VpdmVyLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG59XG5FdmVudFNvdXJjZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWlmcmFtZS1ldmVudHNvdXJjZS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtaWZyYW1lLXhoci1wb2xsaW5nLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydCA9IFNvY2tKU1snaWZyYW1lLXhoci1wb2xsaW5nJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucHJvdG9jb2wgPSAndy1pZnJhbWUteGhyLXBvbGxpbmcnO1xuICAgIHRoYXQuaV9jb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xufTtcblxuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KCk7XG5cblhoclBvbGxpbmdJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3dpbmRvdy5YTUxIdHRwUmVxdWVzdCAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5uZWVkX2JvZHkgPSB0cnVlO1xuWGhyUG9sbGluZ0lmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMzsgLy8gaHRtbCwgamF2YXNjcmlwdCwgeGhyXG5cblxuLy8gdy1pZnJhbWUteGhyLXBvbGxpbmdcbnZhciBYaHJQb2xsaW5nSVRyYW5zcG9ydCA9IEZhY2FkZUpTWyd3LWlmcmFtZS14aHItcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhIUkxvY2FsT2JqZWN0KTtcbn07XG5cblhoclBvbGxpbmdJVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtaWZyYW1lLXhoci1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1pZnJhbWUtaHRtbGZpbGUuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIFRoaXMgdHJhbnNwb3J0IGdlbmVyYWxseSB3b3JrcyBpbiBhbnkgYnJvd3NlciwgYnV0IHdpbGwgY2F1c2UgYVxuLy8gc3Bpbm5pbmcgY3Vyc29yIHRvIGFwcGVhciBpbiBhbnkgYnJvd3NlciBvdGhlciB0aGFuIElFLlxuLy8gV2UgbWF5IHRlc3QgdGhpcyB0cmFuc3BvcnQgaW4gYWxsIGJyb3dzZXJzIC0gd2h5IG5vdCwgYnV0IGluXG4vLyBwcm9kdWN0aW9uIGl0IHNob3VsZCBiZSBvbmx5IHJ1biBpbiBJRS5cblxudmFyIEh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0ID0gU29ja0pTWydpZnJhbWUtaHRtbGZpbGUnXSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5wcm90b2NvbCA9ICd3LWlmcmFtZS1odG1sZmlsZSc7XG4gICAgdGhhdC5pX2NvbnN0cnVjdG9yLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG59O1xuXG4vLyBJbmhlcml0YW5jZS5cbkh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoKTtcblxuSHRtbEZpbGVJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuSHRtbEZpbGVJZnJhbWVUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcbkh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAzOyAvLyBodG1sLCBqYXZhc2NyaXB0LCBodG1sZmlsZVxuXG5cbi8vIHctaWZyYW1lLWh0bWxmaWxlXG52YXIgSHRtbEZpbGVUcmFuc3BvcnQgPSBGYWNhZGVKU1sndy1pZnJhbWUtaHRtbGZpbGUnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL2h0bWxmaWxlJywgSHRtbGZpbGVSZWNlaXZlciwgdXRpbHMuWEhSTG9jYWxPYmplY3QpO1xufTtcbkh0bWxGaWxlVHJhbnNwb3J0LnByb3RvdHlwZSA9IG5ldyBBamF4QmFzZWRUcmFuc3BvcnQoKTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtaWZyYW1lLWh0bWxmaWxlLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1wb2xsaW5nLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgUG9sbGluZyA9IGZ1bmN0aW9uKHJpLCBSZWNlaXZlciwgcmVjdl91cmwsIEFqYXhPYmplY3QpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5yaSA9IHJpO1xuICAgIHRoYXQuUmVjZWl2ZXIgPSBSZWNlaXZlcjtcbiAgICB0aGF0LnJlY3ZfdXJsID0gcmVjdl91cmw7XG4gICAgdGhhdC5BamF4T2JqZWN0ID0gQWpheE9iamVjdDtcbiAgICB0aGF0Ll9zY2hlZHVsZVJlY3YoKTtcbn07XG5cblBvbGxpbmcucHJvdG90eXBlLl9zY2hlZHVsZVJlY3YgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHBvbGwgPSB0aGF0LnBvbGwgPSBuZXcgdGhhdC5SZWNlaXZlcih0aGF0LnJlY3ZfdXJsLCB0aGF0LkFqYXhPYmplY3QpO1xuICAgIHZhciBtc2dfY291bnRlciA9IDA7XG4gICAgcG9sbC5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIG1zZ19jb3VudGVyICs9IDE7XG4gICAgICAgIHRoYXQucmkuX2RpZE1lc3NhZ2UoZS5kYXRhKTtcbiAgICB9O1xuICAgIHBvbGwub25jbG9zZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhhdC5wb2xsID0gcG9sbCA9IHBvbGwub25tZXNzYWdlID0gcG9sbC5vbmNsb3NlID0gbnVsbDtcbiAgICAgICAgaWYgKCF0aGF0LnBvbGxfaXNfY2xvc2luZykge1xuICAgICAgICAgICAgaWYgKGUucmVhc29uID09PSAncGVybWFuZW50Jykge1xuICAgICAgICAgICAgICAgIHRoYXQucmkuX2RpZENsb3NlKDEwMDYsICdQb2xsaW5nIGVycm9yICgnICsgZS5yZWFzb24gKyAnKScpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGF0Ll9zY2hlZHVsZVJlY3YoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnBvbGxfaXNfY2xvc2luZyA9IHRydWU7XG4gICAgaWYgKHRoYXQucG9sbCkge1xuICAgICAgICB0aGF0LnBvbGwuYWJvcnQoKTtcbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1wb2xsaW5nLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1yZWNlaXZlci1ldmVudHNvdXJjZS5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEV2ZW50U291cmNlUmVjZWl2ZXIgPSBmdW5jdGlvbih1cmwpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIGVzID0gbmV3IEV2ZW50U291cmNlKHVybCk7XG4gICAgZXMub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdtZXNzYWdlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7J2RhdGEnOiB1bmVzY2FwZShlLmRhdGEpfSkpO1xuICAgIH07XG4gICAgdGhhdC5lc19jbG9zZSA9IGVzLm9uZXJyb3IgPSBmdW5jdGlvbihlLCBhYm9ydF9yZWFzb24pIHtcbiAgICAgICAgLy8gRVMgb24gcmVjb25uZWN0aW9uIGhhcyByZWFkeVN0YXRlID0gMCBvciAxLlxuICAgICAgICAvLyBvbiBuZXR3b3JrIGVycm9yIGl0J3MgQ0xPU0VEID0gMlxuICAgICAgICB2YXIgcmVhc29uID0gYWJvcnRfcmVhc29uID8gJ3VzZXInIDpcbiAgICAgICAgICAgIChlcy5yZWFkeVN0YXRlICE9PSAyID8gJ25ldHdvcmsnIDogJ3Blcm1hbmVudCcpO1xuICAgICAgICB0aGF0LmVzX2Nsb3NlID0gZXMub25tZXNzYWdlID0gZXMub25lcnJvciA9IG51bGw7XG4gICAgICAgIC8vIEV2ZW50U291cmNlIHJlY29ubmVjdHMgYXV0b21hdGljYWxseS5cbiAgICAgICAgZXMuY2xvc2UoKTtcbiAgICAgICAgZXMgPSBudWxsO1xuICAgICAgICAvLyBTYWZhcmkgYW5kIGNocm9tZSA8IDE1IGNyYXNoIGlmIHdlIGNsb3NlIHdpbmRvdyBiZWZvcmVcbiAgICAgICAgLy8gd2FpdGluZyBmb3IgRVMgY2xlYW51cC4gU2VlOlxuICAgICAgICAvLyAgIGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD04OTE1NVxuICAgICAgICB1dGlscy5kZWxheSgyMDAsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnY2xvc2UnLCB7cmVhc29uOiByZWFzb259KSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgIH07XG59O1xuXG5FdmVudFNvdXJjZVJlY2VpdmVyLnByb3RvdHlwZSA9IG5ldyBSRXZlbnRUYXJnZXQoKTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuZXNfY2xvc2UpIHtcbiAgICAgICAgdGhhdC5lc19jbG9zZSh7fSwgdHJ1ZSk7XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtcmVjZWl2ZXItZXZlbnRzb3VyY2UuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXJlY2VpdmVyLWh0bWxmaWxlLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgX2lzX2llX2h0bWxmaWxlX2NhcGFibGU7XG52YXIgaXNJZUh0bWxmaWxlQ2FwYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChfaXNfaWVfaHRtbGZpbGVfY2FwYWJsZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICgnQWN0aXZlWE9iamVjdCcgaW4gX3dpbmRvdykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBfaXNfaWVfaHRtbGZpbGVfY2FwYWJsZSA9ICEhbmV3IEFjdGl2ZVhPYmplY3QoJ2h0bWxmaWxlJyk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgX2lzX2llX2h0bWxmaWxlX2NhcGFibGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gX2lzX2llX2h0bWxmaWxlX2NhcGFibGU7XG59O1xuXG5cbnZhciBIdG1sZmlsZVJlY2VpdmVyID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcblxuICAgIHRoYXQuaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDYsIDI2KTtcbiAgICB1cmwgKz0gKCh1cmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICtcbiAgICAgICAgJ2M9JyArIGVzY2FwZShXUHJlZml4ICsgJy4nICsgdGhhdC5pZCk7XG5cbiAgICB2YXIgY29uc3RydWN0b3IgPSBpc0llSHRtbGZpbGVDYXBhYmxlKCkgP1xuICAgICAgICB1dGlscy5jcmVhdGVIdG1sZmlsZSA6IHV0aWxzLmNyZWF0ZUlmcmFtZTtcblxuICAgIHZhciBpZnJhbWVPYmo7XG4gICAgX3dpbmRvd1tXUHJlZml4XVt0aGF0LmlkXSA9IHtcbiAgICAgICAgc3RhcnQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmcmFtZU9iai5sb2FkZWQoKTtcbiAgICAgICAgfSxcbiAgICAgICAgbWVzc2FnZTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ21lc3NhZ2UnLCB7J2RhdGEnOiBkYXRhfSkpO1xuICAgICAgICB9LFxuICAgICAgICBzdG9wOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aGF0LmlmcmFtZV9jbG9zZSh7fSwgJ25ldHdvcmsnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC5pZnJhbWVfY2xvc2UgPSBmdW5jdGlvbihlLCBhYm9ydF9yZWFzb24pIHtcbiAgICAgICAgaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2UgPSBpZnJhbWVPYmogPSBudWxsO1xuICAgICAgICBkZWxldGUgX3dpbmRvd1tXUHJlZml4XVt0aGF0LmlkXTtcbiAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnY2xvc2UnLCB7cmVhc29uOiBhYm9ydF9yZWFzb259KSk7XG4gICAgfTtcbiAgICBpZnJhbWVPYmogPSBjb25zdHJ1Y3Rvcih1cmwsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2Uoe30sICdwZXJtYW5lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbn07XG5cbkh0bWxmaWxlUmVjZWl2ZXIucHJvdG90eXBlID0gbmV3IFJFdmVudFRhcmdldCgpO1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5pZnJhbWVfY2xvc2UpIHtcbiAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2Uoe30sICd1c2VyJyk7XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtcmVjZWl2ZXItaHRtbGZpbGUuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLXJlY2VpdmVyLXhoci5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIFhoclJlY2VpdmVyID0gZnVuY3Rpb24odXJsLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBidWZfcG9zID0gMDtcblxuICAgIHRoYXQueG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCwgbnVsbCk7XG4gICAgdGhhdC54by5vbmNodW5rID0gZnVuY3Rpb24oc3RhdHVzLCB0ZXh0KSB7XG4gICAgICAgIGlmIChzdGF0dXMgIT09IDIwMCkgcmV0dXJuO1xuICAgICAgICB3aGlsZSAoMSkge1xuICAgICAgICAgICAgdmFyIGJ1ZiA9IHRleHQuc2xpY2UoYnVmX3Bvcyk7XG4gICAgICAgICAgICB2YXIgcCA9IGJ1Zi5pbmRleE9mKCdcXG4nKTtcbiAgICAgICAgICAgIGlmIChwID09PSAtMSkgYnJlYWs7XG4gICAgICAgICAgICBidWZfcG9zICs9IHArMTtcbiAgICAgICAgICAgIHZhciBtc2cgPSBidWYuc2xpY2UoMCwgcCk7XG4gICAgICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdtZXNzYWdlJywge2RhdGE6IG1zZ30pKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgdGhhdC54by5vbmZpbmlzaCA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICB0aGF0LnhvLm9uY2h1bmsoc3RhdHVzLCB0ZXh0KTtcbiAgICAgICAgdGhhdC54byA9IG51bGw7XG4gICAgICAgIHZhciByZWFzb24gPSBzdGF0dXMgPT09IDIwMCA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnO1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdjbG9zZScsIHtyZWFzb246IHJlYXNvbn0pKTtcbiAgICB9XG59O1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUgPSBuZXcgUkV2ZW50VGFyZ2V0KCk7XG5cblhoclJlY2VpdmVyLnByb3RvdHlwZS5hYm9ydCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC54bykge1xuICAgICAgICB0aGF0LnhvLmNsb3NlKCk7XG4gICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ2Nsb3NlJywge3JlYXNvbjogJ3VzZXInfSkpO1xuICAgICAgICB0aGF0LnhvID0gbnVsbDtcbiAgICB9XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1yZWNlaXZlci14aHIuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3Rlc3QtaG9va3MuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIEZvciB0ZXN0aW5nXG5Tb2NrSlMuZ2V0VXRpbHMgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiB1dGlscztcbn07XG5cblNvY2tKUy5nZXRJZnJhbWVUcmFuc3BvcnQgPSBmdW5jdGlvbigpe1xuICAgIHJldHVybiBJZnJhbWVUcmFuc3BvcnQ7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90ZXN0LWhvb2tzLmpzXG5cbiAgICAgICAgICAgICAgICAgIHJldHVybiBTb2NrSlM7XG4gICAgICAgICAgfSkoKTtcbmlmICgnX3NvY2tqc19vbmxvYWQnIGluIHdpbmRvdykgc2V0VGltZW91dChfc29ja2pzX29ubG9hZCwgMSk7XG5cbi8vIEFNRCBjb21wbGlhbmNlXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCdzb2NranMnLCBbXSwgZnVuY3Rpb24oKXtyZXR1cm4gU29ja0pTO30pO1xufVxuXG5pZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBTb2NrSlM7XG59XG4vLyAgICAgWypdIEVuZCBvZiBsaWIvaW5kZXguanNcblxuLy8gWypdIEVuZCBvZiBsaWIvYWxsLmpzXG5cbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5tb2R1bGUuZXhwb3J0cyA9IFN0cmVhbTtcblxudmFyIEVFID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcblxuaW5oZXJpdHMoU3RyZWFtLCBFRSk7XG5TdHJlYW0uUmVhZGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUuanMnKTtcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xuU3RyZWFtLkR1cGxleCA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9kdXBsZXguanMnKTtcblN0cmVhbS5UcmFuc2Zvcm0gPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vdHJhbnNmb3JtLmpzJyk7XG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC40LnhcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XG5cblxuXG4vLyBvbGQtc3R5bGUgc3RyZWFtcy4gIE5vdGUgdGhhdCB0aGUgcGlwZSBtZXRob2QgKHRoZSBvbmx5IHJlbGV2YW50XG4vLyBwYXJ0IG9mIHRoaXMgY2xhc3MpIGlzIG92ZXJyaWRkZW4gaW4gdGhlIFJlYWRhYmxlIGNsYXNzLlxuXG5mdW5jdGlvbiBTdHJlYW0oKSB7XG4gIEVFLmNhbGwodGhpcyk7XG59XG5cblN0cmVhbS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uKGRlc3QsIG9wdGlvbnMpIHtcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XG5cbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcbiAgICAgIGlmIChmYWxzZSA9PT0gZGVzdC53cml0ZShjaHVuaykgJiYgc291cmNlLnBhdXNlKSB7XG4gICAgICAgIHNvdXJjZS5wYXVzZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHNvdXJjZS5vbignZGF0YScsIG9uZGF0YSk7XG5cbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcbiAgICBpZiAoc291cmNlLnJlYWRhYmxlICYmIHNvdXJjZS5yZXN1bWUpIHtcbiAgICAgIHNvdXJjZS5yZXN1bWUoKTtcbiAgICB9XG4gIH1cblxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIC8vIElmIHRoZSAnZW5kJyBvcHRpb24gaXMgbm90IHN1cHBsaWVkLCBkZXN0LmVuZCgpIHdpbGwgYmUgY2FsbGVkIHdoZW5cbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXG4gIGlmICghZGVzdC5faXNTdGRpbyAmJiAoIW9wdGlvbnMgfHwgb3B0aW9ucy5lbmQgIT09IGZhbHNlKSkge1xuICAgIHNvdXJjZS5vbignZW5kJywgb25lbmQpO1xuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcbiAgfVxuXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cblxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xuICAgIGRpZE9uRW5kID0gdHJ1ZTtcblxuICAgIGlmICh0eXBlb2YgZGVzdC5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSBkZXN0LmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8vIGRvbid0IGxlYXZlIGRhbmdsaW5nIHBpcGVzIHdoZW4gdGhlcmUgYXJlIGVycm9ycy5cbiAgZnVuY3Rpb24gb25lcnJvcihlcikge1xuICAgIGNsZWFudXAoKTtcbiAgICBpZiAoRUUubGlzdGVuZXJDb3VudCh0aGlzLCAnZXJyb3InKSA9PT0gMCkge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCBzdHJlYW0gZXJyb3IgaW4gcGlwZS5cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XG4gIGRlc3Qub24oJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcblxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgY2xlYW51cCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcbiAgfVxuXG4gIHNvdXJjZS5vbignZW5kJywgY2xlYW51cCk7XG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0Lm9uKCdjbG9zZScsIGNsZWFudXApO1xuXG4gIGRlc3QuZW1pdCgncGlwZScsIHNvdXJjZSk7XG5cbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcbiAgcmV0dXJuIGRlc3Q7XG59O1xuIiwidmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XG5cbm1vZHVsZS5leHBvcnRzID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbiAoYXJyKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBkdXBsZXggc3RyZWFtIGlzIGp1c3QgYSBzdHJlYW0gdGhhdCBpcyBib3RoIHJlYWRhYmxlIGFuZCB3cml0YWJsZS5cbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXG4vLyBwcm90b3R5cGFsbHkgaW5oZXJpdHMgZnJvbSBSZWFkYWJsZSwgYW5kIHRoZW4gcGFyYXNpdGljYWxseSBmcm9tXG4vLyBXcml0YWJsZS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBrZXlzLnB1c2goa2V5KTtcbiAgfXJldHVybiBrZXlzO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IER1cGxleDtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcbnZhciBXcml0YWJsZSA9IHJlcXVpcmUoJy4vX3N0cmVhbV93cml0YWJsZScpO1xuXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xuXG52YXIga2V5cyA9IG9iamVjdEtleXMoV3JpdGFibGUucHJvdG90eXBlKTtcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICB2YXIgbWV0aG9kID0ga2V5c1t2XTtcbiAgaWYgKCFEdXBsZXgucHJvdG90eXBlW21ldGhvZF0pIER1cGxleC5wcm90b3R5cGVbbWV0aG9kXSA9IFdyaXRhYmxlLnByb3RvdHlwZVttZXRob2RdO1xufVxuXG5mdW5jdGlvbiBEdXBsZXgob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XG5cbiAgUmVhZGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnJlYWRhYmxlID09PSBmYWxzZSkgdGhpcy5yZWFkYWJsZSA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMud3JpdGFibGUgPT09IGZhbHNlKSB0aGlzLndyaXRhYmxlID0gZmFsc2U7XG5cbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5hbGxvd0hhbGZPcGVuID09PSBmYWxzZSkgdGhpcy5hbGxvd0hhbGZPcGVuID0gZmFsc2U7XG5cbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XG59XG5cbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcbmZ1bmN0aW9uIG9uZW5kKCkge1xuICAvLyBpZiB3ZSBhbGxvdyBoYWxmLW9wZW4gc3RhdGUsIG9yIGlmIHRoZSB3cml0YWJsZSBzaWRlIGVuZGVkLFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxuICBpZiAodGhpcy5hbGxvd0hhbGZPcGVuIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQpIHJldHVybjtcblxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXG4gIC8vIEJ1dCBhbGxvdyBtb3JlIHdyaXRlcyB0byBoYXBwZW4gaW4gdGhpcyB0aWNrLlxuICBwcm9jZXNzTmV4dFRpY2sob25FbmROVCwgdGhpcyk7XG59XG5cbmZ1bmN0aW9uIG9uRW5kTlQoc2VsZikge1xuICBzZWxmLmVuZCgpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkICYmIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5wdXNoKG51bGwpO1xuICB0aGlzLmVuZCgpO1xuXG4gIHByb2Nlc3NOZXh0VGljayhjYiwgZXJyKTtcbn07XG5cbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmKHhzW2ldLCBpKTtcbiAgfVxufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHBhc3N0aHJvdWdoIHN0cmVhbS5cbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxuLy8gRXZlcnkgd3JpdHRlbiBjaHVuayBnZXRzIG91dHB1dCBhcy1pcy5cblxuJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFBhc3NUaHJvdWdoO1xuXG52YXIgVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9fc3RyZWFtX3RyYW5zZm9ybScpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoUGFzc1Rocm91Z2gsIFRyYW5zZm9ybSk7XG5cbmZ1bmN0aW9uIFBhc3NUaHJvdWdoKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFBhc3NUaHJvdWdoKSkgcmV0dXJuIG5ldyBQYXNzVGhyb3VnaChvcHRpb25zKTtcblxuICBUcmFuc2Zvcm0uY2FsbCh0aGlzLCBvcHRpb25zKTtcbn1cblxuUGFzc1Rocm91Z2gucHJvdG90eXBlLl90cmFuc2Zvcm0gPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBjYihudWxsLCBjaHVuayk7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5SZWFkYWJsZS5SZWFkYWJsZVN0YXRlID0gUmVhZGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcblxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVycyh0eXBlKS5sZW5ndGg7XG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIFRPRE8oYm1ldXJlcik6IENoYW5nZSB0aGlzIGJhY2sgdG8gY29uc3Qgb25jZSBob2xlIGNoZWNrcyBhcmVcbi8vIHByb3Blcmx5IG9wdGltaXplZCBhd2F5IGVhcmx5IGluIElnbml0aW9uK1R1cmJvRmFuLlxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgZGVidWdVdGlsID0gcmVxdWlyZSgndXRpbCcpO1xudmFyIGRlYnVnID0gdm9pZCAwO1xuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcbiAgZGVidWcgPSBkZWJ1Z1V0aWwuZGVidWdsb2coJ3N0cmVhbScpO1xufSBlbHNlIHtcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgQnVmZmVyTGlzdCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9CdWZmZXJMaXN0Jyk7XG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xudmFyIFN0cmluZ0RlY29kZXI7XG5cbnV0aWwuaW5oZXJpdHMoUmVhZGFibGUsIFN0cmVhbSk7XG5cbnZhciBrUHJveHlFdmVudHMgPSBbJ2Vycm9yJywgJ2Nsb3NlJywgJ2Rlc3Ryb3knLCAncGF1c2UnLCAncmVzdW1lJ107XG5cbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcbiAgLy8gU2FkbHkgdGhpcyBpcyBub3QgY2FjaGVhYmxlIGFzIHNvbWUgbGlicmFyaWVzIGJ1bmRsZSB0aGVpciBvd25cbiAgLy8gZXZlbnQgZW1pdHRlciBpbXBsZW1lbnRhdGlvbiB3aXRoIHRoZW0uXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XG4gICAgLy8gdXNlcmxhbmQgb25lcy4gIE5FVkVSIERPIFRISVMuIFRoaXMgaXMgaGVyZSBvbmx5IGJlY2F1c2UgdGhpcyBjb2RlIG5lZWRzXG4gICAgLy8gdG8gY29udGludWUgdG8gd29yayB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIE5vZGUuanMgdGhhdCBkbyBub3QgaW5jbHVkZVxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cbiAgICBpZiAoIWVtaXR0ZXIuX2V2ZW50cyB8fCAhZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkgZW1pdHRlci5vbihldmVudCwgZm4pO2Vsc2UgaWYgKGlzQXJyYXkoZW1pdHRlci5fZXZlbnRzW2V2ZW50XSkpIGVtaXR0ZXIuX2V2ZW50c1tldmVudF0udW5zaGlmdChmbik7ZWxzZSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdID0gW2ZuLCBlbWl0dGVyLl9ldmVudHNbZXZlbnRdXTtcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZy4gVXNlZCB0byBtYWtlIHJlYWQobikgaWdub3JlIG4gYW5kIHRvXG4gIC8vIG1ha2UgYWxsIHRoZSBidWZmZXIgbWVyZ2luZyBhbmQgbGVuZ3RoIGNoZWNrcyBnbyBhd2F5XG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMucmVhZGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCBpdCBzdG9wcyBjYWxsaW5nIF9yZWFkKCkgdG8gZmlsbCB0aGUgYnVmZmVyXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgXCJkb24ndCBjYWxsIF9yZWFkIHByZWVtcHRpdmVseSBldmVyXCJcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gQSBsaW5rZWQgbGlzdCBpcyB1c2VkIHRvIHN0b3JlIGRhdGEgY2h1bmtzIGluc3RlYWQgb2YgYW4gYXJyYXkgYmVjYXVzZSB0aGVcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cbiAgLy8gYXJyYXkuc2hpZnQoKVxuICB0aGlzLmJ1ZmZlciA9IG5ldyBCdWZmZXJMaXN0KCk7XG4gIHRoaXMubGVuZ3RoID0gMDtcbiAgdGhpcy5waXBlcyA9IG51bGw7XG4gIHRoaXMucGlwZXNDb3VudCA9IDA7XG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgdGhpcy5lbmRFbWl0dGVkID0gZmFsc2U7XG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIGV2ZW50ICdyZWFkYWJsZScvJ2RhdGEnIGlzIGVtaXR0ZWRcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcbiAgLy8gYW55IGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cbiAgdGhpcy5zeW5jID0gdHJ1ZTtcblxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxuICAvLyB0aGF0IHdlJ3JlIGF3YWl0aW5nIGEgJ3JlYWRhYmxlJyBldmVudCBlbWlzc2lvbi5cbiAgdGhpcy5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgdGhpcy5yZWFkYWJsZUxpc3RlbmluZyA9IGZhbHNlO1xuICB0aGlzLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuXG4gIC8vIGhhcyBpdCBiZWVuIGRlc3Ryb3llZFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuXG4gIC8vIENyeXB0byBpcyBraW5kIG9mIG9sZCBhbmQgY3J1c3R5LiAgSGlzdG9yaWNhbGx5LCBpdHMgZGVmYXVsdCBzdHJpbmdcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXG4gIHRoaXMuZGVmYXVsdEVuY29kaW5nID0gb3B0aW9ucy5kZWZhdWx0RW5jb2RpbmcgfHwgJ3V0ZjgnO1xuXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXG4gIHRoaXMuYXdhaXREcmFpbiA9IDA7XG5cbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxuICB0aGlzLnJlYWRpbmdNb3JlID0gZmFsc2U7XG5cbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcbiAgdGhpcy5lbmNvZGluZyA9IG51bGw7XG4gIGlmIChvcHRpb25zLmVuY29kaW5nKSB7XG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcbiAgICB0aGlzLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihvcHRpb25zLmVuY29kaW5nKTtcbiAgICB0aGlzLmVuY29kaW5nID0gb3B0aW9ucy5lbmNvZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcblxuICB0aGlzLl9yZWFkYWJsZVN0YXRlID0gbmV3IFJlYWRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5XG4gIHRoaXMucmVhZGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlYWQgPT09ICdmdW5jdGlvbicpIHRoaXMuX3JlYWQgPSBvcHRpb25zLnJlYWQ7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcbiAgfVxuXG4gIFN0cmVhbS5jYWxsKHRoaXMpO1xufVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoUmVhZGFibGUucHJvdG90eXBlLCAnZGVzdHJveWVkJywge1xuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxuICAgIC8vIG1hbmFnaW5nIGRlc3Ryb3llZFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdmFsdWU7XG4gIH1cbn0pO1xuXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX3VuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLnVuZGVzdHJveTtcblJlYWRhYmxlLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgY2IoZXJyKTtcbn07XG5cbi8vIE1hbnVhbGx5IHNob3ZlIHNvbWV0aGluZyBpbnRvIHRoZSByZWFkKCkgYnVmZmVyLlxuLy8gVGhpcyByZXR1cm5zIHRydWUgaWYgdGhlIGhpZ2hXYXRlck1hcmsgaGFzIG5vdCBiZWVuIGhpdCB5ZXQsXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXG4vLyB3cml0ZSgpIHNvbWUgbW9yZS5cblJlYWRhYmxlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgc2tpcENodW5rQ2hlY2s7XG5cbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgaWYgKHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgfHwgc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xuICAgICAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gICAgICAgIGVuY29kaW5nID0gJyc7XG4gICAgICB9XG4gICAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHNraXBDaHVua0NoZWNrID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiByZWFkYWJsZUFkZENodW5rKHRoaXMsIGNodW5rLCBlbmNvZGluZywgZmFsc2UsIHNraXBDaHVua0NoZWNrKTtcbn07XG5cbi8vIFVuc2hpZnQgc2hvdWxkICphbHdheXMqIGJlIHNvbWV0aGluZyBkaXJlY3RseSBvdXQgb2YgcmVhZCgpXG5SZWFkYWJsZS5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIChjaHVuaykge1xuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xufTtcblxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBpZiAoY2h1bmsgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZXI7XG4gICAgaWYgKCFza2lwQ2h1bmtDaGVjaykgZXIgPSBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKTtcbiAgICBpZiAoZXIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICB9IGVsc2UgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsgJiYgY2h1bmsubGVuZ3RoID4gMCkge1xuICAgICAgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgIXN0YXRlLm9iamVjdE1vZGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKGNodW5rKSAhPT0gQnVmZmVyLnByb3RvdHlwZSkge1xuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICAgICAgfVxuXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xuICAgICAgICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0udW5zaGlmdCgpIGFmdGVyIGVuZCBldmVudCcpKTtlbHNlIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCB0cnVlKTtcbiAgICAgIH0gZWxzZSBpZiAoc3RhdGUuZW5kZWQpIHtcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XG4gICAgICAgICAgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcbiAgICAgICAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSB8fCBjaHVuay5sZW5ndGggIT09IDApIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7ZWxzZSBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKCFhZGRUb0Zyb250KSB7XG4gICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XG59XG5cbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiAhc3RhdGUuc3luYykge1xuICAgIHN0cmVhbS5lbWl0KCdkYXRhJywgY2h1bmspO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9IGVsc2Uge1xuICAgIC8vIHVwZGF0ZSB0aGUgYnVmZmVyIGluZm8uXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuICAgIGlmIChhZGRUb0Zyb250KSBzdGF0ZS5idWZmZXIudW5zaGlmdChjaHVuayk7ZWxzZSBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG5cbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbiAgfVxuICBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBjaHVua0ludmFsaWQoc3RhdGUsIGNodW5rKSB7XG4gIHZhciBlcjtcbiAgaWYgKCFfaXNVaW50OEFycmF5KGNodW5rKSAmJiB0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICByZXR1cm4gZXI7XG59XG5cbi8vIGlmIGl0J3MgcGFzdCB0aGUgaGlnaCB3YXRlciBtYXJrLCB3ZSBjYW4gcHVzaCBpbiBzb21lIG1vcmUuXG4vLyBBbHNvLCBpZiB3ZSBoYXZlIG5vIGRhdGEgeWV0LCB3ZSBjYW4gc3RhbmQgc29tZVxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXG4vLyBzdWNoIGFzIHRoZSByZXBsLiAgQWxzbywgaWYgdGhlIHB1c2goKSB0cmlnZ2VyZWQgYVxuLy8gcmVhZGFibGUgZXZlbnQsIGFuZCB0aGUgdXNlciBjYWxsZWQgcmVhZChsYXJnZU51bWJlcikgc3VjaCB0aGF0XG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxuLy8gJ3JlYWRhYmxlJyBldmVudCB3aWxsIGJlIHRyaWdnZXJlZC5cbmZ1bmN0aW9uIG5lZWRNb3JlRGF0YShzdGF0ZSkge1xuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPT09IGZhbHNlO1xufTtcblxuLy8gYmFja3dhcmRzIGNvbXBhdGliaWxpdHkuXG5SZWFkYWJsZS5wcm90b3R5cGUuc2V0RW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jKSB7XG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVjb2RlciA9IG5ldyBTdHJpbmdEZWNvZGVyKGVuYyk7XG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5jb2RpbmcgPSBlbmM7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxudmFyIE1BWF9IV00gPSAweDgwMDAwMDtcbmZ1bmN0aW9uIGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pIHtcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xuICAgIG4gPSBNQVhfSFdNO1xuICB9IGVsc2Uge1xuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxuICAgIC8vIHRpbnkgYW1vdW50c1xuICAgIG4tLTtcbiAgICBuIHw9IG4gPj4+IDE7XG4gICAgbiB8PSBuID4+PiAyO1xuICAgIG4gfD0gbiA+Pj4gNDtcbiAgICBuIHw9IG4gPj4+IDg7XG4gICAgbiB8PSBuID4+PiAxNjtcbiAgICBuKys7XG4gIH1cbiAgcmV0dXJuIG47XG59XG5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xuICBpZiAobiA8PSAwIHx8IHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgcmV0dXJuIDA7XG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXR1cm4gMTtcbiAgaWYgKG4gIT09IG4pIHtcbiAgICAvLyBPbmx5IGZsb3cgb25lIGJ1ZmZlciBhdCBhIHRpbWVcbiAgICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGgpIHJldHVybiBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhLmxlbmd0aDtlbHNlIHJldHVybiBzdGF0ZS5sZW5ndGg7XG4gIH1cbiAgLy8gSWYgd2UncmUgYXNraW5nIGZvciBtb3JlIHRoYW4gdGhlIGN1cnJlbnQgaHdtLCB0aGVuIHJhaXNlIHRoZSBod20uXG4gIGlmIChuID4gc3RhdGUuaGlnaFdhdGVyTWFyaykgc3RhdGUuaGlnaFdhdGVyTWFyayA9IGNvbXB1dGVOZXdIaWdoV2F0ZXJNYXJrKG4pO1xuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xuICAvLyBEb24ndCBoYXZlIGVub3VnaFxuICBpZiAoIXN0YXRlLmVuZGVkKSB7XG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICByZXR1cm4gMDtcbiAgfVxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xufVxuXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxuUmVhZGFibGUucHJvdG90eXBlLnJlYWQgPSBmdW5jdGlvbiAobikge1xuICBkZWJ1ZygncmVhZCcsIG4pO1xuICBuID0gcGFyc2VJbnQobiwgMTApO1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgbk9yaWcgPSBuO1xuXG4gIGlmIChuICE9PSAwKSBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcblxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXG4gIC8vIGFscmVhZHkgaGF2ZSBhIGJ1bmNoIG9mIGRhdGEgaW4gdGhlIGJ1ZmZlciwgdGhlbiBqdXN0IHRyaWdnZXJcbiAgLy8gdGhlICdyZWFkYWJsZScgZXZlbnQgYW5kIG1vdmUgb24uXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XG4gICAgZGVidWcoJ3JlYWQ6IGVtaXRSZWFkYWJsZScsIHN0YXRlLmxlbmd0aCwgc3RhdGUuZW5kZWQpO1xuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIGVuZFJlYWRhYmxlKHRoaXMpO2Vsc2UgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xuXG4gIC8vIGlmIHdlJ3ZlIGVuZGVkLCBhbmQgd2UncmUgbm93IGNsZWFyLCB0aGVuIGZpbmlzaCBpdCB1cC5cbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIC8vIEFsbCB0aGUgYWN0dWFsIGNodW5rIGdlbmVyYXRpb24gbG9naWMgbmVlZHMgdG8gYmVcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXG4gIC8vIHN5bnRoZXRpYyBzdHJlYW0gY2FzZXMsIHN1Y2ggYXMgcGFzc3Rocm91Z2ggc3RyZWFtcywgX3JlYWRcbiAgLy8gbWF5IGJlIGEgY29tcGxldGVseSBzeW5jaHJvbm91cyBvcGVyYXRpb24gd2hpY2ggbWF5IGNoYW5nZVxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxuICAvLyBiZWZvcmUgdGhlcmUgd2FzICpub3QqIGVub3VnaC5cbiAgLy9cbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XG4gIC8vIDEuIEZpZ3VyZSBvdXQgd2hhdCB0aGUgc3RhdGUgb2YgdGhpbmdzIHdpbGwgYmUgYWZ0ZXIgd2UgZG9cbiAgLy8gYSByZWFkIGZyb20gdGhlIGJ1ZmZlci5cbiAgLy9cbiAgLy8gMi4gSWYgdGhhdCByZXN1bHRpbmcgc3RhdGUgd2lsbCB0cmlnZ2VyIGEgX3JlYWQsIHRoZW4gY2FsbCBfcmVhZC5cbiAgLy8gTm90ZSB0aGF0IHRoaXMgbWF5IGJlIGFzeW5jaHJvbm91cywgb3Igc3luY2hyb25vdXMuICBZZXMsIGl0IGlzXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxuICAvLyB0aGF0IHRoZSBSZWFkYWJsZSBjbGFzcyBzaG91bGQgYmVoYXZlIGltcHJvcGVybHksIGFzIHN0cmVhbXMgYXJlXG4gIC8vIGRlc2lnbmVkIHRvIGJlIHN5bmMvYXN5bmMgYWdub3N0aWMuXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxuICAvLyBoYXMgcmV0dXJuZWQgeWV0KSwgc28gdGhhdCB3ZSBrbm93IHdoZXRoZXIgb3Igbm90IGl0J3Mgc2FmZSB0byBlbWl0XG4gIC8vICdyZWFkYWJsZScgZXRjLlxuICAvL1xuICAvLyAzLiBBY3R1YWxseSBwdWxsIHRoZSByZXF1ZXN0ZWQgY2h1bmtzIG91dCBvZiB0aGUgYnVmZmVyIGFuZCByZXR1cm4uXG5cbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxuICB2YXIgZG9SZWFkID0gc3RhdGUubmVlZFJlYWRhYmxlO1xuICBkZWJ1ZygnbmVlZCByZWFkYWJsZScsIGRvUmVhZCk7XG5cbiAgLy8gaWYgd2UgY3VycmVudGx5IGhhdmUgbGVzcyB0aGFuIHRoZSBoaWdoV2F0ZXJNYXJrLCB0aGVuIGFsc28gcmVhZCBzb21lXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgfHwgc3RhdGUubGVuZ3RoIC0gbiA8IHN0YXRlLmhpZ2hXYXRlck1hcmspIHtcbiAgICBkb1JlYWQgPSB0cnVlO1xuICAgIGRlYnVnKCdsZW5ndGggbGVzcyB0aGFuIHdhdGVybWFyaycsIGRvUmVhZCk7XG4gIH1cblxuICAvLyBob3dldmVyLCBpZiB3ZSd2ZSBlbmRlZCwgdGhlbiB0aGVyZSdzIG5vIHBvaW50LCBhbmQgaWYgd2UncmUgYWxyZWFkeVxuICAvLyByZWFkaW5nLCB0aGVuIGl0J3MgdW5uZWNlc3NhcnkuXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZG9SZWFkID0gZmFsc2U7XG4gICAgZGVidWcoJ3JlYWRpbmcgb3IgZW5kZWQnLCBkb1JlYWQpO1xuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xuICAgIGRlYnVnKCdkbyByZWFkJyk7XG4gICAgc3RhdGUucmVhZGluZyA9IHRydWU7XG4gICAgc3RhdGUuc3luYyA9IHRydWU7XG4gICAgLy8gaWYgdGhlIGxlbmd0aCBpcyBjdXJyZW50bHkgemVybywgdGhlbiB3ZSAqbmVlZCogYSByZWFkYWJsZSBldmVudC5cbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcbiAgICB0aGlzLl9yZWFkKHN0YXRlLmhpZ2hXYXRlck1hcmspO1xuICAgIHN0YXRlLnN5bmMgPSBmYWxzZTtcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxuICAgIC8vIGFuZCB3ZSBuZWVkIHRvIHJlLWV2YWx1YXRlIGhvdyBtdWNoIGRhdGEgd2UgY2FuIHJldHVybiB0byB0aGUgdXNlci5cbiAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIG4gPSBob3dNdWNoVG9SZWFkKG5PcmlnLCBzdGF0ZSk7XG4gIH1cblxuICB2YXIgcmV0O1xuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XG5cbiAgaWYgKHJldCA9PT0gbnVsbCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgbiA9IDA7XG4gIH0gZWxzZSB7XG4gICAgc3RhdGUubGVuZ3RoIC09IG47XG4gIH1cblxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XG4gICAgLy8gSWYgd2UgaGF2ZSBub3RoaW5nIGluIHRoZSBidWZmZXIsIHRoZW4gd2Ugd2FudCB0byBrbm93XG4gICAgLy8gYXMgc29vbiBhcyB3ZSAqZG8qIGdldCBzb21ldGhpbmcgaW50byB0aGUgYnVmZmVyLlxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG5cbiAgICAvLyBJZiB3ZSB0cmllZCB0byByZWFkKCkgcGFzdCB0aGUgRU9GLCB0aGVuIGVtaXQgZW5kIG9uIHRoZSBuZXh0IHRpY2suXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcbiAgfVxuXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbmZ1bmN0aW9uIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcbiAgaWYgKHN0YXRlLmRlY29kZXIpIHtcbiAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcbiAgICAgIHN0YXRlLmJ1ZmZlci5wdXNoKGNodW5rKTtcbiAgICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICB9XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuXG4gIC8vIGVtaXQgJ3JlYWRhYmxlJyBub3cgdG8gbWFrZSBzdXJlIGl0IGdldHMgcGlja2VkIHVwLlxuICBlbWl0UmVhZGFibGUoc3RyZWFtKTtcbn1cblxuLy8gRG9uJ3QgZW1pdCByZWFkYWJsZSByaWdodCBhd2F5IGluIHN5bmMgbW9kZSwgYmVjYXVzZSB0aGlzIGNhbiB0cmlnZ2VyXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcbi8vIGEgbmV4dFRpY2sgcmVjdXJzaW9uIHdhcm5pbmcsIGJ1dCB0aGF0J3Mgbm90IHNvIGJhZC5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZShzdHJlYW0pIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBzdGF0ZS5uZWVkUmVhZGFibGUgPSBmYWxzZTtcbiAgaWYgKCFzdGF0ZS5lbWl0dGVkUmVhZGFibGUpIHtcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XG4gICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICBpZiAoc3RhdGUuc3luYykgcHJvY2Vzc05leHRUaWNrKGVtaXRSZWFkYWJsZV8sIHN0cmVhbSk7ZWxzZSBlbWl0UmVhZGFibGVfKHN0cmVhbSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcbiAgZGVidWcoJ2VtaXQgcmVhZGFibGUnKTtcbiAgc3RyZWFtLmVtaXQoJ3JlYWRhYmxlJyk7XG4gIGZsb3coc3RyZWFtKTtcbn1cblxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcbi8vIGFuZCBjYWxsZWQgcmVhZCgpIHRvIGNvbnN1bWUgc29tZSBkYXRhLiAgdGhhdCBtYXkgaGF2ZSB0cmlnZ2VyZWRcbi8vIGluIHR1cm4gYW5vdGhlciBfcmVhZChuKSBjYWxsLCBpbiB3aGljaCBjYXNlIHJlYWRpbmcgPSB0cnVlIGlmXG4vLyBpdCdzIGluIHByb2dyZXNzLlxuLy8gSG93ZXZlciwgaWYgd2UncmUgbm90IGVuZGVkLCBvciByZWFkaW5nLCBhbmQgdGhlIGxlbmd0aCA8IGh3bSxcbi8vIHRoZW4gZ28gYWhlYWQgYW5kIHRyeSB0byByZWFkIHNvbWUgbW9yZSBwcmVlbXB0aXZlbHkuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nTW9yZSkge1xuICAgIHN0YXRlLnJlYWRpbmdNb3JlID0gdHJ1ZTtcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1heWJlUmVhZE1vcmVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZGVidWcoJ21heWJlUmVhZE1vcmUgcmVhZCAwJyk7XG4gICAgc3RyZWFtLnJlYWQoMCk7XG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxuICAgICAgLy8gZGlkbid0IGdldCBhbnkgZGF0YSwgc3RvcCBzcGlubmluZy5cbiAgICAgIGJyZWFrO2Vsc2UgbGVuID0gc3RhdGUubGVuZ3RoO1xuICB9XG4gIHN0YXRlLnJlYWRpbmdNb3JlID0gZmFsc2U7XG59XG5cbi8vIGFic3RyYWN0IG1ldGhvZC4gIHRvIGJlIG92ZXJyaWRkZW4gaW4gc3BlY2lmaWMgaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vIGNhbGwgY2IoZXIsIGRhdGEpIHdoZXJlIGRhdGEgaXMgPD0gbiBpbiBsZW5ndGguXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXCJsZW5ndGhcIiBpcyBzb21ld2hhdFxuLy8gYXJiaXRyYXJ5LCBhbmQgcGVyaGFwcyBub3QgdmVyeSBtZWFuaW5nZnVsLlxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignX3JlYWQoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5SZWFkYWJsZS5wcm90b3R5cGUucGlwZSA9IGZ1bmN0aW9uIChkZXN0LCBwaXBlT3B0cykge1xuICB2YXIgc3JjID0gdGhpcztcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcblxuICBzd2l0Y2ggKHN0YXRlLnBpcGVzQ291bnQpIHtcbiAgICBjYXNlIDA6XG4gICAgICBzdGF0ZS5waXBlcyA9IGRlc3Q7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDE6XG4gICAgICBzdGF0ZS5waXBlcyA9IFtzdGF0ZS5waXBlcywgZGVzdF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgc3RhdGUucGlwZXMucHVzaChkZXN0KTtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHN0YXRlLnBpcGVzQ291bnQgKz0gMTtcbiAgZGVidWcoJ3BpcGUgY291bnQ9JWQgb3B0cz0laicsIHN0YXRlLnBpcGVzQ291bnQsIHBpcGVPcHRzKTtcblxuICB2YXIgZG9FbmQgPSAoIXBpcGVPcHRzIHx8IHBpcGVPcHRzLmVuZCAhPT0gZmFsc2UpICYmIGRlc3QgIT09IHByb2Nlc3Muc3Rkb3V0ICYmIGRlc3QgIT09IHByb2Nlc3Muc3RkZXJyO1xuXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XG4gIGlmIChzdGF0ZS5lbmRFbWl0dGVkKSBwcm9jZXNzTmV4dFRpY2soZW5kRm4pO2Vsc2Ugc3JjLm9uY2UoJ2VuZCcsIGVuZEZuKTtcblxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XG4gIGZ1bmN0aW9uIG9udW5waXBlKHJlYWRhYmxlLCB1bnBpcGVJbmZvKSB7XG4gICAgZGVidWcoJ29udW5waXBlJyk7XG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcbiAgICAgIGlmICh1bnBpcGVJbmZvICYmIHVucGlwZUluZm8uaGFzVW5waXBlZCA9PT0gZmFsc2UpIHtcbiAgICAgICAgdW5waXBlSW5mby5oYXNVbnBpcGVkID0gdHJ1ZTtcbiAgICAgICAgY2xlYW51cCgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIG9uZW5kKCkge1xuICAgIGRlYnVnKCdvbmVuZCcpO1xuICAgIGRlc3QuZW5kKCk7XG4gIH1cblxuICAvLyB3aGVuIHRoZSBkZXN0IGRyYWlucywgaXQgcmVkdWNlcyB0aGUgYXdhaXREcmFpbiBjb3VudGVyXG4gIC8vIG9uIHRoZSBzb3VyY2UuICBUaGlzIHdvdWxkIGJlIG1vcmUgZWxlZ2FudCB3aXRoIGEgLm9uY2UoKVxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xuICAvLyB0b28gc2xvdy5cbiAgdmFyIG9uZHJhaW4gPSBwaXBlT25EcmFpbihzcmMpO1xuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gIHZhciBjbGVhbmVkVXAgPSBmYWxzZTtcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcbiAgICBkZWJ1ZygnY2xlYW51cCcpO1xuICAgIC8vIGNsZWFudXAgZXZlbnQgaGFuZGxlcnMgb25jZSB0aGUgcGlwZSBpcyBicm9rZW5cbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcigndW5waXBlJywgb251bnBpcGUpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2RhdGEnLCBvbmRhdGEpO1xuXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcblxuICAgIC8vIGlmIHRoZSByZWFkZXIgaXMgd2FpdGluZyBmb3IgYSBkcmFpbiBldmVudCBmcm9tIHRoaXNcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcbiAgICAvLyBmbG93aW5nIGFnYWluLlxuICAgIC8vIFNvLCBpZiB0aGlzIGlzIGF3YWl0aW5nIGEgZHJhaW4sIHRoZW4gd2UganVzdCBjYWxsIGl0IG5vdy5cbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gJiYgKCFkZXN0Ll93cml0YWJsZVN0YXRlIHx8IGRlc3QuX3dyaXRhYmxlU3RhdGUubmVlZERyYWluKSkgb25kcmFpbigpO1xuICB9XG5cbiAgLy8gSWYgdGhlIHVzZXIgcHVzaGVzIG1vcmUgZGF0YSB3aGlsZSB3ZSdyZSB3cml0aW5nIHRvIGRlc3QgdGhlbiB3ZSdsbCBlbmQgdXBcbiAgLy8gaW4gb25kYXRhIGFnYWluLiBIb3dldmVyLCB3ZSBvbmx5IHdhbnQgdG8gaW5jcmVhc2UgYXdhaXREcmFpbiBvbmNlIGJlY2F1c2VcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cbiAgLy8gPT4gSW50cm9kdWNlIGEgZ3VhcmQgb24gaW5jcmVhc2luZyBhd2FpdERyYWluLlxuICB2YXIgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcbiAgICBkZWJ1Zygnb25kYXRhJyk7XG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xuICAgIHZhciByZXQgPSBkZXN0LndyaXRlKGNodW5rKTtcbiAgICBpZiAoZmFsc2UgPT09IHJldCAmJiAhaW5jcmVhc2VkQXdhaXREcmFpbikge1xuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXG4gICAgICAvLyB0byBnZXQgc3R1Y2sgaW4gYSBwZXJtYW5lbnRseSBwYXVzZWQgc3RhdGUgaWYgdGhhdCB3cml0ZVxuICAgICAgLy8gYWxzbyByZXR1cm5lZCBmYWxzZS5cbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxuICAgICAgaWYgKChzdGF0ZS5waXBlc0NvdW50ID09PSAxICYmIHN0YXRlLnBpcGVzID09PSBkZXN0IHx8IHN0YXRlLnBpcGVzQ291bnQgPiAxICYmIGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpICE9PSAtMSkgJiYgIWNsZWFuZWRVcCkge1xuICAgICAgICBkZWJ1ZygnZmFsc2Ugd3JpdGUgcmVzcG9uc2UsIHBhdXNlJywgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4pO1xuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xuICAgICAgICBpbmNyZWFzZWRBd2FpdERyYWluID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHNyYy5wYXVzZSgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBkZXN0IGhhcyBhbiBlcnJvciwgdGhlbiBzdG9wIHBpcGluZyBpbnRvIGl0LlxuICAvLyBob3dldmVyLCBkb24ndCBzdXBwcmVzcyB0aGUgdGhyb3dpbmcgYmVoYXZpb3IgZm9yIHRoaXMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBkZWJ1Zygnb25lcnJvcicsIGVyKTtcbiAgICB1bnBpcGUoKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGlmIChFRWxpc3RlbmVyQ291bnQoZGVzdCwgJ2Vycm9yJykgPT09IDApIGRlc3QuZW1pdCgnZXJyb3InLCBlcik7XG4gIH1cblxuICAvLyBNYWtlIHN1cmUgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIHVzZXJsYW5kIG9uZXMuXG4gIHByZXBlbmRMaXN0ZW5lcihkZXN0LCAnZXJyb3InLCBvbmVycm9yKTtcblxuICAvLyBCb3RoIGNsb3NlIGFuZCBmaW5pc2ggc2hvdWxkIHRyaWdnZXIgdW5waXBlLCBidXQgb25seSBvbmNlLlxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcbiAgICB1bnBpcGUoKTtcbiAgfVxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XG4gIGZ1bmN0aW9uIG9uZmluaXNoKCkge1xuICAgIGRlYnVnKCdvbmZpbmlzaCcpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG5cbiAgZnVuY3Rpb24gdW5waXBlKCkge1xuICAgIGRlYnVnKCd1bnBpcGUnKTtcbiAgICBzcmMudW5waXBlKGRlc3QpO1xuICB9XG5cbiAgLy8gdGVsbCB0aGUgZGVzdCB0aGF0IGl0J3MgYmVpbmcgcGlwZWQgdG9cbiAgZGVzdC5lbWl0KCdwaXBlJywgc3JjKTtcblxuICAvLyBzdGFydCB0aGUgZmxvdyBpZiBpdCBoYXNuJ3QgYmVlbiBzdGFydGVkIGFscmVhZHkuXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xuICAgIHNyYy5yZXN1bWUoKTtcbiAgfVxuXG4gIHJldHVybiBkZXN0O1xufTtcblxuZnVuY3Rpb24gcGlwZU9uRHJhaW4oc3JjKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xuICAgIGRlYnVnKCdwaXBlT25EcmFpbicsIHN0YXRlLmF3YWl0RHJhaW4pO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluKSBzdGF0ZS5hd2FpdERyYWluLS07XG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xuICAgICAgc3RhdGUuZmxvd2luZyA9IHRydWU7XG4gICAgICBmbG93KHNyYyk7XG4gICAgfVxuICB9O1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUudW5waXBlID0gZnVuY3Rpb24gKGRlc3QpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XG5cbiAgLy8gaWYgd2UncmUgbm90IHBpcGluZyBhbnl3aGVyZSwgdGhlbiBkbyBub3RoaW5nLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XG5cbiAgLy8ganVzdCBvbmUgZGVzdGluYXRpb24uICBtb3N0IGNvbW1vbiBjYXNlLlxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xuICAgIC8vIHBhc3NlZCBpbiBvbmUsIGJ1dCBpdCdzIG5vdCB0aGUgcmlnaHQgb25lLlxuICAgIGlmIChkZXN0ICYmIGRlc3QgIT09IHN0YXRlLnBpcGVzKSByZXR1cm4gdGhpcztcblxuICAgIGlmICghZGVzdCkgZGVzdCA9IHN0YXRlLnBpcGVzO1xuXG4gICAgLy8gZ290IGEgbWF0Y2guXG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICBpZiAoZGVzdCkgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHNsb3cgY2FzZS4gbXVsdGlwbGUgcGlwZSBkZXN0aW5hdGlvbnMuXG5cbiAgaWYgKCFkZXN0KSB7XG4gICAgLy8gcmVtb3ZlIGFsbC5cbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcbiAgICB2YXIgbGVuID0gc3RhdGUucGlwZXNDb3VudDtcbiAgICBzdGF0ZS5waXBlcyA9IG51bGw7XG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XG4gICAgc3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgZGVzdHNbaV0uZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgfXJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gdHJ5IHRvIGZpbmQgdGhlIHJpZ2h0IG9uZS5cbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiB0aGlzO1xuXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XG4gIHN0YXRlLnBpcGVzQ291bnQgLT0gMTtcbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHN0YXRlLnBpcGVzID0gc3RhdGUucGlwZXNbMF07XG5cbiAgZGVzdC5lbWl0KCd1bnBpcGUnLCB0aGlzLCB1bnBpcGVJbmZvKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3Jcbi8vIEVuc3VyZSByZWFkYWJsZSBsaXN0ZW5lcnMgZXZlbnR1YWxseSBnZXQgc29tZXRoaW5nXG5SZWFkYWJsZS5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAoZXYsIGZuKSB7XG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcblxuICBpZiAoZXYgPT09ICdkYXRhJykge1xuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgIT09IGZhbHNlKSB0aGlzLnJlc3VtZSgpO1xuICB9IGVsc2UgaWYgKGV2ID09PSAncmVhZGFibGUnKSB7XG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQgJiYgIXN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nKSB7XG4gICAgICBzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZyA9IHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcbiAgICAgIGlmICghc3RhdGUucmVhZGluZykge1xuICAgICAgICBwcm9jZXNzTmV4dFRpY2soblJlYWRpbmdOZXh0VGljaywgdGhpcyk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xuICAgICAgICBlbWl0UmVhZGFibGUodGhpcyk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlcztcbn07XG5SZWFkYWJsZS5wcm90b3R5cGUuYWRkTGlzdGVuZXIgPSBSZWFkYWJsZS5wcm90b3R5cGUub247XG5cbmZ1bmN0aW9uIG5SZWFkaW5nTmV4dFRpY2soc2VsZikge1xuICBkZWJ1ZygncmVhZGFibGUgbmV4dHRpY2sgcmVhZCAwJyk7XG4gIHNlbGYucmVhZCgwKTtcbn1cblxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxuLy8gSWYgdGhlIHVzZXIgdXNlcyB0aGVtLCB0aGVuIHN3aXRjaCBpbnRvIG9sZCBtb2RlLlxuUmVhZGFibGUucHJvdG90eXBlLnJlc3VtZSA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZScpO1xuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgIHJlc3VtZSh0aGlzLCBzdGF0ZSk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlc3VtZVNjaGVkdWxlZCkge1xuICAgIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlc3VtZV8oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICB9XG5cbiAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XG4gIHN0YXRlLmF3YWl0RHJhaW4gPSAwO1xuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XG4gIGZsb3coc3RyZWFtKTtcbiAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgIXN0YXRlLnJlYWRpbmcpIHN0cmVhbS5yZWFkKDApO1xufVxuXG5SZWFkYWJsZS5wcm90b3R5cGUucGF1c2UgPSBmdW5jdGlvbiAoKSB7XG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xuICBpZiAoZmFsc2UgIT09IHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdwYXVzZScpO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xuICAgIHRoaXMuZW1pdCgncGF1c2UnKTtcbiAgfVxuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgZGVidWcoJ2Zsb3cnLCBzdGF0ZS5mbG93aW5nKTtcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cbn1cblxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cbi8vIFRoaXMgaXMgKm5vdCogcGFydCBvZiB0aGUgcmVhZGFibGUgc3RyZWFtIGludGVyZmFjZS5cbi8vIEl0IGlzIGFuIHVnbHkgdW5mb3J0dW5hdGUgbWVzcyBvZiBoaXN0b3J5LlxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciBwYXVzZWQgPSBmYWxzZTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHN0cmVhbS5vbignZW5kJywgZnVuY3Rpb24gKCkge1xuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFzdGF0ZS5lbmRlZCkge1xuICAgICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XG4gICAgfVxuXG4gICAgc2VsZi5wdXNoKG51bGwpO1xuICB9KTtcblxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBkYXRhJyk7XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG5cbiAgICAvLyBkb24ndCBza2lwIG92ZXIgZmFsc3kgdmFsdWVzIGluIG9iamVjdE1vZGVcbiAgICBpZiAoc3RhdGUub2JqZWN0TW9kZSAmJiAoY2h1bmsgPT09IG51bGwgfHwgY2h1bmsgPT09IHVuZGVmaW5lZCkpIHJldHVybjtlbHNlIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiAoIWNodW5rIHx8ICFjaHVuay5sZW5ndGgpKSByZXR1cm47XG5cbiAgICB2YXIgcmV0ID0gc2VsZi5wdXNoKGNodW5rKTtcbiAgICBpZiAoIXJldCkge1xuICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5wYXVzZSgpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gcHJveHkgYWxsIHRoZSBvdGhlciBtZXRob2RzLlxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cbiAgZm9yICh2YXIgaSBpbiBzdHJlYW0pIHtcbiAgICBpZiAodGhpc1tpXSA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBzdHJlYW1baV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgcmV0dXJuIHN0cmVhbVttZXRob2RdLmFwcGx5KHN0cmVhbSwgYXJndW1lbnRzKTtcbiAgICAgICAgfTtcbiAgICAgIH0oaSk7XG4gICAgfVxuICB9XG5cbiAgLy8gcHJveHkgY2VydGFpbiBpbXBvcnRhbnQgZXZlbnRzLlxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xuICAgIHN0cmVhbS5vbihrUHJveHlFdmVudHNbbl0sIHNlbGYuZW1pdC5iaW5kKHNlbGYsIGtQcm94eUV2ZW50c1tuXSkpO1xuICB9XG5cbiAgLy8gd2hlbiB3ZSB0cnkgdG8gY29uc3VtZSBzb21lIG1vcmUgYnl0ZXMsIHNpbXBseSB1bnBhdXNlIHRoZVxuICAvLyB1bmRlcmx5aW5nIHN0cmVhbS5cbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgX3JlYWQnLCBuKTtcbiAgICBpZiAocGF1c2VkKSB7XG4gICAgICBwYXVzZWQgPSBmYWxzZTtcbiAgICAgIHN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIHNlbGY7XG59O1xuXG4vLyBleHBvc2VkIGZvciB0ZXN0aW5nIHB1cnBvc2VzIG9ubHkuXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcblxuLy8gUGx1Y2sgb2ZmIG4gYnl0ZXMgZnJvbSBhbiBhcnJheSBvZiBidWZmZXJzLlxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcbiAgLy8gbm90aGluZyBidWZmZXJlZFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSByZXR1cm4gbnVsbDtcblxuICB2YXIgcmV0O1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0ID0gc3RhdGUuYnVmZmVyLnNoaWZ0KCk7ZWxzZSBpZiAoIW4gfHwgbiA+PSBzdGF0ZS5sZW5ndGgpIHtcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgcmV0ID0gc3RhdGUuYnVmZmVyLmpvaW4oJycpO2Vsc2UgaWYgKHN0YXRlLmJ1ZmZlci5sZW5ndGggPT09IDEpIHJldCA9IHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGE7ZWxzZSByZXQgPSBzdGF0ZS5idWZmZXIuY29uY2F0KHN0YXRlLmxlbmd0aCk7XG4gICAgc3RhdGUuYnVmZmVyLmNsZWFyKCk7XG4gIH0gZWxzZSB7XG4gICAgLy8gcmVhZCBwYXJ0IG9mIGxpc3RcbiAgICByZXQgPSBmcm9tTGlzdFBhcnRpYWwobiwgc3RhdGUuYnVmZmVyLCBzdGF0ZS5kZWNvZGVyKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59XG5cbi8vIEV4dHJhY3RzIG9ubHkgZW5vdWdoIGJ1ZmZlcmVkIGRhdGEgdG8gc2F0aXNmeSB0aGUgYW1vdW50IHJlcXVlc3RlZC5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gZnJvbUxpc3RQYXJ0aWFsKG4sIGxpc3QsIGhhc1N0cmluZ3MpIHtcbiAgdmFyIHJldDtcbiAgaWYgKG4gPCBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcbiAgICAvLyBzbGljZSBpcyB0aGUgc2FtZSBmb3IgYnVmZmVycyBhbmQgc3RyaW5nc1xuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xuICAgIGxpc3QuaGVhZC5kYXRhID0gbGlzdC5oZWFkLmRhdGEuc2xpY2Uobik7XG4gIH0gZWxzZSBpZiAobiA9PT0gbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXG4gICAgcmV0ID0gbGlzdC5zaGlmdCgpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxuICAgIHJldCA9IGhhc1N0cmluZ3MgPyBjb3B5RnJvbUJ1ZmZlclN0cmluZyhuLCBsaXN0KSA6IGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpO1xuICB9XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcbi8vIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkge1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICB2YXIgcmV0ID0gcC5kYXRhO1xuICBuIC09IHJldC5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIHN0ciA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gc3RyLmxlbmd0aCA/IHN0ci5sZW5ndGggOiBuO1xuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IHN0ci5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xuICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4pO1xuICB2YXIgcCA9IGxpc3QuaGVhZDtcbiAgdmFyIGMgPSAxO1xuICBwLmRhdGEuY29weShyZXQpO1xuICBuIC09IHAuZGF0YS5sZW5ndGg7XG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgdmFyIGJ1ZiA9IHAuZGF0YTtcbiAgICB2YXIgbmIgPSBuID4gYnVmLmxlbmd0aCA/IGJ1Zi5sZW5ndGggOiBuO1xuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcbiAgICBuIC09IG5iO1xuICAgIGlmIChuID09PSAwKSB7XG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICAgICAgKytjO1xuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGlzdC5oZWFkID0gcDtcbiAgICAgICAgcC5kYXRhID0gYnVmLnNsaWNlKG5iKTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICArK2M7XG4gIH1cbiAgbGlzdC5sZW5ndGggLT0gYztcbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcblxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXG4gIC8vIGJ1ZyBpbiBub2RlLiAgU2hvdWxkIG5ldmVyIGhhcHBlbi5cbiAgaWYgKHN0YXRlLmxlbmd0aCA+IDApIHRocm93IG5ldyBFcnJvcignXCJlbmRSZWFkYWJsZSgpXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcblxuICBpZiAoIXN0YXRlLmVuZEVtaXR0ZWQpIHtcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKGVuZFJlYWRhYmxlTlQsIHN0YXRlLCBzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlTlQoc3RhdGUsIHN0cmVhbSkge1xuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmIHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIHN0YXRlLmVuZEVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmICh4c1tpXSA9PT0geCkgcmV0dXJuIGk7XG4gIH1cbiAgcmV0dXJuIC0xO1xufSIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXG4vLyBzb21ldGhpbmcgd2l0aCB0aGUgZGF0YS4gIFNvbWV0aW1lcyBpdCdzIGNhbGxlZCBhIFwiZmlsdGVyXCIsXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxuLy8gc29tZSBiaXRzIHBhc3MgdGhyb3VnaCwgYW5kIG90aGVycyBhcmUgc2ltcGx5IGlnbm9yZWQuICAoVGhhdCB3b3VsZFxuLy8gYmUgYSB2YWxpZCBleGFtcGxlIG9mIGEgdHJhbnNmb3JtLCBvZiBjb3Vyc2UuKVxuLy9cbi8vIFdoaWxlIHRoZSBvdXRwdXQgaXMgY2F1c2FsbHkgcmVsYXRlZCB0byB0aGUgaW5wdXQsIGl0J3Mgbm90IGFcbi8vIG5lY2Vzc2FyaWx5IHN5bW1ldHJpYyBvciBzeW5jaHJvbm91cyB0cmFuc2Zvcm1hdGlvbi4gIEZvciBleGFtcGxlLFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXG4vLyBlbWl0IGEgc2luZ2xlIGNvbXByZXNzZWQgY2h1bmsgc29tZSB0aW1lIGluIHRoZSBmdXR1cmUuXG4vL1xuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxuLy9cbi8vIFRoZSBUcmFuc2Zvcm0gc3RyZWFtIGhhcyBhbGwgdGhlIGFzcGVjdHMgb2YgdGhlIHJlYWRhYmxlIGFuZCB3cml0YWJsZVxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxuLy8gaW50ZXJuYWxseSwgYW5kIHJldHVybnMgZmFsc2UgaWYgdGhlcmUncyBhIGxvdCBvZiBwZW5kaW5nIHdyaXRlc1xuLy8gYnVmZmVyZWQgdXAuICBXaGVuIHlvdSBjYWxsIHJlYWQoKSwgdGhhdCBjYWxscyBfcmVhZChuKSB1bnRpbFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxuLy9cbi8vIEluIGEgdHJhbnNmb3JtIHN0cmVhbSwgdGhlIHdyaXR0ZW4gZGF0YSBpcyBwbGFjZWQgaW4gYSBidWZmZXIuICBXaGVuXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxuLy8gYnVmZmVyZWQgX3dyaXRlIGNiJ3MgYXMgaXQgY29uc3VtZXMgY2h1bmtzLiAgSWYgY29uc3VtaW5nIGEgc2luZ2xlXG4vLyB3cml0dGVuIGNodW5rIHdvdWxkIHJlc3VsdCBpbiBtdWx0aXBsZSBvdXRwdXQgY2h1bmtzLCB0aGVuIHRoZSBmaXJzdFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXG4vLyB0aGUgcmVhZCBidWZmZXIsIGFuZCB3aWxsIGNhdXNlIGl0IHRvIGVtaXQgJ3JlYWRhYmxlJyBpZiBuZWNlc3NhcnkuXG4vL1xuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxuLy8gc2luY2UgX3JlYWQgaGFzIHRvIGJlIGNhbGxlZCB0byBzdGFydCBwcm9jZXNzaW5nIGEgbmV3IGNodW5rLiAgSG93ZXZlcixcbi8vIGEgcGF0aG9sb2dpY2FsIGluZmxhdGUgdHlwZSBvZiB0cmFuc2Zvcm0gY2FuIGNhdXNlIGV4Y2Vzc2l2ZSBidWZmZXJpbmdcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXG4vLyBpbnRlcnByZXRlZCBhcyBhbiBpbnRlZ2VyIGZyb20gMC0yNTUsIGFuZCB0aGVuIHJlc3VsdHMgaW4gdGhhdCBtYW55XG4vLyBieXRlcyBvZiBvdXRwdXQuICBXcml0aW5nIHRoZSA0IGJ5dGVzIHtmZixmZixmZixmZn0gd291bGQgcmVzdWx0IGluXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcbi8vIGFtb3VudCBvZiBpbnB1dCwgYW5kIGVuZCB1cCB3aXRoIGEgdmVyeSBsYXJnZSBhbW91bnQgb2Ygb3V0cHV0LiAgSW5cbi8vIHN1Y2ggYSBwYXRob2xvZ2ljYWwgaW5mbGF0aW5nIG1lY2hhbmlzbSwgdGhlcmUnZCBiZSBubyB3YXkgdG8gdGVsbFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcbi8vIGNhdXNlIHRoZSBzeXN0ZW0gdG8gcnVuIG91dCBvZiBtZW1vcnkuXG4vL1xuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xuLy8gd291bGQgYmUgY29uc3VtZWQsIGFuZCB0aGVuIHRoZSByZXN0IHdvdWxkIHdhaXQgKHVuLXRyYW5zZm9ybWVkKSB1bnRpbFxuLy8gdGhlIHJlc3VsdHMgb2YgdGhlIHByZXZpb3VzIHRyYW5zZm9ybWVkIGNodW5rIHdlcmUgY29uc3VtZWQuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XG5cbnZhciBEdXBsZXggPSByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybVN0YXRlKHN0cmVhbSkge1xuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgcmV0dXJuIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpO1xuICB9O1xuXG4gIHRoaXMubmVlZFRyYW5zZm9ybSA9IGZhbHNlO1xuICB0aGlzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuICB0aGlzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0aGlzLndyaXRlZW5jb2RpbmcgPSBudWxsO1xufVxuXG5mdW5jdGlvbiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG4gIHRzLnRyYW5zZm9ybWluZyA9IGZhbHNlO1xuXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XG5cbiAgaWYgKCFjYikge1xuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcbiAgfVxuXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xuICB0cy53cml0ZWNiID0gbnVsbDtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIGNiKGVyKTtcblxuICB2YXIgcnMgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIHJzLnJlYWRpbmcgPSBmYWxzZTtcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgc3RyZWFtLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59XG5cbmZ1bmN0aW9uIFRyYW5zZm9ybShvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcblxuICBEdXBsZXguY2FsbCh0aGlzLCBvcHRpb25zKTtcblxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZSA9IG5ldyBUcmFuc2Zvcm1TdGF0ZSh0aGlzKTtcblxuICB2YXIgc3RyZWFtID0gdGhpcztcblxuICAvLyBzdGFydCBvdXQgYXNraW5nIGZvciBhIHJlYWRhYmxlIGV2ZW50IG9uY2UgZGF0YSBpcyB0cmFuc2Zvcm1lZC5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gIC8vIHdlIGhhdmUgaW1wbGVtZW50ZWQgdGhlIF9yZWFkIG1ldGhvZCwgYW5kIGRvbmUgdGhlIG90aGVyIHRoaW5nc1xuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXG4gIC8vIHN5bmMgZ3VhcmQgZmxhZy5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5zeW5jID0gZmFsc2U7XG5cbiAgaWYgKG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudHJhbnNmb3JtID09PSAnZnVuY3Rpb24nKSB0aGlzLl90cmFuc2Zvcm0gPSBvcHRpb25zLnRyYW5zZm9ybTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2ggPSBvcHRpb25zLmZsdXNoO1xuICB9XG5cbiAgLy8gV2hlbiB0aGUgd3JpdGFibGUgc2lkZSBmaW5pc2hlcywgdGhlbiBmbHVzaCBvdXQgYW55dGhpbmcgcmVtYWluaW5nLlxuICB0aGlzLm9uY2UoJ3ByZWZpbmlzaCcsIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcbiAgICAgIGRvbmUoc3RyZWFtLCBlciwgZGF0YSk7XG4gICAgfSk7ZWxzZSBkb25lKHN0cmVhbSk7XG4gIH0pO1xufVxuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XG4gIHRoaXMuX3RyYW5zZm9ybVN0YXRlLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgcmV0dXJuIER1cGxleC5wcm90b3R5cGUucHVzaC5jYWxsKHRoaXMsIGNodW5rLCBlbmNvZGluZyk7XG59O1xuXG4vLyBUaGlzIGlzIHRoZSBwYXJ0IHdoZXJlIHlvdSBkbyBzdHVmZiFcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cbi8vICdjaHVuaycgaXMgYW4gaW5wdXQgY2h1bmsuXG4vL1xuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XG4vLyB0byB0aGUgcmVhZGFibGUgc2lkZS4gIFlvdSBtYXkgY2FsbCAncHVzaCcgemVybyBvciBtb3JlIHRpbWVzLlxuLy9cbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXG4vLyBhbiBlcnJvciwgdGhlbiB0aGF0J2xsIHB1dCB0aGUgaHVydCBvbiB0aGUgd2hvbGUgb3BlcmF0aW9uLiAgSWYgeW91XG4vLyBuZXZlciBjYWxsIGNiKCksIHRoZW4geW91J2xsIG5ldmVyIGdldCBhbm90aGVyIGNodW5rLlxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdfdHJhbnNmb3JtKCkgaXMgbm90IGltcGxlbWVudGVkJyk7XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciB0cyA9IHRoaXMuX3RyYW5zZm9ybVN0YXRlO1xuICB0cy53cml0ZWNiID0gY2I7XG4gIHRzLndyaXRlY2h1bmsgPSBjaHVuaztcbiAgdHMud3JpdGVlbmNvZGluZyA9IGVuY29kaW5nO1xuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xuICAgIHZhciBycyA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKHRzLm5lZWRUcmFuc2Zvcm0gfHwgcnMubmVlZFJlYWRhYmxlIHx8IHJzLmxlbmd0aCA8IHJzLmhpZ2hXYXRlck1hcmspIHRoaXMuX3JlYWQocnMuaGlnaFdhdGVyTWFyayk7XG4gIH1cbn07XG5cbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXG4vLyBfdHJhbnNmb3JtIGRvZXMgYWxsIHRoZSB3b3JrLlxuLy8gVGhhdCB3ZSBnb3QgaGVyZSBtZWFucyB0aGF0IHRoZSByZWFkYWJsZSBzaWRlIHdhbnRzIG1vcmUgZGF0YS5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB0cy50cmFuc2Zvcm1pbmcgPSB0cnVlO1xuICAgIHRoaXMuX3RyYW5zZm9ybSh0cy53cml0ZWNodW5rLCB0cy53cml0ZWVuY29kaW5nLCB0cy5hZnRlclRyYW5zZm9ybSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gbWFyayB0aGF0IHdlIG5lZWQgYSB0cmFuc2Zvcm0sIHNvIHRoYXQgYW55IGRhdGEgdGhhdCBjb21lcyBpblxuICAgIC8vIHdpbGwgZ2V0IHByb2Nlc3NlZCwgbm93IHRoYXQgd2UndmUgYXNrZWQgZm9yIGl0LlxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xuICB9XG59O1xuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICBEdXBsZXgucHJvdG90eXBlLl9kZXN0cm95LmNhbGwodGhpcywgZXJyLCBmdW5jdGlvbiAoZXJyMikge1xuICAgIGNiKGVycjIpO1xuICAgIF90aGlzLmVtaXQoJ2Nsb3NlJyk7XG4gIH0pO1xufTtcblxuZnVuY3Rpb24gZG9uZShzdHJlYW0sIGVyLCBkYXRhKSB7XG4gIGlmIChlcikgcmV0dXJuIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcblxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xuXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcbiAgLy8gdGhhdCBub3RoaW5nIG1vcmUgd2lsbCBldmVyIGJlIHByb3ZpZGVkXG4gIHZhciB3cyA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcblxuICBpZiAod3MubGVuZ3RoKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiB3cy5sZW5ndGggIT0gMCcpO1xuXG4gIGlmICh0cy50cmFuc2Zvcm1pbmcpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHN0aWxsIHRyYW5zZm9ybWluZycpO1xuXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXG4vLyBJbXBsZW1lbnQgYW4gYXN5bmMgLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIGNiKSwgYW5kIGl0J2xsIGhhbmRsZSBhbGxcbi8vIHRoZSBkcmFpbiBldmVudCBlbWlzc2lvbiBhbmQgYnVmZmVyaW5nLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbm1vZHVsZS5leHBvcnRzID0gV3JpdGFibGU7XG5cbi8qIDxyZXBsYWNlbWVudD4gKi9cbmZ1bmN0aW9uIFdyaXRlUmVxKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xuICB0aGlzLmVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHRoaXMuY2FsbGJhY2sgPSBjYjtcbiAgdGhpcy5uZXh0ID0gbnVsbDtcbn1cblxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XG4vLyB0aGVyZSB3aWxsIGJlIG9ubHkgMiBvZiB0aGVzZSBmb3IgZWFjaCBzdHJlYW1cbmZ1bmN0aW9uIENvcmtlZFJlcXVlc3Qoc3RhdGUpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB0aGlzLm5leHQgPSBudWxsO1xuICB0aGlzLmVudHJ5ID0gbnVsbDtcbiAgdGhpcy5maW5pc2ggPSBmdW5jdGlvbiAoKSB7XG4gICAgb25Db3JrZWRGaW5pc2goX3RoaXMsIHN0YXRlKTtcbiAgfTtcbn1cbi8qIDwvcmVwbGFjZW1lbnQ+ICovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgYXN5bmNXcml0ZSA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgWyd2MC4xMCcsICd2MC45LiddLmluZGV4T2YocHJvY2Vzcy52ZXJzaW9uLnNsaWNlKDAsIDUpKSA+IC0xID8gc2V0SW1tZWRpYXRlIDogcHJvY2Vzc05leHRUaWNrO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRHVwbGV4O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgaW50ZXJuYWxVdGlsID0ge1xuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBTdHJlYW0gPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvc3RyZWFtJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbnZhciBPdXJVaW50OEFycmF5ID0gZ2xvYmFsLlVpbnQ4QXJyYXkgfHwgZnVuY3Rpb24gKCkge307XG5mdW5jdGlvbiBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKSB7XG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XG59XG5mdW5jdGlvbiBfaXNVaW50OEFycmF5KG9iaikge1xuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcbn1cbi8qPC9yZXBsYWNlbWVudD4qL1xuXG52YXIgZGVzdHJveUltcGwgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveScpO1xuXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xuXG5mdW5jdGlvbiBub3AoKSB7fVxuXG5mdW5jdGlvbiBXcml0YWJsZVN0YXRlKG9wdGlvbnMsIHN0cmVhbSkge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxuICAvLyBjb250YWlucyBidWZmZXJzIG9yIG9iamVjdHMuXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xuXG4gIGlmIChzdHJlYW0gaW5zdGFuY2VvZiBEdXBsZXgpIHRoaXMub2JqZWN0TW9kZSA9IHRoaXMub2JqZWN0TW9kZSB8fCAhIW9wdGlvbnMud3JpdGFibGVPYmplY3RNb2RlO1xuXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyB0aGF0IHdlIGFsd2F5cyByZXR1cm4gZmFsc2UgaWZcbiAgLy8gdGhlIGVudGlyZSBidWZmZXIgaXMgbm90IGZsdXNoZWQgaW1tZWRpYXRlbHkgb24gd3JpdGUoKVxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBod20gfHwgaHdtID09PSAwID8gaHdtIDogZGVmYXVsdEh3bTtcblxuICAvLyBjYXN0IHRvIGludHMuXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IE1hdGguZmxvb3IodGhpcy5oaWdoV2F0ZXJNYXJrKTtcblxuICAvLyBpZiBfZmluYWwgaGFzIGJlZW4gY2FsbGVkXG4gIHRoaXMuZmluYWxDYWxsZWQgPSBmYWxzZTtcblxuICAvLyBkcmFpbiBldmVudCBmbGFnLlxuICB0aGlzLm5lZWREcmFpbiA9IGZhbHNlO1xuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxuICB0aGlzLmVuZGluZyA9IGZhbHNlO1xuICAvLyB3aGVuIGVuZCgpIGhhcyBiZWVuIGNhbGxlZCwgYW5kIHJldHVybmVkXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcbiAgLy8gd2hlbiAnZmluaXNoJyBpcyBlbWl0dGVkXG4gIHRoaXMuZmluaXNoZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBzaG91bGQgd2UgZGVjb2RlIHN0cmluZ3MgaW50byBidWZmZXJzIGJlZm9yZSBwYXNzaW5nIHRvIF93cml0ZT9cbiAgLy8gdGhpcyBpcyBoZXJlIHNvIHRoYXQgc29tZSBub2RlLWNvcmUgc3RyZWFtcyBjYW4gb3B0aW1pemUgc3RyaW5nXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXG4gIHZhciBub0RlY29kZSA9IG9wdGlvbnMuZGVjb2RlU3RyaW5ncyA9PT0gZmFsc2U7XG4gIHRoaXMuZGVjb2RlU3RyaW5ncyA9ICFub0RlY29kZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxuICAvLyBvZiBob3cgbXVjaCB3ZSdyZSB3YWl0aW5nIHRvIGdldCBwdXNoZWQgdG8gc29tZSB1bmRlcmx5aW5nXG4gIC8vIHNvY2tldCBvciBmaWxlLlxuICB0aGlzLmxlbmd0aCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIHNlZSB3aGVuIHdlJ3JlIGluIHRoZSBtaWRkbGUgb2YgYSB3cml0ZS5cbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XG5cbiAgLy8gd2hlbiB0cnVlIGFsbCB3cml0ZXMgd2lsbCBiZSBidWZmZXJlZCB1bnRpbCAudW5jb3JrKCkgY2FsbFxuICB0aGlzLmNvcmtlZCA9IDA7XG5cbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgb253cml0ZSBjYiBpcyBjYWxsZWQgaW1tZWRpYXRlbHksXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XG4gIC8vIGFjdGlvbnMgdGhhdCBzaG91bGRuJ3QgaGFwcGVuIHVudGlsIFwibGF0ZXJcIiBzaG91bGQgZ2VuZXJhbGx5IGFsc29cbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxuICAvLyBtYXkgY2FsbCB0aGUgX3dyaXRlKCkgY2FsbGJhY2sgaW4gdGhlIHNhbWUgdGljaywgc28gdGhhdCB3ZSBkb24ndFxuICAvLyBlbmQgdXAgaW4gYW4gb3ZlcmxhcHBlZCBvbndyaXRlIHNpdHVhdGlvbi5cbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XG5cbiAgLy8gdGhlIGNhbGxiYWNrIHRoYXQncyBwYXNzZWQgdG8gX3dyaXRlKGNodW5rLGNiKVxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcbiAgICBvbndyaXRlKHN0cmVhbSwgZXIpO1xuICB9O1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0IHRoZSB1c2VyIHN1cHBsaWVzIHRvIHdyaXRlKGNodW5rLGVuY29kaW5nLGNiKVxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xuXG4gIC8vIHRoZSBhbW91bnQgdGhhdCBpcyBiZWluZyB3cml0dGVuIHdoZW4gX3dyaXRlIGlzIGNhbGxlZC5cbiAgdGhpcy53cml0ZWxlbiA9IDA7XG5cbiAgdGhpcy5idWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB0aGlzLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuXG4gIC8vIG51bWJlciBvZiBwZW5kaW5nIHVzZXItc3VwcGxpZWQgd3JpdGUgY2FsbGJhY2tzXG4gIC8vIHRoaXMgbXVzdCBiZSAwIGJlZm9yZSAnZmluaXNoJyBjYW4gYmUgZW1pdHRlZFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XG5cbiAgLy8gZW1pdCBwcmVmaW5pc2ggaWYgdGhlIG9ubHkgdGhpbmcgd2UncmUgd2FpdGluZyBmb3IgaXMgX3dyaXRlIGNic1xuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xuICB0aGlzLnByZWZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cbiAgdGhpcy5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcblxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xuICB0aGlzLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcblxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXG4gIC8vIG9uZSBhbGxvY2F0ZWQgYW5kIGZyZWUgdG8gdXNlLCBhbmQgd2UgbWFpbnRhaW4gYXQgbW9zdCB0d29cbiAgdGhpcy5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdCh0aGlzKTtcbn1cblxuV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUuZ2V0QnVmZmVyID0gZnVuY3Rpb24gZ2V0QnVmZmVyKCkge1xuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xuICB2YXIgb3V0ID0gW107XG4gIHdoaWxlIChjdXJyZW50KSB7XG4gICAgb3V0LnB1c2goY3VycmVudCk7XG4gICAgY3VycmVudCA9IGN1cnJlbnQubmV4dDtcbiAgfVxuICByZXR1cm4gb3V0O1xufTtcblxuKGZ1bmN0aW9uICgpIHtcbiAgdHJ5IHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoV3JpdGFibGVTdGF0ZS5wcm90b3R5cGUsICdidWZmZXInLCB7XG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRCdWZmZXIoKTtcbiAgICAgIH0sICdfd3JpdGFibGVTdGF0ZS5idWZmZXIgaXMgZGVwcmVjYXRlZC4gVXNlIF93cml0YWJsZVN0YXRlLmdldEJ1ZmZlciAnICsgJ2luc3RlYWQuJywgJ0RFUDAwMDMnKVxuICAgIH0pO1xuICB9IGNhdGNoIChfKSB7fVxufSkoKTtcblxuLy8gVGVzdCBfd3JpdGFibGVTdGF0ZSBmb3IgaW5oZXJpdGFuY2UgdG8gYWNjb3VudCBmb3IgRHVwbGV4IHN0cmVhbXMsXG4vLyB3aG9zZSBwcm90b3R5cGUgY2hhaW4gb25seSBwb2ludHMgdG8gUmVhZGFibGUuXG52YXIgcmVhbEhhc0luc3RhbmNlO1xuaWYgKHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLmhhc0luc3RhbmNlICYmIHR5cGVvZiBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXSA9PT0gJ2Z1bmN0aW9uJykge1xuICByZWFsSGFzSW5zdGFuY2UgPSBGdW5jdGlvbi5wcm90b3R5cGVbU3ltYm9sLmhhc0luc3RhbmNlXTtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcbiAgICB2YWx1ZTogZnVuY3Rpb24gKG9iamVjdCkge1xuICAgICAgaWYgKHJlYWxIYXNJbnN0YW5jZS5jYWxsKHRoaXMsIG9iamVjdCkpIHJldHVybiB0cnVlO1xuXG4gICAgICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5fd3JpdGFibGVTdGF0ZSBpbnN0YW5jZW9mIFdyaXRhYmxlU3RhdGU7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIHJlYWxIYXNJbnN0YW5jZSA9IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcbiAgfTtcbn1cblxuZnVuY3Rpb24gV3JpdGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIC8vIFdyaXRhYmxlIGN0b3IgaXMgYXBwbGllZCB0byBEdXBsZXhlcywgdG9vLlxuICAvLyBgcmVhbEhhc0luc3RhbmNlYCBpcyBuZWNlc3NhcnkgYmVjYXVzZSB1c2luZyBwbGFpbiBgaW5zdGFuY2VvZmBcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxuXG4gIC8vIFRyeWluZyB0byB1c2UgdGhlIGN1c3RvbSBgaW5zdGFuY2VvZmAgZm9yIFdyaXRhYmxlIGhlcmUgd2lsbCBhbHNvIGJyZWFrIHRoZVxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcbiAgLy8gYF93cml0YWJsZVN0YXRlYCB0aGF0IHdvdWxkIGxlYWQgdG8gaW5maW5pdGUgcmVjdXJzaW9uLlxuICBpZiAoIXJlYWxIYXNJbnN0YW5jZS5jYWxsKFdyaXRhYmxlLCB0aGlzKSAmJiAhKHRoaXMgaW5zdGFuY2VvZiBEdXBsZXgpKSB7XG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcbiAgfVxuXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcblxuICAvLyBsZWdhY3kuXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMud3JpdGV2ID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZXYgPSBvcHRpb25zLndyaXRldjtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5kZXN0cm95ID09PSAnZnVuY3Rpb24nKSB0aGlzLl9kZXN0cm95ID0gb3B0aW9ucy5kZXN0cm95O1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxuV3JpdGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ0Nhbm5vdCBwaXBlLCBub3QgcmVhZGFibGUnKSk7XG59O1xuXG5mdW5jdGlvbiB3cml0ZUFmdGVyRW5kKHN0cmVhbSwgY2IpIHtcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcbiAgLy8gVE9ETzogZGVmZXIgZXJyb3IgZXZlbnRzIGNvbnNpc3RlbnRseSBldmVyeXdoZXJlLCBub3QganVzdCB0aGUgY2JcbiAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbn1cblxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxuLy8gbW9kZSB0aGUgc3RyZWFtIGlzIGluLiBDdXJyZW50bHkgdGhpcyBtZWFucyB0aGF0IGBudWxsYCBpcyBuZXZlciBhY2NlcHRlZFxuLy8gYW5kIHVuZGVmaW5lZC9ub24tc3RyaW5nIHZhbHVlcyBhcmUgb25seSBhbGxvd2VkIGluIG9iamVjdCBtb2RlLlxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcbiAgdmFyIHZhbGlkID0gdHJ1ZTtcbiAgdmFyIGVyID0gZmFsc2U7XG5cbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdNYXkgbm90IHdyaXRlIG51bGwgdmFsdWVzIHRvIHN0cmVhbScpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xuICB9XG4gIGlmIChlcikge1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICB2YWxpZCA9IGZhbHNlO1xuICB9XG4gIHJldHVybiB2YWxpZDtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHJldCA9IGZhbHNlO1xuICB2YXIgaXNCdWYgPSBfaXNVaW50OEFycmF5KGNodW5rKSAmJiAhc3RhdGUub2JqZWN0TW9kZTtcblxuICBpZiAoaXNCdWYgJiYgIUJ1ZmZlci5pc0J1ZmZlcihjaHVuaykpIHtcbiAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGlzQnVmKSBlbmNvZGluZyA9ICdidWZmZXInO2Vsc2UgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XG5cbiAgaWYgKHN0YXRlLmVuZGVkKSB3cml0ZUFmdGVyRW5kKHRoaXMsIGNiKTtlbHNlIGlmIChpc0J1ZiB8fCB2YWxpZENodW5rKHRoaXMsIHN0YXRlLCBjaHVuaywgY2IpKSB7XG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgcmV0ID0gd3JpdGVPckJ1ZmZlcih0aGlzLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5jb3JrID0gZnVuY3Rpb24gKCkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIHN0YXRlLmNvcmtlZCsrO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLnVuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkLS07XG5cbiAgICBpZiAoIXN0YXRlLndyaXRpbmcgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSBjbGVhckJ1ZmZlcih0aGlzLCBzdGF0ZSk7XG4gIH1cbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS5zZXREZWZhdWx0RW5jb2RpbmcgPSBmdW5jdGlvbiBzZXREZWZhdWx0RW5jb2RpbmcoZW5jb2RpbmcpIHtcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSBlbmNvZGluZyA9IGVuY29kaW5nLnRvTG93ZXJDYXNlKCk7XG4gIGlmICghKFsnaGV4JywgJ3V0ZjgnLCAndXRmLTgnLCAnYXNjaWknLCAnYmluYXJ5JywgJ2Jhc2U2NCcsICd1Y3MyJywgJ3Vjcy0yJywgJ3V0ZjE2bGUnLCAndXRmLTE2bGUnLCAncmF3J10uaW5kZXhPZigoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKSkgPiAtMSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZyk7XG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZykge1xuICBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgc3RhdGUuZGVjb2RlU3RyaW5ncyAhPT0gZmFsc2UgJiYgdHlwZW9mIGNodW5rID09PSAnc3RyaW5nJykge1xuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gY2h1bms7XG59XG5cbi8vIGlmIHdlJ3JlIGFscmVhZHkgd3JpdGluZyBzb21ldGhpbmcsIHRoZW4ganVzdCBwdXQgdGhpc1xuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcbi8vIElmIHdlIHJldHVybiBmYWxzZSwgdGhlbiB3ZSBuZWVkIGEgZHJhaW4gZXZlbnQsIHNvIHNldCB0aGF0IGZsYWcuXG5mdW5jdGlvbiB3cml0ZU9yQnVmZmVyKHN0cmVhbSwgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGlmICghaXNCdWYpIHtcbiAgICB2YXIgbmV3Q2h1bmsgPSBkZWNvZGVDaHVuayhzdGF0ZSwgY2h1bmssIGVuY29kaW5nKTtcbiAgICBpZiAoY2h1bmsgIT09IG5ld0NodW5rKSB7XG4gICAgICBpc0J1ZiA9IHRydWU7XG4gICAgICBlbmNvZGluZyA9ICdidWZmZXInO1xuICAgICAgY2h1bmsgPSBuZXdDaHVuaztcbiAgICB9XG4gIH1cbiAgdmFyIGxlbiA9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xuXG4gIHN0YXRlLmxlbmd0aCArPSBsZW47XG5cbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XG4gIC8vIHdlIG11c3QgZW5zdXJlIHRoYXQgcHJldmlvdXMgbmVlZERyYWluIHdpbGwgbm90IGJlIHJlc2V0IHRvIGZhbHNlLlxuICBpZiAoIXJldCkgc3RhdGUubmVlZERyYWluID0gdHJ1ZTtcblxuICBpZiAoc3RhdGUud3JpdGluZyB8fCBzdGF0ZS5jb3JrZWQpIHtcbiAgICB2YXIgbGFzdCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcbiAgICAgIGNodW5rOiBjaHVuayxcbiAgICAgIGVuY29kaW5nOiBlbmNvZGluZyxcbiAgICAgIGlzQnVmOiBpc0J1ZixcbiAgICAgIGNhbGxiYWNrOiBjYixcbiAgICAgIG5leHQ6IG51bGxcbiAgICB9O1xuICAgIGlmIChsYXN0KSB7XG4gICAgICBsYXN0Lm5leHQgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIH1cbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xuICB9IGVsc2Uge1xuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG5mdW5jdGlvbiBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIHdyaXRldiwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xuICBzdGF0ZS53cml0ZWNiID0gY2I7XG4gIHN0YXRlLndyaXRpbmcgPSB0cnVlO1xuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcbiAgaWYgKHdyaXRldikgc3RyZWFtLl93cml0ZXYoY2h1bmssIHN0YXRlLm9ud3JpdGUpO2Vsc2Ugc3RyZWFtLl93cml0ZShjaHVuaywgZW5jb2RpbmcsIHN0YXRlLm9ud3JpdGUpO1xuICBzdGF0ZS5zeW5jID0gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpIHtcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XG5cbiAgaWYgKHN5bmMpIHtcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XG4gICAgLy8gdG8gYXZvaWQgcGlsaW5nIHVwIHRoaW5ncyBvbiB0aGUgc3RhY2tcbiAgICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxuICAgIC8vIGFmdGVyIGVycm9yXG4gICAgcHJvY2Vzc05leHRUaWNrKGZpbmlzaE1heWJlLCBzdHJlYW0sIHN0YXRlKTtcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gIH0gZWxzZSB7XG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXG4gICAgLy8gaXQgaXMgYXN5bmNcbiAgICBjYihlcik7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICAgIC8vIHRoaXMgY2FuIGVtaXQgZmluaXNoLCBidXQgZmluaXNoIG11c3RcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKSB7XG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcbiAgc3RhdGUud3JpdGVjYiA9IG51bGw7XG4gIHN0YXRlLmxlbmd0aCAtPSBzdGF0ZS53cml0ZWxlbjtcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xuICB2YXIgc3luYyA9IHN0YXRlLnN5bmM7XG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XG5cbiAgb253cml0ZVN0YXRlVXBkYXRlKHN0YXRlKTtcblxuICBpZiAoZXIpIG9ud3JpdGVFcnJvcihzdHJlYW0sIHN0YXRlLCBzeW5jLCBlciwgY2IpO2Vsc2Uge1xuICAgIC8vIENoZWNrIGlmIHdlJ3JlIGFjdHVhbGx5IHJlYWR5IHRvIGZpbmlzaCwgYnV0IGRvbid0IGVtaXQgeWV0XG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XG5cbiAgICBpZiAoIWZpbmlzaGVkICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0KSB7XG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcbiAgICB9XG5cbiAgICBpZiAoc3luYykge1xuICAgICAgLyo8cmVwbGFjZW1lbnQ+Ki9cbiAgICAgIGFzeW5jV3JpdGUoYWZ0ZXJXcml0ZSwgc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xuICAgIH0gZWxzZSB7XG4gICAgICBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKSB7XG4gIGlmICghZmluaXNoZWQpIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKTtcbiAgc3RhdGUucGVuZGluZ2NiLS07XG4gIGNiKCk7XG4gIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xufVxuXG4vLyBNdXN0IGZvcmNlIGNhbGxiYWNrIHRvIGJlIGNhbGxlZCBvbiBuZXh0VGljaywgc28gdGhhdCB3ZSBkb24ndFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxuLy8gdmFsdWUsIGFuZCBoYXMgYSBjaGFuY2UgdG8gYXR0YWNoIGEgJ2RyYWluJyBsaXN0ZW5lci5cbmZ1bmN0aW9uIG9ud3JpdGVEcmFpbihzdHJlYW0sIHN0YXRlKSB7XG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XG4gICAgc3RhdGUubmVlZERyYWluID0gZmFsc2U7XG4gICAgc3RyZWFtLmVtaXQoJ2RyYWluJyk7XG4gIH1cbn1cblxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcbmZ1bmN0aW9uIGNsZWFyQnVmZmVyKHN0cmVhbSwgc3RhdGUpIHtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IHRydWU7XG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcblxuICBpZiAoc3RyZWFtLl93cml0ZXYgJiYgZW50cnkgJiYgZW50cnkubmV4dCkge1xuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcbiAgICB2YXIgbCA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50O1xuICAgIHZhciBidWZmZXIgPSBuZXcgQXJyYXkobCk7XG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcbiAgICBob2xkZXIuZW50cnkgPSBlbnRyeTtcblxuICAgIHZhciBjb3VudCA9IDA7XG4gICAgdmFyIGFsbEJ1ZmZlcnMgPSB0cnVlO1xuICAgIHdoaWxlIChlbnRyeSkge1xuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xuICAgICAgaWYgKCFlbnRyeS5pc0J1ZikgYWxsQnVmZmVycyA9IGZhbHNlO1xuICAgICAgZW50cnkgPSBlbnRyeS5uZXh0O1xuICAgICAgY291bnQgKz0gMTtcbiAgICB9XG4gICAgYnVmZmVyLmFsbEJ1ZmZlcnMgPSBhbGxCdWZmZXJzO1xuXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB0cnVlLCBzdGF0ZS5sZW5ndGgsIGJ1ZmZlciwgJycsIGhvbGRlci5maW5pc2gpO1xuXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcbiAgICAvLyBhcyB0aGUgaG90IHBhdGggZW5kcyB3aXRoIGRvV3JpdGVcbiAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAoaG9sZGVyLm5leHQpIHtcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGhvbGRlci5uZXh0O1xuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBuZXcgQ29ya2VkUmVxdWVzdChzdGF0ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIC8vIFNsb3cgY2FzZSwgd3JpdGUgY2h1bmtzIG9uZS1ieS1vbmVcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIHZhciBjaHVuayA9IGVudHJ5LmNodW5rO1xuICAgICAgdmFyIGVuY29kaW5nID0gZW50cnkuZW5jb2Rpbmc7XG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICAgIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIC8vIGlmIHdlIGRpZG4ndCBjYWxsIHRoZSBvbndyaXRlIGltbWVkaWF0ZWx5LCB0aGVuXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxuICAgICAgLy8gYWxzbywgdGhhdCBtZWFucyB0aGF0IHRoZSBjaHVuayBhbmQgY2IgYXJlIGN1cnJlbnRseVxuICAgICAgLy8gYmVpbmcgcHJvY2Vzc2VkLCBzbyBtb3ZlIHRoZSBidWZmZXIgY291bnRlciBwYXN0IHRoZW0uXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoZW50cnkgPT09IG51bGwpIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSBudWxsO1xuICB9XG5cbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgPSAwO1xuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcbiAgc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xufVxuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobmV3IEVycm9yKCdfd3JpdGUoKSBpcyBub3QgaW1wbGVtZW50ZWQnKSk7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuX3dyaXRldiA9IG51bGw7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xuXG4gIGlmICh0eXBlb2YgY2h1bmsgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGNodW5rO1xuICAgIGNodW5rID0gbnVsbDtcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH0gZWxzZSBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBlbmNvZGluZztcbiAgICBlbmNvZGluZyA9IG51bGw7XG4gIH1cblxuICBpZiAoY2h1bmsgIT09IG51bGwgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCkgdGhpcy53cml0ZShjaHVuaywgZW5jb2RpbmcpO1xuXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXG4gIGlmIChzdGF0ZS5jb3JrZWQpIHtcbiAgICBzdGF0ZS5jb3JrZWQgPSAxO1xuICAgIHRoaXMudW5jb3JrKCk7XG4gIH1cblxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXG4gIGlmICghc3RhdGUuZW5kaW5nICYmICFzdGF0ZS5maW5pc2hlZCkgZW5kV3JpdGFibGUodGhpcywgc3RhdGUsIGNiKTtcbn07XG5cbmZ1bmN0aW9uIG5lZWRGaW5pc2goc3RhdGUpIHtcbiAgcmV0dXJuIHN0YXRlLmVuZGluZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID09PSBudWxsICYmICFzdGF0ZS5maW5pc2hlZCAmJiAhc3RhdGUud3JpdGluZztcbn1cbmZ1bmN0aW9uIGNhbGxGaW5hbChzdHJlYW0sIHN0YXRlKSB7XG4gIHN0cmVhbS5fZmluYWwoZnVuY3Rpb24gKGVycikge1xuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xuICAgIGlmIChlcnIpIHtcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVycik7XG4gICAgfVxuICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIH0pO1xufVxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5wcmVmaW5pc2hlZCAmJiAhc3RhdGUuZmluYWxDYWxsZWQpIHtcbiAgICBpZiAodHlwZW9mIHN0cmVhbS5fZmluYWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgICAgc3RhdGUuZmluYWxDYWxsZWQgPSB0cnVlO1xuICAgICAgcHJvY2Vzc05leHRUaWNrKGNhbGxGaW5hbCwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXRlLnByZWZpbmlzaGVkID0gdHJ1ZTtcbiAgICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSkge1xuICB2YXIgbmVlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuICBpZiAobmVlZCkge1xuICAgIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKTtcbiAgICBpZiAoc3RhdGUucGVuZGluZ2NiID09PSAwKSB7XG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgnZmluaXNoJyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBuZWVkO1xufVxuXG5mdW5jdGlvbiBlbmRXcml0YWJsZShzdHJlYW0sIHN0YXRlLCBjYikge1xuICBzdGF0ZS5lbmRpbmcgPSB0cnVlO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbiAgaWYgKGNiKSB7XG4gICAgaWYgKHN0YXRlLmZpbmlzaGVkKSBwcm9jZXNzTmV4dFRpY2soY2IpO2Vsc2Ugc3RyZWFtLm9uY2UoJ2ZpbmlzaCcsIGNiKTtcbiAgfVxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XG4gIHN0cmVhbS53cml0YWJsZSA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbkNvcmtlZEZpbmlzaChjb3JrUmVxLCBzdGF0ZSwgZXJyKSB7XG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XG4gIGNvcmtSZXEuZW50cnkgPSBudWxsO1xuICB3aGlsZSAoZW50cnkpIHtcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBjYihlcnIpO1xuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgfVxuICBpZiAoc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlKSB7XG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IGNvcmtSZXE7XG4gIH1cbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuV3JpdGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5Xcml0YWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLmVuZCgpO1xuICBjYihlcnIpO1xufTsiLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTsgfSB9XG5cbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcbiAgc3JjLmNvcHkodGFyZ2V0LCBvZmZzZXQpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gQnVmZmVyTGlzdCgpIHtcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XG5cbiAgICB0aGlzLmhlYWQgPSBudWxsO1xuICAgIHRoaXMudGFpbCA9IG51bGw7XG4gICAgdGhpcy5sZW5ndGggPSAwO1xuICB9XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIHB1c2godikge1xuICAgIHZhciBlbnRyeSA9IHsgZGF0YTogdiwgbmV4dDogbnVsbCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcbiAgICB0aGlzLnRhaWwgPSBlbnRyeTtcbiAgICArK3RoaXMubGVuZ3RoO1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiB1bnNoaWZ0KHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgdGhpcy50YWlsID0gZW50cnk7XG4gICAgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuO1xuICAgIHZhciByZXQgPSB0aGlzLmhlYWQuZGF0YTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcbiAgICAtLXRoaXMubGVuZ3RoO1xuICAgIHJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY2xlYXIgPSBmdW5jdGlvbiBjbGVhcigpIHtcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5qb2luID0gZnVuY3Rpb24gam9pbihzKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gJyc7XG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XG4gICAgdmFyIHJldCA9ICcnICsgcC5kYXRhO1xuICAgIHdoaWxlIChwID0gcC5uZXh0KSB7XG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcbiAgICB9cmV0dXJuIHJldDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQobikge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIEJ1ZmZlci5hbGxvYygwKTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcbiAgICB2YXIgcmV0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKG4gPj4+IDApO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciBpID0gMDtcbiAgICB3aGlsZSAocCkge1xuICAgICAgY29weUJ1ZmZlcihwLmRhdGEsIHJldCwgaSk7XG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XG4gICAgICBwID0gcC5uZXh0O1xuICAgIH1cbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIHJldHVybiBCdWZmZXJMaXN0O1xufSgpOyIsIid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLy8gdW5kb2N1bWVudGVkIGNiKCkgQVBJLCBuZWVkZWQgZm9yIGNvcmUsIG5vdCBmb3IgcHVibGljIEFQSVxuZnVuY3Rpb24gZGVzdHJveShlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdmFyIHJlYWRhYmxlRGVzdHJveWVkID0gdGhpcy5fcmVhZGFibGVTdGF0ZSAmJiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcblxuICBpZiAocmVhZGFibGVEZXN0cm95ZWQgfHwgd3JpdGFibGVEZXN0cm95ZWQpIHtcbiAgICBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfSBlbHNlIGlmIChlcnIgJiYgKCF0aGlzLl93cml0YWJsZVN0YXRlIHx8ICF0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCkpIHtcbiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcbiAgICB9XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgLy8gd2Ugc2V0IGRlc3Ryb3llZCB0byB0cnVlIGJlZm9yZSBmaXJpbmcgZXJyb3IgY2FsbGJhY2tzIGluIG9yZGVyXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xuXG4gIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICB9XG5cbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxuICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIHRoaXMuX2Rlc3Ryb3koZXJyIHx8IG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICBpZiAoIWNiICYmIGVycikge1xuICAgICAgcHJvY2Vzc05leHRUaWNrKGVtaXRFcnJvck5ULCBfdGhpcywgZXJyKTtcbiAgICAgIGlmIChfdGhpcy5fd3JpdGFibGVTdGF0ZSkge1xuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY2IpIHtcbiAgICAgIGNiKGVycik7XG4gICAgfVxuICB9KTtcbn1cblxuZnVuY3Rpb24gdW5kZXN0cm95KCkge1xuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB9XG5cbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZmluaXNoZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRFcnJvck5UKHNlbGYsIGVycikge1xuICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXG4gIHVuZGVzdHJveTogdW5kZXN0cm95XG59OyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuUGFzc1Rocm91Z2hcbiIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fcmVhZGFibGUuanMnKTtcbmV4cG9ydHMuU3RyZWFtID0gZXhwb3J0cztcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xuZXhwb3J0cy5Xcml0YWJsZSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbmV4cG9ydHMuRHVwbGV4ID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9kdXBsZXguanMnKTtcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcbmV4cG9ydHMuUGFzc1Rocm91Z2ggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3Bhc3N0aHJvdWdoLmpzJyk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV93cml0YWJsZS5qcycpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbnZhciBpc0VuY29kaW5nID0gQnVmZmVyLmlzRW5jb2RpbmcgfHwgZnVuY3Rpb24gKGVuY29kaW5nKSB7XG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcbiAgc3dpdGNoIChlbmNvZGluZyAmJiBlbmNvZGluZy50b0xvd2VyQ2FzZSgpKSB7XG4gICAgY2FzZSAnaGV4JzpjYXNlICd1dGY4JzpjYXNlICd1dGYtOCc6Y2FzZSAnYXNjaWknOmNhc2UgJ2JpbmFyeSc6Y2FzZSAnYmFzZTY0JzpjYXNlICd1Y3MyJzpjYXNlICd1Y3MtMic6Y2FzZSAndXRmMTZsZSc6Y2FzZSAndXRmLTE2bGUnOmNhc2UgJ3Jhdyc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XG4gIGlmICghZW5jKSByZXR1cm4gJ3V0ZjgnO1xuICB2YXIgcmV0cmllZDtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuYykge1xuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiAndXRmOCc7XG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xuICAgICAgY2FzZSAnbGF0aW4xJzpcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gZW5jO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXG4gICAgICAgIGVuYyA9ICgnJyArIGVuYykudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgcmV0cmllZCA9IHRydWU7XG4gICAgfVxuICB9XG59O1xuXG4vLyBEbyBub3QgY2FjaGUgYEJ1ZmZlci5pc0VuY29kaW5nYCB3aGVuIGNoZWNraW5nIGVuY29kaW5nIG5hbWVzIGFzIHNvbWVcbi8vIG1vZHVsZXMgbW9ua2V5LXBhdGNoIGl0IHRvIHN1cHBvcnQgYWRkaXRpb25hbCBlbmNvZGluZ3NcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICB2YXIgbmVuYyA9IF9ub3JtYWxpemVFbmNvZGluZyhlbmMpO1xuICBpZiAodHlwZW9mIG5lbmMgIT09ICdzdHJpbmcnICYmIChCdWZmZXIuaXNFbmNvZGluZyA9PT0gaXNFbmNvZGluZyB8fCAhaXNFbmNvZGluZyhlbmMpKSkgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jKTtcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xufVxuXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXG4vLyBidWZmZXJzIGludG8gYSBzZXJpZXMgb2YgSlMgc3RyaW5ncyB3aXRob3V0IGJyZWFraW5nIGFwYXJ0IG11bHRpLWJ5dGVcbi8vIGNoYXJhY3RlcnMuXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xuZnVuY3Rpb24gU3RyaW5nRGVjb2RlcihlbmNvZGluZykge1xuICB0aGlzLmVuY29kaW5nID0gbm9ybWFsaXplRW5jb2RpbmcoZW5jb2RpbmcpO1xuICB2YXIgbmI7XG4gIHN3aXRjaCAodGhpcy5lbmNvZGluZykge1xuICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xuICAgICAgdGhpcy5lbmQgPSB1dGYxNkVuZDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgdGhpcy5maWxsTGFzdCA9IHV0ZjhGaWxsTGFzdDtcbiAgICAgIG5iID0gNDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xuICAgICAgdGhpcy5lbmQgPSBiYXNlNjRFbmQ7XG4gICAgICBuYiA9IDM7XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhpcy53cml0ZSA9IHNpbXBsZVdyaXRlO1xuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XG4gICAgICByZXR1cm47XG4gIH1cbiAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIHRoaXMubGFzdFRvdGFsID0gMDtcbiAgdGhpcy5sYXN0Q2hhciA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuYik7XG59XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLndyaXRlID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICB2YXIgcjtcbiAgdmFyIGk7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XG4gICAgciA9IHRoaXMuZmlsbExhc3QoYnVmKTtcbiAgICBpZiAociA9PT0gdW5kZWZpbmVkKSByZXR1cm4gJyc7XG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XG4gICAgdGhpcy5sYXN0TmVlZCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgaSA9IDA7XG4gIH1cbiAgaWYgKGkgPCBidWYubGVuZ3RoKSByZXR1cm4gciA/IHIgKyB0aGlzLnRleHQoYnVmLCBpKSA6IHRoaXMudGV4dChidWYsIGkpO1xuICByZXR1cm4gciB8fCAnJztcbn07XG5cblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XG5cbi8vIFJldHVybnMgb25seSBjb21wbGV0ZSBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgcGFydGlhbCBub24tVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXJcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCB0aGlzLmxhc3ROZWVkKTtcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XG4gIH1cbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufTtcblxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxuLy8gY29udGludWF0aW9uIGJ5dGUuXG5mdW5jdGlvbiB1dGY4Q2hlY2tCeXRlKGJ5dGUpIHtcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XG4gIHJldHVybiAtMTtcbn1cblxuLy8gQ2hlY2tzIGF0IG1vc3QgMyBieXRlcyBhdCB0aGUgZW5kIG9mIGEgQnVmZmVyIGluIG9yZGVyIHRvIGRldGVjdCBhblxuLy8gaW5jb21wbGV0ZSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3Rlci4gVGhlIHRvdGFsIG51bWJlciBvZiBieXRlcyAoMiwgMywgb3IgNClcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXG5mdW5jdGlvbiB1dGY4Q2hlY2tJbmNvbXBsZXRlKHNlbGYsIGJ1ZiwgaSkge1xuICB2YXIgaiA9IGJ1Zi5sZW5ndGggLSAxO1xuICBpZiAoaiA8IGkpIHJldHVybiAwO1xuICB2YXIgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xuICAgIHJldHVybiBuYjtcbiAgfVxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XG4gIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHtcbiAgICAgIGlmIChuYiA9PT0gMikgbmIgPSAwO2Vsc2Ugc2VsZi5sYXN0TmVlZCA9IG5iIC0gMztcbiAgICB9XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIHJldHVybiAwO1xufVxuXG4vLyBWYWxpZGF0ZXMgYXMgbWFueSBjb250aW51YXRpb24gYnl0ZXMgZm9yIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgYXNcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XG4vLyBvbmUsIHdlIFwicmVwbGFjZVwiIHRoZSB2YWxpZGF0ZWQgY29udGludWF0aW9uIGJ5dGVzIHdlJ3ZlIHNlZW4gc28gZmFyIHdpdGhcbi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcXHVmZmZkJyksIHRvIG1hdGNoIHY4J3MgVVRGLTggZGVjb2Rpbmdcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2Vcbi8vIHdoZXJlIGFsbCBvZiB0aGUgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIGNoYXJhY3RlciBleGlzdCBpbiB0aGUgc2FtZSBidWZmZXIuXG4vLyBJdCBpcyBhbHNvIGRvbmUgdGhpcyB3YXkgYXMgYSBzbGlnaHQgcGVyZm9ybWFuY2UgaW5jcmVhc2UgaW5zdGVhZCBvZiB1c2luZyBhXG4vLyBsb29wLlxuZnVuY3Rpb24gdXRmOENoZWNrRXh0cmFCeXRlcyhzZWxmLCBidWYsIHApIHtcbiAgaWYgKChidWZbMF0gJiAweEMwKSAhPT0gMHg4MCkge1xuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xuICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHApO1xuICB9XG4gIGlmIChzZWxmLmxhc3ROZWVkID4gMSAmJiBidWYubGVuZ3RoID4gMSkge1xuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgIHNlbGYubGFzdE5lZWQgPSAxO1xuICAgICAgcmV0dXJuICdcXHVmZmZkJy5yZXBlYXQocCArIDEpO1xuICAgIH1cbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcbiAgICAgIGlmICgoYnVmWzJdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICAgICAgc2VsZi5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHAgKyAyKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyLlxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xuICB2YXIgcCA9IHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZDtcbiAgdmFyIHIgPSB1dGY4Q2hlY2tFeHRyYUJ5dGVzKHRoaXMsIGJ1ZiwgcCk7XG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xuICBpZiAodGhpcy5sYXN0TmVlZCA8PSBidWYubGVuZ3RoKSB7XG4gICAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIGJ1Zi5sZW5ndGgpO1xuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XG59XG5cbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxuLy8gcGFydGlhbCBjaGFyYWN0ZXIsIHRoZSBjaGFyYWN0ZXIncyBieXRlcyBhcmUgYnVmZmVyZWQgdW50aWwgdGhlIHJlcXVpcmVkXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXJlIGF2YWlsYWJsZS5cbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xuICB2YXIgdG90YWwgPSB1dGY4Q2hlY2tJbmNvbXBsZXRlKHRoaXMsIGJ1ZiwgaSk7XG4gIGlmICghdGhpcy5sYXN0TmVlZCkgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGkpO1xuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xuICB2YXIgZW5kID0gYnVmLmxlbmd0aCAtICh0b3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCAwLCBlbmQpO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcbn1cblxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBmb3IgZWFjaCBidWZmZXJlZCBieXRlIG9mIGEgKHBhcnRpYWwpXG4vLyBjaGFyYWN0ZXIgbmVlZHMgdG8gYmUgYWRkZWQgdG8gdGhlIG91dHB1dC5cbmZ1bmN0aW9uIHV0ZjhFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgJ1xcdWZmZmQnLnJlcGVhdCh0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gVVRGLTE2TEUgdHlwaWNhbGx5IG5lZWRzIHR3byBieXRlcyBwZXIgY2hhcmFjdGVyLCBidXQgZXZlbiBpZiB3ZSBoYXZlIGFuIGV2ZW5cbi8vIG51bWJlciBvZiBieXRlcyBhdmFpbGFibGUsIHdlIG5lZWQgdG8gY2hlY2sgaWYgd2UgZW5kIG9uIGEgbGVhZGluZy9oaWdoXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cbi8vIGRlY29kZSB0aGUgbGFzdCBjaGFyYWN0ZXIgcHJvcGVybHkuXG5mdW5jdGlvbiB1dGYxNlRleHQoYnVmLCBpKSB7XG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xuICAgIHZhciByID0gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSk7XG4gICAgaWYgKHIpIHtcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XG4gICAgICBpZiAoYyA+PSAweEQ4MDAgJiYgYyA8PSAweERCRkYpIHtcbiAgICAgICAgdGhpcy5sYXN0TmVlZCA9IDI7XG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcbiAgICAgICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgICAgIHRoaXMubGFzdENoYXJbMV0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAxO1xuICB0aGlzLmxhc3RUb3RhbCA9IDI7XG4gIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDFdO1xuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGYxNmxlJywgaSwgYnVmLmxlbmd0aCAtIDEpO1xufVxuXG4vLyBGb3IgVVRGLTE2TEUgd2UgZG8gbm90IGV4cGxpY2l0bHkgYXBwZW5kIHNwZWNpYWwgcmVwbGFjZW1lbnQgY2hhcmFjdGVycyBpZiB3ZVxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXG5mdW5jdGlvbiB1dGYxNkVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHZhciBlbmQgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gICAgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCd1dGYxNmxlJywgMCwgZW5kKTtcbiAgfVxuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gYmFzZTY0VGV4dChidWYsIGkpIHtcbiAgdmFyIG4gPSAoYnVmLmxlbmd0aCAtIGkpICUgMztcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xuICB0aGlzLmxhc3ROZWVkID0gMyAtIG47XG4gIHRoaXMubGFzdFRvdGFsID0gMztcbiAgaWYgKG4gPT09IDEpIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfSBlbHNlIHtcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcbiAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgfVxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcbiAgdmFyIHIgPSBidWYgJiYgYnVmLmxlbmd0aCA/IHRoaXMud3JpdGUoYnVmKSA6ICcnO1xuICBpZiAodGhpcy5sYXN0TmVlZCkgcmV0dXJuIHIgKyB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKCdiYXNlNjQnLCAwLCAzIC0gdGhpcy5sYXN0TmVlZCk7XG4gIHJldHVybiByO1xufVxuXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXG5mdW5jdGlvbiBzaW1wbGVXcml0ZShidWYpIHtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZyh0aGlzLmVuY29kaW5nKTtcbn1cblxuZnVuY3Rpb24gc2ltcGxlRW5kKGJ1Zikge1xuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbn0iLCJ2YXIgdHJhdmVyc2UgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICByZXR1cm4gbmV3IFRyYXZlcnNlKG9iaik7XG59O1xuXG5mdW5jdGlvbiBUcmF2ZXJzZSAob2JqKSB7XG4gICAgdGhpcy52YWx1ZSA9IG9iajtcbn1cblxuVHJhdmVyc2UucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghbm9kZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICBub2RlID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIG5vZGU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKHBzKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoOyBpICsrKSB7XG4gICAgICAgIHZhciBrZXkgPSBwc1tpXTtcbiAgICAgICAgaWYgKCFub2RlIHx8ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBub2RlID0gbm9kZVtrZXldO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAocHMsIHZhbHVlKSB7XG4gICAgdmFyIG5vZGUgPSB0aGlzLnZhbHVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHMubGVuZ3RoIC0gMTsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSBub2RlW2tleV0gPSB7fTtcbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgbm9kZVtwc1tpXV0gPSB2YWx1ZTtcbiAgICByZXR1cm4gdmFsdWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubWFwID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgcmV0dXJuIHdhbGsodGhpcy52YWx1ZSwgY2IsIHRydWUpO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmZvckVhY2ggPSBmdW5jdGlvbiAoY2IpIHtcbiAgICB0aGlzLnZhbHVlID0gd2Fsayh0aGlzLnZhbHVlLCBjYiwgZmFsc2UpO1xuICAgIHJldHVybiB0aGlzLnZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnJlZHVjZSA9IGZ1bmN0aW9uIChjYiwgaW5pdCkge1xuICAgIHZhciBza2lwID0gYXJndW1lbnRzLmxlbmd0aCA9PT0gMTtcbiAgICB2YXIgYWNjID0gc2tpcCA/IHRoaXMudmFsdWUgOiBpbml0O1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBpZiAoIXRoaXMuaXNSb290IHx8ICFza2lwKSB7XG4gICAgICAgICAgICBhY2MgPSBjYi5jYWxsKHRoaXMsIGFjYywgeCk7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gYWNjO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLnBhdGhzID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciBhY2MgPSBbXTtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgYWNjLnB1c2godGhpcy5wYXRoKTsgXG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5ub2RlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMubm9kZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgcGFyZW50cyA9IFtdLCBub2RlcyA9IFtdO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gY2xvbmUgKHNyYykge1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldID09PSBzcmMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbm9kZXNbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHZhciBkc3QgPSBjb3B5KHNyYyk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhcmVudHMucHVzaChzcmMpO1xuICAgICAgICAgICAgbm9kZXMucHVzaChkc3QpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3JFYWNoKG9iamVjdEtleXMoc3JjKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGRzdFtrZXldID0gY2xvbmUoc3JjW2tleV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHBhcmVudHMucG9wKCk7XG4gICAgICAgICAgICBub2Rlcy5wb3AoKTtcbiAgICAgICAgICAgIHJldHVybiBkc3Q7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gc3JjO1xuICAgICAgICB9XG4gICAgfSkodGhpcy52YWx1ZSk7XG59O1xuXG5mdW5jdGlvbiB3YWxrIChyb290LCBjYiwgaW1tdXRhYmxlKSB7XG4gICAgdmFyIHBhdGggPSBbXTtcbiAgICB2YXIgcGFyZW50cyA9IFtdO1xuICAgIHZhciBhbGl2ZSA9IHRydWU7XG4gICAgXG4gICAgcmV0dXJuIChmdW5jdGlvbiB3YWxrZXIgKG5vZGVfKSB7XG4gICAgICAgIHZhciBub2RlID0gaW1tdXRhYmxlID8gY29weShub2RlXykgOiBub2RlXztcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IHt9O1xuICAgICAgICBcbiAgICAgICAgdmFyIGtlZXBHb2luZyA9IHRydWU7XG4gICAgICAgIFxuICAgICAgICB2YXIgc3RhdGUgPSB7XG4gICAgICAgICAgICBub2RlIDogbm9kZSxcbiAgICAgICAgICAgIG5vZGVfIDogbm9kZV8sXG4gICAgICAgICAgICBwYXRoIDogW10uY29uY2F0KHBhdGgpLFxuICAgICAgICAgICAgcGFyZW50IDogcGFyZW50c1twYXJlbnRzLmxlbmd0aCAtIDFdLFxuICAgICAgICAgICAgcGFyZW50cyA6IHBhcmVudHMsXG4gICAgICAgICAgICBrZXkgOiBwYXRoLnNsaWNlKC0xKVswXSxcbiAgICAgICAgICAgIGlzUm9vdCA6IHBhdGgubGVuZ3RoID09PSAwLFxuICAgICAgICAgICAgbGV2ZWwgOiBwYXRoLmxlbmd0aCxcbiAgICAgICAgICAgIGNpcmN1bGFyIDogbnVsbCxcbiAgICAgICAgICAgIHVwZGF0ZSA6IGZ1bmN0aW9uICh4LCBzdG9wSGVyZSkge1xuICAgICAgICAgICAgICAgIGlmICghc3RhdGUuaXNSb290KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV0gPSB4O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBzdGF0ZS5ub2RlID0geDtcbiAgICAgICAgICAgICAgICBpZiAoc3RvcEhlcmUpIGtlZXBHb2luZyA9IGZhbHNlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICdkZWxldGUnIDogZnVuY3Rpb24gKHN0b3BIZXJlKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmUgOiBmdW5jdGlvbiAoc3RvcEhlcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaXNBcnJheShzdGF0ZS5wYXJlbnQubm9kZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUucGFyZW50Lm5vZGUuc3BsaWNlKHN0YXRlLmtleSwgMSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgc3RhdGUucGFyZW50Lm5vZGVbc3RhdGUua2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlzIDogbnVsbCxcbiAgICAgICAgICAgIGJlZm9yZSA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5iZWZvcmUgPSBmIH0sXG4gICAgICAgICAgICBhZnRlciA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5hZnRlciA9IGYgfSxcbiAgICAgICAgICAgIHByZSA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wcmUgPSBmIH0sXG4gICAgICAgICAgICBwb3N0IDogZnVuY3Rpb24gKGYpIHsgbW9kaWZpZXJzLnBvc3QgPSBmIH0sXG4gICAgICAgICAgICBzdG9wIDogZnVuY3Rpb24gKCkgeyBhbGl2ZSA9IGZhbHNlIH0sXG4gICAgICAgICAgICBibG9jayA6IGZ1bmN0aW9uICgpIHsga2VlcEdvaW5nID0gZmFsc2UgfVxuICAgICAgICB9O1xuICAgICAgICBcbiAgICAgICAgaWYgKCFhbGl2ZSkgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlU3RhdGUoKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHN0YXRlLm5vZGUgPT09ICdvYmplY3QnICYmIHN0YXRlLm5vZGUgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmtleXMgfHwgc3RhdGUubm9kZV8gIT09IHN0YXRlLm5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUua2V5cyA9IG9iamVjdEtleXMoc3RhdGUubm9kZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgc3RhdGUuaXNMZWFmID0gc3RhdGUua2V5cy5sZW5ndGggPT0gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmVudHNbaV0ubm9kZV8gPT09IG5vZGVfKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdGF0ZS5jaXJjdWxhciA9IHBhcmVudHNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3RhdGUua2V5cyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHN0YXRlLm5vdExlYWYgPSAhc3RhdGUuaXNMZWFmO1xuICAgICAgICAgICAgc3RhdGUubm90Um9vdCA9ICFzdGF0ZS5pc1Jvb3Q7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHVwZGF0ZVN0YXRlKCk7XG4gICAgICAgIFxuICAgICAgICAvLyB1c2UgcmV0dXJuIHZhbHVlcyB0byB1cGRhdGUgaWYgZGVmaW5lZFxuICAgICAgICB2YXIgcmV0ID0gY2IuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIGlmIChyZXQgIT09IHVuZGVmaW5lZCAmJiBzdGF0ZS51cGRhdGUpIHN0YXRlLnVwZGF0ZShyZXQpO1xuICAgICAgICBcbiAgICAgICAgaWYgKG1vZGlmaWVycy5iZWZvcmUpIG1vZGlmaWVycy5iZWZvcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIFxuICAgICAgICBpZiAoIWtlZXBHb2luZykgcmV0dXJuIHN0YXRlO1xuICAgICAgICBcbiAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5ub2RlID09ICdvYmplY3QnXG4gICAgICAgICYmIHN0YXRlLm5vZGUgIT09IG51bGwgJiYgIXN0YXRlLmNpcmN1bGFyKSB7XG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3RhdGUpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBmb3JFYWNoKHN0YXRlLmtleXMsIGZ1bmN0aW9uIChrZXksIGkpIHtcbiAgICAgICAgICAgICAgICBwYXRoLnB1c2goa2V5KTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnByZSkgbW9kaWZpZXJzLnByZS5jYWxsKHN0YXRlLCBzdGF0ZS5ub2RlW2tleV0sIGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdmFyIGNoaWxkID0gd2Fsa2VyKHN0YXRlLm5vZGVba2V5XSk7XG4gICAgICAgICAgICAgICAgaWYgKGltbXV0YWJsZSAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKHN0YXRlLm5vZGUsIGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUubm9kZVtrZXldID0gY2hpbGQubm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgY2hpbGQuaXNMYXN0ID0gaSA9PSBzdGF0ZS5rZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgICAgICAgICAgY2hpbGQuaXNGaXJzdCA9IGkgPT0gMDtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBpZiAobW9kaWZpZXJzLnBvc3QpIG1vZGlmaWVycy5wb3N0LmNhbGwoc3RhdGUsIGNoaWxkKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAobW9kaWZpZXJzLmFmdGVyKSBtb2RpZmllcnMuYWZ0ZXIuY2FsbChzdGF0ZSwgc3RhdGUubm9kZSk7XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gc3RhdGU7XG4gICAgfSkocm9vdCkubm9kZTtcbn1cblxuZnVuY3Rpb24gY29weSAoc3JjKSB7XG4gICAgaWYgKHR5cGVvZiBzcmMgPT09ICdvYmplY3QnICYmIHNyYyAhPT0gbnVsbCkge1xuICAgICAgICB2YXIgZHN0O1xuICAgICAgICBcbiAgICAgICAgaWYgKGlzQXJyYXkoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNEYXRlKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBEYXRlKHNyYy5nZXRUaW1lID8gc3JjLmdldFRpbWUoKSA6IHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNSZWdFeHAoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IFJlZ0V4cChzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRXJyb3Ioc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0geyBtZXNzYWdlOiBzcmMubWVzc2FnZSB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzQm9vbGVhbihzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgQm9vbGVhbihzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzTnVtYmVyKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBOdW1iZXIoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1N0cmluZyhzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgU3RyaW5nKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoT2JqZWN0LmNyZWF0ZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YpIHtcbiAgICAgICAgICAgIGRzdCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHNyYykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHNyYy5jb25zdHJ1Y3RvciA9PT0gT2JqZWN0KSB7XG4gICAgICAgICAgICBkc3QgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBwcm90byA9XG4gICAgICAgICAgICAgICAgKHNyYy5jb25zdHJ1Y3RvciAmJiBzcmMuY29uc3RydWN0b3IucHJvdG90eXBlKVxuICAgICAgICAgICAgICAgIHx8IHNyYy5fX3Byb3RvX19cbiAgICAgICAgICAgICAgICB8fCB7fVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgdmFyIFQgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgICAgICAgIFQucHJvdG90eXBlID0gcHJvdG87XG4gICAgICAgICAgICBkc3QgPSBuZXcgVDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgZm9yRWFjaChvYmplY3RLZXlzKHNyYyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGRzdFtrZXldID0gc3JjW2tleV07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gZHN0O1xuICAgIH1cbiAgICBlbHNlIHJldHVybiBzcmM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyAob2JqKSB7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHJlcy5wdXNoKGtleSlcbiAgICByZXR1cm4gcmVzO1xufTtcblxuZnVuY3Rpb24gdG9TIChvYmopIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopIH1cbmZ1bmN0aW9uIGlzRGF0ZSAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nIH1cbmZ1bmN0aW9uIGlzUmVnRXhwIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyB9XG5mdW5jdGlvbiBpc0Vycm9yIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBFcnJvcl0nIH1cbmZ1bmN0aW9uIGlzQm9vbGVhbiAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nIH1cbmZ1bmN0aW9uIGlzTnVtYmVyIChvYmopIHsgcmV0dXJuIHRvUyhvYmopID09PSAnW29iamVjdCBOdW1iZXJdJyB9XG5mdW5jdGlvbiBpc1N0cmluZyAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgU3RyaW5nXScgfVxuXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gaXNBcnJheSAoeHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbnZhciBmb3JFYWNoID0gZnVuY3Rpb24gKHhzLCBmbikge1xuICAgIGlmICh4cy5mb3JFYWNoKSByZXR1cm4geHMuZm9yRWFjaChmbilcbiAgICBlbHNlIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZm4oeHNbaV0sIGksIHhzKTtcbiAgICB9XG59O1xuXG5mb3JFYWNoKG9iamVjdEtleXMoVHJhdmVyc2UucHJvdG90eXBlKSwgZnVuY3Rpb24gKGtleSkge1xuICAgIHRyYXZlcnNlW2tleV0gPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICB2YXIgdCA9IG5ldyBUcmF2ZXJzZShvYmopO1xuICAgICAgICByZXR1cm4gdFtrZXldLmFwcGx5KHQsIGFyZ3MpO1xuICAgIH07XG59KTtcblxudmFyIGhhc093blByb3BlcnR5ID0gT2JqZWN0Lmhhc093blByb3BlcnR5IHx8IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIHJldHVybiBrZXkgaW4gb2JqO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBwdW55Y29kZSA9IHJlcXVpcmUoJ3B1bnljb2RlJyk7XG52YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG5leHBvcnRzLnBhcnNlID0gdXJsUGFyc2U7XG5leHBvcnRzLnJlc29sdmUgPSB1cmxSZXNvbHZlO1xuZXhwb3J0cy5yZXNvbHZlT2JqZWN0ID0gdXJsUmVzb2x2ZU9iamVjdDtcbmV4cG9ydHMuZm9ybWF0ID0gdXJsRm9ybWF0O1xuXG5leHBvcnRzLlVybCA9IFVybDtcblxuZnVuY3Rpb24gVXJsKCkge1xuICB0aGlzLnByb3RvY29sID0gbnVsbDtcbiAgdGhpcy5zbGFzaGVzID0gbnVsbDtcbiAgdGhpcy5hdXRoID0gbnVsbDtcbiAgdGhpcy5ob3N0ID0gbnVsbDtcbiAgdGhpcy5wb3J0ID0gbnVsbDtcbiAgdGhpcy5ob3N0bmFtZSA9IG51bGw7XG4gIHRoaXMuaGFzaCA9IG51bGw7XG4gIHRoaXMuc2VhcmNoID0gbnVsbDtcbiAgdGhpcy5xdWVyeSA9IG51bGw7XG4gIHRoaXMucGF0aG5hbWUgPSBudWxsO1xuICB0aGlzLnBhdGggPSBudWxsO1xuICB0aGlzLmhyZWYgPSBudWxsO1xufVxuXG4vLyBSZWZlcmVuY2U6IFJGQyAzOTg2LCBSRkMgMTgwOCwgUkZDIDIzOTZcblxuLy8gZGVmaW5lIHRoZXNlIGhlcmUgc28gYXQgbGVhc3QgdGhleSBvbmx5IGhhdmUgdG8gYmVcbi8vIGNvbXBpbGVkIG9uY2Ugb24gdGhlIGZpcnN0IG1vZHVsZSBsb2FkLlxudmFyIHByb3RvY29sUGF0dGVybiA9IC9eKFthLXowLTkuKy1dKzopL2ksXG4gICAgcG9ydFBhdHRlcm4gPSAvOlswLTldKiQvLFxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIGZvciBhIHNpbXBsZSBwYXRoIFVSTFxuICAgIHNpbXBsZVBhdGhQYXR0ZXJuID0gL14oXFwvXFwvPyg/IVxcLylbXlxcP1xcc10qKShcXD9bXlxcc10qKT8kLyxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIHJlc2VydmVkIGZvciBkZWxpbWl0aW5nIFVSTHMuXG4gICAgLy8gV2UgYWN0dWFsbHkganVzdCBhdXRvLWVzY2FwZSB0aGVzZS5cbiAgICBkZWxpbXMgPSBbJzwnLCAnPicsICdcIicsICdgJywgJyAnLCAnXFxyJywgJ1xcbicsICdcXHQnXSxcblxuICAgIC8vIFJGQyAyMzk2OiBjaGFyYWN0ZXJzIG5vdCBhbGxvd2VkIGZvciB2YXJpb3VzIHJlYXNvbnMuXG4gICAgdW53aXNlID0gWyd7JywgJ30nLCAnfCcsICdcXFxcJywgJ14nLCAnYCddLmNvbmNhdChkZWxpbXMpLFxuXG4gICAgLy8gQWxsb3dlZCBieSBSRkNzLCBidXQgY2F1c2Ugb2YgWFNTIGF0dGFja3MuICBBbHdheXMgZXNjYXBlIHRoZXNlLlxuICAgIGF1dG9Fc2NhcGUgPSBbJ1xcJyddLmNvbmNhdCh1bndpc2UpLFxuICAgIC8vIENoYXJhY3RlcnMgdGhhdCBhcmUgbmV2ZXIgZXZlciBhbGxvd2VkIGluIGEgaG9zdG5hbWUuXG4gICAgLy8gTm90ZSB0aGF0IGFueSBpbnZhbGlkIGNoYXJzIGFyZSBhbHNvIGhhbmRsZWQsIGJ1dCB0aGVzZVxuICAgIC8vIGFyZSB0aGUgb25lcyB0aGF0IGFyZSAqZXhwZWN0ZWQqIHRvIGJlIHNlZW4sIHNvIHdlIGZhc3QtcGF0aFxuICAgIC8vIHRoZW0uXG4gICAgbm9uSG9zdENoYXJzID0gWyclJywgJy8nLCAnPycsICc7JywgJyMnXS5jb25jYXQoYXV0b0VzY2FwZSksXG4gICAgaG9zdEVuZGluZ0NoYXJzID0gWycvJywgJz8nLCAnIyddLFxuICAgIGhvc3RuYW1lTWF4TGVuID0gMjU1LFxuICAgIGhvc3RuYW1lUGFydFBhdHRlcm4gPSAvXlsrYS16MC05QS1aXy1dezAsNjN9JC8sXG4gICAgaG9zdG5hbWVQYXJ0U3RhcnQgPSAvXihbK2EtejAtOUEtWl8tXXswLDYzfSkoLiopJC8sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgY2FuIGFsbG93IFwidW5zYWZlXCIgYW5kIFwidW53aXNlXCIgY2hhcnMuXG4gICAgdW5zYWZlUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBuZXZlciBoYXZlIGEgaG9zdG5hbWUuXG4gICAgaG9zdGxlc3NQcm90b2NvbCA9IHtcbiAgICAgICdqYXZhc2NyaXB0JzogdHJ1ZSxcbiAgICAgICdqYXZhc2NyaXB0Oic6IHRydWVcbiAgICB9LFxuICAgIC8vIHByb3RvY29scyB0aGF0IGFsd2F5cyBjb250YWluIGEgLy8gYml0LlxuICAgIHNsYXNoZWRQcm90b2NvbCA9IHtcbiAgICAgICdodHRwJzogdHJ1ZSxcbiAgICAgICdodHRwcyc6IHRydWUsXG4gICAgICAnZnRwJzogdHJ1ZSxcbiAgICAgICdnb3BoZXInOiB0cnVlLFxuICAgICAgJ2ZpbGUnOiB0cnVlLFxuICAgICAgJ2h0dHA6JzogdHJ1ZSxcbiAgICAgICdodHRwczonOiB0cnVlLFxuICAgICAgJ2Z0cDonOiB0cnVlLFxuICAgICAgJ2dvcGhlcjonOiB0cnVlLFxuICAgICAgJ2ZpbGU6JzogdHJ1ZVxuICAgIH0sXG4gICAgcXVlcnlzdHJpbmcgPSByZXF1aXJlKCdxdWVyeXN0cmluZycpO1xuXG5mdW5jdGlvbiB1cmxQYXJzZSh1cmwsIHBhcnNlUXVlcnlTdHJpbmcsIHNsYXNoZXNEZW5vdGVIb3N0KSB7XG4gIGlmICh1cmwgJiYgdXRpbC5pc09iamVjdCh1cmwpICYmIHVybCBpbnN0YW5jZW9mIFVybCkgcmV0dXJuIHVybDtcblxuICB2YXIgdSA9IG5ldyBVcmw7XG4gIHUucGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCk7XG4gIHJldHVybiB1O1xufVxuXG5VcmwucHJvdG90eXBlLnBhcnNlID0gZnVuY3Rpb24odXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAoIXV0aWwuaXNTdHJpbmcodXJsKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQYXJhbWV0ZXIgJ3VybCcgbXVzdCBiZSBhIHN0cmluZywgbm90IFwiICsgdHlwZW9mIHVybCk7XG4gIH1cblxuICAvLyBDb3B5IGNocm9tZSwgSUUsIG9wZXJhIGJhY2tzbGFzaC1oYW5kbGluZyBiZWhhdmlvci5cbiAgLy8gQmFjayBzbGFzaGVzIGJlZm9yZSB0aGUgcXVlcnkgc3RyaW5nIGdldCBjb252ZXJ0ZWQgdG8gZm9yd2FyZCBzbGFzaGVzXG4gIC8vIFNlZTogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTI1OTE2XG4gIHZhciBxdWVyeUluZGV4ID0gdXJsLmluZGV4T2YoJz8nKSxcbiAgICAgIHNwbGl0dGVyID1cbiAgICAgICAgICAocXVlcnlJbmRleCAhPT0gLTEgJiYgcXVlcnlJbmRleCA8IHVybC5pbmRleE9mKCcjJykpID8gJz8nIDogJyMnLFxuICAgICAgdVNwbGl0ID0gdXJsLnNwbGl0KHNwbGl0dGVyKSxcbiAgICAgIHNsYXNoUmVnZXggPSAvXFxcXC9nO1xuICB1U3BsaXRbMF0gPSB1U3BsaXRbMF0ucmVwbGFjZShzbGFzaFJlZ2V4LCAnLycpO1xuICB1cmwgPSB1U3BsaXQuam9pbihzcGxpdHRlcik7XG5cbiAgdmFyIHJlc3QgPSB1cmw7XG5cbiAgLy8gdHJpbSBiZWZvcmUgcHJvY2VlZGluZy5cbiAgLy8gVGhpcyBpcyB0byBzdXBwb3J0IHBhcnNlIHN0dWZmIGxpa2UgXCIgIGh0dHA6Ly9mb28uY29tICBcXG5cIlxuICByZXN0ID0gcmVzdC50cmltKCk7XG5cbiAgaWYgKCFzbGFzaGVzRGVub3RlSG9zdCAmJiB1cmwuc3BsaXQoJyMnKS5sZW5ndGggPT09IDEpIHtcbiAgICAvLyBUcnkgZmFzdCBwYXRoIHJlZ2V4cFxuICAgIHZhciBzaW1wbGVQYXRoID0gc2ltcGxlUGF0aFBhdHRlcm4uZXhlYyhyZXN0KTtcbiAgICBpZiAoc2ltcGxlUGF0aCkge1xuICAgICAgdGhpcy5wYXRoID0gcmVzdDtcbiAgICAgIHRoaXMuaHJlZiA9IHJlc3Q7XG4gICAgICB0aGlzLnBhdGhuYW1lID0gc2ltcGxlUGF0aFsxXTtcbiAgICAgIGlmIChzaW1wbGVQYXRoWzJdKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gc2ltcGxlUGF0aFsyXTtcbiAgICAgICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5zZWFyY2guc3Vic3RyKDEpKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnF1ZXJ5ID0gdGhpcy5zZWFyY2guc3Vic3RyKDEpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgICAgdGhpcy5zZWFyY2ggPSAnJztcbiAgICAgICAgdGhpcy5xdWVyeSA9IHt9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9XG5cbiAgdmFyIHByb3RvID0gcHJvdG9jb2xQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gIGlmIChwcm90bykge1xuICAgIHByb3RvID0gcHJvdG9bMF07XG4gICAgdmFyIGxvd2VyUHJvdG8gPSBwcm90by50b0xvd2VyQ2FzZSgpO1xuICAgIHRoaXMucHJvdG9jb2wgPSBsb3dlclByb3RvO1xuICAgIHJlc3QgPSByZXN0LnN1YnN0cihwcm90by5sZW5ndGgpO1xuICB9XG5cbiAgLy8gZmlndXJlIG91dCBpZiBpdCdzIGdvdCBhIGhvc3RcbiAgLy8gdXNlckBzZXJ2ZXIgaXMgKmFsd2F5cyogaW50ZXJwcmV0ZWQgYXMgYSBob3N0bmFtZSwgYW5kIHVybFxuICAvLyByZXNvbHV0aW9uIHdpbGwgdHJlYXQgLy9mb28vYmFyIGFzIGhvc3Q9Zm9vLHBhdGg9YmFyIGJlY2F1c2UgdGhhdCdzXG4gIC8vIGhvdyB0aGUgYnJvd3NlciByZXNvbHZlcyByZWxhdGl2ZSBVUkxzLlxuICBpZiAoc2xhc2hlc0Rlbm90ZUhvc3QgfHwgcHJvdG8gfHwgcmVzdC5tYXRjaCgvXlxcL1xcL1teQFxcL10rQFteQFxcL10rLykpIHtcbiAgICB2YXIgc2xhc2hlcyA9IHJlc3Quc3Vic3RyKDAsIDIpID09PSAnLy8nO1xuICAgIGlmIChzbGFzaGVzICYmICEocHJvdG8gJiYgaG9zdGxlc3NQcm90b2NvbFtwcm90b10pKSB7XG4gICAgICByZXN0ID0gcmVzdC5zdWJzdHIoMik7XG4gICAgICB0aGlzLnNsYXNoZXMgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIGlmICghaG9zdGxlc3NQcm90b2NvbFtwcm90b10gJiZcbiAgICAgIChzbGFzaGVzIHx8IChwcm90byAmJiAhc2xhc2hlZFByb3RvY29sW3Byb3RvXSkpKSB7XG5cbiAgICAvLyB0aGVyZSdzIGEgaG9zdG5hbWUuXG4gICAgLy8gdGhlIGZpcnN0IGluc3RhbmNlIG9mIC8sID8sIDssIG9yICMgZW5kcyB0aGUgaG9zdC5cbiAgICAvL1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIEAgaW4gdGhlIGhvc3RuYW1lLCB0aGVuIG5vbi1ob3N0IGNoYXJzICphcmUqIGFsbG93ZWRcbiAgICAvLyB0byB0aGUgbGVmdCBvZiB0aGUgbGFzdCBAIHNpZ24sIHVubGVzcyBzb21lIGhvc3QtZW5kaW5nIGNoYXJhY3RlclxuICAgIC8vIGNvbWVzICpiZWZvcmUqIHRoZSBALXNpZ24uXG4gICAgLy8gVVJMcyBhcmUgb2Jub3hpb3VzLlxuICAgIC8vXG4gICAgLy8gZXg6XG4gICAgLy8gaHR0cDovL2FAYkBjLyA9PiB1c2VyOmFAYiBob3N0OmNcbiAgICAvLyBodHRwOi8vYUBiP0BjID0+IHVzZXI6YSBob3N0OmMgcGF0aDovP0BjXG5cbiAgICAvLyB2MC4xMiBUT0RPKGlzYWFjcyk6IFRoaXMgaXMgbm90IHF1aXRlIGhvdyBDaHJvbWUgZG9lcyB0aGluZ3MuXG4gICAgLy8gUmV2aWV3IG91ciB0ZXN0IGNhc2UgYWdhaW5zdCBicm93c2VycyBtb3JlIGNvbXByZWhlbnNpdmVseS5cblxuICAgIC8vIGZpbmQgdGhlIGZpcnN0IGluc3RhbmNlIG9mIGFueSBob3N0RW5kaW5nQ2hhcnNcbiAgICB2YXIgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9zdEVuZGluZ0NoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKGhvc3RFbmRpbmdDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuXG4gICAgLy8gYXQgdGhpcyBwb2ludCwgZWl0aGVyIHdlIGhhdmUgYW4gZXhwbGljaXQgcG9pbnQgd2hlcmUgdGhlXG4gICAgLy8gYXV0aCBwb3J0aW9uIGNhbm5vdCBnbyBwYXN0LCBvciB0aGUgbGFzdCBAIGNoYXIgaXMgdGhlIGRlY2lkZXIuXG4gICAgdmFyIGF1dGgsIGF0U2lnbjtcbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpIHtcbiAgICAgIC8vIGF0U2lnbiBjYW4gYmUgYW55d2hlcmUuXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGF0U2lnbiBtdXN0IGJlIGluIGF1dGggcG9ydGlvbi5cbiAgICAgIC8vIGh0dHA6Ly9hQGIvY0BkID0+IGhvc3Q6YiBhdXRoOmEgcGF0aDovY0BkXG4gICAgICBhdFNpZ24gPSByZXN0Lmxhc3RJbmRleE9mKCdAJywgaG9zdEVuZCk7XG4gICAgfVxuXG4gICAgLy8gTm93IHdlIGhhdmUgYSBwb3J0aW9uIHdoaWNoIGlzIGRlZmluaXRlbHkgdGhlIGF1dGguXG4gICAgLy8gUHVsbCB0aGF0IG9mZi5cbiAgICBpZiAoYXRTaWduICE9PSAtMSkge1xuICAgICAgYXV0aCA9IHJlc3Quc2xpY2UoMCwgYXRTaWduKTtcbiAgICAgIHJlc3QgPSByZXN0LnNsaWNlKGF0U2lnbiArIDEpO1xuICAgICAgdGhpcy5hdXRoID0gZGVjb2RlVVJJQ29tcG9uZW50KGF1dGgpO1xuICAgIH1cblxuICAgIC8vIHRoZSBob3N0IGlzIHRoZSByZW1haW5pbmcgdG8gdGhlIGxlZnQgb2YgdGhlIGZpcnN0IG5vbi1ob3N0IGNoYXJcbiAgICBob3N0RW5kID0gLTE7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub25Ib3N0Q2hhcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoZWMgPSByZXN0LmluZGV4T2Yobm9uSG9zdENoYXJzW2ldKTtcbiAgICAgIGlmIChoZWMgIT09IC0xICYmIChob3N0RW5kID09PSAtMSB8fCBoZWMgPCBob3N0RW5kKSlcbiAgICAgICAgaG9zdEVuZCA9IGhlYztcbiAgICB9XG4gICAgLy8gaWYgd2Ugc3RpbGwgaGF2ZSBub3QgaGl0IGl0LCB0aGVuIHRoZSBlbnRpcmUgdGhpbmcgaXMgYSBob3N0LlxuICAgIGlmIChob3N0RW5kID09PSAtMSlcbiAgICAgIGhvc3RFbmQgPSByZXN0Lmxlbmd0aDtcblxuICAgIHRoaXMuaG9zdCA9IHJlc3Quc2xpY2UoMCwgaG9zdEVuZCk7XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoaG9zdEVuZCk7XG5cbiAgICAvLyBwdWxsIG91dCBwb3J0LlxuICAgIHRoaXMucGFyc2VIb3N0KCk7XG5cbiAgICAvLyB3ZSd2ZSBpbmRpY2F0ZWQgdGhhdCB0aGVyZSBpcyBhIGhvc3RuYW1lLFxuICAgIC8vIHNvIGV2ZW4gaWYgaXQncyBlbXB0eSwgaXQgaGFzIHRvIGJlIHByZXNlbnQuXG4gICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUgfHwgJyc7XG5cbiAgICAvLyBpZiBob3N0bmFtZSBiZWdpbnMgd2l0aCBbIGFuZCBlbmRzIHdpdGggXVxuICAgIC8vIGFzc3VtZSB0aGF0IGl0J3MgYW4gSVB2NiBhZGRyZXNzLlxuICAgIHZhciBpcHY2SG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lWzBdID09PSAnWycgJiZcbiAgICAgICAgdGhpcy5ob3N0bmFtZVt0aGlzLmhvc3RuYW1lLmxlbmd0aCAtIDFdID09PSAnXSc7XG5cbiAgICAvLyB2YWxpZGF0ZSBhIGxpdHRsZS5cbiAgICBpZiAoIWlwdjZIb3N0bmFtZSkge1xuICAgICAgdmFyIGhvc3RwYXJ0cyA9IHRoaXMuaG9zdG5hbWUuc3BsaXQoL1xcLi8pO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBob3N0cGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0ID0gaG9zdHBhcnRzW2ldO1xuICAgICAgICBpZiAoIXBhcnQpIGNvbnRpbnVlO1xuICAgICAgICBpZiAoIXBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICB2YXIgbmV3cGFydCA9ICcnO1xuICAgICAgICAgIGZvciAodmFyIGogPSAwLCBrID0gcGFydC5sZW5ndGg7IGogPCBrOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChwYXJ0LmNoYXJDb2RlQXQoaikgPiAxMjcpIHtcbiAgICAgICAgICAgICAgLy8gd2UgcmVwbGFjZSBub24tQVNDSUkgY2hhciB3aXRoIGEgdGVtcG9yYXJ5IHBsYWNlaG9sZGVyXG4gICAgICAgICAgICAgIC8vIHdlIG5lZWQgdGhpcyB0byBtYWtlIHN1cmUgc2l6ZSBvZiBob3N0bmFtZSBpcyBub3RcbiAgICAgICAgICAgICAgLy8gYnJva2VuIGJ5IHJlcGxhY2luZyBub24tQVNDSUkgYnkgbm90aGluZ1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9ICd4JztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIG5ld3BhcnQgKz0gcGFydFtqXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gd2UgdGVzdCBhZ2FpbiB3aXRoIEFTQ0lJIGNoYXIgb25seVxuICAgICAgICAgIGlmICghbmV3cGFydC5tYXRjaChob3N0bmFtZVBhcnRQYXR0ZXJuKSkge1xuICAgICAgICAgICAgdmFyIHZhbGlkUGFydHMgPSBob3N0cGFydHMuc2xpY2UoMCwgaSk7XG4gICAgICAgICAgICB2YXIgbm90SG9zdCA9IGhvc3RwYXJ0cy5zbGljZShpICsgMSk7XG4gICAgICAgICAgICB2YXIgYml0ID0gcGFydC5tYXRjaChob3N0bmFtZVBhcnRTdGFydCk7XG4gICAgICAgICAgICBpZiAoYml0KSB7XG4gICAgICAgICAgICAgIHZhbGlkUGFydHMucHVzaChiaXRbMV0pO1xuICAgICAgICAgICAgICBub3RIb3N0LnVuc2hpZnQoYml0WzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub3RIb3N0Lmxlbmd0aCkge1xuICAgICAgICAgICAgICByZXN0ID0gJy8nICsgbm90SG9zdC5qb2luKCcuJykgKyByZXN0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5ob3N0bmFtZSA9IHZhbGlkUGFydHMuam9pbignLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuaG9zdG5hbWUubGVuZ3RoID4gaG9zdG5hbWVNYXhMZW4pIHtcbiAgICAgIHRoaXMuaG9zdG5hbWUgPSAnJztcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaG9zdG5hbWVzIGFyZSBhbHdheXMgbG93ZXIgY2FzZS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lLnRvTG93ZXJDYXNlKCk7XG4gICAgfVxuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIC8vIElETkEgU3VwcG9ydDogUmV0dXJucyBhIHB1bnljb2RlZCByZXByZXNlbnRhdGlvbiBvZiBcImRvbWFpblwiLlxuICAgICAgLy8gSXQgb25seSBjb252ZXJ0cyBwYXJ0cyBvZiB0aGUgZG9tYWluIG5hbWUgdGhhdFxuICAgICAgLy8gaGF2ZSBub24tQVNDSUkgY2hhcmFjdGVycywgaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZlxuICAgICAgLy8geW91IGNhbGwgaXQgd2l0aCBhIGRvbWFpbiB0aGF0IGFscmVhZHkgaXMgQVNDSUktb25seS5cbiAgICAgIHRoaXMuaG9zdG5hbWUgPSBwdW55Y29kZS50b0FTQ0lJKHRoaXMuaG9zdG5hbWUpO1xuICAgIH1cblxuICAgIHZhciBwID0gdGhpcy5wb3J0ID8gJzonICsgdGhpcy5wb3J0IDogJyc7XG4gICAgdmFyIGggPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuICAgIHRoaXMuaG9zdCA9IGggKyBwO1xuICAgIHRoaXMuaHJlZiArPSB0aGlzLmhvc3Q7XG5cbiAgICAvLyBzdHJpcCBbIGFuZCBdIGZyb20gdGhlIGhvc3RuYW1lXG4gICAgLy8gdGhlIGhvc3QgZmllbGQgc3RpbGwgcmV0YWlucyB0aGVtLCB0aG91Z2hcbiAgICBpZiAoaXB2Nkhvc3RuYW1lKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS5zdWJzdHIoMSwgdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAyKTtcbiAgICAgIGlmIChyZXN0WzBdICE9PSAnLycpIHtcbiAgICAgICAgcmVzdCA9ICcvJyArIHJlc3Q7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gbm93IHJlc3QgaXMgc2V0IHRvIHRoZSBwb3N0LWhvc3Qgc3R1ZmYuXG4gIC8vIGNob3Agb2ZmIGFueSBkZWxpbSBjaGFycy5cbiAgaWYgKCF1bnNhZmVQcm90b2NvbFtsb3dlclByb3RvXSkge1xuXG4gICAgLy8gRmlyc3QsIG1ha2UgMTAwJSBzdXJlIHRoYXQgYW55IFwiYXV0b0VzY2FwZVwiIGNoYXJzIGdldFxuICAgIC8vIGVzY2FwZWQsIGV2ZW4gaWYgZW5jb2RlVVJJQ29tcG9uZW50IGRvZXNuJ3QgdGhpbmsgdGhleVxuICAgIC8vIG5lZWQgdG8gYmUuXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBhdXRvRXNjYXBlLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGFlID0gYXV0b0VzY2FwZVtpXTtcbiAgICAgIGlmIChyZXN0LmluZGV4T2YoYWUpID09PSAtMSlcbiAgICAgICAgY29udGludWU7XG4gICAgICB2YXIgZXNjID0gZW5jb2RlVVJJQ29tcG9uZW50KGFlKTtcbiAgICAgIGlmIChlc2MgPT09IGFlKSB7XG4gICAgICAgIGVzYyA9IGVzY2FwZShhZSk7XG4gICAgICB9XG4gICAgICByZXN0ID0gcmVzdC5zcGxpdChhZSkuam9pbihlc2MpO1xuICAgIH1cbiAgfVxuXG5cbiAgLy8gY2hvcCBvZmYgZnJvbSB0aGUgdGFpbCBmaXJzdC5cbiAgdmFyIGhhc2ggPSByZXN0LmluZGV4T2YoJyMnKTtcbiAgaWYgKGhhc2ggIT09IC0xKSB7XG4gICAgLy8gZ290IGEgZnJhZ21lbnQgc3RyaW5nLlxuICAgIHRoaXMuaGFzaCA9IHJlc3Quc3Vic3RyKGhhc2gpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIGhhc2gpO1xuICB9XG4gIHZhciBxbSA9IHJlc3QuaW5kZXhPZignPycpO1xuICBpZiAocW0gIT09IC0xKSB7XG4gICAgdGhpcy5zZWFyY2ggPSByZXN0LnN1YnN0cihxbSk7XG4gICAgdGhpcy5xdWVyeSA9IHJlc3Quc3Vic3RyKHFtICsgMSk7XG4gICAgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAgIHRoaXMucXVlcnkgPSBxdWVyeXN0cmluZy5wYXJzZSh0aGlzLnF1ZXJ5KTtcbiAgICB9XG4gICAgcmVzdCA9IHJlc3Quc2xpY2UoMCwgcW0pO1xuICB9IGVsc2UgaWYgKHBhcnNlUXVlcnlTdHJpbmcpIHtcbiAgICAvLyBubyBxdWVyeSBzdHJpbmcsIGJ1dCBwYXJzZVF1ZXJ5U3RyaW5nIHN0aWxsIHJlcXVlc3RlZFxuICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgdGhpcy5xdWVyeSA9IHt9O1xuICB9XG4gIGlmIChyZXN0KSB0aGlzLnBhdGhuYW1lID0gcmVzdDtcbiAgaWYgKHNsYXNoZWRQcm90b2NvbFtsb3dlclByb3RvXSAmJlxuICAgICAgdGhpcy5ob3N0bmFtZSAmJiAhdGhpcy5wYXRobmFtZSkge1xuICAgIHRoaXMucGF0aG5hbWUgPSAnLyc7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gIGlmICh0aGlzLnBhdGhuYW1lIHx8IHRoaXMuc2VhcmNoKSB7XG4gICAgdmFyIHAgPSB0aGlzLnBhdGhuYW1lIHx8ICcnO1xuICAgIHZhciBzID0gdGhpcy5zZWFyY2ggfHwgJyc7XG4gICAgdGhpcy5wYXRoID0gcCArIHM7XG4gIH1cblxuICAvLyBmaW5hbGx5LCByZWNvbnN0cnVjdCB0aGUgaHJlZiBiYXNlZCBvbiB3aGF0IGhhcyBiZWVuIHZhbGlkYXRlZC5cbiAgdGhpcy5ocmVmID0gdGhpcy5mb3JtYXQoKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBmb3JtYXQgYSBwYXJzZWQgb2JqZWN0IGludG8gYSB1cmwgc3RyaW5nXG5mdW5jdGlvbiB1cmxGb3JtYXQob2JqKSB7XG4gIC8vIGVuc3VyZSBpdCdzIGFuIG9iamVjdCwgYW5kIG5vdCBhIHN0cmluZyB1cmwuXG4gIC8vIElmIGl0J3MgYW4gb2JqLCB0aGlzIGlzIGEgbm8tb3AuXG4gIC8vIHRoaXMgd2F5LCB5b3UgY2FuIGNhbGwgdXJsX2Zvcm1hdCgpIG9uIHN0cmluZ3NcbiAgLy8gdG8gY2xlYW4gdXAgcG90ZW50aWFsbHkgd29ua3kgdXJscy5cbiAgaWYgKHV0aWwuaXNTdHJpbmcob2JqKSkgb2JqID0gdXJsUGFyc2Uob2JqKTtcbiAgaWYgKCEob2JqIGluc3RhbmNlb2YgVXJsKSkgcmV0dXJuIFVybC5wcm90b3R5cGUuZm9ybWF0LmNhbGwob2JqKTtcbiAgcmV0dXJuIG9iai5mb3JtYXQoKTtcbn1cblxuVXJsLnByb3RvdHlwZS5mb3JtYXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGF1dGggPSB0aGlzLmF1dGggfHwgJyc7XG4gIGlmIChhdXRoKSB7XG4gICAgYXV0aCA9IGVuY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICBhdXRoID0gYXV0aC5yZXBsYWNlKC8lM0EvaSwgJzonKTtcbiAgICBhdXRoICs9ICdAJztcbiAgfVxuXG4gIHZhciBwcm90b2NvbCA9IHRoaXMucHJvdG9jb2wgfHwgJycsXG4gICAgICBwYXRobmFtZSA9IHRoaXMucGF0aG5hbWUgfHwgJycsXG4gICAgICBoYXNoID0gdGhpcy5oYXNoIHx8ICcnLFxuICAgICAgaG9zdCA9IGZhbHNlLFxuICAgICAgcXVlcnkgPSAnJztcblxuICBpZiAodGhpcy5ob3N0KSB7XG4gICAgaG9zdCA9IGF1dGggKyB0aGlzLmhvc3Q7XG4gIH0gZWxzZSBpZiAodGhpcy5ob3N0bmFtZSkge1xuICAgIGhvc3QgPSBhdXRoICsgKHRoaXMuaG9zdG5hbWUuaW5kZXhPZignOicpID09PSAtMSA/XG4gICAgICAgIHRoaXMuaG9zdG5hbWUgOlxuICAgICAgICAnWycgKyB0aGlzLmhvc3RuYW1lICsgJ10nKTtcbiAgICBpZiAodGhpcy5wb3J0KSB7XG4gICAgICBob3N0ICs9ICc6JyArIHRoaXMucG9ydDtcbiAgICB9XG4gIH1cblxuICBpZiAodGhpcy5xdWVyeSAmJlxuICAgICAgdXRpbC5pc09iamVjdCh0aGlzLnF1ZXJ5KSAmJlxuICAgICAgT2JqZWN0LmtleXModGhpcy5xdWVyeSkubGVuZ3RoKSB7XG4gICAgcXVlcnkgPSBxdWVyeXN0cmluZy5zdHJpbmdpZnkodGhpcy5xdWVyeSk7XG4gIH1cblxuICB2YXIgc2VhcmNoID0gdGhpcy5zZWFyY2ggfHwgKHF1ZXJ5ICYmICgnPycgKyBxdWVyeSkpIHx8ICcnO1xuXG4gIGlmIChwcm90b2NvbCAmJiBwcm90b2NvbC5zdWJzdHIoLTEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICAvLyBvbmx5IHRoZSBzbGFzaGVkUHJvdG9jb2xzIGdldCB0aGUgLy8uICBOb3QgbWFpbHRvOiwgeG1wcDosIGV0Yy5cbiAgLy8gdW5sZXNzIHRoZXkgaGFkIHRoZW0gdG8gYmVnaW4gd2l0aC5cbiAgaWYgKHRoaXMuc2xhc2hlcyB8fFxuICAgICAgKCFwcm90b2NvbCB8fCBzbGFzaGVkUHJvdG9jb2xbcHJvdG9jb2xdKSAmJiBob3N0ICE9PSBmYWxzZSkge1xuICAgIGhvc3QgPSAnLy8nICsgKGhvc3QgfHwgJycpO1xuICAgIGlmIChwYXRobmFtZSAmJiBwYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJykgcGF0aG5hbWUgPSAnLycgKyBwYXRobmFtZTtcbiAgfSBlbHNlIGlmICghaG9zdCkge1xuICAgIGhvc3QgPSAnJztcbiAgfVxuXG4gIGlmIChoYXNoICYmIGhhc2guY2hhckF0KDApICE9PSAnIycpIGhhc2ggPSAnIycgKyBoYXNoO1xuICBpZiAoc2VhcmNoICYmIHNlYXJjaC5jaGFyQXQoMCkgIT09ICc/Jykgc2VhcmNoID0gJz8nICsgc2VhcmNoO1xuXG4gIHBhdGhuYW1lID0gcGF0aG5hbWUucmVwbGFjZSgvWz8jXS9nLCBmdW5jdGlvbihtYXRjaCkge1xuICAgIHJldHVybiBlbmNvZGVVUklDb21wb25lbnQobWF0Y2gpO1xuICB9KTtcbiAgc2VhcmNoID0gc2VhcmNoLnJlcGxhY2UoJyMnLCAnJTIzJyk7XG5cbiAgcmV0dXJuIHByb3RvY29sICsgaG9zdCArIHBhdGhuYW1lICsgc2VhcmNoICsgaGFzaDtcbn07XG5cbmZ1bmN0aW9uIHVybFJlc29sdmUoc291cmNlLCByZWxhdGl2ZSkge1xuICByZXR1cm4gdXJsUGFyc2Uoc291cmNlLCBmYWxzZSwgdHJ1ZSkucmVzb2x2ZShyZWxhdGl2ZSk7XG59XG5cblVybC5wcm90b3R5cGUucmVzb2x2ZSA9IGZ1bmN0aW9uKHJlbGF0aXZlKSB7XG4gIHJldHVybiB0aGlzLnJlc29sdmVPYmplY3QodXJsUGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKSkuZm9ybWF0KCk7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlT2JqZWN0KHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgaWYgKCFzb3VyY2UpIHJldHVybiByZWxhdGl2ZTtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmVPYmplY3QocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmVPYmplY3QgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICBpZiAodXRpbC5pc1N0cmluZyhyZWxhdGl2ZSkpIHtcbiAgICB2YXIgcmVsID0gbmV3IFVybCgpO1xuICAgIHJlbC5wYXJzZShyZWxhdGl2ZSwgZmFsc2UsIHRydWUpO1xuICAgIHJlbGF0aXZlID0gcmVsO1xuICB9XG5cbiAgdmFyIHJlc3VsdCA9IG5ldyBVcmwoKTtcbiAgdmFyIHRrZXlzID0gT2JqZWN0LmtleXModGhpcyk7XG4gIGZvciAodmFyIHRrID0gMDsgdGsgPCB0a2V5cy5sZW5ndGg7IHRrKyspIHtcbiAgICB2YXIgdGtleSA9IHRrZXlzW3RrXTtcbiAgICByZXN1bHRbdGtleV0gPSB0aGlzW3RrZXldO1xuICB9XG5cbiAgLy8gaGFzaCBpcyBhbHdheXMgb3ZlcnJpZGRlbiwgbm8gbWF0dGVyIHdoYXQuXG4gIC8vIGV2ZW4gaHJlZj1cIlwiIHdpbGwgcmVtb3ZlIGl0LlxuICByZXN1bHQuaGFzaCA9IHJlbGF0aXZlLmhhc2g7XG5cbiAgLy8gaWYgdGhlIHJlbGF0aXZlIHVybCBpcyBlbXB0eSwgdGhlbiB0aGVyZSdzIG5vdGhpbmcgbGVmdCB0byBkbyBoZXJlLlxuICBpZiAocmVsYXRpdmUuaHJlZiA9PT0gJycpIHtcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLy8gaHJlZnMgbGlrZSAvL2Zvby9iYXIgYWx3YXlzIGN1dCB0byB0aGUgcHJvdG9jb2wuXG4gIGlmIChyZWxhdGl2ZS5zbGFzaGVzICYmICFyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgIC8vIHRha2UgZXZlcnl0aGluZyBleGNlcHQgdGhlIHByb3RvY29sIGZyb20gcmVsYXRpdmVcbiAgICB2YXIgcmtleXMgPSBPYmplY3Qua2V5cyhyZWxhdGl2ZSk7XG4gICAgZm9yICh2YXIgcmsgPSAwOyByayA8IHJrZXlzLmxlbmd0aDsgcmsrKykge1xuICAgICAgdmFyIHJrZXkgPSBya2V5c1tya107XG4gICAgICBpZiAocmtleSAhPT0gJ3Byb3RvY29sJylcbiAgICAgICAgcmVzdWx0W3JrZXldID0gcmVsYXRpdmVbcmtleV07XG4gICAgfVxuXG4gICAgLy91cmxQYXJzZSBhcHBlbmRzIHRyYWlsaW5nIC8gdG8gdXJscyBsaWtlIGh0dHA6Ly93d3cuZXhhbXBsZS5jb21cbiAgICBpZiAoc2xhc2hlZFByb3RvY29sW3Jlc3VsdC5wcm90b2NvbF0gJiZcbiAgICAgICAgcmVzdWx0Lmhvc3RuYW1lICYmICFyZXN1bHQucGF0aG5hbWUpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gcmVzdWx0LnBhdGhuYW1lID0gJy8nO1xuICAgIH1cblxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICBpZiAocmVsYXRpdmUucHJvdG9jb2wgJiYgcmVsYXRpdmUucHJvdG9jb2wgIT09IHJlc3VsdC5wcm90b2NvbCkge1xuICAgIC8vIGlmIGl0J3MgYSBrbm93biB1cmwgcHJvdG9jb2wsIHRoZW4gY2hhbmdpbmdcbiAgICAvLyB0aGUgcHJvdG9jb2wgZG9lcyB3ZWlyZCB0aGluZ3NcbiAgICAvLyBmaXJzdCwgaWYgaXQncyBub3QgZmlsZTosIHRoZW4gd2UgTVVTVCBoYXZlIGEgaG9zdCxcbiAgICAvLyBhbmQgaWYgdGhlcmUgd2FzIGEgcGF0aFxuICAgIC8vIHRvIGJlZ2luIHdpdGgsIHRoZW4gd2UgTVVTVCBoYXZlIGEgcGF0aC5cbiAgICAvLyBpZiBpdCBpcyBmaWxlOiwgdGhlbiB0aGUgaG9zdCBpcyBkcm9wcGVkLFxuICAgIC8vIGJlY2F1c2UgdGhhdCdzIGtub3duIHRvIGJlIGhvc3RsZXNzLlxuICAgIC8vIGFueXRoaW5nIGVsc2UgaXMgYXNzdW1lZCB0byBiZSBhYnNvbHV0ZS5cbiAgICBpZiAoIXNsYXNoZWRQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgICAgZm9yICh2YXIgdiA9IDA7IHYgPCBrZXlzLmxlbmd0aDsgdisrKSB7XG4gICAgICAgIHZhciBrID0ga2V5c1t2XTtcbiAgICAgICAgcmVzdWx0W2tdID0gcmVsYXRpdmVba107XG4gICAgICB9XG4gICAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgcmVzdWx0LnByb3RvY29sID0gcmVsYXRpdmUucHJvdG9jb2w7XG4gICAgaWYgKCFyZWxhdGl2ZS5ob3N0ICYmICFob3N0bGVzc1Byb3RvY29sW3JlbGF0aXZlLnByb3RvY29sXSkge1xuICAgICAgdmFyIHJlbFBhdGggPSAocmVsYXRpdmUucGF0aG5hbWUgfHwgJycpLnNwbGl0KCcvJyk7XG4gICAgICB3aGlsZSAocmVsUGF0aC5sZW5ndGggJiYgIShyZWxhdGl2ZS5ob3N0ID0gcmVsUGF0aC5zaGlmdCgpKSk7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3QpIHJlbGF0aXZlLmhvc3QgPSAnJztcbiAgICAgIGlmICghcmVsYXRpdmUuaG9zdG5hbWUpIHJlbGF0aXZlLmhvc3RuYW1lID0gJyc7XG4gICAgICBpZiAocmVsUGF0aFswXSAhPT0gJycpIHJlbFBhdGgudW5zaGlmdCgnJyk7XG4gICAgICBpZiAocmVsUGF0aC5sZW5ndGggPCAyKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgcmVzdWx0LnBhdGhuYW1lID0gcmVsUGF0aC5qb2luKCcvJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbGF0aXZlLnBhdGhuYW1lO1xuICAgIH1cbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICAgIHJlc3VsdC5ob3N0ID0gcmVsYXRpdmUuaG9zdCB8fCAnJztcbiAgICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGg7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdDtcbiAgICByZXN1bHQucG9ydCA9IHJlbGF0aXZlLnBvcnQ7XG4gICAgLy8gdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnBhdGhuYW1lIHx8IHJlc3VsdC5zZWFyY2gpIHtcbiAgICAgIHZhciBwID0gcmVzdWx0LnBhdGhuYW1lIHx8ICcnO1xuICAgICAgdmFyIHMgPSByZXN1bHQuc2VhcmNoIHx8ICcnO1xuICAgICAgcmVzdWx0LnBhdGggPSBwICsgcztcbiAgICB9XG4gICAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICB2YXIgaXNTb3VyY2VBYnMgPSAocmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJyksXG4gICAgICBpc1JlbEFicyA9IChcbiAgICAgICAgICByZWxhdGl2ZS5ob3N0IHx8XG4gICAgICAgICAgcmVsYXRpdmUucGF0aG5hbWUgJiYgcmVsYXRpdmUucGF0aG5hbWUuY2hhckF0KDApID09PSAnLydcbiAgICAgICksXG4gICAgICBtdXN0RW5kQWJzID0gKGlzUmVsQWJzIHx8IGlzU291cmNlQWJzIHx8XG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuaG9zdCAmJiByZWxhdGl2ZS5wYXRobmFtZSkpLFxuICAgICAgcmVtb3ZlQWxsRG90cyA9IG11c3RFbmRBYnMsXG4gICAgICBzcmNQYXRoID0gcmVzdWx0LnBhdGhuYW1lICYmIHJlc3VsdC5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcmVsUGF0aCA9IHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLnNwbGl0KCcvJykgfHwgW10sXG4gICAgICBwc3ljaG90aWMgPSByZXN1bHQucHJvdG9jb2wgJiYgIXNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdO1xuXG4gIC8vIGlmIHRoZSB1cmwgaXMgYSBub24tc2xhc2hlZCB1cmwsIHRoZW4gcmVsYXRpdmVcbiAgLy8gbGlua3MgbGlrZSAuLi8uLiBzaG91bGQgYmUgYWJsZVxuICAvLyB0byBjcmF3bCB1cCB0byB0aGUgaG9zdG5hbWUsIGFzIHdlbGwuICBUaGlzIGlzIHN0cmFuZ2UuXG4gIC8vIHJlc3VsdC5wcm90b2NvbCBoYXMgYWxyZWFkeSBiZWVuIHNldCBieSBub3cuXG4gIC8vIExhdGVyIG9uLCBwdXQgdGhlIGZpcnN0IHBhdGggcGFydCBpbnRvIHRoZSBob3N0IGZpZWxkLlxuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gJyc7XG4gICAgcmVzdWx0LnBvcnQgPSBudWxsO1xuICAgIGlmIChyZXN1bHQuaG9zdCkge1xuICAgICAgaWYgKHNyY1BhdGhbMF0gPT09ICcnKSBzcmNQYXRoWzBdID0gcmVzdWx0Lmhvc3Q7XG4gICAgICBlbHNlIHNyY1BhdGgudW5zaGlmdChyZXN1bHQuaG9zdCk7XG4gICAgfVxuICAgIHJlc3VsdC5ob3N0ID0gJyc7XG4gICAgaWYgKHJlbGF0aXZlLnByb3RvY29sKSB7XG4gICAgICByZWxhdGl2ZS5ob3N0bmFtZSA9IG51bGw7XG4gICAgICByZWxhdGl2ZS5wb3J0ID0gbnVsbDtcbiAgICAgIGlmIChyZWxhdGl2ZS5ob3N0KSB7XG4gICAgICAgIGlmIChyZWxQYXRoWzBdID09PSAnJykgcmVsUGF0aFswXSA9IHJlbGF0aXZlLmhvc3Q7XG4gICAgICAgIGVsc2UgcmVsUGF0aC51bnNoaWZ0KHJlbGF0aXZlLmhvc3QpO1xuICAgICAgfVxuICAgICAgcmVsYXRpdmUuaG9zdCA9IG51bGw7XG4gICAgfVxuICAgIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzICYmIChyZWxQYXRoWzBdID09PSAnJyB8fCBzcmNQYXRoWzBdID09PSAnJyk7XG4gIH1cblxuICBpZiAoaXNSZWxBYnMpIHtcbiAgICAvLyBpdCdzIGFic29sdXRlLlxuICAgIHJlc3VsdC5ob3N0ID0gKHJlbGF0aXZlLmhvc3QgfHwgcmVsYXRpdmUuaG9zdCA9PT0gJycpID9cbiAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3QgOiByZXN1bHQuaG9zdDtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSAocmVsYXRpdmUuaG9zdG5hbWUgfHwgcmVsYXRpdmUuaG9zdG5hbWUgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgOiByZXN1bHQuaG9zdG5hbWU7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICBzcmNQYXRoID0gcmVsUGF0aDtcbiAgICAvLyBmYWxsIHRocm91Z2ggdG8gdGhlIGRvdC1oYW5kbGluZyBiZWxvdy5cbiAgfSBlbHNlIGlmIChyZWxQYXRoLmxlbmd0aCkge1xuICAgIC8vIGl0J3MgcmVsYXRpdmVcbiAgICAvLyB0aHJvdyBhd2F5IHRoZSBleGlzdGluZyBmaWxlLCBhbmQgdGFrZSB0aGUgbmV3IHBhdGggaW5zdGVhZC5cbiAgICBpZiAoIXNyY1BhdGgpIHNyY1BhdGggPSBbXTtcbiAgICBzcmNQYXRoLnBvcCgpO1xuICAgIHNyY1BhdGggPSBzcmNQYXRoLmNvbmNhdChyZWxQYXRoKTtcbiAgICByZXN1bHQuc2VhcmNoID0gcmVsYXRpdmUuc2VhcmNoO1xuICAgIHJlc3VsdC5xdWVyeSA9IHJlbGF0aXZlLnF1ZXJ5O1xuICB9IGVsc2UgaWYgKCF1dGlsLmlzTnVsbE9yVW5kZWZpbmVkKHJlbGF0aXZlLnNlYXJjaCkpIHtcbiAgICAvLyBqdXN0IHB1bGwgb3V0IHRoZSBzZWFyY2guXG4gICAgLy8gbGlrZSBocmVmPSc/Zm9vJy5cbiAgICAvLyBQdXQgdGhpcyBhZnRlciB0aGUgb3RoZXIgdHdvIGNhc2VzIGJlY2F1c2UgaXQgc2ltcGxpZmllcyB0aGUgYm9vbGVhbnNcbiAgICBpZiAocHN5Y2hvdGljKSB7XG4gICAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IHNyY1BhdGguc2hpZnQoKTtcbiAgICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAgIC8vdGhpcyBlc3BlY2lhbGx5IGhhcHBlbnMgaW4gY2FzZXMgbGlrZVxuICAgICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5ob3N0LnNwbGl0KCdAJykgOiBmYWxzZTtcbiAgICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgICByZXN1bHQuaG9zdCA9IHJlc3VsdC5ob3N0bmFtZSA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICAvL3RvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKCF1dGlsLmlzTnVsbChyZXN1bHQucGF0aG5hbWUpIHx8ICF1dGlsLmlzTnVsbChyZXN1bHQuc2VhcmNoKSkge1xuICAgICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICAgIH1cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIC8vIG5vIHBhdGggYXQgYWxsLiAgZWFzeS5cbiAgICAvLyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQgdGhlIG90aGVyIHN0dWZmIGFib3ZlLlxuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmIChyZXN1bHQuc2VhcmNoKSB7XG4gICAgICByZXN1bHQucGF0aCA9ICcvJyArIHJlc3VsdC5zZWFyY2g7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gbnVsbDtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGlmIGEgdXJsIEVORHMgaW4gLiBvciAuLiwgdGhlbiBpdCBtdXN0IGdldCBhIHRyYWlsaW5nIHNsYXNoLlxuICAvLyBob3dldmVyLCBpZiBpdCBlbmRzIGluIGFueXRoaW5nIGVsc2Ugbm9uLXNsYXNoeSxcbiAgLy8gdGhlbiBpdCBtdXN0IE5PVCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgdmFyIGxhc3QgPSBzcmNQYXRoLnNsaWNlKC0xKVswXTtcbiAgdmFyIGhhc1RyYWlsaW5nU2xhc2ggPSAoXG4gICAgICAocmVzdWx0Lmhvc3QgfHwgcmVsYXRpdmUuaG9zdCB8fCBzcmNQYXRoLmxlbmd0aCA+IDEpICYmXG4gICAgICAobGFzdCA9PT0gJy4nIHx8IGxhc3QgPT09ICcuLicpIHx8IGxhc3QgPT09ICcnKTtcblxuICAvLyBzdHJpcCBzaW5nbGUgZG90cywgcmVzb2x2ZSBkb3VibGUgZG90cyB0byBwYXJlbnQgZGlyXG4gIC8vIGlmIHRoZSBwYXRoIHRyaWVzIHRvIGdvIGFib3ZlIHRoZSByb290LCBgdXBgIGVuZHMgdXAgPiAwXG4gIHZhciB1cCA9IDA7XG4gIGZvciAodmFyIGkgPSBzcmNQYXRoLmxlbmd0aDsgaSA+PSAwOyBpLS0pIHtcbiAgICBsYXN0ID0gc3JjUGF0aFtpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHNyY1BhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXArKztcbiAgICB9IGVsc2UgaWYgKHVwKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoIW11c3RFbmRBYnMgJiYgIXJlbW92ZUFsbERvdHMpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHNyY1BhdGgudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICBpZiAobXVzdEVuZEFicyAmJiBzcmNQYXRoWzBdICE9PSAnJyAmJlxuICAgICAgKCFzcmNQYXRoWzBdIHx8IHNyY1BhdGhbMF0uY2hhckF0KDApICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC51bnNoaWZ0KCcnKTtcbiAgfVxuXG4gIGlmIChoYXNUcmFpbGluZ1NsYXNoICYmIChzcmNQYXRoLmpvaW4oJy8nKS5zdWJzdHIoLTEpICE9PSAnLycpKSB7XG4gICAgc3JjUGF0aC5wdXNoKCcnKTtcbiAgfVxuXG4gIHZhciBpc0Fic29sdXRlID0gc3JjUGF0aFswXSA9PT0gJycgfHxcbiAgICAgIChzcmNQYXRoWzBdICYmIHNyY1BhdGhbMF0uY2hhckF0KDApID09PSAnLycpO1xuXG4gIC8vIHB1dCB0aGUgaG9zdCBiYWNrXG4gIGlmIChwc3ljaG90aWMpIHtcbiAgICByZXN1bHQuaG9zdG5hbWUgPSByZXN1bHQuaG9zdCA9IGlzQWJzb2x1dGUgPyAnJyA6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcmNQYXRoLmxlbmd0aCA/IHNyY1BhdGguc2hpZnQoKSA6ICcnO1xuICAgIC8vb2NjYXRpb25hbHkgdGhlIGF1dGggY2FuIGdldCBzdHVjayBvbmx5IGluIGhvc3RcbiAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAvL3VybC5yZXNvbHZlT2JqZWN0KCdtYWlsdG86bG9jYWwxQGRvbWFpbjEnLCAnbG9jYWwyQGRvbWFpbjInKVxuICAgIHZhciBhdXRoSW5Ib3N0ID0gcmVzdWx0Lmhvc3QgJiYgcmVzdWx0Lmhvc3QuaW5kZXhPZignQCcpID4gMCA/XG4gICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgaWYgKGF1dGhJbkhvc3QpIHtcbiAgICAgIHJlc3VsdC5hdXRoID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgfVxuICB9XG5cbiAgbXVzdEVuZEFicyA9IG11c3RFbmRBYnMgfHwgKHJlc3VsdC5ob3N0ICYmIHNyY1BhdGgubGVuZ3RoKTtcblxuICBpZiAobXVzdEVuZEFicyAmJiAhaXNBYnNvbHV0ZSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoIXNyY1BhdGgubGVuZ3RoKSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gbnVsbDtcbiAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgcmVzdWx0LnBhdGhuYW1lID0gc3JjUGF0aC5qb2luKCcvJyk7XG4gIH1cblxuICAvL3RvIHN1cHBvcnQgcmVxdWVzdC5odHRwXG4gIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICByZXN1bHQucGF0aCA9IChyZXN1bHQucGF0aG5hbWUgPyByZXN1bHQucGF0aG5hbWUgOiAnJykgK1xuICAgICAgICAgICAgICAgICAgKHJlc3VsdC5zZWFyY2ggPyByZXN1bHQuc2VhcmNoIDogJycpO1xuICB9XG4gIHJlc3VsdC5hdXRoID0gcmVsYXRpdmUuYXV0aCB8fCByZXN1bHQuYXV0aDtcbiAgcmVzdWx0LnNsYXNoZXMgPSByZXN1bHQuc2xhc2hlcyB8fCByZWxhdGl2ZS5zbGFzaGVzO1xuICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgcmV0dXJuIHJlc3VsdDtcbn07XG5cblVybC5wcm90b3R5cGUucGFyc2VIb3N0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBob3N0ID0gdGhpcy5ob3N0O1xuICB2YXIgcG9ydCA9IHBvcnRQYXR0ZXJuLmV4ZWMoaG9zdCk7XG4gIGlmIChwb3J0KSB7XG4gICAgcG9ydCA9IHBvcnRbMF07XG4gICAgaWYgKHBvcnQgIT09ICc6Jykge1xuICAgICAgdGhpcy5wb3J0ID0gcG9ydC5zdWJzdHIoMSk7XG4gICAgfVxuICAgIGhvc3QgPSBob3N0LnN1YnN0cigwLCBob3N0Lmxlbmd0aCAtIHBvcnQubGVuZ3RoKTtcbiAgfVxuICBpZiAoaG9zdCkgdGhpcy5ob3N0bmFtZSA9IGhvc3Q7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgaXNTdHJpbmc6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB0eXBlb2YoYXJnKSA9PT0gJ3N0cmluZyc7XG4gIH0sXG4gIGlzT2JqZWN0OiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsO1xuICB9LFxuICBpc051bGxPclVuZGVmaW5lZDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PSBudWxsO1xuICB9XG59O1xuIiwiXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZGVwcmVjYXRlO1xuXG4vKipcbiAqIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2Uubm9EZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudGhyb3dEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCB0aHJvdyBhbiBFcnJvciB3aGVuIGludm9rZWQuXG4gKlxuICogSWYgYGxvY2FsU3RvcmFnZS50cmFjZURlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGRlcHJlY2F0ZWQgZnVuY3Rpb25zXG4gKiB3aWxsIGludm9rZSBgY29uc29sZS50cmFjZSgpYCBpbnN0ZWFkIG9mIGBjb25zb2xlLmVycm9yKClgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIC0gdGhlIGZ1bmN0aW9uIHRvIGRlcHJlY2F0ZVxuICogQHBhcmFtIHtTdHJpbmd9IG1zZyAtIHRoZSBzdHJpbmcgdG8gcHJpbnQgdG8gdGhlIGNvbnNvbGUgd2hlbiBgZm5gIGlzIGludm9rZWRcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXCJkZXByZWNhdGVkXCIgdmVyc2lvbiBvZiBgZm5gXG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbmZ1bmN0aW9uIGRlcHJlY2F0ZSAoZm4sIG1zZykge1xuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcbiAgICByZXR1cm4gZm47XG4gIH1cblxuICB2YXIgd2FybmVkID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGRlcHJlY2F0ZWQoKSB7XG4gICAgaWYgKCF3YXJuZWQpIHtcbiAgICAgIGlmIChjb25maWcoJ3Rocm93RGVwcmVjYXRpb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgY29uc29sZS50cmFjZShtc2cpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XG4gICAgICB9XG4gICAgICB3YXJuZWQgPSB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgfVxuXG4gIHJldHVybiBkZXByZWNhdGVkO1xufVxuXG4vKipcbiAqIENoZWNrcyBgbG9jYWxTdG9yYWdlYCBmb3IgYm9vbGVhbiB2YWx1ZXMgZm9yIHRoZSBnaXZlbiBgbmFtZWAuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XG4gIC8vIGFjY2Vzc2luZyBnbG9iYWwubG9jYWxTdG9yYWdlIGNhbiB0cmlnZ2VyIGEgRE9NRXhjZXB0aW9uIGluIHNhbmRib3hlZCBpZnJhbWVzXG4gIHRyeSB7XG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XG4gIH0gY2F0Y2ggKF8pIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHZhbCA9IGdsb2JhbC5sb2NhbFN0b3JhZ2VbbmFtZV07XG4gIGlmIChudWxsID09IHZhbCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xufVxuIl19
