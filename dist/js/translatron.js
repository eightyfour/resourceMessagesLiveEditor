(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var C = {
    FILE_MANAGER: {
        FILE_TYPES: {
            IMAGE: 'image',
            FILE: 'file'
        },
        ENCODING: {
            image: 'base64',
            file: 'utf8'
        }
    },
    SESSION: {
        renewal_interval_in_ms: 1000 * 15
    }
};

module.exports = C;

},{}],2:[function(require,module,exports){
'use strict';

/**
 * TODO fade out when maxLengthOfMessages exceeded looks not so nice
 * @param id
 * @return {Object}
 * @constructor
 */
var toast = new function Toast(id) {
    var DELAY = 4000,
        opacityFadeSteps = 0.04,
        maxLengthOfMessages = 4,
        toastNode = document.getElementById(id),
        isReadyForStartAgain = true,
        newMessage = true,
        initToast = function initToast() {
        var rootNode = document.getElementsByTagName('body')[0];
        toastNode = document.createElement('div');
        toastNode.id = id;
        toastNode.style.cssText = "position:fixed;z-index:999;top:4.5em;right:2em;border-radius:5px;color:#fff;font-size:1.2em;font-weight:bold;background-color:rgba(63,143,251,0.9);padding: 1em 0.5em; box-sizing: border-box; max-width: 50%; text-align: center; word-wrap: break-word; break-word: break-all;";
        rootNode.appendChild(toastNode);
    },
        toast = {
        fadeOut: function fadeOut(_node, _done) {
            var node = _node;
            var done = _done;
            var opacity = 1;
            (function decrementOpacity() {
                if (opacity > opacityFadeSteps) {
                    opacity = opacity - opacityFadeSteps;
                    node.style.opacity = opacity;
                    setTimeout(function () {
                        decrementOpacity();
                    }, 40);
                } else {
                    console.log('PARENT NODE:');
                    console.log(node);
                    console.log(node.parentNode);
                    if (node.parentNode != null) {
                        node.parentNode.removeChild(node);
                    }
                    done();
                }
            })();
        },
        showMessage: function showMessage(msg) {
            if (!toastNode) {
                initToast();
            }
            toastNode.style.opacity = 1;
            var p = document.createElement('p');
            p.style.cssText = "padding:0px 10px";
            p.innerHTML = msg;
            toastNode.insertBefore(p, toastNode.firstChild);
            (function fadeOutToMuchMessages() {
                if (toastNode.childNodes.length > maxLengthOfMessages) {
                    toast.fadeOut(toastNode.children[toastNode.children.length - 1], function () {
                        fadeOutToMuchMessages();
                    });
                }
            })();
            var timeOut = DELAY;
            newMessage = true;
            function fadeOut(_fc) {
                var fc = _fc;
                var opacity = toastNode.style.opacity;
                if (opacity > opacityFadeSteps) {
                    if (newMessage) {
                        // resetMessage
                        newMessage = false;
                        timeOut = DELAY;
                        toastNode.style.opacity = 1;
                    } else {
                        opacity = opacity - opacityFadeSteps;
                        toastNode.style.opacity = opacity;
                        timeOut = 40;
                    }
                    // start timer
                    setTimeout(function () {
                        fadeOut(fc);
                    }, timeOut);
                } else {
                    while (toastNode.firstChild) {
                        toastNode.removeChild(toastNode.firstChild);
                    }
                    toastNode.style.opacity = 0;
                    // callback
                    fc(true);
                }
            }
            if (isReadyForStartAgain) {
                isReadyForStartAgain = false;
                timeOut = DELAY;
                fadeOut(function (_b) {
                    isReadyForStartAgain = true;
                });
            }
        }
    };
    return toast;
}('toast');

if (typeof module != "undefined") {
    console.log('exports');
    module.exports = toast;
} else {
    console.log('asign to global scope');
    window.toast = toast;
}

},{}],3:[function(require,module,exports){
'use strict';

/**
 * controller for the image uplaoder view - calls the server to upload a image and notifier the ui event handler
 * @type {{}}
 */
var canny = require('canny'),
    JMBFUploader = canny.JMBFUploader,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;
/**
 * Call this for each file - will call a call back with the server answer
 * @param file
 */
function sendFile(file, directCallback) {
    var uri = '/uploadJMBFFile?projectId=' + projectInfo.id + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        var data;
        if (xhr.readyState == 4 && xhr.status == 200) {
            // Handle response.
            data = JSON.parse(xhr.responseText);
            directCallback && directCallback(data); // handle response.
            // {file: "//sub/sub1/sub1_blue_coke.jpg", name: "sub1_blue_coke.jpg", type: "image/jpg"}
            console.log(data);
            uiEvents.callUievent('JMBFFileUploaded', projectInfo.id, uploadId, data.name);
        } else if (xhr.readyState == 4 && xhr.status === 406) {
            toast.showMessage('Upload failure. The file language is not supported');
        }
    };
    fd.append('myFile', file);
    // Initiate a multipart/form-data upload
    xhr.send(fd);
}

/**
 * Save data in member variable used by further upload operations
 * @param data: Project data
 */
function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showJMBFUploader: function showJMBFUploader(id) {
        displayManager.show('JMBFUploaderView');
    }
});

JMBFUploader.onUpload(function (file) {
    // TODO additional to the upload id we need the project ID
    console.log('uploadController:upload id: file:', uploadId, file);
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":21,"canny":50}],4:[function(require,module,exports){
'use strict';

var canny = require('canny'),
    JsonImport = canny.JsonImport,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;

function sendFile(file) {
    var uri = '/importJSON?projectId=' + projectInfo.id + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        if (xhr.readyState == 4) {
            var data = JSON.parse(xhr.responseText);
            if (xhr.status == 200) {
                // data.name does not exist - and is also not used, is it ?
                uiEvents.callUievent('jsonImported', projectInfo.id, uploadId, data.name);
            } else if (xhr.status === 406) {
                toast.showMessage('Upload failure. There is an error:<br />' + data.msg);
            }
        }
    };
    fd.append('myFile', file);
    xhr.send(fd);
}

function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showJSONImport: function showJSONImport(id) {
        displayManager.show('JSONImportView');
    }
});

JsonImport.onUpload(function (file) {
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":21,"canny":50}],5:[function(require,module,exports){
'use strict';

var async = require('canny/mod/async'),
    auth = require('canny').auth;

auth.onLogout(function () {
    async.doAjax({
        path: '/logout',
        onSuccess: function onSuccess(response) {
            location.reload();
        }
    });
});

module.exports = {};

},{"canny":50,"canny/mod/async":51}],6:[function(require,module,exports){
'use strict';

var breadcrumb = require('../uiModules/breadcrumb'),
    canny = require('canny'),
    trade = require('../trade'),
    uiEvents = require('../uiEventManager');

canny.add('breadcrumb', breadcrumb);

breadcrumb.onClick(function (directoryId) {
    trade.getDirectory(directoryId, function (err) {
        if (err !== false) {
            // TODO call the
            uiEvents.callUievent('showOverviewPage');
        } else {
            console.log('breadcrumbController:getDirectory can not load project for directory name:', directoryId);
        }
    });
});

module.exports = {
    setPath: function setPath(url) {
        var path = '/';
        if (url === '/') return breadcrumb.updateFolders([{ id: '/', name: '' }]);

        breadcrumb.updateFolders(url.split('/').map(function (folder) {
            path = path[path.length - 1] !== '/' ? path + '/' + folder : path + folder;
            return {
                id: path, name: folder
            };
        }));
    },
    getDirectory: function getDirectory(data) {
        console.log('breadcrumbController:parentDirectories', data.parentDirectories);
        breadcrumb.updateFolders(data.parentDirectories);
    }
};

},{"../trade":20,"../uiEventManager":21,"../uiModules/breadcrumb":26,"canny":50}],7:[function(require,module,exports){
'use strict';

var createNewProject = require('canny').createNewProject,
    displayManager = require('canny').displayManager,
    trade = require('../trade');

var currentDirectory;

createNewProject.onCreateNewProject(function (projectName) {
    trade.createNewProject(projectName, currentDirectory);
    displayManager.hide('createNewProjectView');
});

createNewProject.onCreateNewDirectoy(function (directoryName) {
    trade.createNewDirectory(directoryName, currentDirectory);
    displayManager.hide('createNewDirectoryView');
});

module.exports = {
    // TODO introduce new event: onDirectoryChanged - because a "getDirectory" event does not really explain what's
    // happening here
    getDirectory: function getDirectory(data) {
        currentDirectory = data.currentDirectory;
    }
};

},{"../trade":20,"canny":50}],8:[function(require,module,exports){
'use strict';

var anchorMenu = require('canny').anchorMenu,
    translationViewConfig = require('../uiModules/translationView').config,
    uiEvents = require('../uiEventManager');

/**
 * Nice approach but the order is different from the DOM.
 * TODO It would be better to read the elements from the DOM
 *  1. it's easier to reinitialize if a key is renamed or created new (Y)
 *  2. the order will be same as in the DOM (Y)
 *  con: we need to wait until the DOM is rendered - otherwise elements will be missing
 *
 *  We need:
 *  * DOM render success event (the translationView controller has to throw it) (so far the controller is added after the translationController it looks like that this is not an issue)
 *  * an a if anchor is clicked (in view) event ; then also focus the correct menu right element
 *  * the right menu element interact only as scroll overview - not as anchor helper as it is right now
 *
 * @param keys
 */

anchorMenu.onSelect(function (id) {
    var dom = document.getElementById(translationViewConfig.rowPrefix + id);
    if (dom) {
        var bodyRect = document.body.getBoundingClientRect(),
            elemRect = dom.getBoundingClientRect(),
            offset = elemRect.top - bodyRect.top;
        window.scrollTo(0, offset - 60);
        uiEvents.callUievent('anchorFocus', '#' + id);
    }
});

uiEvents.addUiEventListener({
    anchorFocus: function anchorFocus(id) {
        anchorMenu.focusElement(id.replace('#', ''));
    }
});

module.exports = {
    renameCategory: function renameCategory(oldName, newName) {
        anchorMenu.renderMenu();
    },
    removeCategory: function removeCategory(categoryName) {
        anchorMenu.renderMenu();
    },
    renameKey: function renameKey(oldKey, newKey) {
        anchorMenu.renderMenu();
    },
    removeKey: function removeKey(key) {
        anchorMenu.renderMenu();
    },
    onCreateKey: function onCreateKey() {
        anchorMenu.renderMenu();
    },
    onKeyCloned: function onKeyCloned(projectId, data) {
        anchorMenu.renderMenu();
    },
    /**
     * Will be called with the complete JSON object from a specific project
     * @param projectData
     */
    onLoadProject: function onLoadProject(projectData) {
        anchorMenu.renderMenu();
    },
    onNewProjectCreated: function onNewProjectCreated() {
        anchorMenu.renderMenu();
    }
};

},{"../uiEventManager":21,"../uiModules/translationView":39,"canny":50}],9:[function(require,module,exports){
'use strict';

var canny = require('canny');

/**
 * just the implementation of the callbacks
 */

/**
 * Apply project description data to dom elements
 * @param data: Project configuration data
 */
function applyProjectData(data, project) {
    if (project.hasOwnProperty('name')) {
        // project specific config
        canny.texts.setTexts({ projectName: project.name });
    }

    // FIXME: Categories should not be named "__description" as they would override the project description
    if (data.hasOwnProperty('keyDescriptions')) {
        // project specific config - if property is present
        canny.texts.setTexts({
            projectDescription: data.keyDescriptions['__description'] ? data.keyDescriptions['__description'] : ''
        });
    }
}

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData,
    onNewDirectoryCreated: function onNewDirectoryCreated(data) {
        canny.texts.setTexts({
            projectName: data.directoryId
        });
    }
};

},{"canny":50}],10:[function(require,module,exports){
'use strict';

var canny = require('canny'),
    domOpts = require('dom-opts'),
    trade = require('../trade.js'),
    events = require('../events.js'),
    uiEvents = require('../uiEventManager.js'),
    keyValueCounter = {
    projectMap: {},
    getCountObj: function getCountObj() {
        return {
            keyMap: {}, // just collect all unique keys for getting total number of existing keys
            langMap: {} // save for each language all "valid" keys
        };
    }
},
    projectConfig = {},
    projectInfo = {},
    availableLanguages = [];

canny.projectMainNavigation.onLanguageSelect(function (obj) {
    var eventName;
    if (obj.isActive) {
        eventName = obj.isInactive ? 'deActivateLanguage' : 'activateLanguage';
        uiEvents.callUievent(eventName, obj.language);
    } else {
        uiEvents.callUievent('addLanguage', obj.language);
    }
    console.log('Click on language', obj);
});

(function () {
    var editorModeEnabled = false;

    canny.projectMainNavigation.onEnableEditorMode(function () {
        console.log('projectMainNavigationController:onEnableEditorMode show JSON format in new tab.');
        uiEvents.callUievent('enableEditorMode', !editorModeEnabled);
    });
    //maybe someone else calls this too
    uiEvents.addUiEventListener({
        enableEditorMode: function enableEditorMode(enabled) {
            editorModeEnabled = enabled;
        }
    });
})();

(function () {
    var wordCountEnabled = false;

    canny.projectMainNavigation.onToggleWordCount(function () {
        wordCountEnabled = !wordCountEnabled;
        uiEvents.callUievent('toggleWordCount', wordCountEnabled);
    });
})();

canny.projectMainNavigation.onShowJSON(function () {
    console.log('projectMainNavigationController:onShowJSON show JSON format in new tab.');
    window.open('/' + projectInfo.id + '.json?category=true', '_blank' // <- This is what makes it open in a new window.
    );
});

canny.projectMainNavigation.onShowJMBFUploader(function () {
    console.log('projectMainNavigationController:onShowJMBFUploader show message bundle uploader');
    uiEvents.callUievent('showJMBFUploader');
});

canny.projectMainNavigation.onShowJSONImport(function () {
    console.log('projectMainNavigationController:onShowJSONImport show JSON import overlay');
    uiEvents.callUievent('showJSONImport');
});

canny.projectMainNavigation.onShowJMBF(function () {
    console.log('projectMainNavigationController:onShowJMBF show JMBF format in new tab.');

    var lang = window.prompt('Enter a language code. E.g.: ' + function () {
        var existingLanguages = [];
        Object.keys(projectConfig.keys).forEach(function (lang) {
            if (Object.keys(projectConfig.keys[lang]).length > 0) {
                existingLanguages.push(lang);
            }
        });
        return existingLanguages;
    }().join(', '));

    if (lang !== null) {
        window.open('/' + projectInfo.id + '.properties' + (lang !== '' ? '?lang=' + lang : ''), '_blank' // <- This is what makes it open in a new window.
        );
    }
});

/**
 * server event listener
 */
events.addServerListener('newProjectWasCreated', function (projectName) {
    toast.showMessage('A new project with name: "' + projectName + '" was created.');
});
/**
 * server event listener
 */
events.addServerListener('keyUpdated', function (projectId, language, keyName, keyValue) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (projectId === currentProjectId) {
    //    var projectName = projectId.substring(projectId.lastIndexOf('/') + 1);
    //    updateKeyToProjectMap(projectName, language, keyName, keyValue);
    //    console.log('projectMainNavigationController:updateKey', projectId, language, keyName, keyValue);
    //}
});
/**
 * server event listener
 */
events.addServerListener('keyDeleted', function (bundleName, obj) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (bundleName === projectConfig.project) {
    //    console.log('projectMainNavigationController:keyRenamed', bundleName, obj);
    //    // TODO update the statistics...
    //}
});

/**
 *
 * @param projectName
 * @param lang
 * @param key
 * @param value
 */
function saveKeyToProjectMap(projectName, lang, key, value) {

    // just collect all keys (only the unique keys are relevant)
    if (keyValueCounter.projectMap[projectName] === undefined) {
        console.log('projectMainNavigationController:saveKeyToProjectMap project name not exists:', projectName);
        keyValueCounter.projectMap[projectName] = keyValueCounter.getCountObj();
    }

    keyValueCounter.projectMap[projectName].keyMap[key] = true;
    if (keyValueCounter.projectMap[projectName].langMap[lang] === undefined) {
        keyValueCounter.projectMap[projectName].langMap[lang] = {};
    }
    // only save the keys as object if it is a valid key otherwise delete it
    if (value) {
        keyValueCounter.projectMap[projectName].langMap[lang][key] = true;
    } else if (keyValueCounter.projectMap[projectName].langMap[lang][key]) {
        // if this key exists than remove it
        delete keyValueCounter.projectMap[projectName].langMap[lang][key];
    }
}

// TODO should use projectId, not projectName
function updateKeyToProjectMap(projectName, lang, key, value) {
    saveKeyToProjectMap(projectName, lang, key, value);
    canny.projectMainNavigation.setNumberOfTranslatedLanguageKey(Object.keys(keyValueCounter.projectMap[projectName].langMap[lang]).length, lang);
    canny.projectMainNavigation.setNumberOfTranslationMaxKeys(Object.keys(keyValueCounter.projectMap[projectName].keyMap).length);
}

// register listener function to the ui events
uiEvents.addUiEventListener({
    /**
     * the internal updateKey event - the server will not trigger the updateKey for the own client
     */
    updateKey: function updateKey(projectName, lang, key, value) {
        console.log('projectMainNavigationController:updateKey', projectName, lang, key, value);
        updateKeyToProjectMap(projectName, lang, key, value);
    },
    projectSelected: function projectSelected(projectId) {
        console.log('projectMainNavigationController:projectSelected Click on project', projectId);
        trade.loadProject(projectId, function (error) {
            if (error === false) console.error('projectMainNavigationController:loadProject fails for projectId:', projectId);
        });
    },
    activateLanguage: function activateLanguage(lang) {
        canny.projectMainNavigation.activateLang(lang);
    },
    deActivateLanguage: function deActivateLanguage(lang) {
        canny.projectMainNavigation.deActivateLang(lang);
    },
    addLanguage: function addLanguage(lang) {
        canny.projectMainNavigation.activateLang(lang);
    }
});

function computeTotalTranslationProgree(translations) {
    var totalProgress = {};
    Object.keys(translations).forEach(function (lang) {
        Object.keys(translations[lang]).forEach(function (key) {
            totalProgress[key] = undefined;
        });
    });
    return Object.keys(totalProgress).length;
}

function computeTranslationProgress(translations) {
    var progressByLanguage = {};
    Object.keys(translations).forEach(function (lang) {
        progressByLanguage[lang] = Object.keys(translations[lang]).length;
    });
    return progressByLanguage;
}

/**
 * Callback implementation of the onLoadProject & onNewProjectCreated
 * @param projectData (see project JSON file)
 */
function applyProjectData(data, project) {
    projectConfig = data;
    projectInfo = project;

    canny.projectMainNavigation.setAvailableLanguages(data.availableLanguages);

    canny.projectMainNavigation.setActivatedProjectLanguages(computeTotalTranslationProgree(data.keys), computeTranslationProgress(data.keys));

    Object.keys(data.keys).forEach(function (lang) {
        if (Object.keys(data.keys[lang]).length > 0 && availableLanguages.indexOf(lang) !== -1) {

            Object.keys(data.keys[lang]).forEach(function (key) {
                saveKeyToProjectMap(data.project, lang, key, data.keys[lang][key]);
            });

            if (keyValueCounter.projectMap[data.project].langMap[lang]) {
                console.log('projectMainNavigationController:onLoadProject ', keyValueCounter.projectMap[data.project].langMap[lang]);
                console.log('projectMainNavigationController:onLoadProject maxKeys are', Object.keys(keyValueCounter.projectMap[data.project].keyMap).length);
                //canny.projectMainNavigation.setNumberOfTranslationMaxKeys(Object.keys(keyValueCounter.projectMap[projectData.project].keyMap).length);
                //canny.projectMainNavigation.setNumberOfTranslatedLanguageKey(Object.keys(keyValueCounter.projectMap[projectData.project].langMap[lang]).length, lang);
                // TODO refactor this and make one call ;)
                canny.projectMainNavigation.activateLang(lang);
                canny.projectMainNavigation.deActivateLang(lang);
            } else {
                console.log('projectMainNavigationController:onLoadProject get language without any keys for locale:', lang);
            }
        }
    });

    // reset or reinitialize or initialize the key value counter (otherwise the counter can't detect deleted keys. E.g. from the editor mode)
    keyValueCounter.projectMap[data.project] = keyValueCounter.getCountObj();
    // show default language as selected language in menu
    // TODO check who decides to show which language as default - and then call this event from there
    uiEvents.callUievent('activateLanguage', data.defaultLanguage);
}

/**
 * the implementation of the callbacks
 */
module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../events.js":16,"../trade.js":20,"../uiEventManager.js":21,"canny":50,"dom-opts":63}],11:[function(require,module,exports){
'use strict';

var projectOverview = require('canny').projectOverview,
    displayManager = require('canny').displayManager,
    trade = require('../trade.js'),
    uiEvents = require('../uiEventManager.js'),
    canny = require('canny'),
    toast = require('../Toast.js'),
    events = require('../events.js');

var projectOverviewController = function () {

    var currentParentDirectory, currentDirectory,
    /**
     * Maps project names to projects IDs
     */
    projects,
    /**
     * Maps directory names to directory IDs
     */
    directories;

    uiEvents.addUiEventListener({
        showOverviewPage: function showOverviewPage() {
            displayManager.show('projectsOverview');
        }
    });

    projectOverview.onParentDirectorySelected(function () {
        if (currentParentDirectory !== currentDirectory) {
            trade.getDirectory(currentParentDirectory);
        } else {
            console.log('No parent directory');
        }
    });

    projectOverview.onProjectSelected(function (projectName) {
        uiEvents.callUievent('projectSelected', projects[projectName]);
    });

    projectOverview.onDirectorySelected(function (directoryName) {
        var directoryId = directories[directoryName];
        trade.getDirectory(directoryId, function () {
            console.log('projectOverviewController:can not load project for directory name:', directoryId);
        });
    });

    projectOverview.onCreateProjectPressed(function () {
        displayManager.show('createNewProjectView');
    });

    projectOverview.onCreateDirectoryPressed(function () {
        displayManager.show('createNewDirectoryView');
    });

    projectOverview.onDeleteFolderPressed(function (dirName) {
        trade.deleteFolder(dirName, currentDirectory, function (err, dirName) {
            var toastMessage;
            if (!err) {
                projectOverview.deleteProjectListNode(dirName);
                toastMessage = 'Folder "' + dirName + '" has been deleted.';
            } else {
                toastMessage = 'There was an error: "' + err.message + '"';
            }
            toast.showMessage(toastMessage);
        });
    });

    projectOverview.onDeleteProjectPressed(function (projectName) {
        trade.deleteProject(projects[projectName], function (err, project) {
            var toastMessage;
            if (!err) {
                projectOverview.deleteProjectListNode(project.name);
                toastMessage = 'Project "' + project.name + '" has been deleted.';
            } else {
                toastMessage = 'There was an error: "' + err.message + '"';
            }
            toast.showMessage(toastMessage);
        });
    });

    events.addServerListener('newDirectoryCreated', function (directoryId) {
        var lastDirSepIdx = directoryId.lastIndexOf('/');
        var parentDirectory = directoryId.substring(0, lastDirSepIdx + 1);
        if (parentDirectory === currentParentDirectory) {
            var directoryName = directoryId.substring(lastDirSepIdx + 1);
            directories[directoryName] = directoryId;
            // TODO show message only if projectOverview is currently visible - but canny.flowcontrol currently does not
            // have anything to find out which view is the active one
            toast.showMessage('A new directory "' + directoryName + '" has been created by another user.');
            projectOverview.setProjectsAndDirectories(Object.keys(projects), Object.keys(directories));
        }
    });

    return {
        /**
         * Callback from the server which handles a fresh directory/projects list
         *
         * @param {{currentDirectory:string, dirs:[{name, id}], parentDirectories:[{name, id}], parentDirectory:string, projects:[{name, id}] }} data - an object with 2 properties "projects" and "directories", each listing project/directory names.
         */
        getDirectory: function getDirectory(data, project) {
            console.log('ProjectOverviewController.getDirectory: ', data);
            if (data === false) {
                console.error("Server call failed");
            } else if (data.hasOwnProperty('projects') && data.hasOwnProperty('dirs')) {

                projects = {};
                data.projects.forEach(function (entry) {
                    projects[entry.name] = entry.id;
                });

                directories = {};
                data.dirs.forEach(function (entry) {
                    directories[entry.name] = entry.id;
                });

                projectOverview.setProjectsAndDirectories(Object.keys(projects), Object.keys(directories));
                currentParentDirectory = data.parentDirectory;
                currentDirectory = data.currentDirectory;
            } else {
                console.warn('Data rcvd from server is missing expected properties ("projects", "dirs")');
            }
        },
        onNewDirectoryCreated: function onNewDirectoryCreated(data) {
            displayManager.show('projectsOverview');
            trade.getDirectory(data.directoryId, function () {
                console.log('projectOverviewController.onNewDirectoryCreated: trade callback');
            });
        }
    };
}();

module.exports = projectOverviewController;

},{"../Toast.js":2,"../events.js":16,"../trade.js":20,"../uiEventManager.js":21,"canny":50}],12:[function(require,module,exports){
'use strict';

var textEditor = require('canny').textEditor,
    trade = require('../trade.js'),
    toast = require('../Toast.js'),
    events = require('../events.js'),
    currentProjectId;
/**
 * returns the language or false
 * @param fileName
 * @returns {*}
 */
function getLanguageFromFileName(fileName) {
    var reg = /messages_(.*)\..*./g.exec(fileName);
    if (reg && reg.length === 2) {
        return reg[1];
    }
    return false;
}

/**
 * handle the change project description event in the view
 */
textEditor.onChange(function (id, value, fc) {
    console.log('textEditorController:onChange', value);
    if (currentProjectId) {
        if (!id) {
            // TODO to keep backward functionality this is the "main" project description - will be changed in future
            id = '__description';
        }
        // TODO remove the tv_ from the id
        trade.saveProjectDescription(currentProjectId, id, value, function (success) {
            if (success) {
                fc(true);
                toast.showMessage('Project description changed for project ' + currentProjectId);
            } else {
                fc(false);
            }
        });
    }
});
/**
 * just the implementation of the callbacks
 *
 */
module.exports = {
    onLoadProject: function onLoadProject(data, _ref) {
        var id = _ref.id,
            name = _ref.name,
            url = _ref.url;

        if (id) currentProjectId = id;
    }
};

},{"../Toast.js":2,"../events.js":16,"../trade.js":20,"canny":50}],13:[function(require,module,exports){
'use strict';

var canny = require("canny"),
    translationView = require('../uiModules/translationView'),
    translationViewImageUpload = require('../uiModules/translationViewImageUpload'),
    wordCounter = require('../util/wordCounter'),
    domOpts = require('dom-opts'),
    uiEvents = require('../uiEventManager.js'),
    events = require('../events.js'),
    trade = require('../trade.js'),
    url = require('../util/url'),
    sortByKey = function sortByKey(a, b) {
    if (a.key < b.key) {
        return -1;
    }
    if (a.key > b.key) {
        return 1;
    }
    return 0;
},
    projectConfig,
    projectInfo,
    availableLanguages = [],

/**
 * An object (used as a set datastructure here) holding all existing keys of the project (no matter for how many
 * languages it is used). It is needed when adding a new language, see the function for addLanguage which is added
 * to uiEvents.
 * @type {{}}
 */
existingKeys = {};

translationViewImageUpload.onUploadButton(function (id) {
    uiEvents.callUievent('showFileUpload', id);
});

translationViewImageUpload.onDeleteButton(function (id) {
    if (confirm('Delete the image for category » ' + id + ' « forever?')) {
        trade.removeImage(projectConfig.projectId, id);
    }
});

translationView.onCategoryClicked(function (id) {
    uiEvents.callUievent('anchorFocus', '#' + id);
});
/**
 * Setup the UI events and manage the logic for them.
 *
 * TODO replace bundle with locale and refactor the calls from translationView
 */
translationView.onSaveKey(function (key, lang, value) {

    // TODO: Count words and tell word count label to update

    console.log('translationViewController:onSaveValue', [].slice.call(arguments));
    trade.saveKey(projectConfig.projectId, lang || projectConfig.defaultLanguage, {
        key: key,
        value: value || undefined
    }, function (projectId, language, key, value) {
        var catId;

        if (projectId === projectConfig.projectId) {
            // prevent applying the callback if project has been changed in the meantime
            catId = key.split('_')[0];
            existingKeys[key] = undefined; // save the key
            projectConfig.keys[lang][key] = value;
            translationView.printBundleTemplate([{
                key: key,
                value: value || ''
            }], language, availableLanguages, function () {
                updateCategoryWordCount(catId, language);
            });

            toast.showMessage('Auto save: "' + key + '" (success)');

            translationView.sendSuccess(key, 'value_');
            // TODO not sure if this is needed
            uiEvents.callUievent('updateKey', projectId, language, key, value);
        }
    });
});

/**
 * Setup the UI events and manage the logic for them.
 *
 * TODO replace bundle with locale and refactor the calls from translationView
 */
translationView.onCreateKey(function (key, lang, value) {
    console.log('translationViewController:onSaveValue', [].slice.call(arguments));
    trade.createKey(projectConfig.projectId, lang || projectConfig.defaultLanguage, {
        key: key,
        value: value || undefined
    }, function (projectId, language, key, value) {
        var catId = key.split('_')[0];
        if (projectId === projectConfig.projectId) {
            // prevent applying the callback if project has been changed in the meantime
            existingKeys[key] = undefined; // save the key
            projectConfig.keys[language] = projectConfig.keys[language] ? projectConfig.keys[language] : {};
            projectConfig.keys[language][key] = value;
            translationView.printBundleTemplate([{
                key: key,
                value: value || '',
                words: 0
            }], language, availableLanguages, function () {
                updateCategoryWordCount(catId, language);
            });
            toast.showMessage('Auto save: "' + key + '" (success)');

            translationView.sendSuccess(key, 'value_');
            // TODO not sure if this is needed
            uiEvents.callUievent('updateKey', projectId, language, key, value);
        }
    });
});

translationView.onCloneKey(function (keyId, keyName, fromCategory, toCategory) {
    trade.cloneKey(projectConfig.projectId, {
        id: keyId,
        key: keyName,
        sourceCategory: fromCategory,
        targetCategory: toCategory
    }, function (err, projectId, data) {
        var texts;
        if (projectId === projectConfig.projectId) {
            existingKeys[data.key] = undefined;
            texts = data.values;
            for (var lang in texts) {
                if (texts.hasOwnProperty(lang)) {
                    projectConfig.keys[lang][data.key] = texts[lang];
                    translationView.printBundleTemplate([{
                        key: data.key,
                        value: texts[lang] || ''
                    }], lang, availableLanguages, function () {
                        updateCategoryWordCount(toCategory, lang);
                    });
                }
            }
            canny.translationViewDescription.addDescriptions(data.keyDescriptions);
        }
    });
});

/**
 * Read the from param as default language otherwise take it from the project.json
 * @param config
 */
function saveProjectConfig(config, project) {
    var idx,

    // the from parameter can overwrite the default language (legacy)
    defaultLanguage = domOpts.params.from ? domOpts.params.from : config.defaultLanguage;
    projectConfig = config;
    projectInfo = project;

    // Set ${ defaultLanguage } as default in case a project was just created (i.e. does not contain any keys yet)
    // TODO: Better create / add check of object to functional helper object instead ?
    availableLanguages = Object.keys(projectConfig.keys).length === 0 && JSON.stringify(projectConfig.keys) === JSON.stringify({}) ? [defaultLanguage] : Object.keys(projectConfig.keys);

    idx = availableLanguages.indexOf(defaultLanguage);

    if (idx !== -1 && idx !== 0) {
        // move default to the begin of the list (this defines the order how the translation languages are shown)
        availableLanguages.splice(0, 0, availableLanguages.splice(idx, 1)[0]);
    }
}

///**
// * TODO replace bundle with locale and refactor the calls from translationView
// * TODO this code is not called!?
// */
//translationView.onAddNewKey(function (lang, key, value, cb) {
//    console.log('translationViewController:onAddNewKey', [].slice.call(arguments));
//    alert('huhu');
//    trade.sendResource({
//        bundle: projectConfig.project,
//        locale: lang
//    }, {
//        key: key,
//        value: value
//    }, function (key) {
//        cb(key)
//    });
//});

translationView.onCreateNewProject(function (prjName, obj) {
    trade.createNewProject(prjName, obj);
});

translationView.onRemoveCategory(function (obj) {
    console.log('translationViewController:onRemoveCategory', obj, projectConfig.projectId);
    trade.removeCategory(projectConfig.projectId, obj.category);
});

translationView.onRenameCategory(function (obj) {
    console.log('translationViewController:onRenameCategory', obj, projectConfig.projectId);
    trade.renameCategory(projectConfig.projectId, obj.oldName, obj.newName);
});

translationView.onRenameKey(function (obj) {
    console.log('translationViewController:onRenameKey', obj, projectConfig.projectId);
    trade.renameKey(projectConfig.projectId, {
        newKey: obj.newKey,
        oldKey: obj.oldKey
    });
});

translationView.onRemoveKey(function (obj) {
    console.log('translationViewController:onRemoveKey', obj, projectConfig.projectId);
    trade.removeKey(projectConfig.projectId, obj.key, function (key) {
        var catName = key.split('_')[0];
        for (var lang in projectConfig.keys) {
            if (projectConfig.keys.hasOwnProperty(lang)) {
                delete projectConfig.keys[lang][key];
                updateCategoryWordCount(catName, lang);
            }
        }
    });
});

// register listener function to the ui events
uiEvents.addUiEventListener({
    activateLanguage: function activateLanguage(lang) {
        //        translationViewHeader.showLang(lang);
        translationView.showLang(lang);
    },
    deActivateLanguage: function deActivateLanguage(lang) {
        //        translationViewHeader.hideLang(lang);
        translationView.hideLang(lang);
    },
    toggleWordCount: function toggleWordCount(active) {
        translationView.toggleWordCount(active);
    },
    // TODO  don't trigger it twice for the same language
    addLanguage: function addLanguage(lang) {
        availableLanguages.push(lang);
        projectConfig.keys[lang] = {};
        translationView.addLanguage(Object.keys(existingKeys), lang);
        //        translationViewHeader.showLang(lang);
        translationView.showLang(lang);
    },
    enableEditorMode: function enableEditorMode(enabled) {
        translationView.enableEditorMode(enabled);
    },
    fileUploaded: function fileUploaded(projectId, key, fileName, url) {
        canny.translationViewImageUpload.appendImage(projectConfig.projectId, key, fileName, url);
    },
    JMBFFileUploaded: function JMBFFileUploaded(projectId) {
        trade.loadProject(projectId, function (error) {
            if (error === false) console.error('translationViewController:loadProject fails for projectId:', prj.projectId);
        });
    },
    jsonImported: function jsonImported(projectId) {
        trade.loadProject(projectId, function (error) {
            if (error === false) {
                console.warn('Project with id ' + projectId + ' could not be loaded.');
                console.error(error.toString());
            }
        });
    }
});

/**
 * server event listener
 */
events.addServerListener('keyUpdated', function () {
    // TODO more client changes are coming, we'll finish the code below then
    //if (projectId === projectConfig.projectId) {
    //    existingKeys[keyName] = undefined; // save the key // what's happening here?
    //    var data = {};
    //    data[keyName] = keyValue;
    //    translationView.printBundleTemplate([data], language, availableLanguages, projectConfig.project);
    //}
});

/**
 * server event listener
 * all users will be notified of changes
 */
events.addServerListener('onKeyCloned', function () {
    console.log('events.listener::onKeyCloned' + [].slice.call(arguments));
});

/**
 * server event listener
 */
events.addServerListener('keyDeleted', function (bundleName, obj) {
    // TODO more client changes are coming, we'll finish the code below then
    //if (bundleName === projectConfig.project) {
    //    console.log('translationViewController:keyRenamed', bundleName, obj);
    //    toast.showMessage('Key deleted!' + obj.key);
    //    translationView.markKeyAsRemoved(obj.key);
    //}
});

events.addServerListener('categoryDeleted', function (bundleName, obj) {
    console.log('events.listener::categoryDeleted' + [].slice.call(arguments));
});

events.addServerListener('categoryRenamed', function (bundleName, obj) {
    console.log('events.listener::categoryRenamed' + [].slice.call(arguments));
});

/**
 * server event listener
 */
events.addServerListener('imageRemoved', function (bundleName, categoryName) {
    if (bundleName === projectConfig.projectId) {
        toast.showMessage('Image removed for category: ' + categoryName);
        translationView.removeImage(categoryName);
    }
});

/**
 * Get word count for given category and language
 * @param category
 * @param lang
 * @returns Number
 */
function countWordsInCategory(category, lang) {
    var wordCount = 0;
    Object.keys(projectConfig.keys[lang]).forEach(function (key) {
        if (key.split('_')[0] === category) {
            wordCount += wordCounter.countWordsInString(projectConfig.keys[lang][key]);
        }
    });
    return wordCount;
}

/**
 * Update overall word-count view for category language
 * @param catId
 * @param lang
 */
function updateCategoryWordCount(catId, lang) {
    translationView.updateCategoryWordCount({
        id: catId,
        language: lang,
        words: countWordsInCategory(catId, lang)
    });
}

/**
 * Filter category names by iterating through project keys
 * @param keys
 * @returns Array
 */
function getCategoriesByKeys(keys) {
    var currentCatName,
        defaultKeys,
        categories = [];
    for (var lang in keys) {
        if (keys.hasOwnProperty(lang)) {
            defaultKeys = keys[lang];
            for (var key in defaultKeys) {
                if (defaultKeys.hasOwnProperty(key)) {
                    currentCatName = key.split('_')[0];
                    if (categories.indexOf(currentCatName) === -1) {
                        categories.push(currentCatName);
                    }
                }
            }
        }
    }
    return categories;
}

/**
 * Removes category related keys from "session" data - stored in projectConfig.keys
 * (member var declared on top of this file)
 * Invoked by category was removed
 * @param category
 */
function removeCategoryData(category) {
    Object.keys(projectConfig.keys).forEach(function (lang) {
        var langData = projectConfig.keys[lang];
        Object.keys(langData).forEach(function (key) {
            if (key.split('_')[0] === category) {
                delete langData[key];
            }
        });
    });
}

function handleNewProjectConfig(newProjectConfig, project) {
    // project specific config
    console.log('translationViewController get new config', newProjectConfig);
    // n.b. nothing is saved here - "saving" only happens as in "store in our data structure"
    saveProjectConfig(newProjectConfig, project);
    // before there was a check do not clear the view if the actual project is the same.
    // The problem is if you remove a key in the editor view than the translation view can't
    // detect this.
    translationView.clearView();
    canny.flowControl.show('resourceBundle');
}

function renderProject(projectData, project, cb) {
    var categories = getCategoriesByKeys(projectData.keys);

    handleNewProjectConfig(projectData, project);

    Object.keys(projectData.keys).forEach(function (lang) {
        var sorted,
            datas = [];
        Object.keys(projectData.keys[lang]).forEach(function (key) {
            datas.push({
                key: key,
                value: projectData.keys[lang][key]
            });
        });
        sorted = datas.sort(sortByKey);

        sorted.forEach(function (data) {
            existingKeys[data.key] = undefined;
        });

        // TODO projectConfig.project will be removed if the trade call moved to this controller
        translationView.printBundleTemplate(sorted, lang, availableLanguages, cb || function () {});

        categories.forEach(function (category) {
            updateCategoryWordCount(category, lang);
        });
    });
}

module.exports = {
    renameCategory: function renameCategory(oldName, newName) {
        toast.showMessage('Renamed category ' + oldName + ' to ' + newName + '!');
        translationView.renameCategory(oldName, newName, availableLanguages);
    },
    removeCategory: function removeCategory(catName) {
        toast.showMessage('Removed category ' + catName + '!');
        removeCategoryData(catName);
        translationView.removeCategory(catName);
    },
    /**
     * is called if the user rename key request was successful
     * @param newKey
     * @param oldKey
     */
    renameKey: function renameKey(oldKey, newKey) {
        if (oldKey) {
            toast.showMessage('Key renamed successful! From ' + oldKey + ' to ' + newKey);
            translationView.renameKey(oldKey, newKey, availableLanguages);
        } else {
            toast.showMessage('Key renamed failed!');
        }
    },
    removeKey: function removeKey(key) {
        toast.showMessage('Key removed successful!', key);
        translationView.removeKey(key);
    },
    imageRemoved: function imageRemoved(categoryName) {
        toast.showMessage('Image removed for category: ' + categoryName);
        translationView.removeImage(categoryName);
    },
    /**
     * Will be called with the complete JSON object from a specific project
     * @param projectData
     */
    onLoadProject: function onLoadProject(projectData, project) {
        var anchor = url.hasAnchor() ? url.getAnchor().replace('#', '') : false;
        renderProject(projectData, project, function (viewId) {
            if (anchor) {
                if (viewId === anchor) {
                    var dom = document.getElementById(translationView.config.rowPrefix + viewId);
                    // do the element exists?
                    if (dom) {
                        uiEvents.callUievent('anchorFocus', url.getAnchor());
                        setTimeout(function () {
                            var bodyRect = document.body.getBoundingClientRect(),
                                elemRect = dom.getBoundingClientRect(),
                                offset = elemRect.top - bodyRect.top;
                            window.scrollTo(0, offset);
                        }, 1000);
                    }
                }
            }
        });
        // add the descriptions
        canny.translationViewDescription.addDescriptions(projectData.keyDescriptions);
        Object.keys(projectData.images).forEach(function (key) {
            canny.translationViewImageUpload.appendImage(project.id, key, projectData.images[key]);
        });
    },
    onNewProjectCreated: function onNewProjectCreated(projectData, project) {
        console.log('translationViewController.onNewProjectCreated');
        renderProject(projectData, project);
    }
};

},{"../events.js":16,"../trade.js":20,"../uiEventManager.js":21,"../uiModules/translationView":39,"../uiModules/translationViewImageUpload":41,"../util/url":44,"../util/wordCounter":45,"canny":50,"dom-opts":63}],14:[function(require,module,exports){
'use strict';

/**
 * controller for the image uplaoder view - calls the server to upload a image and notifier the ui event handler
 * @type {{}}
 */
var canny = require('canny'),
    upload = canny.upload,
    displayManager = canny.displayManager,
    uiEvents = require('../uiEventManager.js'),
    uploadId,
    projectInfo;
/**
 * Call this for each file - will call a call back with the server answer
 * @param file
 */
function sendFile(file, directCallback) {
    var uri = '/uploadFile?projectId=' + projectInfo.id + '&key=' + uploadId + '&project=' + projectInfo.name,
        xhr = new XMLHttpRequest(),
        fd = new FormData();

    xhr.open("POST", uri, true);
    xhr.onreadystatechange = function () {
        var data;
        if (xhr.readyState == 4 && xhr.status == 200) {
            // Handle response.
            data = JSON.parse(xhr.responseText);
            directCallback && directCallback(data); // handle response.
            // {file: "//sub/sub1/sub1_blue_coke.jpg", name: "sub1_blue_coke.jpg", type: "image/jpg"}
            console.log(data);
            uiEvents.callUievent('fileUploaded', projectInfo.id, uploadId, data.file);
        }
    };
    fd.append('myFile', file);
    // Initiate a multipart/form-data upload
    xhr.send(fd);
}

/**
 * Save data in member variable used by further upload operations
 * @param data: Project data
 */
function applyProjectData(data, project) {
    projectInfo = project;
}

uiEvents.addUiEventListener({
    showFileUpload: function showFileUpload(id) {
        uploadId = id;
        displayManager.show('uploadView');
    }
});

upload.onUpload(function (file) {
    // TODO additional to the upload id we need the project ID
    console.log('uploadController:upload id: file:', uploadId, file);
    sendFile(file);
});

module.exports = {
    onNewProjectCreated: applyProjectData,
    onLoadProject: applyProjectData
};

},{"../uiEventManager.js":21,"canny":50}],15:[function(require,module,exports){
'use strict';

var trade = require('../trade'),
    uiEvents = require('../uiEventManager'),
    url = require('../util/url');
/**
 * TODO handle the browser back and next button and load the correct view
 */
function processAjaxData(response, urlPath) {
    document.title = response.pageTitle;
    window.history.pushState({
        "html": response.html,
        "pageTitle": response.pageTitle,
        id: response.id,
        isProject: response.isProject
    }, "", urlPath + url.getAnchor());
}

/**
 * Manipulate browser history / location with given project data
 * @param data: Project related data
 */
function applyProjectData(data, project) {
    // add the project path to the URL
    if (project.name) {
        processAjaxData({
            pageTitle: project.id,
            html: '',
            id: project.id,
            isProject: true
            // to persists the links we save the id in URL - it's not human readable but links will work forever
        }, '/' + project.id + '.prj');
    }
}

uiEvents.addUiEventListener({
    anchorFocus: function anchorFocus(id) {
        // set the anchor to the URL
        window.history.pushState(null, null, id);
    }
});

window.onpopstate = function (e) {
    //    console.log('onpopstate', e.state.id);
    if (e.state) {
        if (e.state.isProject) {
            trade.loadProject(e.state.id, function (err) {
                if (err === false) console.error('urlManipulator:loadProject fails for projectId:', e.state.id);
            });
        } else {
            trade.getDirectory(e.state.id, function (err) {
                if (err !== false) {
                    // TODO call the
                    uiEvents.callUievent('showOverviewPage');
                } else {
                    console.log('urlManipulator:getDirectory can not load project for directory name:', e.state.id);
                }
            });
        }
    }
};

/**
 * TODO there is a problem with activating the project view or the overview page...
 *
 * just the implementation of the callbacks
 *
 */
module.exports = {
    onLoadProject: applyProjectData,
    onNewProjectCreated: applyProjectData,
    getDirectory: function getDirectory(data) {
        processAjaxData({
            pageTitle: 'translatron overview',
            html: '',
            id: data.currentDirectory,
            isProject: false
        }, data.currentDirectory);
    }
};

},{"../trade":20,"../uiEventManager":21,"../util/url":44}],16:[function(require,module,exports){
'use strict';

/**
 * Created by eightyfour.
 *
 * All server events. Multiple clients can register on each event
 * and will be notified if method is called from server.
 *
 * TODO RENAME FILE
 * TODO to what? :)
 * What about "externalChangeNotifications"?
 *
 * TBD why don't we integrate this one with ui events? that would cut down on the number of components we have and we "only" (?)
 * have to do some sensible renaming of events, like renaming all events handled here by adding "external" or similar
 * (e.g. "keyUpdated" becomes "keyUpdatedExternally").
 */
var events = function () {
    "use strict";

    var eventQueue = {},
        callQueue = function callQueue(name, args) {
        console.log('got notification for ', name, 'with payload', args);
        if (eventQueue.hasOwnProperty(name)) {
            eventQueue[name].map(function (fc) {
                fc.apply(null, args);
            });
        }
    };
    return {
        serverEvents: {
            // TBD can be removed?
            sendFile: function sendFile() {
                callQueue('sendFile', [].slice.call(arguments));
            },
            // TBD can be removed?
            sendPathList: function sendPathList() {
                callQueue('sendPathList', [].slice.call(arguments));
            },
            keyUpdated: function keyUpdated(projectId, language, keyName, keyValue) {
                callQueue('keyUpdated', [projectId, language, keyName, keyValue]);
            },
            onKeyCloned: function onKeyCloned(projectId, data) {
                callQueue('onKeyCloned', [projectId, data]);
            },
            keyRenamed: function keyRenamed(projectId, oldKeyName, newKeyName) {
                callQueue('keyRenamed', [projectId, oldKeyName, newKeyName]);
            },
            /**
             * @param bundleObj {locale: string, bundle: string}
             * @param data {oldKey:string, newKey: string}
             */
            keyDeleted: function keyDeleted(projectId, keyName) {
                callQueue('keyDeleted', [projectId, keyName]);
            },
            imageRemoved: function imageRemoved(projectId, categoryName) {
                callQueue('imageRemoved', [projectId, categoryName]);
            },
            newProjectWasCreated: function newProjectWasCreated(projectId) {
                callQueue('newProjectWasCreated', [projectId]);
            },
            categoryRenamed: function categoryRenamed(projectId, oldName, newName) {
                callQueue('categoryRenamed', [projectId, oldName, newName]);
            },
            categoryDeleted: function categoryDeleted(projectId, catName) {
                callQueue('categoryDeleted', [projectId, catName]);
            },
            newDirectoryCreated: function newDirectoryCreated(directoryId) {
                callQueue('newDirectoryCreated', [directoryId]);
            },
            projectDescriptionUpdated: function projectDescriptionUpdated(projectId, id, description) {
                callQueue('projectDescriptionUpdated', [projectId, id, description]);
            }
        },
        addServerListener: function addServerListener(name, cb) {
            if (eventQueue.hasOwnProperty(name)) {
                eventQueue[name].push(cb);
            } else {
                eventQueue[name] = [cb];
            }
        }
    };
}();

module.exports = events;

},{}],17:[function(require,module,exports){
'use strict';

var C = require('./CONST');
var connectionLost = require('./uiModules/connectionLost');

/**
 * Refresh the user session and detects if the user is not authenticated anymore
 * useful for:
 *  * session keep alive
 *  * detect if the user is not authenticated anymore
 *  * detects server shut down
 */
module.exports = function handleSessionTimeOut() {
    var connectionLostUi = connectionLost({
        onReload: function onReload() {
            return location.reload();
        },
        onClose: function onClose() {
            return connectionLostUi.destroy();
        }
    });
    var interval = setInterval(function () {
        fetch(location.protocol + '//' + location.host + '/touchSession', {
            credentials: "same-origin"
        }).then(function (d) {
            if (d.status === 401) {
                clearInterval(interval);
                // whoops server has no authentication anymore...
                connectionLostUi.render('AUTH');
            }
        }).catch(function (e) {
            clearInterval(interval);
            connectionLostUi.render('SERVER_DOWN', 'Maybe a server restart happens. Please try to login again in few minutes');
        });
    }, C.SESSION.renewal_interval_in_ms);
};

},{"./CONST":1,"./uiModules/connectionLost":28}],18:[function(require,module,exports){
'use strict';

/*global domOpts */
/*jslint browser: true */
var unicode = require('./unicode.js');
var toast = require('./Toast.js');
var canny = require('canny');
var trade = require('./trade.js');
var handleSessionTimeOut = require('./handleSessionTimeOut');
var breadCrumbController = require('./controller/breadcrumbController.js');

window.domOpts = window.domOpts || require('dom-opts');
// made it public - just for development
window.canny = canny;

canny.add('repeat', require('canny/mod/repeat'));
canny.add('whisker', require('canny/mod/whisker'));
canny.add('async', require('canny/mod/async'));
canny.add('flowControl', require('canny/mod/flowControl')('flowControl'));
canny.add('displayManager', require('./uiModules/displayManager.js'));
canny.add('textEditor', require('./textEditor.js'));
canny.add('cookieManager', require('canny-cookieManager-lib'));

canny.add('texts', require('./uiModules/texts.js'));
canny.add('auth', require('./uiModules/auth.js'));
canny.add('projectMainNavigation', require('./uiModules/projectMainNavigation.js'));
canny.add('translationView', require('./uiModules/translationView.js'));
canny.add('translationViewImageUpload', require('./uiModules/translationViewImageUpload.js'));
//canny.add('translationViewHeader',  require('./uiModules/translationViewHeader.js'));
canny.add('imageViewer', require('./uiModules/imageViewer.js'));
canny.add('projectOverview', require('./uiModules/projectOverview.js'));
canny.add('createNewProject', require('./uiModules/createNewProject.js'));
canny.add('menuRight', require('./uiModules/menuRight.js'));
canny.add('anchorMenu', require('./uiModules/anchorMenu.js'));

canny.add('translationViewDescription', require('./uiModules/translationViewDescription.js'));
canny.add('upload', require('./uiModules/upload.js'));
canny.add('JMBFUploader', require('./uiModules/JMBFUploader.js'));
canny.add('JsonImport', require('./uiModules/JsonImport.js'));

trade.addController(require('./controller/projectMainNavigationController.js'));
trade.addController(require('./controller/pageHeaderController.js'));
trade.addController(require('./controller/translationViewController.js'));
trade.addController(require('./controller/textEditorController.js'));
trade.addController(require('./controller/urlManipulator.js'));
trade.addController(require('./controller/projectOverviewController.js'));
trade.addController(require('./controller/createNewProjectController.js'));
trade.addController(breadCrumbController);
trade.addController(require('./controller/authController.js'));
trade.addController(require('./controller/menuRightController.js'));
trade.addController(require('./controller/uploadController.js'));
trade.addController(require('./controller/JMBFUploaderController.js'));
trade.addController(require('./controller/JsonImportController.js'));

canny.ready(function () {
    "use strict";
    // create websocket connection via trade

    trade.initialize(function (userObject, sessionsEnabled) {

        if (userObject === null) {
            alert('A fatal error happens while loading the view');
            location.reload();
            return;
        }
        canny.texts.setTexts({ userName: userObject.name });

        if (userObject.isAdmin) {
            document.body.classList.add('isAdmin');
        }

        if (sessionsEnabled) {
            // trigger a "session keep alive" and detects if the user is not authenticated anymore or the server is down
            handleSessionTimeOut();
        }
    });
});

window.canny = canny;
window.domOpts = require('dom-opts');
window.unicode = unicode;
window.toast = toast;

// QUESTION: can it happen that the above call to trade.initialize (in canny.ready) finishes earlier than the next lines?
// i.e. the callback for trade.ready will never be executed? if yes: why not pass the callback already to trade.initialize?
trade.ready(function () {
    'use strict';

    var prj = function getProjectNameAndPathFromURL() {
        var split = location.pathname.split('/'),
            path = location.pathname,
            prjName;
        if (/\.prj/.test(split[split.length - 1])) {
            // remove .prj extension and first slash
            prjName = path.replace('.prj', '').replace('/', '');
            path = split.slice(0, -1).join('/');
        }
        if (path[0] !== '/') {
            path = '/' + path;
        }

        return {
            path: path,
            projectId: prjName
        };
    }();

    // QUESTION: since this is working on the URL the application was loaded with and this URL can be either a directory URL
    // or a project URL: why can't we decide first what we actually have in the URL and then either call getDirectory
    // or loadProject? ANSWER: depends. if the URL points to a directory, we only have to do the getDirectory call.
    // if the URL is a project, two calls have to be made: one loadProject call and one extra getDirectory call for the
    // parent of the project (mainly for navigation component which needs to know the siblings of the project). But: take
    // care that this extra getDirectory must *not* change the state of the breadcrumb trail (that one should still show
    // the selected project)


    if (prj.projectId) {
        // this is the initial call to trigger a project load - you will get
        // the project.json and all translations
        trade.loadProject(prj.projectId, function (err, data, project) {
            // callback is only called if an error occurs
            if (err) {
                toast.showMessage('Loading project \'' + prj.projectId + '\' failed - project doesn\'t exists');
                console.error('translationViewController:loadProject fails for projectId:', prj.projectId);
            } else {
                // required for the breadcrumb
                breadCrumbController.setPath(project.url);
            }
        });
    } else {
        trade.getDirectory(prj.path, function (obj) {});
    }
});

},{"./Toast.js":2,"./controller/JMBFUploaderController.js":3,"./controller/JsonImportController.js":4,"./controller/authController.js":5,"./controller/breadcrumbController.js":6,"./controller/createNewProjectController.js":7,"./controller/menuRightController.js":8,"./controller/pageHeaderController.js":9,"./controller/projectMainNavigationController.js":10,"./controller/projectOverviewController.js":11,"./controller/textEditorController.js":12,"./controller/translationViewController.js":13,"./controller/uploadController.js":14,"./controller/urlManipulator.js":15,"./handleSessionTimeOut":17,"./textEditor.js":19,"./trade.js":20,"./uiModules/JMBFUploader.js":22,"./uiModules/JsonImport.js":23,"./uiModules/anchorMenu.js":24,"./uiModules/auth.js":25,"./uiModules/createNewProject.js":29,"./uiModules/displayManager.js":30,"./uiModules/imageViewer.js":32,"./uiModules/menuRight.js":34,"./uiModules/projectMainNavigation.js":36,"./uiModules/projectOverview.js":37,"./uiModules/texts.js":38,"./uiModules/translationView.js":39,"./uiModules/translationViewDescription.js":40,"./uiModules/translationViewImageUpload.js":41,"./uiModules/upload.js":42,"./unicode.js":43,"canny":50,"canny-cookieManager-lib":49,"canny/mod/async":51,"canny/mod/flowControl":52,"canny/mod/repeat":53,"canny/mod/whisker":54,"dom-opts":63}],19:[function(require,module,exports){
'use strict';

/**
 * textEditor
 */
(function () {
    "use strict";

    var textEditor = function () {

        var texts = {
            originText: 'Double click to edit this text',
            editBtn: 'Edit',
            cancelBtn: 'Cancel',
            changeBtn: 'Save changes'
        },
            onChangeAllList = [];

        function findClosestAncestorWithId(element) {
            while ((element = element.parentElement) && !element.id) {}
            return element;
        }

        function callChangeList(id, value, fc) {
            onChangeAllList.forEach(function (cb) {
                return cb(id, value, fc);
            });
        }

        function editWithTextarea(node, buttonWrap, obj) {
            var open = false,
                divWrapper = document.createElement('div'),
                button = document.createElement('div'),
                cancelButton = document.createElement('div'),
                area = document.createElement('textarea'),
                jsTextN;

            if (obj && obj.hasOwnProperty('placeholder')) {
                area.setAttribute('placeholder', obj.placeholder);
            }

            function close() {
                node.classList.add('textEditor-hide');
                open = false;
            }

            function edit() {
                if (!open) {
                    jsTextN = node.querySelector('.js-text');
                    open = true;
                    area.value = jsTextN.innerHTML;
                    setTimeout(function () {
                        node.classList.remove('textEditor-hide');
                    }, 100);
                }
            }

            // set classes
            cancelButton.className = 'textEditor-button textEditor-button-cancel octicon octicon-x';
            button.className = 'textEditor-button textEditor-button-change octicon octicon-check';
            area.className = 'textEditor-area';
            divWrapper.className = 'textEditor-wrap-area';
            node.classList.add('textEditor-hide');

            // register listeners
            cancelButton.addEventListener('click', close);
            button.addEventListener('click', function () {
                var val = area.value,
                    id = findClosestAncestorWithId(this).id,
                    ret = callChangeList(id, val, function (success) {
                    if (success) {
                        jsTextN.innerHTML = val;
                        close();
                    } else {
                        console.warn('textEditor:toTextareaNode text not accepted! Ignore changes.');
                    }
                });
            });
            node.addEventListener('dblclick', edit);

            // set titles
            node.setAttribute('title', texts.originText);
            cancelButton.setAttribute('title', texts.cancelBtn);
            button.setAttribute('title', texts.changeBtn);

            // append to wrapper div
            divWrapper.appendChild(area);
            buttonWrap.appendChild(cancelButton);
            buttonWrap.appendChild(button);

            // append to parent
            node.appendChild(divWrapper);

            // return click function
            return function () {
                if (!open) {
                    // show input
                    edit();
                } else {
                    // show text
                    close();
                }
            };
        }

        return {
            /**
             * Register a function to a specific editor.
             * If the function returns undefined than the editor expect that the passed callback
             * is called with true or false. If the method returns true the text will change.
             * If the method returns false the text is not changed.
             *
             * @param id
             * @param fc <- is called with (textValue, callbackFunction) can return undefined, false and true
             */
            onChange: function onChange(fc) {
                onChangeAllList.push(fc);
            },
            /**
             *
             * @param node
             * @param id
             */
            add: function add(node, obj) {
                var buttonWrap = document.createElement('div'),
                    editIconButton = document.createElement('div');
                buttonWrap.className = 'textEditor-buttonWrap';
                editIconButton.className = 'textEditor-button textEditor-button-edit octicon octicon-pencil';
                editIconButton.addEventListener('click', editWithTextarea(node, buttonWrap, obj));
                editIconButton.setAttribute('title', texts.editBtn);
                // append editIconButton to parent
                node.classList.add('textEditor-main-wrap');
                buttonWrap.appendChild(editIconButton);
                node.appendChild(buttonWrap);
            }
        };
    }();

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = textEditor;
    } else {
        canny.add('textEditor', textEditor);
    }
})();

},{}],20:[function(require,module,exports){
'use strict';

/*jslint browser: true */
/**
 * handle the connection between server and client
 */
var canny = require('canny');
var events = require('./events.js');
var shoe = require('shoe');
var dnode = require('dnode');
var connectionLost = require('./uiModules/connectionLost/index.js');

window.domOpts = window.domOpts || require('dom-opts');

/**
 * Some of the callbacks are handled via the registered controller - addController method.
 */
var trade = function () {
    "use strict";
    // ready queue call registered call backs when trade is ready

    var cbs = [],
        server,
        registeredController = [],

    // this flag should be true if there is a stable server connection
    hasServerConnection = false,
        tryToReconnect = false,
        connectionLostUi = connectionLost({
        onReload: function onReload() {
            return location.reload();
        },
        onReconnect: function onReconnect() {
            tryToReconnect = true;
            connectionLostUi.showProgress();
            stream = shoe('/trade');
            createConnection(function (userObject, sessionsEnabled) {
                if (userObject === null) {
                    // this is the case when the session ends on server side
                    connectionLostUi.render('RECONNECT_FAIL');
                } else {
                    connectionLostUi.destroy();
                    tryToReconnect = false;
                }
            });
        },
        onClose: function onClose() {
            connectionLostUi.destroy();
        }
    });
    var stream = shoe('/trade');
    var d = void 0;

    function init(s, fc) {
        server = s;

        if (server.setUserRights) {
            server.setUserRights(canny.cookieManager.forSessionCookie('translatron_session').getValues(), fc);
        } else {
            fc({ name: 'Logout', isAdmin: true }, false);
        }

        server.attachClientCallbacks(events.serverEvents);
        // call ready queue
        cbs.map(function (cb) {
            cb && cb();
            return null;
        });
    }

    function createConnection(fc) {
        d = dnode();
        d.on('remote', function (server) {
            hasServerConnection = true;
            init(server, fc);
        });
        d.on('fail', function (err) {
            console.log(err);
            hasServerConnection = false;
            connectionLostUi.render('CONNECTION_FAIL');
        });
        d.on('error', function (err) {
            console.log(err);
            // something happens
            // e.g. a UI update throws an exception
            hasServerConnection = false;
            connectionLostUi.render('EXCEPTION', err.name);
        });
        d.on('end', function (err) {
            // this is called if the connection is closes from server
            hasServerConnection = false;
            console.error('trade:end', err);
            // the setTimeout is for avoid flickering if page reload via e.g. F5
            if (tryToReconnect) connectionLostUi.render('RECONNECT_FAIL');else setTimeout(function () {
                return connectionLostUi.render('CONNECTION_END');
            }, 1000);
        });
        d.pipe(stream).pipe(d);
    }
    /**
     * Check if connection is available - otherwise send view error
     * @returns {boolean}
     */
    function isConnected() {
        if (hasServerConnection) return true;
        connectionLostUi.render('RECONNECT');
        return false;
    }

    /**
     *
     * @param functionName the function to call
     * @param args an array of parameters which are passed to the function
     */
    function callController(functionName, args) {
        registeredController.forEach(function (controller) {
            if (controller.hasOwnProperty(functionName)) {
                try {
                    console.log('controller:', functionName);
                    controller[functionName].apply(null, args);
                } catch (e) {
                    connectionLostUi.render('FATAL', e.message);
                    console.error(e);
                }
            }
        });
    }

    return {
        initialize: function initialize(fc) {
            createConnection(fc);
        },
        addController: function addController(obj) {
            registeredController.push(obj);
        },
        /**
         * Load the whole project files with all required data (project specific json)
         * @param {string} projectId
         * @param {function} cb
         */
        loadProject: function loadProject(projectId, cb) {
            server.loadProject(projectId, function (data, _ref) {
                var id = _ref.id,
                    name = _ref.name,
                    url = _ref.url;

                if (data) {
                    // overwrite project id
                    data.projectId = id;
                    data.project = name;
                    callController('onLoadProject', [data, { id: id, name: name, url: url }]);
                    cb && cb(null, data, { id: id, name: name, url: url });
                } else {
                    // callback a error so the caller has the control about error handling
                    cb && cb(false);
                }
            });
        },
        /**
         * actually same as saveKey but the internal controller call is different
         * @param projectId
         * @param language
         * @param keyAndValue
         * @param cb
         */
        createKey: function createKey(projectId, language, keyAndValue, cb) {
            if (isConnected()) server.saveKey(projectId, language, keyAndValue, function (err, key, value) {
                // TODO handle error case
                if (!err) {
                    cb(projectId, language, key, value);
                    callController('onCreateKey', [projectId, language, key, value]);
                }
            });
        },
        /**
         *
         * @param projectId
         * @param {{id :string, sourceCategory:string, targetCategory:string}} keyAndValue
         * @param cb
         */
        cloneKey: function cloneKey(projectId, keyAndValue, cb) {
            if (isConnected()) server.cloneKey(projectId, keyAndValue, function (err, projectId, data) {
                cb(err, projectId, data);
                callController('onKeyCloned', [projectId, data]);
            });
        },
        /**
         * Save changes to a key's value. Change will be broadcast to other clients.
         * @param {string} projectId
         * @param {string} language
         * @param {{key:string, value:string}} keyAndValue
         * @param {function} cb - callback to execute after saving
         */
        saveKey: function saveKey(projectId, language, keyAndValue, cb) {
            if (isConnected()) server.saveKey(projectId, language, keyAndValue, function (err, key, value) {
                // TODO handle error case
                if (!err) {
                    cb(projectId, language, key, value);
                }
            });
        },
        /**
         *
         * @param {string} projectName
         * @param currentDirId if of the directory in which the new project will be created
         */
        createNewProject: function createNewProject(projectName, currentDirId) {
            if (isConnected()) server.createNewProject(currentDirId, projectName, {}, function (err, projectData, project) {
                // TODO handle error case
                if (!err) {
                    callController('onNewProjectCreated', [projectData, project]);
                }
            });
        },
        /**
         *
         * @param {string} directoryName
         * @param {string} currentDirectory
         */
        createNewDirectory: function createNewDirectory(directoryName, currentDirectory) {
            if (isConnected()) server.createNewDirectory(directoryName, currentDirectory, function (err, directoryData) {
                // TODO handle error case
                if (!err) {
                    callController('onNewDirectoryCreated', [directoryData]);
                }
            });
        },
        /**
         * Renames a category.
         * @param {string} projectId
         * @param {string} oldName
         * @param {string} newName
         */
        renameCategory: function renameCategory(projectId, oldName, newName) {
            if (isConnected()) server.renameCategory(projectId, oldName, newName, function (err, oldName, newName) {
                if (!err) {
                    callController('renameCategory', [oldName, newName]);
                }
            });
        },
        /**
         * Removes a category with all it's child keys.
         * @param {string} projectId
         * @param {string} catName
         */
        removeCategory: function removeCategory(projectId, catName) {
            if (isConnected()) server.removeCategory(projectId, catName, function (err, catName) {
                if (!err) {
                    callController('removeCategory', [catName]);
                }
            });
        },
        /**
         * Renames a key for all languages
         * @param {string} projectId
         * @param {{newKey: string, oldKey: string}} obj
         */
        renameKey: function renameKey(projectId, obj) {
            if (isConnected()) server.renameKey(projectId, {
                newKey: obj.newKey,
                oldKey: obj.oldKey
            }, function (err, oldKey, newKey) {
                if (!err) {
                    callController('renameKey', [oldKey, newKey]);
                } else {
                    callController('renameKey', [false]);
                }
            });
        },
        /**
         * Removes a key for all languages.
         * @param {string} projectId
         * @param {string} keyName
         * @param {function} cb
         */
        removeKey: function removeKey(projectId, keyName, cb) {
            if (isConnected()) server.removeKey(projectId, keyName, function (err, keyName) {
                if (!err) {
                    cb(keyName);
                    callController('removeKey', [keyName]);
                }
            });
        },
        /**
         *
         * @param {string} projectId
         * @param {string} categoryName
         */
        removeImage: function removeImage(projectId, categoryName) {
            if (isConnected()) server.removeImage(projectId, categoryName, function (err, categoryName) {
                if (!err) {
                    callController('imageRemoved', [categoryName]);
                } else {
                    toast.showMessage(err.message);
                }
            });
        },
        /**
         *
         * Get the contents of the directory.
         *
         * @param dir the selected directory.
         * @param cb {projects:[String]:dirs:[String]}
         */
        getDirectory: function getDirectory(dir, cb) {
            if (isConnected()) server.getDirectory(dir, function (err, args) {
                if (err !== null) {
                    toast.showMessage('Internal server error! Please report this message to a developer: ' + err.message);
                    console.error(err.message);
                    return;
                }
                // only call the controller if not false
                cb && cb(args);
                if (args !== false) {
                    callController('getDirectory', [args]);
                }
            });
        },
        /**
         * save the project description
         * @param projectId
         * @param id
         * @param description
         * @param callback
         */
        saveProjectDescription: function saveProjectDescription(projectId, id, description, callback) {
            if (isConnected()) server.saveProjectDescription(projectId, id, description, function (err) {
                if (!err) {
                    callback && callback(true);
                    callController('savedProjectDescription', []);
                } else {
                    callback && callback(false);
                }
            });
        },
        /**
         * TODO summarize projectName + currentDirId to one projectId
         * Delete a project.
         * @param projectName
         * @param currentDirId - @deprecated
         * @param callback
         */
        deleteProject: function deleteProject(id, cb) {
            if (isConnected()) {
                server.deleteProject(id, function (err, project) {
                    if (!err) {
                        // TODO change to: prjName
                        cb && cb(null, project);
                        callController('projectDeleted', [project]);
                    } else {
                        cb && cb(err);
                    }
                });
            }
        },
        /**
         * Delete a project.
         * @param dirName
         * @param currentDirId
         * @param callback
         */
        deleteFolder: function deleteFolder(dirName, currentDirId, callback) {
            if (isConnected()) server.deleteFolder(currentDirId, dirName, function (err, dirName) {
                if (!err) {
                    callback && callback(null, dirName);
                    callController('folderDeleted', [dirName]);
                } else {
                    callback && callback(err);
                }
            });
        },
        // Not really tested
        ready: function ready(cb) {
            if (server) {
                cb();
            } else {
                cbs.push(cb);
            }
        }
    };
}();

module.exports = trade;

},{"./events.js":16,"./uiModules/connectionLost/index.js":28,"canny":50,"dnode":61,"dom-opts":63,"shoe":78}],21:[function(require,module,exports){
"use strict";

var uiEvent = function () {
    var eventQueues = {
        activateLanguage: [],
        deActivateLanguage: [],
        addLanguage: [],
        showExportDialog: [],
        projectSelected: [],
        showOverviewPage: [],
        updateKey: [],
        anchorFocus: [],
        enableEditorMode: [],
        toggleWordCount: [],
        showFileUpload: [],
        showJMBFUploader: [],
        showJSONImport: [],
        JMBFFileUploaded: [],
        jsonImported: [],
        fileUploaded: []
    };
    return {
        addUiEventListener: function addUiEventListener(obj) {
            Object.keys(obj).forEach(function (key) {
                if (eventQueues.hasOwnProperty(key)) {
                    eventQueues[key].push(obj[key]);
                }
            });
        },
        callUievent: function callUievent(eventName, args) {
            var argsList = [].slice.call(arguments, 1, arguments.length);
            if (eventQueues.hasOwnProperty(eventName)) {
                eventQueues[eventName].forEach(function (fc) {
                    fc.apply(null, argsList);
                });
            }
        }
    };
}();

module.exports = uiEvent;

},{}],22:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    console.log('c-upload:trigger upload');
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],23:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],24:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

/**
 * anchorMenu
 *
 * TODO show the actual frame:
 *  * detect which dome categories in dom are in view and add a classes to the menu ul category.
 *      * the expected effect will be look like a frame which categories are in view
 *      * first-child border-top last-child border bottom and the rest border left and right will give a frame effect
 *
 *  do it for all c-anchorMenu-parent element which could be found in view
 *
 * The anchor menu shows all elements which have the class c-anchorMenu-parent as parent and searches for children
 * with class c-anchorMenu-child. It renders a ul li list and registered a click call to throw a click event with the id.
 *
 * @type {exports}
 */
var util = require('../util/url'),
    translationViewConfig = require('./translationView').config,
    rootNode,
    parentNodeList = [],
    _onSelect = function onSelect() {},
    shrinkOffsetForViewDetection = 100,
    highlightTopMostKey = function () {

    var highlightedItem;

    /**
     * check if node is aligned top most in the browser view
     * @param obj
     */
    return function () {

        var firstOpenCategory = rootNode.querySelector('li.c-inView'),
            currentMainViewCategoryNode,
            currentMainViewCategoryChildNodes,
            mainViewTopMostKeyNode;

        if (!firstOpenCategory) {
            return;
        }

        // Reset previous highlighted item
        if (highlightedItem) {
            highlightedItem.classList.remove('c-key-highlight');
        }

        // Highlight topmost item
        currentMainViewCategoryNode = document.body.querySelector('#' + translationViewConfig.rowPrefix + firstOpenCategory.attributes.data.nodeValue.replace('anchor_', ''));
        if (currentMainViewCategoryNode) {
            currentMainViewCategoryChildNodes = currentMainViewCategoryNode.querySelectorAll('.c-anchorMenu-child');
            mainViewTopMostKeyNode = getFirstElementInViewport(currentMainViewCategoryChildNodes);
        } else {
            console.error('anchorMenu:Can\'t find the category node with id', translationViewConfig.rowPrefix + firstOpenCategory.attributes.data.nodeValue.replace('anchor_', ''));
        }

        if (mainViewTopMostKeyNode) {
            highlightedItem = rootNode.querySelector('[data=anchor_' + mainViewTopMostKeyNode.id.replace(translationViewConfig.rowPrefix, '') + ']');
            if (highlightedItem) {
                highlightedItem.classList.add('c-key-highlight');
            }
        }
    };
}();

function _focusElement(id, elem) {
    var dom;
    // handle the active class from menu
    [].slice.call(rootNode.querySelectorAll('.c-active')).forEach(function (n) {
        n.classList.remove('c-active');
    });
    elem.classList.add('c-active');
    elem.parentNode.parentNode.classList.add('c-active');
    // handle the common dom active class
    [].slice.call(document.querySelectorAll('.c-anchorMenu-focus')).forEach(function (n) {
        n.classList.remove('c-anchorMenu-focus');
    });
    dom = document.getElementById(translationViewConfig.rowPrefix + id);
    if (dom) {
        dom.classList.add('c-anchorMenu-focus');
    } else {
        console.log('anchorMenu:focusElement can\'t find element for a anchor', id);
    }
}
/**
 *
 * @param items [{id : string, children : [string]}]
 */
function addItems(root, items) {
    var ul = document.createElement('ul'),
        anchor = util.getAnchor();
    root.appendChild(ul);
    items.forEach(function (catObj) {
        var li = document.createElement('li'),
            span = document.createElement('span');
        // TODO check with log
        if ((typeof catObj === 'undefined' ? 'undefined' : _typeof(catObj)) !== 'object') {
            console.error('anchorMenu:category needs to be an object', catObj);
        }
        span.appendChild(document.createTextNode(catObj.id));
        li.appendChild(span);
        li.setAttribute('data', 'anchor_' + catObj.id);
        span.addEventListener('click', function () {
            _onSelect(catObj.id);
            _focusElement(catObj.id, li);
        });

        if (catObj.children) {
            addItems(li, catObj.children);
        }
        ul.appendChild(li);
        if ('#' + catObj.id === anchor) {
            _focusElement(catObj.id, li);
        }
    });
}

/**
 * check is the node is in the view
 * @param node
 */
function isNodeInView(node) {
    var yOffset = window.scrollY || window.pageYOffset,
        w = {
        top: yOffset,
        bottom: yOffset + window.innerHeight
    },
        bodyRect = document.body.getBoundingClientRect(),
        elemRect = node.getBoundingClientRect(),
        offset = elemRect.top - bodyRect.top + shrinkOffsetForViewDetection,
        nodeHeight = offset + node.offsetHeight - shrinkOffsetForViewDetection * 2;
    return offset > w.top && offset < w.bottom || // is top frame in view
    nodeHeight > w.top && nodeHeight < w.bottom || // is bottom frame in view
    offset < w.top && nodeHeight > w.bottom; // is top frame above view and bottom frame below view
}

function cutCategories(val) {
    var split = val.split('_');
    if (split.length > 1) {
        split.splice(0, 1);
    }
    return {
        id: val,
        value: split.join('_')
    };
}

function expandCategoriesInView() {
    parentNodeList.forEach(function (obj) {
        var li = rootNode.querySelector('[data=anchor_' + obj.id + ']');
        if (isNodeInView(obj.node)) {
            li.classList.add('c-inView');
        } else {
            li.classList.remove('c-inView');
        }
    });
}

function getFirstElementInViewport(nodes) {
    var keyNode,
        pageScrollOffset = document.body.scrollTop || document.documentElement && document.documentElement.scrollTop,
        i = nodes.length,
        nodeMargin;

    while (i--) {
        keyNode = nodes[i];
        nodeMargin = parseInt(window.getComputedStyle(keyNode, null).marginBottom, 10);
        if (getPageOffsetForElement(keyNode) - nodeMargin * 2 <= pageScrollOffset) {
            return keyNode;
        }
    }

    // Return first key node for current active category
    return nodes[0];
}

function getPageOffsetForElement(elem) {
    var bodyRect = document.body.getBoundingClientRect(),
        elemRect = elem.getBoundingClientRect();
    return elemRect.top - bodyRect.top;
}

module.exports = {
    focusElement: function focusElement(id) {
        var li = rootNode.querySelector('[data=anchor_' + id + ']');
        if (li) {
            _focusElement(id, li);
        }
    },
    onSelect: function onSelect(fc) {
        _onSelect = fc;
    },
    renderMenu: function renderMenu() {
        var catObj = [];
        // clear parent node list
        parentNodeList = [];

        [].slice.call(document.querySelectorAll('.c-anchorMenu-parent')).forEach(function (parent) {
            var id = parent.getAttribute('id'),
                children = [];
            if (id) {
                id = id.replace(translationViewConfig.rowPrefix, '');
                // collect parents
                parentNodeList.push({ node: parent, id: id });

                [].slice.call(parent.querySelectorAll('.c-anchorMenu-child')).forEach(function (child) {
                    var id = child.getAttribute('id');
                    if (id) {
                        children.push(cutCategories(id.replace(translationViewConfig.rowPrefix, '')));
                    }
                });
                catObj.push({ id: id, children: children });
            }
        });
        [].slice.call(rootNode.children).forEach(function (child) {
            child.parentNode.removeChild(child);
        });
        addItems(rootNode, catObj);
        rootNode.children[0].style.height = window.innerHeight - 125 + 'px';

        // time delayed trigger the init view
        setTimeout(function () {
            expandCategoriesInView();
            highlightTopMostKey();
        }, 1000);
    },
    add: function add(node, attr) {
        rootNode = node;
    },
    ready: function ready() {
        window.addEventListener('scroll', function (e) {
            expandCategoriesInView();
            highlightTopMostKey();
        });
        window.addEventListener('resize', function () {
            if (rootNode.children[0]) {
                rootNode.children[0].style.height = window.innerHeight - 125 + 'px';
            }
        });
        // init the menu with a time delay
        setTimeout(function () {
            expandCategoriesInView();
            highlightTopMostKey();
        }, 1500);
    }
};

},{"../util/url":44,"./translationView":39}],25:[function(require,module,exports){
'use strict';

var _onLogout = function onLogout() {
    console.log('auth:onLogout is not handled');
},
    brain = {
    logoutButton: function logoutButton(node) {
        node.addEventListener('click', _onLogout);
    }
};

module.exports = {
    onLogout: function onLogout(fc) {
        _onLogout = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr](node);
        }
    }
};

},{}],26:[function(require,module,exports){
'use strict';

var repeatFcPointer,
    _onClick = function onClick(item) {
    console.warn('breadcrumb:click handler not registered', item);
};

module.exports = {
    onClick: function onClick(fc) {
        _onClick = fc;
    },
    add: function add(node, attr) {},
    /**
     *
     * @param parentDirectories [String]
     */
    updateFolders: function updateFolders(parentDirectories) {
        repeatFcPointer(parentDirectories.map(function (item) {
            return { name: item.name, onClick: function onClick() {
                    _onClick(item.id);
                } };
        }));
    },
    /**
     * for canny repeat to get
     */
    registerCannyRepeat: function registerCannyRepeat(fc) {
        repeatFcPointer = fc;
    }
};

},{}],27:[function(require,module,exports){
module.exports = "<div class=\"connectionLost\">\n  <section>\n    <i class=\"octicon octicon-plug\"></i>\n    <h2>{{item.title}}</h2>\n    <div class=\"errorCode\"><p>Error code: <strong>{{item.errorCode}}</strong><span class=\"errorMessage\" wk-bind=\"item.errorMessage\"></span></p></div>\n    <div class=\"button-section\">\n      <button class=\"reconnect\" wk-bind=\"item.reconnect\" title=\"Try to reconnect your changes will be overwritten\">reconnect</button>\n      <button class=\"close\" wk-bind=\"item.close\" title=\"You can close this view to rescure you changes manually\">close</button>\n      <button class=\"reload\" wk-bind=\"item.reload\" title=\"If you do a page reload all your unsaved changes will be lost\">reload page</button>\n    </div>\n  </section>\n  <div class=\"progressUi\"></div>\n</div>";

},{}],28:[function(require,module,exports){
'use strict';

var whisker = require('canny/mod/whisker');
var template = require('./index.html');
var TEXTS = function TEXTS(code) {
    switch (code) {
        case 'EXCEPTION':
            return 'wow... not good - please report this problem to a developer';
        case 'FATAL':
            return 'dammed... this should not happen - please consult dev of trust';
        case 'AUTH':
            return 'Session timeout please login again';
        case 'RECONNECT_FAIL':
            return 'can\'t create a connection';
        default:
            return 'whooops... server connection lost';
    }
};
/**
 *
 * @param onReload
 * @param onReconnect
 * @returns {{render: (function(string)), destroy: (function())}}
 */
module.exports = function (_ref) {
    var onReload = _ref.onReload,
        onReconnect = _ref.onReconnect,
        onClose = _ref.onClose;

    // saves the active node
    var ui = void 0;

    function _render(_ref2) {
        var errorCode = _ref2.errorCode,
            _errorMessage = _ref2.errorMessage;

        if (ui) ui.remove();
        var d = document.createElement('div');
        d.innerHTML = template;
        whisker.add(d.children[0], {
            reconnect: function reconnect(n) {
                if (errorCode === 'RECONNECT_FAIL' || errorCode === 'FATAL' || errorCode === 'AUTH' || errorCode === 'SERVER_DOWN' || errorCode === 'EXCEPTION') return false;
                n.addEventListener('click', onReconnect);
            },
            close: function close(n) {
                return n.addEventListener('click', onClose);
            },
            reload: function reload(n) {
                return n.addEventListener('click', onReload);
            },
            errorCode: errorCode,
            title: TEXTS(errorCode),
            errorMessage: function errorMessage(n) {
                if (_errorMessage) {
                    n.innerHTML = ' ' + _errorMessage;
                } else return false;
            }
        });
        document.body.appendChild(ui = d.children[0]);
    }

    return {
        /**
         * Show the module
         * @param {string} err - error code to print on the view
         */
        render: function render(err, msg) {
            return _render({ errorCode: err, errorMessage: msg });
        },
        /**
         * Remove the module from ui
         */
        destroy: function destroy() {
            ui.remove();
            ui = undefined;
        },
        /**
         * indicates that the view is busy
         */
        showProgress: function showProgress() {
            ui.classList.add('progress');
        }
    };
};

},{"./index.html":27,"canny/mod/whisker":54}],29:[function(require,module,exports){
'use strict';

var _onCreateNewProject = function onCreateNewProject() {
    console.warn('createNewProject.onCreateNewProject not set');
},
    onCreateNewDirectory = function onCreateNewDirectory() {
    console.warn('createNewProject.onCreateNewDirectory not set');
};

var projectNameInputNode, directoryNameInputNode;

function isValidProjectName(projectName) {
    return projectName.length > 0 && projectName.search('\\.|,| ') === -1 ? true : false;
}

function isValidDirectoryName(directoryName) {
    // TBD more forbidden characters?
    return directoryName.length > 0 && directoryName.search('/') === -1 ? true : false;
}

module.exports = {
    add: function add(node, attribute) {
        switch (attribute) {
            case 'createNewProjectInputProject':
                projectNameInputNode = node;
                break;
            case 'newDirectoryNameInput':
                directoryNameInputNode = node;
                break;
            case 'createNewProjectSubmit':
                node.addEventListener('click', function () {
                    var projectName = projectNameInputNode.value;
                    if (isValidProjectName(projectName)) {
                        _onCreateNewProject(projectName);
                    } else {
                        projectNameInputNode.classList.add('error');
                    }
                });
                break;
            case 'createNewDirectorySubmit':
                node.addEventListener('click', function () {
                    var directoryName = directoryNameInputNode.value;
                    if (isValidDirectoryName(directoryName)) {
                        onCreateNewDirectory(directoryName);
                    } else {
                        directoryNameInputNode.classList.add('error');
                    }
                });
                break;
            case 'cancel':
                node.addEventListener('click', function () {
                    canny.displayManager.hide(this.dataset.view);
                });
                break;
        }
    },
    /**
     * Pass in listener for execution of creating new project.
     * @param func
     */
    onCreateNewProject: function onCreateNewProject(func) {
        _onCreateNewProject = func;
    },
    /**
     * Pass in listener for execution of creating a new directory.
     * @param func
     */
    onCreateNewDirectoy: function onCreateNewDirectoy(func) {
        onCreateNewDirectory = func;
    }
};

},{}],30:[function(require,module,exports){
'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Overlay = require('./overlay'),
    displayManager = function displayManager() {

	var mainController = canny.flowControl,
	    overlayController = canny.flowControl.createNewInstance('overlays'),
	    children = {
		overlay: {
			ids: [],
			controller: overlayController,
			add: function add(node, id) {

				var overlay = new Overlay(node, id);
				overlay.onClick(function () {
					setDisplayStateById(id, false);
				});

				this.controller.add(overlay.node, {
					'view': overlay.id
				});
				this.ids.push(overlay.id);
			}
		},
		view: {
			ids: [],
			controller: mainController,
			add: function add(node, id) {
				this.controller.add(node, {
					'view': id
				});
				this.ids.push(id);
			}
		}
	};

	function setDisplayStateById(id, show) {
		Object.keys(children).map(function (type) {
			var pool = children[type],
			    ids = pool.ids,
			    currentId;

			for (var i = 0; i < ids.length; i++) {
				currentId = ids[i];
				if (id === currentId) {
					if (show) {
						pool.controller.show(currentId);
					} else if (pool.controller.mod[id]) {
						pool.controller.mod[id].forEach(function (obj) {
							obj.hide();
						});
					}
					break;
				}
			}
		});
	}

	return {
		add: function add(node, descriptor) {
			var keys, key;
			if ((typeof descriptor === 'undefined' ? 'undefined' : _typeof(descriptor)) === 'object') {
				keys = Object.keys(descriptor);
				for (var i = 0; i < keys.length; i++) {
					key = keys[i];
					if (children.hasOwnProperty(key)) {
						children[key].add(node, descriptor[key]);
					}
				}
			} else {
				console.warn('Parameter to add child to displayManager is not valid: ' + descriptor);
			}
		},
		show: function show(id) {
			setDisplayStateById(id, true);
		},
		hide: function hide(id) {
			setDisplayStateById(id, false);
		}

	};
};

module.exports = displayManager;

},{"./overlay":35}],31:[function(require,module,exports){
'use strict';

/**
 * handles all texts
 */
var domOpts = require('dom-opts'),
    flagMap = {
    da: 'dk',
    de: 'de',
    fr: 'fr',
    nl: 'nl',
    en: 'us',
    en_GB: 'gb',
    sv: 'se',
    es: 'es'
};

function getLang(lang) {
    var flagLang = lang;
    if (flagMap.hasOwnProperty(lang)) {
        flagLang = flagMap[lang];
    }
    return flagLang;
}

module.exports = {
    getFlag: function getFlag(lang) {
        return domOpts.createElement('span', null, 'flag-icon flag-icon-' + getLang(lang));
    },
    getFlagClasses: function getFlagClasses(lang) {
        return ['flag-icon', 'flag-icon-' + getLang(lang)];
    }
};

},{"dom-opts":63}],32:[function(require,module,exports){
'use strict';

/*global ace */
/*jslint browser: true */
var trade = require('../trade.js'),
    events = require('../events.js'),
    C = require('../CONST.js');

window.domOpts = window.domOpts || require('dom-opts');

var imageViewer = function () {
    "use strict";

    var nodeToAppend,
        init = false,
        config = {
        idPrefix: 'imageViewer_'
    },
        setupContainerCSS = function setupContainerCSS(node, css) {
        for (var prop in css) {
            node.style[prop] = css[prop];
        }
    },
        settings = {
        maxWidth: 300,
        maxHeight: 300
    },
        fc = {
        hideImageViewer: function hideImageViewer() {
            var pres = nodeToAppend.domChildTags('img');

            if (pres.length > 0) {
                // there are other open images
                pres.forEach(function (e) {
                    e.domAddClass('hidden');
                });
            }
        },
        showImage: function showImage(obj) {
            var img,
                id = config.idPrefix + obj.id,
                actualImg = document.getElementById(id);

            if (actualImg !== null) {
                actualImg.domRemoveClass('hidden');
            } else {
                img = new Image();
                img.onload = function () {
                    console.log('DONE IMAGE');
                };
                img.src = "data:image/png;base64," + obj.data;
                setupContainerCSS(img, {
                    maxWidth: '100%',
                    maxHeight: '100%'
                });
                img.setAttribute('id', id);
                img.domAppendTo(nodeToAppend);
            }
        }
    };

    events.addServerListener('sendFile', function (obj) {
        if (init) {
            fc.hideImageViewer();

            if (obj.fileType === C.FILE_MANAGER.FILE_TYPES.IMAGE) {
                fc.showImage(obj);
            }
        }
    });

    return {
        add: function add(node, attr) {
            init = true;
            nodeToAppend = node;
            nodeToAppend.setAttribute('id', 'imageViewer');

            setupContainerCSS(nodeToAppend, {
                width: settings.maxWidth + 'px',
                height: settings.maxHeight + 'px'
            });
        },
        setup: function setup(config) {
            var obj;
            for (obj in config) {
                settings[obj] = config[obj];
            }
        }
    };
}();

module.exports = imageViewer;

},{"../CONST.js":1,"../events.js":16,"../trade.js":20,"dom-opts":63}],33:[function(require,module,exports){
'use strict';

function addEdit(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button edit octicon octicon-pencil');
    div.addEventListener('click', function (event) {
        node.classList.add('c-edit');
        fc(event);
    });
    div.setAttribute('title', 'edit');
    node.appendChild(div);
}
function addCancel(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button cancel octicon octicon-x');
    div.addEventListener('click', function (event) {
        node.classList.remove('c-edit');
        fc(event);
    });
    div.setAttribute('title', 'cancel');
    node.appendChild(div);
}

function addSave(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button save octicon octicon-check');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'save changes');
    node.appendChild(div);
}

function addClone(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button save octicon octicon-file-symlink-file');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'move key into other category');
    node.appendChild(div);
}

function addDelete(node, fc) {
    var div = domOpts.createElement('div', null, 'inputEditManager-button delete octicon octicon-trashcan');
    div.addEventListener('click', function (event) {
        fc(event);
    });
    div.setAttribute('title', 'remove this key');
    node.appendChild(div);
}

function closeEditorView(keyInputNode) {
    var editorPanelNode = keyInputNode.parentNode.querySelector('.inputEditManager.wrap');
    if (editorPanelNode) {
        editorPanelNode.classList.remove('c-edit');
    }
}

module.exports = {
    /**
     * each key input node hast
     * @param keyInputNode
     */
    closeEditView: function closeEditView(keyInputNode) {
        if (keyInputNode) {
            closeEditorView(keyInputNode);
        }
    },
    addEditorPanel: function addEditorPanel(keyNode, listeners) {
        var containerNode = domOpts.createElement('div', null, 'inputEditManager wrap');

        if (listeners.hasOwnProperty('onEdit')) {
            addEdit(containerNode, listeners.onEdit);
        }
        if (listeners.hasOwnProperty('onDelete')) {
            addDelete(containerNode, listeners.onDelete);
        }
        if (listeners.hasOwnProperty('onSave')) {
            addSave(containerNode, listeners.onSave);
        }
        if (listeners.hasOwnProperty('onClone')) {
            addClone(containerNode, listeners.onClone);
        }
        if (listeners.hasOwnProperty('onCancel')) {
            addCancel(containerNode, listeners.onCancel);
        }

        containerNode.domAppendTo(keyNode);

        return containerNode;
    },
    removePanel: function removePanel(node) {
        node.querySelector('.inputEditManager.wrap').domRemove();
    }
};

},{}],34:[function(require,module,exports){
'use strict';

var rootNode;

module.exports = {
    show: function show() {
        rootNode.classList.add('c-show');
    },
    hide: function hide() {
        rootNode.classList.remove('c-show');
    },
    add: function add(node, attr) {
        if (attr === 'button') {
            node.addEventListener('click', function () {
                if (rootNode.classList.contains('c-show')) {
                    rootNode.classList.remove('c-show');
                } else {
                    rootNode.classList.add('c-show');
                }
            });
        } else {
            rootNode = node;
        }
    }
};

},{}],35:[function(require,module,exports){
'use strict';

module.exports = function Overlay(node, id) {

	var id = id,
	    node = node,
	    clickHandler = function clickHandler() {
		console.warn('Click listener not attached for overlay with id: ' + id);
	};

	node.classList.add('displayManager-overlay');
	node.addEventListener('click', function (e) {
		if (node === e.target) {
			clickHandler();
		}
	});

	return {
		id: id,
		node: node,
		onClick: function onClick(cb) {
			clickHandler = cb;
		}
	};
};

},{}],36:[function(require,module,exports){
'use strict';

/*global */
/*jslint browser: true*/

var canny = require('canny'),
    flag = require('./flag'),
    texts = require('./texts');

/**
 * E.g.: canny-mod="flowControl" canny-var="{'view' : 'viewToShow'}"
 *
 * you can activate a initial view with a anchor in the URL e.g.: yourdomain.html#viewToShow
 * Or pass a comma separated module list for activate more module #viewToShow,otherView
 *
 * TODO made it possible to summarize views with one identifier.
 * Instead of call: gdom.flowControl.show('view1', 'view2', 'view3') call gdom.flowControl.show('view').
 */
var projectMainNavigation = function () {
    "use strict";

    var mainNode,
        selectLanguageQueue = [],
        onShowJSONQueue = [],
        onEnableEditorModeQueue = [],
        onToggleWordCountQueue = [],
        onShowJMBFQueue = [],
        onShowJMBFUploaderQueue = [],
        onShowJSONImportQueue = [],
        bundleName = window.domOpts.params.bundle,
        modViews = {
        main: function main(node) {
            mainNode = node;
        },
        menuToggleButton: function menuToggleButton(node) {
            new svgIcon(node, {
                hamburgerCross: {
                    url: '/dist/animatedSVG/svg/hamburger.svg',
                    animation: [{
                        el: 'path:nth-child(1)',
                        animProperties: {
                            from: { val: '{"path" : "m 5.0916789,20.818994 53.8166421,0"}' },
                            to: { val: '{"path" : "M 12.972944,50.936147 51.027056,12.882035"}' }
                        }
                    }, {
                        el: 'path:nth-child(2)',
                        animProperties: {
                            from: { val: '{"transform" : "s1 1", "opacity" : 1}', before: '{"transform" : "s0 0"}' },
                            to: { val: '{"opacity" : 0}' }
                        }
                    }, {
                        el: 'path:nth-child(3)',
                        animProperties: {
                            from: { val: '{"path" : "m 5.0916788,42.95698 53.8166422,0"}' },
                            to: { val: '{"path" : "M 12.972944,12.882035 51.027056,50.936147"}' }
                        }
                    }]
                }
            }, {
                easing: mina.elastic, speed: 1200, size: { w: '4em', h: '3em' }
            });
            node.addEventListener('click', function () {
                if (mainNode.classList.contains('c-open')) {
                    mainNode.classList.remove('c-open');
                } else {
                    mainNode.classList.add('c-open');
                }
            });
        },
        showResourceBundleEditor: function showResourceBundleEditor(node) {
            // reload the page because the files are not synced
            node.setAttribute('href', '#');
            node.addEventListener('click', function () {
                location.reload();
            });
        },
        showMessageBundleFormat: function showMessageBundleFormat(node) {
            node.addEventListener('click', function () {
                onShowJMBFQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJSONBundle: function showJSONBundle(node) {
            node.addEventListener('click', function () {
                onShowJSONQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJMBFUploader: function showJMBFUploader(node) {
            node.addEventListener('click', function () {
                onShowJMBFUploaderQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        showJSONImport: function showJSONImport(node) {
            node.addEventListener('click', function () {
                onShowJSONImportQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        enableEditorMode: function enableEditorMode(node) {
            node.addEventListener('click', function () {
                onEnableEditorModeQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        toggleWordCount: function toggleWordCount(node) {
            node.addEventListener('click', function () {
                onToggleWordCountQueue.forEach(function (fc) {
                    fc();
                });
            });
        },
        from: function from(node) {
            this.from.node = node;
        },
        to: function to(node) {
            this.to.node = node;
        }
    };

    /**
     *
     * @param locales []
     * @param node
     */
    function setLocale(locales, node) {
        var ul = node.querySelector('.languages'),
            li,
            languageNameNode,
            progressNode,
            flagIC;
        if (ul) {
            // remove all existing children first
            [].slice.call(ul.querySelectorAll('li')).forEach(function (elem) {
                ul.removeChild(elem);
            });
        } else {
            ul = window.domOpts.createElement('ul', null, 'navigationMenu languages');
        }
        locales.forEach(function (key) {
            var numOfTransKeys = window.domOpts.createElement('span', null, 'numOfTransKeys'),
                maxKeyNode = window.domOpts.createElement('span', null, 'maxKey');
            li = window.domOpts.createElement('li');
            languageNameNode = window.domOpts.createElement('span');
            progressNode = window.domOpts.createElement('span', null, 'progress');
            numOfTransKeys.appendChild(document.createTextNode('-'));
            numOfTransKeys.domAppendTo(progressNode);
            progressNode.appendChild(document.createTextNode('/'));
            maxKeyNode.appendChild(document.createTextNode('-'));
            maxKeyNode.domAppendTo(progressNode);

            li.classList.add('lang');
            li.classList.add(key);

            li.addEventListener('click', function () {
                var isInactive = true,
                    isActive = this.classList.contains('c-active');

                if (isActive) {
                    this.classList.toggle('c-inactive');
                    isInactive = this.classList.contains('c-inactive');
                } else {
                    // has no state
                }

                selectLanguageQueue.forEach(function (fc) {
                    fc({
                        isActive: isActive,
                        isInactive: isInactive,
                        project: bundleName,
                        language: key
                    });
                });
            });

            languageNameNode.innerHTML = texts.getLanguageNames(key);
            languageNameNode.className = 'langName';
            languageNameNode.domAppendTo(li);
            progressNode.domAppendTo(li);
            flagIC = flag.getFlag(key);
            flagIC.classList.add('icon', 'octicon', 'octicon-plus');
            flagIC.domAppendTo(li);
            li.domAppendTo(ul);
        });
        ul.domAppendTo(node);
    }

    /**
     * update all language max keys for all languages
     * @param keys
     * @param node
     */
    function updateMaxKeys(keys, node) {
        [].slice.call(node.querySelectorAll('.languages .lang')).forEach(function (langNode) {
            langNode.querySelector('.maxKey').innerHTML = keys;
        });
    }

    /**
     * update a specific language
     * @param key
     * @param lang
     * @param node
     */
    function updateNumberOfLangKeys(key, lang, node) {
        console.log('projectMainNavigation:updateNumberOfLangKeys', key, lang);
        node.querySelector('.languages .lang.' + lang + ' .numOfTransKeys').innerHTML = key;
    }

    return {
        setNumberOfTranslationMaxKeys: function setNumberOfTranslationMaxKeys(maxKeys) {
            updateMaxKeys(maxKeys, modViews.from.node);
        },
        setNumberOfTranslatedLanguageKey: function setNumberOfTranslatedLanguageKey(numberOfKeys, lang) {
            updateNumberOfLangKeys(numberOfKeys, lang, modViews.from.node);
        },
        onLanguageSelect: function onLanguageSelect(fc) {
            selectLanguageQueue.push(fc);
        },
        onShowJSON: function onShowJSON(fc) {
            onShowJSONQueue.push(fc);
        },
        onShowJMBF: function onShowJMBF(fc) {
            onShowJMBFQueue.push(fc);
        },
        onShowJMBFUploader: function onShowJMBFUploader(fc) {
            onShowJMBFUploaderQueue.push(fc);
        },
        onShowJSONImport: function onShowJSONImport(fc) {
            onShowJSONImportQueue.push(fc);
        },
        onEnableEditorMode: function onEnableEditorMode(fc) {
            onEnableEditorModeQueue.push(fc);
        },
        onToggleWordCount: function onToggleWordCount(fc) {
            onToggleWordCountQueue.push(fc);
        },
        activateLang: function activateLang(lang) {
            var node = mainNode.querySelector('li.' + lang);
            node.classList.remove('c-inactive');
            node.classList.add('c-active');
        },
        deActivateLang: function deActivateLang(lang) {
            var node = mainNode.querySelector('li.' + lang);
            node.classList.add('c-inactive');
        },
        /**
         * Apply the current project's number to the flags: activate flag where translations exist and show number of
         * translated keys.
         * @param keysTotal the total number of keys
         * @param translatedKeysPerLang the number of translated keys per language
         */
        setActivatedProjectLanguages: function setActivatedProjectLanguages(keysTotal, translatedKeysPerLang) {
            [].slice.call(mainNode.querySelectorAll('li')).forEach(function (node) {
                var progressNode = node.querySelector('.progress');
                node.classList.remove('c-active');
                if (progressNode) {
                    progressNode.children[0].innerHTML = "-";
                    progressNode.children[1].innerHTML = "-";
                }
            });

            Object.keys(translatedKeysPerLang).forEach(function (key) {
                [].slice.call(mainNode.querySelectorAll('li.' + key)).forEach(function (node) {
                    var progressNode = node.querySelector('.progress');
                    node.classList.add('c-active');
                    if (progressNode) {
                        progressNode.children[0].innerHTML = translatedKeysPerLang[key];
                        progressNode.children[1].innerHTML = keysTotal;
                    }
                });
            });
        },
        setAvailableLanguages: function setAvailableLanguages(languages) {
            setLocale(languages, modViews.from.node);
        },
        ready: function ready() {
            console.log('nav-controller ready event');
        },
        add: function add(node, attr) {
            // part of api
            if (modViews.hasOwnProperty(attr)) {
                modViews[attr](node);
            } else {
                console.log('LINK NOT IMPLEMENTED');
            }
        }
    };
}();

module.exports = projectMainNavigation;

},{"./flag":31,"./texts":38,"canny":50}],37:[function(require,module,exports){
'use strict';

var projectOverview = function () {
    'use strict';

    var componentRootNode,
        renderProjectsAndDirectoriesList,
        _onCreateProjectPressed = function onCreateProjectPressed() {
        console.warn('projectOverview.onCreateProjectPressed not set');
    },
        _onParentDirectorySelected = function onParentDirectorySelected() {
        console.warn('projectOverview.onParentDirectorySelected not set');
    },
        _onProjectSelected = function onProjectSelected() {
        console.warn('projectOverview.onProjectSelected not set');
    },
        _onDeleteProjectPressed = function onDeleteProjectPressed() {
        console.warn('projectOverview.onDeleteProjectPressed not set');
    },
        _onDeleteFolderPressed = function onDeleteFolderPressed() {
        console.warn('projectOverview.onDeleteFolderPressed not set');
    },
        _onDirectorySelected = function onDirectorySelected() {
        console.warn('projectOverview.onDirectorySelected not set');
    },
        _onCreateDirectoryPressed = function onCreateDirectoryPressed() {
        console.warn('projectOverview.onCreateDirectoryPressed not set');
    },
        editModeEnabled = false;

    return {
        /**
         * Called from canny when registering components. The only component which we expect to be registered is
         * "projectOverviewContainer" (the root node of the component).
         * @param node
         * @param vars
         */
        add: function add(node, attr) {
            if (componentRootNode === undefined) {
                componentRootNode = node;
            } else {
                console.warn('projectOverview:add multiple views detected - it should be registered only ones in the DOM!');
            }
        },
        /**
         * Called from canny on documentReady event.
         */
        ready: function ready() {

            var createProjectButtonNode = componentRootNode.querySelector('.js-createProjectButton');
            if (!createProjectButtonNode) {
                console.error('No child node with class "createProjectButton found inside "projectOverviewContainer"');
            } else {
                createProjectButtonNode.addEventListener('click', function (event) {
                    _onCreateProjectPressed();
                });
            }

            var createFolderButtonNode = componentRootNode.querySelector('.js-createFolderButton');
            if (!createFolderButtonNode) {
                console.error('No child node with class "createFolderButton found inside "projectOverviewContainer"');
            } else {
                createFolderButtonNode.addEventListener('click', function (event) {
                    _onCreateDirectoryPressed();
                });
            }

            var toggleEditModeButtonNode = componentRootNode.querySelector('.js-toggleEditModeButton');
            if (!toggleEditModeButtonNode) {
                console.error('No child node with class "createFolderButton found inside "projectOverviewContainer"');
            } else {
                toggleEditModeButtonNode.addEventListener('click', function (event) {
                    editModeEnabled = !editModeEnabled;
                    componentRootNode.classList.toggle('editMode-enabled', editModeEnabled);
                    toggleEditModeButtonNode.classList.toggle('active', editModeEnabled);
                });
            }

            var selectParentDirectoryButton = componentRootNode.querySelector('.js-selectParentDirectoryButton');
            if (!selectParentDirectoryButton) {
                console.error('No child node with class "selectParentDirectoryButton" found inside "projectOverviewContainer"');
            } else {
                selectParentDirectoryButton.addEventListener('click', function (event) {
                    _onParentDirectorySelected();
                });
            }
        },
        /**
         * Inform the ui module about the new current set of directories and projects to list. This will also trigger
         * a new rendering of the projects list with the new content.
         * @param projectNames
         * @param directoryNames
         */
        setProjectsAndDirectories: function setProjectsAndDirectories(projectNames, directoryNames) {
            var projectsAndDirectories = [];

            if (!projectNames || !directoryNames) {
                return;
            } else if (!renderProjectsAndDirectoriesList) {
                console.error('renderProjectsAndDirectoriesList function has not been set, new list cannot be shown');
                return;
            }

            console.log('got projects', projectNames);
            console.log('got directories', directoryNames);

            projectNames.forEach(function (projectName) {
                projectsAndDirectories.push({
                    name: projectName,
                    dir: false,
                    openProjectListItem: function openProjectListItem() {
                        console.log('project selected:', projectName);
                        if (_onProjectSelected) {
                            _onProjectSelected(projectName);
                        }
                    },
                    deleteProjectListItem: function deleteProjectListItem() {
                        var deletionConfirmed = window.confirm('Really delete project ' + projectName + '?');
                        if (_onDeleteProjectPressed && deletionConfirmed) {
                            _onDeleteProjectPressed(projectName);
                        }
                    }
                });
            });
            directoryNames.forEach(function (directoryName) {
                projectsAndDirectories.push({
                    name: directoryName,
                    dir: true,
                    openProjectListItem: function openProjectListItem() {
                        console.log('directory selected:', directoryName);
                        if (_onDirectorySelected) {
                            _onDirectorySelected(directoryName);
                        }
                    },
                    deleteProjectListItem: function deleteProjectListItem() {
                        var deletionConfirmed = window.confirm('Really delete folder ' + directoryName + '?');
                        if (_onDeleteFolderPressed && deletionConfirmed) {
                            _onDeleteFolderPressed(directoryName);
                        }
                    }
                });
            });

            renderProjectsAndDirectoriesList(projectsAndDirectories);
        },
        /**
         * For canny-repeat registered on the projects list, provide the function for rendering the list.
         * @param func a function which will set the list of projects and directories.
         */
        setRenderProjectsAndDirectoriesListFunction: function setRenderProjectsAndDirectoriesListFunction(func) {
            renderProjectsAndDirectoriesList = func;
        },
        deleteProjectListNode: function deleteProjectListNode(itemName) {
            var node = componentRootNode.querySelector('tr[data-listItem=' + itemName + ']');
            if (node && node.parentNode) {
                node.parentNode.removeChild(node);
            }
        },
        /**
         * Register a listener callback which will react to "to parent directory" event.
         * @param listener
         */
        onParentDirectorySelected: function onParentDirectorySelected(listener) {
            _onParentDirectorySelected = listener;
        },
        /**
         * Register a listener callback which will react to clicks on a project. The callback function should expect
         * one parameter which is the project name.
         * @param listener
         */
        onProjectSelected: function onProjectSelected(listener) {
            _onProjectSelected = listener;
        },
        /**
         * Register a listener callback which will react to clicks on a directory. The callback function should expect
         * one parameter which is the directory name.
         * @param listener
         */
        onDirectorySelected: function onDirectorySelected(listener) {
            _onDirectorySelected = listener;
        },
        onCreateProjectPressed: function onCreateProjectPressed(func) {
            _onCreateProjectPressed = func;
        },
        onDeleteProjectPressed: function onDeleteProjectPressed(func) {
            _onDeleteProjectPressed = func;
        },
        onDeleteFolderPressed: function onDeleteFolderPressed(func) {
            _onDeleteFolderPressed = func;
        },
        onCreateDirectoryPressed: function onCreateDirectoryPressed(func) {
            _onCreateDirectoryPressed = func;
        }
    };
}();

module.exports = projectOverview;

},{}],38:[function(require,module,exports){
'use strict';

/**
 * handles all texts
 */
var texts = function () {
    'use strict';

    var node,
        languageNames = {
        da: 'Danmark',
        de: 'Deutschland',
        fr: 'France',
        nl: 'Nederland',
        en: 'United States (Default)',
        en_GB: 'United Kingdom',
        sv: 'Sverige',
        es: 'Espanol'
    },
        texts = {
        changeTexts: function changeTexts() {},
        data: {
            projectName: '',
            projectDescription: ''
        }
    };

    return {
        getLanguageNames: function getLanguageNames(key) {
            return languageNames[key];
        },
        setTexts: function setTexts(data) {
            texts.changeTexts('msg', data);
        },
        getTexts: function getTexts(fc) {
            console.log('texts:yes text is triggered');
            texts.changeTexts = fc;
            texts.changeTexts('msg', texts.data);
        },
        add: function add(elem, attr) {
            node = elem;
        },
        ready: function ready() {
            console.log('texts ready!');
        }
    };
}();

module.exports = texts;

},{}],39:[function(require,module,exports){
'use strict';

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

var flag = require('./flag.js'),
    inputEditManager = require('./inputEditManager.js'),
    wordCounter = require('../util/wordCounter'),
    displayManager = require('canny').displayManager,
    conf = {
    rowPrefix: "tv_",
    inputPrefix: "keyValue_",
    inputTransPrefix: "trans_"
},
    catPrefix = 'tv_';
/**
 * Rename all DOM id attributes from old to new key
 * @param oldKey
 * @param newKey
 */
function renameDOMIds(oldKey, newKey, availableLanguages) {
    Object.keys(conf).forEach(function (prop) {
        var node;
        if (prop === 'inputTransPrefix') {
            availableLanguages.forEach(function (lang) {
                node = document.getElementById(getLanguageTextId(oldKey, lang));
                if (node) {
                    node.setAttribute('id', getLanguageTextId(newKey, lang));
                } else {
                    console.error('translationView:renameIds can not find dom node for id', getLanguageTextId(newKey, lang));
                }
            });
        } else {
            node = document.getElementById(conf[prop] + oldKey);
            if (node) {
                node.setAttribute('id', conf[prop] + newKey);
            } else {
                console.error('translationView:renameIds can not find dom node for id', conf[prop] + oldKey, 'property:', prop);
            }
        }
    });
}

function textAreaKeyPressListener(e) {
    var key = e.keyCode || e.which;
    // TODO allow enter - it's useful for formatting a text - but it's a mess for all other
    if (key === 13) {
        e.returnValue = false;
    }
    return true;
}

function keyKeyPressListener(e) {
    var key = e.keyCode || e.which;
    if (key === 32) {
        e.returnValue = false;
    }
    return true;
}

function validateNewKey(string) {
    return string.length > 0 && string.search('\\.|,| ') === -1 ? true : false;
}

function getLanguageTextId(key, lang) {
    return conf.inputTransPrefix + [key, lang].join('_');
}

function getWordCountText(count) {
    return 'Words: ' + count;
}

/**
 * Count only letters
 * @param value
 */
function getCharacterCount(value) {
    while (/{.*?}/.test(value)) {
        value = value.replace(/{.*?}/, '');
    }return [].concat(_toConsumableArray(value)).filter(function (char) {
        return (/[a-zA-z]/.test(char)
        );
    }).length;
}

function getWordCountHeadline(category) {
    return 'Overall words in ' + category;
}

function createWordCountForLanguage(lang) {
    var countWrapper = domOpts.createElement('div', null, 'data js_' + lang),
        flagClass = flag.getFlagClasses(lang).pop(),
        wordCountLabel = domOpts.createElement('span', null, 'wordCountLabel '.concat(flagClass));
    wordCountLabel.innerHTML = getWordCountText(0);
    countWrapper.appendChild(wordCountLabel);
    return countWrapper;
}

/**
 * handle the translation overview
 * TODO refactor base.connection
 */
var translationView = function () {
    'use strict';

    /**
     * TODO remove project name - only the controller needs to know this
     *
     * @param {HTMLElement} node
     * @param {string} key - @deprecated
     * @param {string} lang
     * @param {string} text
     *
     * @class
     */

    function SaveOnLeave(node, key, lang, text) {
        var textList = [text],
            textIdx = 0;

        /**
         *
         * @param {HTMLElement} node
         * @returns {string} the key id
         */
        function getIdFromRow(node) {
            return node.parentNode.parentNode.parentNode.getAttribute('id').replace(conf.rowPrefix, '');
        }

        node.addEventListener('change', function (e) {
            console.log("Old: " + textList[textIdx]);
            var newValue = this.value;
            if (textList[textIdx] !== newValue) {
                textList.push(newValue);
                textIdx++;
            }
            console.log(textList);
            _onSaveKey && _onSaveKey(getIdFromRow(node), lang, newValue);
        });
    }

    /**
     * Clean up the attached event listeners and removes them from the node.
     * It removes the 'change' and 'keypress' event from all textArea's and input fields and
     * set it to "read only"
     *
     * @param {HTMLElement} rowNode
     */
    function removeEventListenersFromRow(rowNode) {
        [].slice.call(rowNode.querySelectorAll('textarea')).forEach(function (tarea) {
            tarea.removeEventListener('change', false);
            tarea.setAttribute('readonly', 'true');
        });

        [].slice.call(rowNode.querySelectorAll('input')).forEach(function (input) {
            input.removeEventListener('keypress', false);
            input.setAttribute('readonly', 'true');
        });
    }

    /**
     *
     * @param {HTMLElement} catNodeToInsert
     * @param {Array<HTMLElement>} catNodes
     */
    function insertCategory(catNodeToInsert, catNodes) {
        var catToAppendID = catNodeToInsert.id.toLowerCase(),
            shownCatNode,
            shownCatID;

        for (var i = 0; i < catNodes.length; i++) {
            shownCatNode = catNodes[i];
            shownCatID = catNodes[i].id.toLowerCase();
            if (catToAppendID < shownCatID) {
                rootNode.insertBefore(catNodeToInsert, shownCatNode);
                break;
            }
        }

        if (catNodes.length === 0 || catToAppendID > shownCatID) {
            rootNode.appendChild(catNodeToInsert);
        }
    }

    var rootNode,
        // main node all content are added to here
    renderTextFc,
        selectors = {
        root: "resourceBundleTable",
        debug: "debugIncomming",
        tpl: {
            tableBody: 'tableBody'
        }
    },

    // QUESTION: are these real queues?
    onQueues = {
        addNewKey: [],
        createNewProject: [],
        removeKey: [],
        renameKey: [],
        categoryClicked: [],
        removeCategory: [],
        renameCategory: []
    },
        ui = {
        css: {
            sendSuccess: 'sendSuccess',
            updateKey: 'updateKey'
        },
        /**
         *
         * @param key
         * @param inputPrefix
         */
        sendSuccess: function sendSuccess(key, inputPrefix) {
            var node1 = document.getElementById(conf.rowPrefix + key),
                node2 = document.getElementById(inputPrefix + key);
            if (node1) {
                ui.removeStateClasses(node1).classList.remove(ui.css.sendSuccess);
                setTimeout(function () {
                    ui.removeStateClasses(node1).classList.add(ui.css.sendSuccess);
                }, 100);
            }
            if (node2) {
                ui.removeStateClasses(node2).classList.remove(ui.css.sendSuccess);
                setTimeout(function () {
                    ui.removeStateClasses(node2).classList.add(ui.css.sendSuccess);
                }, 100);
            }
        },
        updateInputFields: function updateInputFields(key, inputPrefix) {
            console.error('translationView:updateInputFields', 'is this still in use????????????????????????????????????');
            debugger;
            var node = document.getElementById(inputPrefix + key);
            if (node) {
                ui.removeStateClasses(node).domAddClass(ui.css.updateKey);
            }
        },
        removeStateClasses: function removeStateClasses(node) {
            var cssState,
                classes = '';
            if (!node) {
                return;
            }
            // TODO refactor Object.keys()
            for (cssState in ui.css) {
                classes += cssState + ' ';
            }
            node.domRemoveClass(classes);
            return node;
        }
    },

    /**
     * Callback (registered from controller) to be called when changes to a key must be saved
     */
    _onSaveKey = function onSaveKey() {
        console.warn('translationView:onSaveKey not initialized');
    },
        _onCreateKey = function onCreateKey() {
        console.warn('translationView:onCreateKey not initialized');
    },
        _onCloneKey = function onCloneKey() {
        console.warn('translationView:onCloneKey not initialized');
    },
        brain = {
        cloneKeyOverlay: {
            init: function init(node) {
                this.node = node;
            },
            setData: function setData(data) {
                this.data = data;
                renderTextFc('cloneKeyOverlayText', {
                    keyName: data.keyName,
                    categoryName: data.contextName
                });
            },
            getData: function getData() {
                return this.data;
            }
        },
        cloneKeyInputCategory: {
            init: function init(node) {
                this.node = node;
            }
        },
        cloneKeyButtonSubmit: {
            init: function init(node) {
                node.addEventListener('click', function () {
                    if (brain.cloneKeyInputCategory.node.value.length === 0) {
                        brain.cloneKeyInputCategory.node.classList.add('error');
                        return;
                    }
                    var data = brain.cloneKeyOverlay.getData();
                    _onCloneKey(data.key, data.keyName, data.contextName, brain.cloneKeyInputCategory.node.value);
                });
            }
        },
        createNewProjectInputProject: {
            init: function init(node) {
                this.node = node;
            }
        },
        createNewProjectProjectDescription: {
            init: function init(node) {
                this.node = node;
            }
        },
        createNewProjectSubmit: function () {
            var node;
            return {
                init: function init(elem) {
                    node = elem;
                    node.addEventListener('click', function () {
                        var projectValue = brain.createNewProjectInputProject.node.value;

                        if (validateNewKey(projectValue)) {
                            // TODO read description field
                            onQueues.createNewProject.forEach(function (fc) {
                                fc(projectValue, {
                                    description: brain.createNewProjectProjectDescription.node.value
                                });
                            });
                            // TODO check if closed is needed?
                            displayManager.hide('createNewProjectView');
                        } else {
                            // TODO replace with classes
                            brain.createNewProjectInputProject.node.style.backgroundColor = '#ff4444';
                        }
                    });
                }
            };
        }(),
        projectShow: {
            init: function init(node) {
                node.addEventListener('click', function () {
                    displayManager.show('translationViewProjectCategoryKey');
                });
            }
        },
        projectInputCategory: {
            init: function init(node) {
                this.node = node;
            }
        },
        projectInputKey: {
            init: function init(node) {
                this.node = node;
            }
        },
        cancel: function () {
            return {
                init: function init(node) {
                    node.addEventListener('click', function () {
                        canny.displayManager.hide(this.dataset.view);
                    });
                }
            };
        }(),
        projectSubmit: function () {
            var node;
            return {
                init: function init(elem) {
                    node = elem;
                    node.addEventListener('click', function () {
                        var categoryKey = brain.projectInputCategory.node.value,
                            key = brain.projectInputKey.node.value,
                            newKey;

                        if (validateNewKey(categoryKey) && validateNewKey(key)) {
                            // TODO default language
                            newKey = categoryKey + '_' + key;
                            _onCreateKey(newKey);
                        } else {
                            // TODO replace with classes
                            brain.projectInputCategory.node.classList.add('error');
                            brain.projectInputKey.node.classList.add('error');
                        }
                    });
                }
            };
        }()
    },
        fc = {
        /**
         *
         * @returns {{rowPrefix: string, inputPrefix: string, inputTransPrefix: string}}
         */
        get config() {
            return conf;
        },
        enableEditorMode: function enableEditorMode(enable) {
            if (enable) {
                rootNode.classList.add('c-enableEditorMode');
            } else {
                rootNode.classList.remove('c-enableEditorMode');
            }
        },
        toggleWordCount: function toggleWordCount(enable) {
            rootNode.classList.toggle('c-wordCountEnabled', enable);
        },
        sendSuccess: ui.sendSuccess,
        add: function add(node, attr) {
            if (attr === 'main') {
                rootNode = node;
            } else if (brain.hasOwnProperty(attr)) {
                brain[attr].init(node);
            }
        },
        getViewKeyObject: function getViewKeyObject(obj) {
            var newKey,
                contextName = null,
                delimiter = '_';
            if (/\./.test(obj.key)) {
                delimiter = '.';
            }

            newKey = obj.key.split(delimiter);

            if (newKey.length > 1) {
                // use slice if we need the complete key in the view
                contextName = newKey.splice(0, 1)[0];
            }
            return {
                id: obj.key, // deprecated
                key: obj.key,
                contextName: contextName,
                keyName: newKey.join(delimiter),
                value: obj.value
            };
        },
        isBundleEqual: function isBundleEqual(bundle1, bundle2) {
            if (bundle1.bundle === bundle2.bundle && bundle1.locale === bundle2.locale) {
                return true;
            }
            return false;
        },
        getBundleNameFrom: function getBundleNameFrom() {

            return {
                bundle: domOpts.params.bundle || 'messages',
                locale: this.getFromParam()
            };
        },
        getFromParam: function getFromParam() {
            return domOpts.params.from || 'de';
        },
        getBundleNameTo: function getBundleNameTo() {

            return {
                bundle: domOpts.params.bundle || 'messages',
                locale: domOpts.params.to || null
            };
        },
        getBundleName: function getBundleName(locale) {
            var bundle = domOpts.params.bundle || 'messages';
            return bundle + '_' + locale;
        },
        /**
         * Render the i18n input field for keys from a single language. The row header (i.e. the actual key field) is
         * rendered, too if it does not exist yet.
         * @param bundles {key: string, data: string}
         * @param actualLanguage
         * @param availableProjectLanguages
         * @param projectName
         */
        printBundleTemplate: function printBundleTemplate(bundles, actualLanguage, availableProjectLanguages, cb) {
            var keyObj,
                projectNode,
                shownCategories = [].slice.call(rootNode.querySelectorAll('.categoryNode'));
            /**
             * Setup header and handle the category
             *
             * @param {string} contextName
             * @returns {HTMLElement}
             */
            function prepareCategoryNode(contextName, languages) {
                var categoryNode = document.getElementById(conf.rowPrefix + contextName);
                if (!categoryNode) {
                    categoryNode = document.querySelector('#templates .categoryNode').cloneNode(true);
                    categoryNode.classList.add('c-anchorMenu-parent');
                    var categoryName = contextName;
                    var categoryNodeId = categoryName;
                    categoryNode.setAttribute('id', conf.rowPrefix + categoryNodeId);
                    if (categoryName) {
                        var wrapper = categoryNode.querySelector('.headlineWrapper'),
                            h2 = categoryNode.querySelector('h2');
                        // TODO make a span for it
                        h2.appendChild(function () {
                            var span = document.createElement('span');
                            span.appendChild(document.createTextNode(categoryName));
                            span.className = 'keyName';
                            return span;
                        }());
                        h2.addEventListener('click', function (event) {
                            onQueues.categoryClicked.forEach(function (fc) {
                                fc(categoryNodeId);
                            });
                        });

                        var editPanel = inputEditManager.addEditorPanel(categoryNode, {
                            onEdit: function onEdit(event) {
                                event.stopImmediatePropagation();
                                keyInputNode.removeAttribute('disabled');
                                contextName = keyInputNode.value;
                                keyInputNode.focus();
                            },
                            onCancel: function onCancel(event) {
                                event.stopImmediatePropagation();
                                keyInputNode.setAttribute('disabled', 'true');
                                keyInputNode.value = contextName;
                            },
                            onSave: function onSave(event) {
                                event.stopImmediatePropagation();
                                onQueues.renameCategory.forEach(function (fc) {
                                    fc({
                                        oldName: contextName,
                                        newName: keyInputNode.value
                                    });
                                });
                            },
                            onDelete: function onDelete(event) {
                                event.stopImmediatePropagation();
                                var yes = window.confirm('Delete this category?\nAll keys within with will be lost.');
                                if (yes) {
                                    onQueues.removeCategory.forEach(function (fc) {
                                        fc({
                                            category: categoryName
                                        });
                                    });
                                }
                            }
                        });
                        wrapper.appendChild(editPanel);

                        var keyInputNode = domOpts.createElement('input', conf.rowPrefix + categoryName + '_input', 'categoryField');
                        keyInputNode.setAttribute('disabled', 'true');
                        keyInputNode.addEventListener('click', function (event) {
                            event.stopImmediatePropagation();
                        });
                        keyInputNode.addEventListener('keypress', keyKeyPressListener);
                        h2.appendChild(keyInputNode);
                        keyInputNode.value = categoryName;

                        // add the description functionality
                        var catDescNode = categoryNode.querySelector('.js-cat-description');
                        var span = document.createElement('span');
                        span.className = 'js-text';
                        catDescNode.appendChild(span);
                        if (catDescNode) {
                            canny.textEditor.add(catDescNode, {
                                id: categoryName,
                                placeholder: 'Add here the category description'
                            });
                            canny.translationViewImageUpload.add(categoryNode.querySelector('.js-imageUpload-editButton'), categoryName);
                        }
                        // add add key input field and button
                        var keyNameInput = categoryNode.querySelector('.addNewKeyrow input');
                        keyNameInput.setAttribute('category', categoryName);
                        keyNameInput.addEventListener('keypress', keyKeyPressListener);
                        categoryNode.querySelector('label').innerText = categoryName + "_";
                        var button = categoryNode.querySelector('button');
                        button.addEventListener('click', function () {
                            if (validateNewKey(keyNameInput.value)) {
                                var newKey = keyNameInput.getAttribute('category') + '_' + keyNameInput.value;
                                // TODO refactor this - server should add the key for all available languages - or pass default lang
                                _onCreateKey(newKey, actualLanguage);
                            } else {
                                button.style.color = '#ff0000';
                                keyNameInput.style.backgroundColor = "#ff4444";
                            }
                        });
                    }

                    // add overall word count for each language of a category
                    var overallWordsWrapper = categoryNode.querySelector('.overallWordCountWrapper'),
                        overallHeadline = overallWordsWrapper.querySelector('.overallWordsHeadline'),
                        countersWrapper = overallWordsWrapper.querySelector('.translationContainer');
                    overallHeadline.innerHTML = getWordCountHeadline(categoryName);
                    languages.forEach(function (lang) {
                        countersWrapper.appendChild(createWordCountForLanguage(lang));
                    });
                }
                return categoryNode;
            };

            bundles.forEach(function (data) {
                keyObj = fc.getViewKeyObject(data);
                // TODO which who calc the cate...
                projectNode = prepareCategoryNode(keyObj.contextName, availableProjectLanguages);
                insertCategory(projectNode, shownCategories);
                fc.addRowWithLanguages(projectNode, keyObj, actualLanguage, availableProjectLanguages);
                cb(projectNode.getAttribute('id').replace(conf.rowPrefix, ''));
                cb(keyObj.key);
            });
        },
        /**
         * Update the word count for a given category
         * @param data
         */
        updateCategoryWordCount: function updateCategoryWordCount(data) {
            var label = document.querySelector('#' + conf.rowPrefix + data.id + ' .overallWordCountWrapper .js_' + data.language + ' .wordCountLabel');
            if (label) {
                label.innerHTML = getWordCountText(data.words);
            }
        },
        /**
         * creates a key field
         *
         * @param node
         * @param data
         */
        addKeyField: function addKeyField(node, data) {
            var keyInputNode = document.getElementById(conf.inputPrefix + data.key),
                keyNode;
            if (!keyInputNode) {
                keyInputNode = domOpts.createElement('input', conf.inputPrefix + data.key, 'keyField');
                keyNode = domOpts.createElement('div', null, 'data key octicon octicon-key');
                keyInputNode.setAttribute('disabled', 'true');
                inputEditManager.addEditorPanel(keyNode, {
                    onDelete: function onDelete() {
                        var yes = window.confirm('Delete this key?\nThis key with all translations will removed.');
                        if (yes) {
                            onQueues.removeKey.forEach(function (fc) {
                                fc({
                                    key: data.key
                                });
                            });
                        }
                    },
                    onEdit: function onEdit() {
                        keyInputNode.removeAttribute('disabled');
                        // save actual key for restoring if cancel
                        data.keyName = keyInputNode.value;
                        // get the key: take id attribute and remove the value from it
                        data.key = keyInputNode.getAttribute('id').replace(conf.inputPrefix, '');
                        data.contextName = data.key.split('_')[0];
                        keyInputNode.focus();
                    },
                    onCancel: function onCancel() {
                        keyInputNode.setAttribute('disabled', 'true');
                        keyInputNode.value = data.keyName;
                    },
                    onSave: function onSave() {
                        console.log('translationView:addKeyField save new key');
                        var value = data.contextName ? data.contextName + '_' + keyInputNode.value : keyInputNode.value;
                        if (keyInputNode.value != '' && value != data.key) {
                            onQueues.renameKey.forEach(function (fc) {
                                fc({
                                    newKey: value,
                                    oldKey: data.key
                                });
                            });
                        }
                    },
                    onClone: function onClone() {
                        brain.cloneKeyOverlay.setData(data);
                        displayManager.show('translationViewCloneKey');
                    }
                });
                // register the input key listener to capture wrong character
                keyInputNode.addEventListener('keypress', keyKeyPressListener);
                keyNode.appendChild(function () {
                    var span = document.createElement('span');
                    span.appendChild(document.createTextNode(data.keyName));
                    span.className = 'keyName';
                    return span;
                }());

                keyNode.appendChild(keyInputNode);
                node.insertBefore(keyNode, node.children[0]);
                keyInputNode.value = data.keyName;
            }
        },
        /**
         * Call this to update/create a language field
         * @param node
         * @param key
         * @param value
         * @param lang
         * @param wordCount
         */
        addLanguageField: function addLanguageField(node, key, value, lang, wordCount) {

            var textNode = document.getElementById(getLanguageTextId(key, lang)),
                dataNode,
                wordCountNode,
                charCountNode,
                textInformationNode;

            if (!textNode) {
                textNode = domOpts.createElement('textarea', getLanguageTextId(key, lang), 'textField');
                dataNode = domOpts.createElement('div', null, 'data tpl js_' + lang);
                textInformationNode = domOpts.createElement('div', null, 'textInformation');
                wordCountNode = domOpts.createElement('span', null, 'textInformation-wordCountLabel');
                charCountNode = domOpts.createElement('span', null, 'textInformation-charCountLabel');
                wordCountNode.innerHTML = getWordCountText(0);

                textInformationNode.appendChild(flag.getFlag(lang));
                textInformationNode.appendChild(wordCountNode);
                textInformationNode.appendChild(charCountNode);

                textNode.addEventListener('keyup', function () {
                    charCountNode.innerHTML = getCharacterCount(this.value);
                    wordCountNode.innerHTML = getWordCountText(wordCounter.countWordsInString(this.value));
                });

                textNode.addEventListener('keypress', textAreaKeyPressListener);
                textNode.setAttribute('type', 'text');

                new SaveOnLeave(textNode, key, lang, value);

                dataNode.appendChild(textNode);
                dataNode.appendChild(textInformationNode);

                node.appendChild(dataNode);
            } else {
                wordCountNode = textNode.parentElement.querySelector('.textInformation-wordCountLabel');
                charCountNode = textNode.parentElement.querySelector('.textInformation-charCountLabel');
            }

            if (value || value === '') {
                textNode.value = value ? unicode.encode(value) : '';
                wordCountNode.innerHTML = getWordCountText(wordCounter.countWordsInString(value));
                charCountNode.innerHTML = getCharacterCount(value);
            }
        },
        /**
         * creates a row
         * @param {HTMLElement} node
         * @param {string} key
         * @returns {HTMLElement} the existing row or in case if not exists a new created row
         */
        getRow: function getRow(node, key) {
            // try to get the row
            var row = document.getElementById(conf.rowPrefix + key),
                translationContainer = row !== null ? row.querySelector('.translationContainer') : document.createElement('div');

            translationContainer.className = "translationContainer";

            // if there is a row but it is marked as removed than removed it
            if (row && row.classList.contains('c-removed')) {
                row.domRemove();
                row = undefined;
            }
            // create a row if the row is not exists
            if (!row) {
                row = domOpts.createElement('div', conf.rowPrefix + key, 'row c-row c-anchorMenu-child');
                // add the description functionality
                var catDescNode = document.createElement('div');
                var span = document.createElement('span');
                span.className = 'js-text';
                catDescNode.appendChild(span);
                catDescNode.className = 'js-row-description';
                row.appendChild(catDescNode);
                canny.textEditor.add(catDescNode, { id: key, placeholder: 'Add here the key description' });

                // add the translation area field container
                row.appendChild(translationContainer);
                node.querySelector('.keysWrapper').appendChild(row);
            }
            return row;
        },
        addRowWithLanguages: function addRowWithLanguages(node, data, actualLanguage, allProjectLanguages) {
            var row = fc.getRow(node, data.key);

            fc.addKeyField(row, data);

            allProjectLanguages.forEach(function (lang) {
                fc.addLanguageField(row.querySelector('.translationContainer'), data.key, actualLanguage === lang ? data.value : null, lang);
            });
        },
        addLanguage: function addLanguage(keys, lang) {
            var row,
                categories = [],
                currentCategory;
            keys.forEach(function (key) {
                row = document.getElementById(conf.rowPrefix + key);
                if (row) {
                    fc.addLanguageField(row.querySelector('.translationContainer'), key, null, lang, 0);

                    currentCategory = key.split('_')[0];
                    if (categories.indexOf(currentCategory) === -1) {
                        categories.push(currentCategory);
                    }
                } else {
                    console.log('translationView:addLanguage found key which is not available in view:', key);
                }
            });

            categories.forEach(function (category) {
                var overallWordCount = document.querySelector('#' + conf.rowPrefix + category + ' .overallWordCountWrapper .translationContainer');
                overallWordCount.appendChild(createWordCountForLanguage(lang));
            });
        },
        clearView: function clearView() {
            // just reset all for now
            // TODO do it better ;)
            [].slice.call(rootNode.children).forEach(function (child) {
                rootNode.removeChild(child);
            });
        },
        showLang: function showLang(lang) {
            // show the lang tab
            rootNode.classList.remove('c-hide_' + lang);
        },
        /**
         * remove a category
         * TODO it's not called if own user renames a category
         */
        renameCategory: function renameCategory(oldName, newName, availableProjectLanguages) {
            var categoryNode = document.getElementById(conf.rowPrefix + oldName),
                rows = categoryNode.querySelectorAll('.c-row'),
                headline = categoryNode.querySelector('h2'),
                addKeyNode = categoryNode.querySelector('.addNewKeyrow');

            categoryNode.id = conf.rowPrefix + newName;

            headline.querySelector('.keyName').childNodes[0].nodeValue = newName;

            addKeyNode.querySelector('label').innerHTML = newName + '_';
            addKeyNode.querySelector('input').setAttribute('category', newName);

            [].slice.call(rows).forEach(function (row) {
                var id = row.id.replace(conf.rowPrefix, ''),
                    splitName = id.split('_'),
                    newKeyName;

                splitName.shift();
                newKeyName = newName + '_' + splitName.join('_');
                if (id !== '') {
                    renameDOMIds(id, newKeyName, availableProjectLanguages);
                } else {
                    console.error('translationView:renameCategory should not hav an empty id', row);
                }
            });
            inputEditManager.closeEditView(headline);
            headline.querySelector('.categoryField').setAttribute('disabled', 'true');
        },
        /**
         * remove a category
         */
        removeCategory: function removeCategory(cat) {
            var row = document.getElementById(conf.rowPrefix + cat);
            if (row) {
                row.domRemove();
            }
        },
        /**
         * show a key as deleted
         * @param key
         */
        markKeyAsRemoved: function markKeyAsRemoved(key) {
            var row = document.getElementById(conf.rowPrefix + key),
                removeIc;
            if (row && !row.classList.contains('c-removed')) {
                row.classList.add('c-removed');
                removeIc = domOpts.createElement('div', null, 'remove-button octicon octicon-x');
                removeIc.addEventListener('click', function () {
                    row.domRemove();
                });
                removeIc.domAppendTo(row);
                removeEventListenersFromRow(row);
                inputEditManager.removePanel(row);
            } else {
                console.error('translationView:markkeyAsRemoved no node found for key', key, row);
            }
        },
        /**
         * remove a key
         */
        removeKey: function removeKey(key) {
            var row = document.getElementById(conf.rowPrefix + key);
            if (row) {
                row.domRemove();
            }
        },
        /**
         * rename a key
         *
         * @param oldKey
         * @param newKey
         * @param availableProjectLanguages []
         */
        renameKey: function renameKey(oldKey, newKey, availableProjectLanguages) {
            var keyInputNode = document.getElementById(conf.inputPrefix + oldKey),
                keyName;

            if (keyInputNode) {
                keyName = fc.getViewKeyObject({ key: newKey }).keyName;
                renameDOMIds(oldKey, newKey, availableProjectLanguages);
                keyInputNode.value = keyName;
                // close the edit view
                inputEditManager.closeEditView(keyInputNode);
                // disabled the input field
                keyInputNode.setAttribute('disabled', 'true');
                keyInputNode.parentNode.querySelector('.keyName').childNodes[0].nodeValue = keyName;
            }
        },
        removeImage: function removeImage(categoryName) {
            var imageBox = rootNode.querySelector('#' + conf.rowPrefix + categoryName + ' .imageUpload-imageBox');
            while (imageBox.firstChild) {
                imageBox.removeChild(imageBox.firstChild);
            }
            imageBox.classList.remove('c-show');
        },
        hideLang: function hideLang(lang) {
            rootNode.classList.add('c-hide_' + lang);
        },
        onCreateNewProject: function onCreateNewProject(cb) {
            onQueues.createNewProject.push(cb);
        },
        onCategoryClicked: function onCategoryClicked(cb) {
            onQueues.categoryClicked.push(cb);
        },
        onAddNewKey: function onAddNewKey(cb) {
            onQueues.addNewKey.push(cb);
        },
        onRenameKey: function onRenameKey(cb) {
            onQueues.renameKey.push(cb);
        },
        onRemoveKey: function onRemoveKey(cb) {
            onQueues.removeKey.push(cb);
        },
        onRemoveCategory: function onRemoveCategory(cb) {
            onQueues.removeCategory.push(cb);
        },
        onRenameCategory: function onRenameCategory(cb) {
            onQueues.renameCategory.push(cb);
        },
        /**
         * Set logic for handling saving changes to a key.
         * @param func
         */
        onSaveKey: function onSaveKey(func) {
            _onSaveKey = func;
        },
        /**
         * Set logic for handling saving changes to a key.
         * @param func
         */
        onCreateKey: function onCreateKey(func) {
            _onCreateKey = func;
        },
        onCloneKey: function onCloneKey(func) {
            _onCloneKey = func;
        },
        registerWhisker: function registerWhisker(fc) {
            renderTextFc = fc;
        }
    };
    return fc;
}();

module.exports = translationView;

},{"../util/wordCounter":45,"./flag.js":31,"./inputEditManager.js":33,"canny":50}],40:[function(require,module,exports){
'use strict';

var node;
module.exports = {
    add: function add(elem, attr) {
        node = elem;
    },
    addDescriptions: function addDescriptions(keyDescriptions) {
        Object.keys(keyDescriptions).forEach(function (key) {
            var parent = document.getElementById(key),
                child;
            if (parent) {
                child = parent.querySelector('.js-text');
                if (child) {
                    child.innerHTML = keyDescriptions[key];
                }
            }
        });
    }
};

},{}],41:[function(require,module,exports){
'use strict';

/**
 * is for the translation view to add the image upload button and show the images
 */
var rootNode,
    _onUploadButton = function onUploadButton() {
    console.warn('translationViewImageUpload::onUploadButton() not implemented.');
},
    _onDeleteButton = function onDeleteButton() {
    console.warn('translationViewImageUpload::onDeleteButton() not implemented.');
};

function uploadButton(id) {
    var node = document.createElement('div');
    node.className = 'upload-btn octicon octicon-cloud-upload';
    node.addEventListener('click', function () {
        _onUploadButton(id);
    });
    node.setAttribute('title', 'upload a image file');
    return node;
}

function editPanel(id) {
    var deleteBtn = document.createElement('div'),
        editBtn = document.createElement('div'),
        cancelBtn = document.createElement('div'),
        panelWrap = document.createElement('div');

    panelWrap.className = 'imageUpload-imageBox-editPanel';
    editBtn.className = 'edit-btn octicon octicon-pencil';
    editBtn.addEventListener('click', function () {
        panelWrap.classList.add('c-edit');
    });
    cancelBtn.className = 'cancel-btn octicon octicon-x';
    cancelBtn.addEventListener('click', function () {
        panelWrap.classList.remove('c-edit');
    });
    deleteBtn.className = 'delete-btn octicon octicon-trashcan';
    deleteBtn.addEventListener('click', function () {
        _onDeleteButton(id);
    });

    deleteBtn.setAttribute('title', 'remove image');
    cancelBtn.setAttribute('title', 'cancel');
    editBtn.setAttribute('title', 'edit');

    panelWrap.appendChild(editBtn);
    panelWrap.appendChild(cancelBtn);
    panelWrap.appendChild(deleteBtn);
    return panelWrap;
}

function getImage(file) {
    var img = new Image();
    img.src = file;
    img.addEventListener('click', function () {
        var win = window.open(file, '_blank');
        win.focus();
    });
    return img;
}

function addImageContent(id, img) {
    var node = document.createElement('div'),
        resizeAble = document.createElement('div');
    resizeAble.className = 'imageUpload-imageBox-resizeable';
    node.className = 'imageUpload-imageBox-content';
    resizeAble.appendChild(img);
    node.appendChild(resizeAble);
    node.appendChild(editPanel(id));
    return node;
}

module.exports = {
    onUploadButton: function onUploadButton(fc) {
        _onUploadButton = fc;
    },
    onDeleteButton: function onDeleteButton(fc) {
        _onDeleteButton = fc;
    },
    add: function add(node, attr) {
        node.appendChild(uploadButton(attr));
    },
    appendImage: function appendImage(projectId, id, url) {
        var dom = document.getElementById('tv_' + id),
            imgContainer;
        if (dom) {
            imgContainer = dom.querySelector('.js-imageUpload-box');
            if (imgContainer) {
                [].slice.call(imgContainer.children).forEach(function (n) {
                    n.remove();
                });
                imgContainer.classList.add('c-show');
                imgContainer.appendChild(addImageContent(id, getImage('/images' + url)));
            }
        }
    }
};

},{}],42:[function(require,module,exports){
'use strict';

/**
 * shows the uploader form to upload a image to the server
 */
var _onUpload = function onUpload() {},
    brain = {
    fileInput: {
        init: function init(node) {
            node.addEventListener('change', upload);
        }
    }
};

function upload() {
    console.log('c-upload:trigger upload');
    var file = this.files[0];
    if (file) {
        // send it direct after drop
        [].slice.call(this.files).forEach(function (file) {
            // TODO instead pass  directly a array of files - so we save POST calls
            _onUpload(file);
        });
        // cleanup value otherwise file with same name can't uploaded again
        this.value = null;
        return false;
    }
}
/**
 *
 * @returns {{add: Function, ready: Function}}
 */
module.exports = {
    onUpload: function onUpload(fc) {
        _onUpload = fc;
    },
    add: function add(node, attr) {
        if (brain.hasOwnProperty(attr)) {
            brain[attr].init(node);
        }
    }
};

},{}],43:[function(require,module,exports){
'use strict';

var unicode = function () {

    String.prototype.getEachChar = function (cb) {
        var newString = this;
        for (var i = 0; i < newString.length; i++) {
            newString[i] = cb(newString[i]);
        }
        return newString.toString();
    };
    var reg = new RegExp('\\\\u([0-9a-fA-F]{4})', "g");
    return {
        encode: function encode(string) {
            if (!string) {
                return '';
            }
            var newstring = string.replace(reg, function (match, submatch) {
                return String.fromCharCode(parseInt(submatch, 16));
            });
            return newstring;
        },
        decode: function decode(string) {
            return string.getEachChar(function (c) {
                for (var i = 0; i < table.length; i++) {
                    if (table[i] == c) {
                        console.log('found:' + table[i]);
                        return table[i];
                    }
                }
                return c;
            });
        }

    };
}();

module.exports = unicode;

var table = ['\xC0', '\xC1', '\xC2', '\xC3', '\xC4', '\xC5', '\xC6', '\xC7', '\xC8', '\xC9', '\xCA', '\xCB', '\xCC', '\xCD', '\xCE', '\xCF', '\xD0', '\xD1', '\xD2', '\xD3', '\xD4', '\xD5', '\xD6', '\xD8', '\xD9', '\xDA', '\xDB', '\xDC', '\xDD', '\xDE', '\xDF', '\xE0', '\xE1', '\xE2', '\xE3', '\xE4', '\xE5', '\xE6', '\xE7', '\xE8', '\xE9', '\xEA', '\xEB', '\xEC', '\xED', '\xEE', '\xEF', '\xF0', '\xF1', '\xF2', '\xF3', '\xF4', '\xF5', '\xF6', '\xF8', '\xF9', '\xFA', '\xFB', '\xFC', '\xFD', '\xFE', '\xFF'];

},{}],44:[function(require,module,exports){
'use strict';

function getAnchor() {
    var href = location.href;
    if (/#/.test(href)) {
        return '#' + location.href.replace(/.*#/, '');
    }
    return '';
}

module.exports = {
    getAnchor: getAnchor,
    hasAnchor: function hasAnchor() {
        return getAnchor() !== '';
    }
};

},{}],45:[function(require,module,exports){
'use strict';

var regExPunc = new RegExp(/[\.,\s!;?:\"]+/gi);

/**
 * Count amount of words in a given String
 * @param str
 * @returns Number
 */
module.exports.countWordsInString = function countWordsInString(str) {
    if (str) {
        return str.replace(regExPunc, ' ').trim().split(' ').length;
    }
    return 0;
};

},{}],46:[function(require,module,exports){
'use strict'

exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function placeHoldersCount (b64) {
  var len = b64.length
  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // the number of equal signs (place holders)
  // if there are two placeholders, than the two characters before it
  // represent one byte
  // if there is only one, then the three characters before it represent 2 bytes
  // this is just a cheap hack to not do indexOf twice
  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0
}

function byteLength (b64) {
  // base64 is 4/3 + up to two characters of the original data
  return (b64.length * 3 / 4) - placeHoldersCount(b64)
}

function toByteArray (b64) {
  var i, l, tmp, placeHolders, arr
  var len = b64.length
  placeHolders = placeHoldersCount(b64)

  arr = new Arr((len * 3 / 4) - placeHolders)

  // if there are placeholders, only get up to the last complete 4 chars
  l = placeHolders > 0 ? len - 4 : len

  var L = 0

  for (i = 0; i < l; i += 4) {
    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]
    arr[L++] = (tmp >> 16) & 0xFF
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  if (placeHolders === 2) {
    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[L++] = tmp & 0xFF
  } else if (placeHolders === 1) {
    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[L++] = (tmp >> 8) & 0xFF
    arr[L++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var output = ''
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    output += lookup[tmp >> 2]
    output += lookup[(tmp << 4) & 0x3F]
    output += '=='
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])
    output += lookup[tmp >> 10]
    output += lookup[(tmp >> 4) & 0x3F]
    output += lookup[(tmp << 2) & 0x3F]
    output += '='
  }

  parts.push(output)

  return parts.join('')
}

},{}],47:[function(require,module,exports){

},{}],48:[function(require,module,exports){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */

'use strict'

var base64 = require('base64-js')
var ieee754 = require('ieee754')

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

var K_MAX_LENGTH = 0x7fffffff
exports.kMaxLength = K_MAX_LENGTH

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Print warning and recommend using `buffer` v4.x which has an Object
 *               implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * We report that the browser does not support typed arrays if the are not subclassable
 * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`
 * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support
 * for __proto__ and has a buggy typed array implementation.
 */
Buffer.TYPED_ARRAY_SUPPORT = typedArraySupport()

if (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&
    typeof console.error === 'function') {
  console.error(
    'This browser lacks typed array (Uint8Array) support which is required by ' +
    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'
  )
}

function typedArraySupport () {
  // Can typed array instances can be augmented?
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42
  } catch (e) {
    return false
  }
}

function createBuffer (length) {
  if (length > K_MAX_LENGTH) {
    throw new RangeError('Invalid typed array length')
  }
  // Return an augmented `Uint8Array` instance
  var buf = new Uint8Array(length)
  buf.__proto__ = Buffer.prototype
  return buf
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(arg)
  }
  return from(arg, encodingOrOffset, length)
}

// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
if (typeof Symbol !== 'undefined' && Symbol.species &&
    Buffer[Symbol.species] === Buffer) {
  Object.defineProperty(Buffer, Symbol.species, {
    value: null,
    configurable: true,
    enumerable: false,
    writable: false
  })
}

Buffer.poolSize = 8192 // not used by this implementation

function from (value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (isArrayBuffer(value)) {
    return fromArrayBuffer(value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(value, encodingOrOffset)
  }

  return fromObject(value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(value, encodingOrOffset, length)
}

// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:
// https://github.com/feross/buffer/pull/148
Buffer.prototype.__proto__ = Uint8Array.prototype
Buffer.__proto__ = Uint8Array

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(size).fill(fill, encoding)
      : createBuffer(size).fill(fill)
  }
  return createBuffer(size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(size, fill, encoding)
}

function allocUnsafe (size) {
  assertSize(size)
  return createBuffer(size < 0 ? 0 : checked(size) | 0)
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(size)
}

function fromString (string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  var buf = createBuffer(length)

  var actual = buf.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    buf = buf.slice(0, actual)
  }

  return buf
}

function fromArrayLike (array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  var buf = createBuffer(length)
  for (var i = 0; i < length; i += 1) {
    buf[i] = array[i] & 255
  }
  return buf
}

function fromArrayBuffer (array, byteOffset, length) {
  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  var buf
  if (byteOffset === undefined && length === undefined) {
    buf = new Uint8Array(array)
  } else if (length === undefined) {
    buf = new Uint8Array(array, byteOffset)
  } else {
    buf = new Uint8Array(array, byteOffset, length)
  }

  // Return an augmented `Uint8Array` instance
  buf.__proto__ = Buffer.prototype
  return buf
}

function fromObject (obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    var buf = createBuffer(len)

    if (buf.length === 0) {
      return buf
    }

    obj.copy(buf, 0, 0, len)
    return buf
  }

  if (obj) {
    if (isArrayBufferView(obj) || 'length' in obj) {
      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {
        return createBuffer(0)
      }
      return fromArrayLike(obj)
    }

    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {
      return fromArrayLike(obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= K_MAX_LENGTH) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return b != null && b._isBuffer === true
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!Array.isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (isArrayBufferView(string) || isArrayBuffer(string)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)
// to detect a Buffer instance. It's not possible to use `instanceof Buffer`
// reliably in a browserify context because there could be multiple different
// copies of the 'buffer' package in use. This method works even for Buffer
// instances that were created from another copy of the `buffer` package.
// See: https://github.com/feross/buffer/issues/154
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (numberIsNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (numberIsNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset >>> 0
    if (isFinite(length)) {
      length = length >>> 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf = this.subarray(start, end)
  // Return an augmented `Uint8Array` instance
  newBuf.__proto__ = Buffer.prototype
  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  offset = offset >>> 0
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  byteLength = byteLength >>> 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset + 3] = (value >>> 24)
  this[offset + 2] = (value >>> 16)
  this[offset + 1] = (value >>> 8)
  this[offset] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    var limit = Math.pow(2, (8 * byteLength) - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  this[offset] = (value >>> 8)
  this[offset + 1] = (value & 0xff)
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  this[offset] = (value & 0xff)
  this[offset + 1] = (value >>> 8)
  this[offset + 2] = (value >>> 16)
  this[offset + 3] = (value >>> 24)
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  this[offset] = (value >>> 24)
  this[offset + 1] = (value >>> 16)
  this[offset + 2] = (value >>> 8)
  this[offset + 3] = (value & 0xff)
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  value = +value
  offset = offset >>> 0
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : new Buffer(val, encoding)
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = str.trim().replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check
// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166
function isArrayBuffer (obj) {
  return obj instanceof ArrayBuffer ||
    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&
      typeof obj.byteLength === 'number')
}

// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`
function isArrayBufferView (obj) {
  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)
}

function numberIsNaN (obj) {
  return obj !== obj // eslint-disable-line no-self-compare
}

},{"base64-js":46,"ieee754":65}],49:[function(require,module,exports){
/*global base.cookieHandler, canny */

(function () {
    var DEFAULT_LIFETIME_AS_DAYS = 365 * 5,
        DEFAULT_PATH = '/';

    var cookieManager = {};

    /**
     * A cookie manager for handling cookies where the cookie value is a JSON-stringified object.
     *
     * For creating a session cookie (i.e. deleted when browser closes), add a null-valued domain property to
     * cookieAttributes.
     *
     * @param cookieName
     * @param cookieAttributes: an optional object where the properties are attributes of the cookie - expireDays,
     * domain, path (if any of those is left out defaults will be used).
     * @returns {{cookieName, store: store, storeAll: storeAll, getValue: getValue, getValues: getValues}}
     * @constructor
     */
    var CookieManager = function(cookieName, cookieAttributes) {

        var lifetimeAsDays = (function() {
            if (cookieAttributes && cookieAttributes.expireDays) {
                return cookieAttributes.expireDays;
            } else if (cookieAttributes && cookieAttributes.expireDays === null) {
                return null;
            } else {
                return DEFAULT_LIFETIME_AS_DAYS;
            }
        })();
        var domain = cookieAttributes && cookieAttributes.domain ?
            cookieAttributes.domain : cookieManager.computeCookieDomain(document.location.hostname, false);
        var path = cookieAttributes && cookieAttributes.path ?
            cookieAttributes.path : DEFAULT_PATH;

        function getCookieValues(cookieName) {
            var i, currentName, currentValue, decodedValue,
                allCookies = window.document.cookie.split(";"),
                cookieValue = {};
            for (i = 0; i < allCookies.length; i++) {
                currentName = allCookies[i].substr(0, allCookies[i].indexOf("="));
                currentName = currentName.replace(/^\s+|\s+$/g, "");
                if (currentName === cookieName) {
                    currentValue = allCookies[i].substr(allCookies[i].indexOf("=") + 1);
                    try {
                      cookieValue = JSON.parse(decodeURIComponent(currentValue));
                    } catch (err) {
                      cookieValue = decodeURIComponent(currentValue);
                    }

                }
            }
            return cookieValue;
        }

        function computeNewExpiryDateString() {
            var expiryDate = new Date();
            expiryDate.setDate(expiryDate.getDate() + lifetimeAsDays);
            return expiryDate.toUTCString();
        }

        /**
         * Update the *full* value of the cookie, incl. writing all other cookie attributes according to
         * configuration of cookie manager.
         * @param cookieValue an object where each own property is an entry in the cookie value.
         */
        function updateCookie(cookieValue) {
            var cookieParts = [
                cookieName + '=' + encodeURIComponent(JSON.stringify(cookieValue)),
                'path=' + path,
                'domain=' + domain
            ];
            if (lifetimeAsDays) {
                cookieParts.push('expires=' + computeNewExpiryDateString());
            }

            window.document.cookie = cookieParts.join(';');
        }

        /**
         * Merge new values into existing/old values.
         * @param newCookieValues an object holding all new cookie value entries (entries may already exist
         * in existingCookieValues)
         * @param existingCookieValues an object holding all existing cookie value entries.
         * @returns {*}
         */
        function mergeNewIntoOldValues(newCookieValues, existingCookieValues) {
            Object.keys(newCookieValues).forEach(function (key) {
                existingCookieValues[key] = newCookieValues[key];
            });
            return existingCookieValues;
        }

        function updateCookieValues(cookieValues) {
            var oldCookieValue = getCookieValues(cookieName);
            if (Object.keys(oldCookieValue).length === 0) {
                updateCookie(cookieValues);
            } else {
                updateCookie(mergeNewIntoOldValues(cookieValues, oldCookieValue));
            }
        }

        function isValidCookieValueEntries(entries) {
            return typeof entries === 'object' && Object.prototype.toString.call( entries ) !== '[object Array]';
        }

        return {
            get cookieName() { return cookieName; },
            /**
             *
             * @param key a key (String)
             * @param value a value, can be any type of object (incl. nested). value can be a JSON string but will
             *     *not*  be parsed.
             */
            store : function(key, value) {
                var newValue = {};
                newValue[key] = value;
                updateCookieValues(newValue);
            },
            /**
             *
             * @param entries an object where all own properties will be added to the cookie value (rules for values
             * from store function apply here as well). Existing entries will be overwritten. No object encoded as
             * Json string accepted, no Arrays either.
             */
            storeAll : function(entries) {
                if (!isValidCookieValueEntries(entries)) {
                    throw new TypeError('cookieManager.storeAll accepts only objects (incl. no arrays), parameter was "'
                        + entries + '"');
                }
                updateCookieValues(entries);
            },
            /**
             * Get the value of a single entry from the cookie.
             * @param key
             * @returns {*}
             */
            getValue : function(key) {
                return getCookieValues(cookieName)[key];
            },
            /**
             * Get all entries (as an object) from the cookie.
             * @returns {*}
             */
            getValues : function() {
                return getCookieValues(cookieName);
            }
            // if needed, add remove(key) and removeAll(keys) functions to the api
        };
    };

    /**
     * Factory function which produces a cookie manager for the given cookie name and config.
     * @param cookieName
     * @param cookieAttributes: see constructor documentation
     * @returns {CookieManager}
     */
    cookieManager.forCookie = function(cookieName, cookieAttributes) {
        return new CookieManager(cookieName, cookieAttributes);
    };

    /**
     *
     * @param cookieName the name of the cookie
     * @param cookieAttributes attributes of the cookie (but note that expires attributes cannot be overwritten, it will
     * be added to that object)
     * @returns {CookieManager}
     */
    cookieManager.forSessionCookie = function(cookieName, cookieAttributes) {
        cookieAttributes = cookieAttributes || {};
        cookieAttributes['expireDays'] = null;
        return new CookieManager(cookieName, cookieAttributes);
    };

    /**
     * Convenience factory function which produces a cookie manager for the standard GD cookie.
     * @param cookieAttributes: see constructor documentation
     * @returns {CookieManager}
     */
    cookieManager.forGDStandardCookie = function () {
        // TODO what is the name of the standard cookie?
        return new CookieManager('GD');
    };

    /**
     * Extracts the cookie domain from the given hostname.
     * @param hostname
     * @param includeSubDomains if true all subdomains will be omitted
     */
    cookieManager.computeCookieDomain = function(hostname, includeSubDomains) {
        if (hostname.indexOf('gameduell') !== -1 && !includeSubDomains) {
            var hostnameParts = hostname.split('.');
            for (var i = 0; i < hostnameParts.length; i++) {
                if (hostnameParts[i] === "gameduell") {
                    // some infos about the leading dot:
                    // http://stackoverflow.com/questions/9618217/what-does-the-dot-prefix-in-the-cookie-domain-mean
                    // tl;dr: an obsolete RFC defined that a domain with a leading dot would mean "allow for
                    // subdomains, too" IE8/9 are still affected. Others should just disregard the dot (as per newer
                    // RFC)
                    return '.' + hostnameParts.splice(i).join('.');
                }
            }
        }

        return hostname;
    };

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = cookieManager;
    } else {
        canny.add('cookieManager', cookieManager);
    }

}());

},{}],50:[function(require,module,exports){
/*global */
/*jslint browser: true*/
/**
 *
 * E.g.:
 *  canny-mod="moduleObj" canny-var="{'propertyKey':'value'}"
 *  canny-mod="moduleString" canny-var="button"
 *
 * Instead of canny-var you can use the module name to avoid conflicts like:
 * E.g.: canny-mod="mod1 mod2" canny-mod1={'foo':'123456', 'bar':'654321'} canny-mod2="mod2Property"
 *
 * ---------------------------------------------------------------------------- eightyfour
 */
(function (global) {
    "use strict";
    var canny = (function () {
        var readyQueue = [],
            readyQueueInit = false,
            moduleQueue = []; // save modules to call the ready method once

        /**
         * Find the single quotes and replace them with double quotes except string which
         * are part of the property string.
         *
         * @param string
         * @returns {string}
         */
        function escapeStringForJSON(string) {
            var s = string
                .replace(/\{\s*\'/g,'{"').replace(/\'\s*\}/g,'"}')
                .replace(/:\s*\'/g,':"').replace(/\'\s*:/g,'":')
                .replace(/,\s*\'/g,',"').replace(/\'\s*,/g,'",')
                .replace(/\[\s*\'/g,'["').replace(/\'\s*\]/g,'"]');
            return s;
        }

        function escapeStringForJSONArray(string) {
            var s = string
                .replace(/,\s*\'/g,',"').replace(/\'\s*,/g,'",')
                .replace(/\[\s*\'/g,'["').replace(/\'\s*\]/g,'"]');
            return s;
        }

        function callMethodQueue(queue) {
            (function reduce() {
                var fc = queue.pop();
                if (fc) {
                    fc();
                    reduce();
                } else {
                    queue = [];
                }
            }());
        }

        function parseNode(node, name, cb) {
            var that = this, gdModuleChildren = [].slice.call(node.querySelectorAll('[' + name + '-mod]')), prepareReadyQueue = {};

            gdModuleChildren.forEach(function (node) {
                var attribute = node.getAttribute(name + '-mod'), attr, viewPart, attributes, cannyVar;

                attributes = attribute.split(' ');

                attributes.forEach(function (moduleName) {
                    if (that[moduleName]) {
                        if (node.getAttribute(name + '-mod')) {
                            if (node.getAttribute(name + '-' + moduleName)) {
                                cannyVar = node.getAttribute(name + '-' + moduleName);
                            } else {
                                cannyVar = node.getAttribute(name + '-var');
                            }
                            if (cannyVar) {
                                // simple JSON test
                                if (/\{\s*\'|\".*:.*\}/.test(cannyVar)) {
                                    attr = escapeStringForJSON(cannyVar);
                                    // could be a JSON
                                    try {
                                        viewPart = JSON.parse(attr);
                                    } catch (ex) {
                                        console.error("canny can't parse passed JSON for module: " + moduleName, node);
                                    }
                                } else if (/\[\s*\'|\".*\'|\"\]/.test(cannyVar)) {
                                    attr = escapeStringForJSONArray(cannyVar);
                                    try {
                                        viewPart = JSON.parse(attr);
                                    } catch (ex) {
                                        console.error("canny can't parse passed JSON for module: " + moduleName, node);
                                    }
                                } else {
                                    viewPart = cannyVar;
                                }
                            }
                        }
                        // has module a ready function than save it for calling
                        if (that[moduleName].hasOwnProperty('ready')) {
                            // TODO or call it immediately?
                            prepareReadyQueue[moduleName] = that[moduleName].ready;
                        }
                        if (that.hasOwnProperty(moduleName)) {
                            that[moduleName].add(node, viewPart);
                        }
                    } else {
                        console.warn('canny parse: module with name ´' + moduleName + '´ is not registered');
                    }
                });
            });
            // add ready callback to moduleQueue
            Object.keys(prepareReadyQueue).forEach(function (name) {
                moduleQueue.push(prepareReadyQueue[name]);
            });
            cb && cb();
        }

        document.addEventListener('DOMContentLoaded', function cannyDomLoad() {
            document.removeEventListener('DOMContentLoaded', cannyDomLoad);

            parseNode.apply(canny, [document, 'canny']);

            callMethodQueue(moduleQueue);
            // call registered ready functions
            readyQueueInit = true;
            callMethodQueue(readyQueue);
        }, false);

        return {
            add : function (name, module) {
                var moduleApi = module;
                if (!this.hasOwnProperty(name)) {
                    if (typeof module === 'function') {
                        moduleApi = module(this); // initialize the module with the actual canny instance
                    }
                    this[name] = moduleApi;
                } else {
                    console.error('canny: Try to register module with name ' + name + ' twice');
                }
            },
            ready : function (fc) {
                if (!readyQueueInit) {
                    readyQueue.push(fc);
                } else {
                    fc();
                }
            },
            cannyParse : function (node, name, cb) {
                // TODO needs a callback
                if (typeof name === 'function') {
                    cb = name;
                    name = "canny";
                }
                parseNode.apply(this || canny, [node, name || 'canny', function () {
                    callMethodQueue(moduleQueue);
                    cb && cb();
                }]);
            }
        };
    }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) { module.exports = canny; } else {global.canny = canny; }
}(this));
},{}],51:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * Required: 'canny' in global scope
 *
 * E.g.:
 * canny.async.load(URL, function (src) {
 *     node.innerHTML = src;
 *     // trigger canny parse to register canny on our new modules
 *     canny.cannyParse(node, function () {
 *         console.log('CANNY PARSE DONE');
 *     });
 * });
 *
 * Alternative you can just use loadHTML (scripts will automatically added and parsed by canny):
 * canny.async.loadHTML(node, {url : URL}, function () {
 *     console.log('kodos_load READY');
 * });
 *
 * Or directly as canny module:
 * <div canny-mod="async" canny-var="{'url':'/you/HTML/file.html'}"></div>
 *
 * TODO solve dependency problem to canny.
 *
 */
(function () {
    'use strict';
    var async = (function () {
        var filesToLoad = [],
            pushLoadCBs = [],
            ready = false;

        /**
         *
         * @param script
         * @param mediaURL
         * @param cb
         */
        function appendScript(script, mediaURL, cb) {
            var node = document.createElement('script'),
                src = script.getAttribute('src');
            // handle mediaURL and all relative script are loaded from the media URL string
            if (mediaURL && src[0] !== '/') {
                if (mediaURL[mediaURL.length - 1] !== '/') {
                    mediaURL += '/';
                }
                src = mediaURL + src;
            }
            node.type = "text/javascript";
            node.async = true;
            node.setAttribute('src', src);
            node.addEventListener('load', cb, false);
            node.addEventListener('error', cb, true);
            document.head.appendChild(node);
        }

        /**
         *
         * @param scripts
         * @param mediaURL
         * @param cb
         */
        function appendScriptsToHead(scripts, mediaURL, cb) {
            var script, i, includesScripts = false,
                scriptCounter = (function () {
                    var count = 0;
                    return {
                        up : function () {count++; },
                        ready : function () {
                            count--;
                            if (count <= 0) {
                                cb();
                            }
                        }
                    };
                }());

            for (i = 0; i < scripts.length; i++) {
                script = scripts[i];
                if (script.getAttribute('src')) {
                    includesScripts = true;
                    scriptCounter.up();
                    appendScript(script, mediaURL, scriptCounter.ready);
                } else {
                    console.warn('async: found inline script tag!!!');
                }
            }

            if (scripts.length === 0 || includesScripts === false) {
                cb();
            }

        }

        /**
         * Parse the complete given DOM and prefix all relative href URL's with the given URL
         * All URL's are handled as relative if there starts not with a / or http:// or https://
         * TODO add support for URL's with a ./ or ../ and so on
         *
         * @param node parent element
         * @param mediaURL mediaPath to another server
         */
        function handleLinks(node, mediaURL) {
            Array.prototype.slice.call(node.querySelectorAll('link')).forEach(function (link) {
                var href = link.getAttribute('href');
                if (link.getAttribute('type') === 'text/css' && 
                        href !== undefined && 
                        href[0] !== '/' &&
                        !/^http:\/\/.*/.test(href) &&
                        !/^https:\/\/.*/.test(href)) {
                    if (mediaURL[mediaURL.length - 1] !== '/') {
                        mediaURL += '/';
                    }
                    href = mediaURL + href;
                    link.setAttribute('href', href);
                }
            })
        }

        /**
         *
         * @param node
         * @param attr {{url:string, mediaURL: string}}
         * @param cb
         */
        function loadHTML(node, attr, cb) {
            var template = document.createElement('template'),
                div = ('content' in template ? template : document.implementation.createHTMLDocument('main').body),
                body,
                scripts,
                // only parse if html and scripts are loaded (scripts has callbacks because there are needs to loaded asynchronous)
                handleCannyParse = (function (cb) {
                    var waitForScripts = true,
                        waitForHTML = true,
                        triggger = function () {
                            if (!waitForScripts && !waitForHTML) {
                                canny.cannyParse(node, cb); // init only canny own modules
                            }
                        };
                    return {
                        scriptReady : function () {
                            waitForScripts = false;
                            triggger();
                        },
                        htmlReady : function () {
                            waitForHTML = false;
                            triggger();
                        }
                    };
                }(function () {
                    cb(attr);
                }));

            load(attr.url, function (src) {
                var childs;
                if (src) {
                    div.innerHTML = src;
                    // if it is a template we need the content
                    body = 'content' in div ? div.content : div;
                    scripts = body.querySelectorAll('script');
                    childs = [].slice.call(body.childNodes);
                    appendScriptsToHead(scripts, attr.mediaURL, handleCannyParse.scriptReady);

                    if (attr.mediaURL) {
                        handleLinks(body, attr.mediaURL);
                    }
                    childs.forEach(function (child) {
                        if (!(child.tagName === 'SCRIPT' && child.getAttribute('src'))) {
                            node.appendChild(child);
                        }
                    });
                    handleCannyParse.htmlReady();
                } else {
                    console.warn('async: Loading async HTML failed');
                }
            });
        }
        /**
         * simple wrapper to load HTML files with GET
         * @param path
         * @param cb
         */
        function load(path, cb) {
            doAjax({
                method: 'GET',
                path: path,
                onSuccess: function (response) {
                    cb(response.responseText);
                }
            });
        }
        /**
         *
         * @param params {{
         *   noCache:boolean,
         *   method:string|POST(default),
         *   data:object|string,
         *   path:string,
         *   async:boolean|true(default),
         *   onRequest:function (will be called with the xmlHTTPRequest object quite close before the send method is called),
         *   onFailure:function,
         *   onSuccess:function,
         *   contentType:string|Content-Type(default),
         *   mimeType:string|text plain(default)
         * }}
         */
         function doAjax(params) {
            var call = new XMLHttpRequest();
            var url = params.path;
            if (params.method === 'GET' && typeof params.data === 'object') {
                for (var attr in params.data) {
                    url = url + ((/\?/).test(url) ? "&" : "?") + attr + "=" + params.data[attr];
                }
            }
            if (params.noCache) {
                url = url + ((/\?/).test(url) ? "&" : "?") + "ts=" + (new Date()).getTime();
            }
            params.method = params.method || 'POST';
            call.open(params.method, url, params.async !== false);

            if (params.onSuccess) {
                call.addEventListener("load", function (s) {
                    params.onSuccess(s.target);
                });
            }

            if (params.onFailure) {
                call.addEventListener("error", function (s) {
                    params.onFailure(s.target);
                });
            }

            call.setRequestHeader(params.contentType || "Content-Type", params.mimeType || "text/plain");

            // allow the caller to do some extra stuff on the request object
            if (params.onRequest && typeof params.onRequest === 'function') {
                params.onRequest(call);
            }

            if (params.method === 'POST') {
                call.send(params.data);
            } else {
                call.send(null);
            }
        }

        return {
            /**
             * add a callback. So you will be notified when files are loaded asynchronous.
             * You will be called only once except your return true then async will keep
             * your callback in the notifier list and you will be informed for each async request.
             *
             * The async module will call each callback with the actual attr. So you have the control
             * how often you will be notified.
             *
             * Might be changed in the future version of async:
             * Currently this is only executed for canny modules which are loaded from the DOM directly.
             *
             * @param fc
             */
            pushLoadCB : function (fc) {
                pushLoadCBs.push(fc);
            },
            /**
             * Do a simple ajax call.
             *
             * @param params {{
             *   noCache:boolean,
             *   method:string|POST(default),
             *   data:object,string,
             *   async:boolean|true(default),
             *   path:string,
             *   onRequest:function (will be called with the xmlHTTPRequest object quite close before the send method is called),
             *   onFailure:function,
             *   onSuccess:function,
             *   contentType:string|Content-Type(default),
             *   mimeType:string|text plain(default)
             * }}
             */
            doAjax: doAjax,
            /**
             *
             * @param node
             * @param attr {{
             *  url:string,
             *  mediaURL:string
             * }}
             * @param cb
             */
            loadHTML : loadHTML,
            /**
             * Deprecated: use loadHTML instead
             * @param path
             * @param cb
             */
            load: function () {
                console.warn('async:load function load is deprecated. Use loadHTML instead');
                load.apply(null, arguments);
            },
            /**
             * canny's add method
             *
             * @param node
             * @param attr
             */
            add: function (node, attr) {    // part of api
                // TODO implement logic for loading it directly from html
                if (attr.hasOwnProperty('url')) {
                    if (!ready) {
                        filesToLoad.push({
                            node: node,
                            attr: attr
                        });
                    } else {
                        loadHTML(node, attr);
                    }
                }
            },
            ready: function () {
                var obj, cbCount = filesToLoad.length;
                while (filesToLoad.length > 0) {
                    obj = filesToLoad.splice(0, 1)[0];
                    loadHTML(obj.node, obj.attr, function (attr) {
                        var keepPushCB = [], tmpCb;
                        cbCount--;
                        while (pushLoadCBs.length > 0) {
                            tmpCb = pushLoadCBs.splice(0, 1)[0];
                            if (tmpCb(attr) === true) {
                                keepPushCB.push(tmpCb);
                            }
                        }
                        pushLoadCBs = keepPushCB;
                    });
                }
            }
        };
    }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = async;
    } else {
        canny.add('async', async);
    }

}());
},{}],52:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * E.g.: canny-mod="flowControl" canny-var="{'view' : 'viewName'}"
 *
 * you can activate a initial view with a anchor in the URL e.g.: yourdomain.html#viewToShow
 * Or pass a comma separated module list for activate more module #viewToShow,otherView.
 *
 * TODO made it possible to summarize views with one identifier.
 * Instead of call: canny.flowControl.show('view1', 'view2', 'view3') call canny.flowControl.show('view').
 *
 * TODO add a hide method that just hide the specific element.
 *
 * TODO handle the fade in and out via CSS classes - and use transitions for it
 */
(function () {
    "use strict";

    /**
     * wraps transitionend event vendor implementation
     */
    function onTransitionEndOnce(node, cb) {
        var event = (function () {
                if (node.style.webkitTransition !== undefined) {
                    return 'webkitTransitionEnd';
                } else if (node.style.transition !== undefined) {
                    return 'transitionend';
                }
            }()),
            listener = function(e) {
                e.target.removeEventListener(e.type, listener);
                cb(e);
            };
        if (event) {
            node.addEventListener(event, listener, false);
        } else {
            cb();
        }
    }

    var flowControlInstance = function (fcInstanceName) {
            var instanceName = fcInstanceName,
                // flag to save if the initial queue is already initialized or not
                showInitialViewComplete = false,
                onShowInitialViewComplete = [],
                modViews = {}, // saves module views
                getViewAnchor = function () {
                    var hash = location.hash || null,
                        rx = new RegExp('[^a-zA-Z-_,]', 'g'),
                        hashSub;

                    if (hash) {
                        hashSub = hash.substr(1);
                        if (hashSub.search(rx) > -1) {
                            hashSub = hashSub.substring(0, hashSub.search(rx));
                        }
                        return hashSub.split(',');
                    }

                    return hash;
                },
                getAllModuleChildrens = function (cNode) {
                    // TODO test selector if we have more than one module in canny-mod
                    var children = cNode.querySelectorAll('[canny-mod*=' + instanceName + ']'),
                        fc_childNodes = {};
//                            if (cNode.hasChildNodes()) {
//                                [].slice.call(cNode.children).forEach(findChildren);
//                            }
                    [].slice.call(children).forEach(function (mod) {
                        var attrValue, view;
                        // TODO read attributes should be a part of canny functionality
                        attrValue = mod.getAttribute('canny-var').split("\'").join('\"');
                        if (/:/.test(attrValue)) {
                            // could be a JSON
                            view = JSON.parse(attrValue).view;
                        } else {
                            view = attrValue;
                        }
                        fc_childNodes[view] = mod;
                    });
                    return fc_childNodes;
                },
                /**
                 * Each flowControl node will end up in a flowControlModule.
                 *
                 * @param node
                 * @param attr
                 * @returns {{hasChildrenWithName: hasChildrenWithName, getViewName: getViewName, show: show, hide: hide, fadeOut: fadeOut, getNode: getNode, fadeIn: fadeIn}}
                 */
                flowControlModule = function (node, attr) {
                    var flowControlChildNodes = {},
                        async = false,
                        parentViews = fc.getParentNode(attr.view);
                    // saves all children in a object
                    flowControlChildNodes = getAllModuleChildrens(node);
//                    console.log('flowControlChildNodes:', flowControlChildNodes);
                    return {
                        hasChildrenWithName : function (viewName) {
                            return flowControlChildNodes.hasOwnProperty(viewName);
                        },
                        getViewName : function () {
                            return attr.view;
                        },
                        display : function () {
                            // don't call parents
                            // don't fade in
                            node.style.display = '';
                        },
                        show : function (cb) {
                            if (parentViews) {
                                parentViews.forEach(function (fc_module) {
//                                console.log('parentViews', fc_module.getViewName());
                                    fc_module.display();
                                });
                            }
                            if (!async && attr.hasOwnProperty('async')) {
                                canny.async.loadHTML(node, {url : attr.async}, function () {
                                    if (attr.whisker) {
                                        if (canny.whisker !== undefined) {
                                            canny.whisker.add(node, attr.whisker);
                                        } else {
                                            console.error("flowControl:try execute whisker but no whisker module is registered on canny.")
                                        }
                                    }
                                    node.style.display = '';
                                    cb();
                                });
                                async = true;
                            } else {
                                node.style.display = '';
                                cb && cb();
                            }
                        },
                        hide : function () {
                            node.style.display = 'none';
                        },
                        fadeOut : function (cb) {
                            fc.fadeOut(node, cb || function () {});
                        },
                        getNode : function () {
                            return node;
                        },
                        fadeIn : function (cb) {
                            if (parentViews) {
                                parentViews.forEach(function (fc_module) {
//                                console.log('parentViews', fc_module.getViewName());
                                    fc_module.display();
                                });
                            }
                            if (!async && attr.hasOwnProperty('async')) {
                                canny.async.loadHTML(node, {url : attr.async}, function () {
                                    if (attr.whisker) {
                                        if (canny.whisker !== undefined) {
                                            canny.whisker.add(node, attr.whisker);
                                        } else {
                                            console.error("flowControl:try execute whisker but no whisker module is registered on canny.");
                                        }
                                    }
                                    fc.fadeIn(node,  cb || function () {});
                                });
                                async = true;
                            } else {
                                fc.fadeIn(node,  cb || function () {});
                            }
                        }
                    };

                },
                showInitialView = getViewAnchor(),
                fc = {
                    // get all parent modules from the given viewName
                    getParentNode : function (viewName) {
                        var queue = Object.keys(modViews), l, i, parents = [];
                        l = queue.length;
                        for (i = 0; i < l; i++) {
                            // TODO
                            if (viewName !== queue[i] && modViews[queue[i]][0].hasChildrenWithName(viewName)) {
                                parents.push(modViews[queue[i]][0]);
                            }
                        }
                        return parents.length === 0 ? null : parents;
                    },
                    // passes a view list and complete the list with all parent node names
                    addParents : function (views) {
                        var extViews = views, i, l, pNode,
                            pushExtViews = function (name) {
                                if (extViews.indexOf(name) === -1) {
                                    extViews.push(name);
                                }
                            },
                            addParentView = function (viewName) {
                                // TODO call ends always with null - viewName is top parent
                                var pViewName = fc.getParentNode(viewName);
//                            console.log('viewName: ' + viewName, 'pViewName ' + pViewName );
                                if (pViewName) {
                                    pViewName.forEach(function (fc_module) {
                                        // TODO while has parent add it to the extViews
                                        pushExtViews(fc_module.getViewName());
                                        addParentView(fc_module.getViewName());
                                    });
                                }
                            };
                        l = views.length;
                        for (i = 0; i < l; i++) {
                            pNode = fc.getParentNode(views[i]);
                            if (pNode) {
                                pNode.forEach(function (fc_module) {
                                    pushExtViews(fc_module.getViewName());
                                    // so far we have parents do it recursive
                                    // TODO not needed each parent will do it by own -
                                    addParentView(fc_module.getViewName());
                                });
                            }
                        }
                        return extViews;
                    },
                    fadeOut : function (node, cb) {

                        if(node.style.display === 'none') {
                            cb();
                        } else {
                            node.classList.add('c-flowControl');
                            node.classList.add('fade-out');

                            setTimeout(function () {
                                node.style.display = 'none';
                                node.classList.remove('c-flowControl');
                                node.classList.remove('fade-out');
                                cb();
                            }, 300);
                        }

                    },
                    fadeIn : function (node, cb) {
                        // TODO: fade in does not work properly
                        node.style.display = '';
                        node.classList.add('c-flowControl');
                        node.classList.add('fade-in');

                        setTimeout(function() {
                            node.classList.remove('c-flowControl');
                            node.classList.remove('fade-in');
                            cb();

                            // trigger reflow to fix the black boxes issue FTTWO-1249
                            // TODO: check if this can be avoided or
                            var box = document.querySelector('.t-centerBox-content');
                            if (box) {
                                box.style.opacity = 0.99;
                                setTimeout(function() {
                                    box.style.opacity = 1;
                                }, 50);
                            }
                        }, 300);
                    }
                },
                ext = {
                    /**
                     *
                     * @param node
                     * @param innerNode
                     * @returns {{remove: remove}}
                     */
                    progress : function (node, innerNode) {
                        var newNode = document.createElement('div'), centerNode = document.createElement('div'), txtNode;
                        node.style.position = 'relative';
                        newNode.style.opacity = '0.6';
                        newNode.style.backgroundColor = '#666';
                        newNode.style.position = 'absolute';
                        newNode.style.top = 0;
                        newNode.style.left = 0;
                        newNode.style.width = node.offsetWidth + 'px';
                        newNode.style.height = node.offsetHeight + 'px';
                        newNode.style.borderRadius = window.getComputedStyle(node, null).borderRadius;

                        centerNode.style.position = 'absolute';
                        centerNode.style.top = (node.offsetHeight / 2) - 30 + 'px';
                        centerNode.style.width = node.offsetWidth + 'px';
                        centerNode.style.textAlign = 'center';

                        if (innerNode) {
                            centerNode.appendChild(innerNode);
                        }
                        node.appendChild(newNode);
                        node.appendChild(centerNode);
                        return {
                            remove : function (delay, cb) {
                                setTimeout(function () {
                                    node.removeChild(newNode);
                                    node.removeChild(centerNode);
                                    cb && cb();
                                }, delay || 0);
                            },
                            fadeOut : function (delay, cb) {
                                setTimeout(function () {
                                    fc.fadeOut(newNode, function () {
                                        node.removeChild(newNode);
                                        node.removeChild(centerNode);
                                        cb && cb();
                                    });
                                }, delay || 0);
                            }
                        };
                    }
                },
                /**
                 *
                 * @type {{mod: {}, createNewInstance: createNewInstance, ready: ready, add: add, show: show, fadeIn: fadeIn, showImmediately: showImmediately, overlay: overlay}}
                 */
                api = {
                    mod : modViews, // part of api
                    /**
                     * this method could be used to create new instances of flowControl (only needed if you
                     * load this script directly without require)
                     * @param name (unique module name)
                     **/
                    createNewInstance : function (name) {
                        return flowControl(name);
                    },
                    ready : function () {
                        var modNames = Object.keys(modViews),
                            callInitialViewCompleteQueue = true,
                            l = modNames.length,
                            i;
                        if (showInitialView && l > 0) {
                            // check if showInitialView contains a registered module
                            for (i = 0; i < l; i++) {
                                // check for existing name in showInitialView
                                if (showInitialView.indexOf(modNames[i]) !== -1) {
                                    showInitialView.push(function () {
                                        onShowInitialViewComplete.forEach(function(fc) {
                                            showInitialViewComplete = true;
                                            fc();
                                        });
                                    });
                                    callInitialViewCompleteQueue = false;
                                    api.showImmediately.apply(null, showInitialView);
                                    break;
                                }
                            }
                        }

                        if (callInitialViewCompleteQueue) {
                            onShowInitialViewComplete.forEach(function(fc) {
                                showInitialViewComplete = true;
                                fc();
                            });
                        }
                    },
                    /**
                     * Calls the given function after loading all initial views.
                     *
                     * @param fc
                     */
                    onShowInitialViewComplete : function(fc) {
                        // make sure that the passed function will be called also after initialisation
                        if (!showInitialViewComplete) {
                            onShowInitialViewComplete.push(fc);
                        } else {
                            fc();
                        }
                    },
                    /**
                     *
                     * @param node
                     * @param attr {{view:(identifier),}}
                     */
                    add : function (node, attr) {    // part of api
                        if (!modViews[attr.view]) {
                            modViews[attr.view] = [];
                        }
                        modViews[attr.view].push(flowControlModule(node, attr));
                    },
                    /**
                     * @deprecated will handle showImmediately in near future
                     */
                    show : function () {
                        api.fadeIn.apply(this, arguments);
                    },
                    /**
                     * @param name (arguments list of views to show)
                     */
                    fadeIn : function (name) {
                        var showMods = [].slice.call(arguments),
                            queue = Object.keys(modViews),
                            queueCount = 0,// = queue.length,
                            fadeIn = function () {
                                showMods.forEach(function (module) {
                                    if (modViews.hasOwnProperty(module)) {
                                        modViews[module].forEach(function (obj) {
                                            obj.fadeIn(function () {
                                                // TODO remove
//                                                console.log('FADE IN DONE');
                                                // TODO count callbacks and handle it ?
                                            });
                                        });
                                    }
                                });
                                // if last param is function than handle it as callback
                                if (typeof showMods[showMods.length - 1] === 'function') {
                                    showMods[showMods.length - 1]();
                                }
                            };
                        showMods = fc.addParents(showMods);
                        queue.forEach(function (view) {
                            queueCount += modViews[view].length;
                        });
                        // iterate over all registered modules
                        queue.forEach(function (view) {
                            // iterate over all instances of the same view
                            modViews[view].forEach(function (obj) {
                                // hide all (except incoming and parents) TODO but only the parents of the module
                                if (showMods.indexOf(view) === -1) {
                                    obj.fadeOut(function () {
                                        queueCount--;
                                        if (queueCount <= 0) {
                                            fadeIn();
                                        }
                                    });
                                } else {
                                    queueCount--;
                                    if (queueCount <= 0) {
                                        fadeIn();
                                    }
                                }
                            });
                        });
                    },
                    /**
                     * @deprecated use show instead
                     * @param name
                     */
                    showImmediately : function () {    // module specific
                        var showMods = [].slice.call(arguments),
                            queue = Object.keys(modViews),
                            countCb = (function () {
                                var cb, length = 0;
                                // if last param is function than handle it as callback
                                if (typeof showMods[showMods.length - 1] === 'function') {
                                    cb = showMods[showMods.length - 1];
                                }
                                return {
                                    countUp : function (num) {
                                        length += num;
                                    },
                                    reduce : function () {
                                        length--;
                                        if (cb && length <= 0) {
                                            cb();
                                        }
                                    }
                                };
                            }()),
                            show = function () {
                                showMods.forEach(function (module) {
                                    if (modViews.hasOwnProperty(module)) {
                                        countCb.countUp(modViews[module].length);
                                        modViews[module].forEach(function (obj) {
                                            obj.show(countCb.reduce);
                                        });
                                    }
                                });
                            };
                        showMods = fc.addParents(showMods);
                        // hide all (except incoming)
                        queue.forEach(function (view) {
                            modViews[view].forEach(function (obj) {
                                if (showMods.indexOf(obj) === -1) {
                                    obj.hide();
                                }
                            });
                        });
                        show();
                    },
                    overlay : function (name) {
                        var node;
                        // it's own module?
                        if (modViews.hasOwnProperty(name)) {
                            node = modViews[name].getNode();
                        } else {
                            node = document.getElementById(name);
                        }

                        return {
                            by : function (name, text) {
                                return ext[name](node, text);
                            }
                        };
                    }
                };
            return api;
        },
        flowControl = (function () {
            var instances = {};
            return function (name) {
                var instance,
                    def = name || 'flowControl';
                if (instances.hasOwnProperty(def)) {
                    instance = instances[def];
                } else {
                    instances[def] = flowControlInstance(def);
                    instance = instances[def];
                }
                return instance;
            };
        }());
    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) { module.exports = flowControl; } else {canny.add('flowControl', flowControl('flowControl')); }

}());
},{}],53:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/

/**
 * repeat
 *
 * E.g.
 *  <div canny-mod="repeat" canny-var="{'for':'item', 'in':'path.to.list'}">
 *     <p>DATA: {{item}})</p>
 *  </div>
 *  or:
 *  <div canny-mod="repeat" canny-var="{'for':'objectItem', 'in':'path.to.object'}">
 *     <p>DATA FOO: {{objectItem.foo}})</p>
 *     <p>DATA BAR: {{objectItem.bar}})</p>
 *  </div>
 *
 * for:
 * is the name of the iterating item to have access from the DOM.
 *
 * in:
 * is the source where repeat can find the array.
 * It accepts functions, array, and objects pointer
 * - object: keep in mind that object has no specific sorting
 * - array:
 * - function: repeat will call it with the following parameter:
 *  * function which needs to be called with the object or list
 *  * ...
 *
 *  TODO: add example to get data direct from
 *   * a list of function
 *   * a object which contain functions
 *
 */
(function () {
    'use strict';

    var openChar = '{',
        endChar  = '}',
        ESCAPE_RE = /[-.*+?^${}()|[\]\/\\]/g,
        repeat = (function () {
            var BINDING_RE = getRegex();

            /**
             *  Parse a piece of text, return an array of tokens
             *  TODO refactor method
             *  @param text
             *  @return [{key:String, html:boolean}]
             */
            function parse(text) {
                if (!BINDING_RE.test(text)) {return null; }
                var m, i, token, match, tokens = [], orig = {text: text, idx : 0}, textObject;
                /* jshint boss: true */
                while (m = text.match(BINDING_RE)) {
                    i = m.index;
                    token = {concat : true};
                    if (i > 0) {
                        if (orig.idx === 0) {
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                            orig.idx += i;
                        } else {
                            orig.idx += i;
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                        }
                        tokens.push(textObject);
                    }
                    orig.idx += i;
                    token.key = m[1].trim();
                    match = m[0];
                    token.html =
                        match.charAt(2) === openChar &&
                        match.charAt(match.length - 3) === endChar;
                    tokens.push(token);
                    text = text.slice(i + m[0].length);
                }
                if (text.length) {
                    tokens.push({value : text, text : true, concat: true});
                }
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             * @return tokens [{key:String, node:DOM node, html: boolean}]
             */
            function compileTextNode(node, dataObj, itemName) {
                var tokens = parse(node.nodeValue),
                    obj = dataObj,
                    el, token, i, l, tmp, tokenObjectProperty, val;
                if (!tokens || obj === undefined) {return; }

                for (i = 0, l = tokens.length; i < l; i++) {
                    token = tokens[i];
                    if (typeof token === 'object' && token.hasOwnProperty('key')) {
                        tmp = token.key.split('.');

                        if (tmp.length > 0 && tmp[0] === itemName) {

                            if (tmp[0] !== itemName) {
                                // TODO implement error handling if key doesn't match with itemName
                                console.error('repeat:compileTextNode hups something is wrong which needs to be fixed!!! Token with name', token.key, 'doesn\'t match with scope name: ', itemName , ' Repeat will continue but be carefully this "bug" will be removed in next version of repeat!!!');
                            }

                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                val = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                val = obj;
                            }
                        } else {
                            // just a string?
                            val = obj;
                        }
                        if (typeof val === 'string' || typeof val === 'number') {
                            el = document.createTextNode(val);
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'boolean') {
                            el = document.createTextNode(val.toString());
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'function') {
                            el = document.createTextNode(val(node.parentNode));
                            node.parentNode.insertBefore(el, node);
                        } else if (tmp[0] === itemName) {
                            // property is not exists but it is the same scope
                            el = document.createTextNode('');
                            node.parentNode.insertBefore(el, node);
                        } else {
                            // restore the token... looks like is not mine
                            el = document.createTextNode('{{' + token.key + '}}');
                            node.parentNode.insertBefore(el, node);
                        }
                        token.node = el;
                    } else {
                        el = document.createTextNode(token.value);
                        // just normal string put back to view
                        node.parentNode.insertBefore(el, node);
                    }
                }
                node.parentNode.removeChild(node);
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             */
            function compileElement (node, dataObj, itemName) {
                // recursively compile childNodes
                if (node.hasChildNodes()) {
                    [].slice.call(node.childNodes).forEach(function (child) {
                        compile(child, dataObj, itemName);
                    });
                }
            }
            /**
             * Compile a DOM node (recursive)
             * @param node
             * @param dataObj
             * @param itemName
             * @returns {*}
             */
            function compile(node, dataObj, itemName) {
                var nodeType = node.nodeType;
                if (nodeType === 1 && node.tagName !== 'SCRIPT') { // a normal node
                    compileElement(node, dataObj, itemName);
                } else if (nodeType === 3) {
                    compileTextNode(node, dataObj, itemName);
                }

                return node;
            }

            /**
             * helper function to do the read variable from string magic.
             * The cb will called with the property value - in case of undefined the variable does not exists
             * @param node
             * @param attributeName
             * @param cb
             */
            function getLoopValueFromAttribute(node, obj, itemName, attributeName, cb) {
                var tmp = node.getAttribute(attributeName).split('.'), tokenObjectProperty;
                if (tmp.length > 0 && tmp[0] === itemName) {
                    tokenObjectProperty = tmp.slice(1).join('.');
                    cb(getGlobalCall(tokenObjectProperty, obj));
                } else {
                    // TODO handle this correctly
                    console.error('repeat:getLoopValueFromAttribute has problems');
                }
            }

            /**
             * register click events
             * 
             * @deprecated use rp-bind attribute
             * 
             * @param clone
             * @param item
             * @param itemName
             */
            function handleEvents(clone, obj, itemName) {
                var onClick = 'on-click';
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' + onClick + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, onClick, function (val) {
                        if (typeof val === 'function') {
                            node.addEventListener('click', val);
                        } else {
                            console.log('repeat:can not register click listener without a function', node);
                        }
                    });
                });
            }

            /**
             * register rp-bind handler
             * 
             * With help of this the if and if-not and onClick attribute is deprecated - you can just pass a function 
             * pointer to rp-bind and do all the required logic by your own.
             * 
             * If you return false then the node will be removed from the DOM
             *
             * @param clone
             * @param obj
             * @param itemName
             */
            function handleRPBindAttribute(clone, obj, itemName) {
                var attrName = 'rp-bind';
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' + attrName + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attrName, function (val) {
                        if (typeof val === 'function') {
                            if (val(node) === false) {
                                // remove node if function returns false
                               node.parentNode.removeChild(node); 
                            }
                        } else {
                            console.error('repeat:can not register control function without a function pointer', node);
                        }
                    });
                });
            }

            /**
             * Replaces expressions for all tag attributes
             *
             * @param clone
             * @param obj
             * @param itemName (currently not in used but needs to be checked)
             */
            function handleAttributes(containerNode, obj, itemName) {
                var returnTokens = [];
                (function searchForExpressions(children) {
                    [].slice.call(children).forEach(function (node) {
                        var i, attr, rTokens;
                        if (node.children.length > 0) {
                            // do it recursive for all children
                            searchForExpressions(node.children);
                        }
                        // loop through each attribute
                        for (i = 0; i < node.attributes.length; i++) {
                            attr = node.attributes[i];
                            if (/\{\{/.test(attr.textContent)) {
                                if (attr.name) {
                                    rTokens = (function () {
                                        var token = parse(attr.textContent),
                                            endData = [], tmpToken, j, tmpTokenSplit, value;
                                        for (j = 0; j < token.length; j++) {
                                            tmpToken = token[j];
                                            // if token not itemName skipp all
                                            if (tmpToken.key !== undefined && tmpToken.key.split('.')[0] === itemName) {
                                                // save the attribute
                                                tmpToken.attr = attr;
                                                if (/\./.test(tmpToken.key)) {
                                                    tmpTokenSplit = tmpToken.key.split('.').slice(1).join('.');
                                                } else {
                                                    tmpTokenSplit = tmpToken.key;
                                                }
                                                if (typeof obj === 'object') {
                                                    tmpToken.value = getGlobalCall(tmpTokenSplit, obj);
                                                    if (typeof tmpToken.value === 'function') {
                                                        value = tmpToken.value();
                                                    } else {
                                                        value = tmpToken.value;
                                                    }
                                                } else if (typeof obj === 'string') {
                                                    value = obj;
                                                } else if (typeof obj === 'function') {
                                                    value = obj(node);
                                                }

                                            } else if (tmpToken.hasOwnProperty('key')) {
                                                // restore the expression - might be another whisker instance will
                                                // needs this
                                                value = '{{' + tmpToken.key + '}}';
                                            } else {
                                                value = tmpToken.value;
                                            }
                                            endData.push({value : value, concat : tmpToken.concat});
                                        }
                                        attr.textContent = endData.map(function (d) {
                                            return d.concat ? d.value : ' ' + d.value;
                                        }).join('');
                                        return token;
                                    }());
                                    returnTokens = returnTokens.concat(rTokens);
                                }
                            }
                        }
                    });
                }(containerNode.children));
                return returnTokens;
            }

            /**
             * handle the if conditions if and if-not
             * 
             * @deprecated use rp-bind attribute
             * 
             * @param clone
             * @param obj
             * @param itemName
             */
            function handleIfCondition(clone, obj, itemName) {
                var attributeName_if = 'if',
                    attributeName_if_not = 'if-not';

                function checkIf(val, node) {
                    if (!val) {
                        node.parentNode.removeChild(node);
                    }
                }
                function checkIfNot(val, node) {
                    if (val) {
                        node.parentNode.removeChild(node);
                    }
                }
                // check children of clone
                [].slice.call(clone.querySelectorAll('[' +attributeName_if + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attributeName_if, function (val) {checkIf(val, node);});
                });

                [].slice.call(clone.querySelectorAll('[' +attributeName_if_not + ']')).forEach(function (node) {
                    getLoopValueFromAttribute(node, obj, itemName, attributeName_if_not, function (val) {checkIfNot(val, node);});
                });
            }

            /**
             * Looped through the collection and do the logic for each clone instance.
             * Actually it supports only collection - no objects.
             * @param node
             * @param itemName
             * @param collection
             * @param template
             */
            function registerTemplate(node, itemName, collection, template) {
                var mainFrag;
                if (typeof collection === 'object') {
                    if (Object.prototype.toString.call(collection) === '[object Array]') {
                        // it is an array
                        mainFrag = document.createDocumentFragment();
                        collection.forEach(function (item) {
                            // item could be an object or just a property like a
                            // string (in case of it is direct a list of strings)
                            template.forEach(function (childTpl) {
                                // TODO works also with fragment but then the qunit test fails
                                // - there is a problem with the phantomjs
//                                var fragment = document.createDocumentFragment();
                                var fragment = document.createElement('div');
                                fragment.appendChild(childTpl.cloneNode(true));
                                
                                handleIfCondition(fragment, item, itemName);
                                // if conditions can remove elements from clone - it's important that this is executed first
                                if (fragment.children && fragment.children.length === 1) {
                                    handleRPBindAttribute(fragment, item, itemName);
                                }
                                // rp-bind attribute can also remove elements so need to check again if node exists
                                if (fragment.children && fragment.children.length === 1) {
                                    handleEvents(fragment, item, itemName);
                                    handleAttributes(fragment, item, itemName);
                                    // replace texts:
                                    mainFrag.appendChild(compile(fragment.children[0], item, itemName));
                                } else {
                                   // console.log('repeat:element has been removed from DOM');
                                }
                            });
                        });
                        node.appendChild(mainFrag);
                    } else {
                        // it is an object
                        console.error('repeat detect object but object currently not supported');
                        // what render? - property name or value? - Both?
                    }
                } else {
                    console.error('repeat:registerTemplate detect none acceptable data argument', collection);
                }
            }

            /**
             * Create a new repeat instance and do the "magic".
             * @param node
             * @param scopeName
             * @param data {[], function}
             */
            function execRepeat(node, scopeName, data) {
                var template = [];
                [].slice.call(node.children).forEach(function (child) {
                    template.push(node.removeChild(child));
                });

                if (typeof data === 'function') {
                    data(function (name, data) {
                        if (data) {
                            scopeName = name;
                        } else {
                            data = name;
                        }
                        // better would be a update children but this is much effort to detect
                        [].slice.call(node.children).forEach(function (child) {
                            node.removeChild(child);
                        });
                        registerTemplate(node, scopeName, data, template);
                    });
                } else {
                    registerTemplate(node, scopeName, data, template)
                }
            }

            return {
                /**
                 * the attribute requires:
                 *  for: name of the iterator
                 *  in: pointer to: function, array or object
                 *
                 * @param node
                 * @param attr {{for:string,in:string}}
                 */
                add : function (node, attr) {
                    var inPointer;
                    if (typeof attr === 'object' && attr.in && attr.for) {
                        if (typeof attr.in === 'string') {
                            // TODO replace window with this and also other instances could use the magic as closure
                            inPointer = getGlobalCall(attr.in, window);
                        } else {
                            inPointer = attr.in;
                        }
                        execRepeat(node, attr.for || 'item', inPointer);
                    } else if (Object.prototype.toString.call(attr) === '[object Array]') {
                        execRepeat(node, 'item', attr);
                    } else if (typeof attr === 'function') {
                        execRepeat(node, 'item', attr);
                    } else if (typeof attr === 'string') {
                        inPointer = getGlobalCall(attr, window);
                        execRepeat(node, 'item', inPointer);
                    } else {
                        console.warn('repeat:add none acceptable attributes', attr);
                    }
                }
            };
        }());

    function escapeRegex(str) {
        return str.replace(ESCAPE_RE, '\\$&');
    }

    function getRegex() {
        var open = escapeRegex(openChar),
            end  = escapeRegex(endChar);
        return new RegExp(open + open + open + '?(.+?)' + end + '?' + end + end);
    }

    /**
     * Read a property from a given string and object.
     * Returns the founded property pointer or undefined.
     * @param value
     * @param obj
     * @returns {*} or undefined
     */
    function getGlobalCall (value, obj) {
        var split = value.split('.'),
            rec = function (cur) {
                if (obj[cur] !== undefined) {
                    obj = obj[cur];
                    rec(split.shift());
                } else if (cur === value ) {
                    obj = undefined;
                }
            };
        rec(split.shift());
        return obj;
    }

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = repeat;
    } else {
        canny.add('repeat', repeat);
    }

}());

},{}],54:[function(require,module,exports){
/*global canny */
/*jslint browser: true*/
/**
 *
 * E.g. {{whisker}}:
 *  <div canny-mod="whisker" canny-var="{'bind':'scope','to':{'message':'My text'}}">
 *     <p>DATA: {{scope.message}})</p>
 *  </div>
 *  Or just pass the function pointer the default scope is 'scope'.
 *  <div canny-mod="whisker" canny-var="mymodule.functionPointer">
 *     <p>DATA: {{scope.message}})</p>
 *  </div>
 *
 */
(function () {
    "use strict";

    var openChar = '{',
        endChar  = '}',
        ESCAPE_RE = /[-.*+?^${}()|[\]\/\\]/g,
        whisker = (function () {
            var BINDING_RE = getRegex();
            /**
             *  Parse a piece of text, return an array of tokens
             *  TODO refactor method
             *  @param text
             *  @return [{key:String, html:boolean}]
             */
            function parse(text) {
                if (!BINDING_RE.test(text)) {return null; }
                var m, i, token, match, tokens = [], orig = {text: text, idx : 0}, textObject;
                /* jshint boss: true */
                while (m = text.match(BINDING_RE)) {
                    i = m.index;
                    token = {concat : true};
                    if (i > 0) {
                        if (orig.idx === 0) {
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                            orig.idx += i;
                        } else {
                            orig.idx += i;
                            textObject = {
                                concat : orig.text[orig.idx - 1] !== ' ',
                                value : text.slice(0, i),
                                text : true
                            };
                        }
                        tokens.push(textObject);
                    }
                    orig.idx += i;
                    token.key = m[1].trim();
                    match = m[0];
                    token.html =
                        match.charAt(2) === openChar &&
                        match.charAt(match.length - 3) === endChar;
                    tokens.push(token);
                    text = text.slice(i + m[0].length);
                }
                if (text.length) {
                    tokens.push({value : text, text : true, concat: true});
                }
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             * @return tokens [{key:String, node:DOM node, html: boolean}]
             */
            function compileTextNode(node, dataObj, itemName) {
                var tokens = parse(node.nodeValue),
                    obj = dataObj,
                    el, token, i, l, tmp, tokenObjectProperty, val, valUnknown;
                if (!tokens || obj === undefined || typeof obj === 'string') {return; }

                for (i = 0, l = tokens.length; i < l; i++) {
                    token = tokens[i];

                    if (typeof token === 'object' && token.hasOwnProperty('key')) {
                        tmp = token.key.split('.');
                        if (tmp.length > 0 && tmp[0] === itemName) {
                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                valUnknown = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                valUnknown = obj;
                            }
                        } else {
                            // just a string?
                            valUnknown = obj;
                        }

                        if (typeof valUnknown === 'function') {
                            val = valUnknown(node);
                        } else {
                            val = valUnknown;
                        }

                        if (typeof val === 'string' || typeof val === 'number') {
                            el = document.createTextNode(val);
                            node.parentNode.insertBefore(el, node);
                        } else if (typeof val === 'boolean') {
                            el = document.createTextNode(val.toString());
                            node.parentNode.insertBefore(el, node);
                        } else if (val instanceof HTMLElement) {
                            el = val;
                            node.parentNode.insertBefore(el, node);
                        } else if (tmp[0] === itemName) {
                            // property is not exists but it is the same scope
                            el = document.createTextNode('');
                            node.parentNode.insertBefore(el, node);
                        } else {
                            // restore the token... looks like is not mine
                            el = document.createTextNode('{{' + token.key + '}}');
                            node.parentNode.insertBefore(el, node);
                        }
                        token.node = el;
                    } else {
                        el = document.createTextNode(token.value);
                        // just normal string put back to view
                        node.parentNode.insertBefore(el, node);
                    }
                }
                node.parentNode.removeChild(node);
                return tokens;
            }
            /**
             *
             * @param node
             * @param dataObj
             * @param itemName
             */
            function compileElement (node, dataObj, itemName) {
                var tokens = [],
                    token;
                // recursively compile childNodes
                if (node.hasChildNodes()) {
                    [].slice.call(node.childNodes).forEach(function (child) {
                        token = compile(child, dataObj, itemName);
                        if (token) {
                            tokens = tokens.concat(token);
                        }
                    });
                }
                return tokens.length > 0 ? tokens : undefined;
            }


            /**
             * helper function to do the read variable from string magic.
             * The cb will called with the property value - in case of undefined the variable does not exists
             * 
             * @param node
             * @param obj
             * @param itemName
             * @param attributeName
             * 
             * @return {function} | false if it is not a function or not available 
             */
            function getWkBindValue(node, obj, itemName, attributeName) {
                var tmp = node.getAttribute(attributeName).split('.'), tokenObjectProperty;
                if (tmp.length > 0 && tmp[0] === itemName) {
                    tokenObjectProperty = tmp.slice(1).join('.');
                    return getGlobalCall(tokenObjectProperty, obj) || false;
                }
                return false;
            }

            /**
             * register rp-bind handler
             *
             * With help of this the if and if-not and onClick attribute is deprecated - you can just pass a function pointer to rp-bind and
             * do all the required logic by your own.
             *
             * If you return false then the node will be removed from the DOM
             *
             * @param node
             * @param obj
             * @param scopeName
             */
            function handleWKBindAttribute(node, obj, scopeName) {

                function parseChildAttribute(child, data, scopeName) {
                    var attrName = 'wk-bind',
                        key = child.getAttribute('wk-bind'),
                        token,
                        fc = getWkBindValue(child, data, scopeName, attrName);
                    if (fc) {
                        (function (fc) {
                            var shadow,
                                hidden = false;
                            if (typeof fc === 'function') {
                                shadow = document.createElement('div');
                                shadow.style.display = 'none';
                                if (fc(child) === false) {
                                    // remove node if function returns false
                                    child = child.parentNode.replaceChild(shadow, child);
                                    hidden = true;
                                }
                                token = {
                                    hidden : hidden,
                                    node : child,
                                    shadowNode : shadow,
                                    isWkBindToken : true,
                                    // check if key is needed because it has the wkBind function pointer
                                    key : child.getAttribute('wk-bind')
                                }

                            } else {
                                console.error('whisker:can not register control function without a function pointer', child);
                            }
                        }(fc));
                    } else {
                        // valid in case of there is a different scope variable or
                    }
                    return token;
                }

                var attrName = 'wk-bind',
                    tokens = [];
                // check children of clone
                [].slice.call(node.querySelectorAll('[' + attrName + ']')).forEach(function (child) {
                    var tmpToken = parseChildAttribute(child, obj, scopeName);
                    if (tmpToken) {
                        tokens.push(tmpToken);
                    }
                });
                return tokens
            }

            /**
             *  Compile a DOM node (recursive)
             * @param node
             * @param dataObj
             * @param itemName
             * @returns {*}
             */
            function compile(node, dataObj, itemName) {
                var nodeType = node.nodeType,
                    tokens = [],
                    token;
                if (nodeType === 1 && node.tagName !== 'SCRIPT') { // a normal node
                    token = compileElement(node, dataObj, itemName);
                    if (token) {
                        tokens = tokens.concat(token);
                    }
                } else if (nodeType === 3) {
                    token = compileTextNode(node, dataObj, itemName);
                    if (token) {
                        tokens = tokens.concat(token);
                    }
                }
                return tokens.length > 0 ? tokens : undefined;
            }

            /**
             * Replaces expressions for all tag attributes
             *
             * loop though all children and check if a attribute has a expressions inside
             *
             * @param containerNode
             * @param obj
             * @param itemName
             * @return returnTokens [{key:String, attr: node attribute reference, html: boolean}]
             */
            function handleAttributes(containerNode, obj, itemName) {
                var returnTokens = [];
                (function searchForExpressions(children) {
                    [].slice.call(children).forEach(function (node) {
                        var i, attr, rTokens;
                        if (node.children.length > 0) {
                            // do it recursive for all children
                            searchForExpressions(node.children);
                        }
                        // loop through each attribute
                        for (i = 0; i < node.attributes.length; i++) {
                            attr = node.attributes[i];
                            if (/\{\{/.test(attr.textContent)) {
                                if (attr.name) {
                                    rTokens = (function () {
                                        var token = parse(attr.textContent),
                                            endData = [], tmpToken, j, tmpTokenSplit, value, tmpValue;
                                        for (j = 0; j < token.length; j++) {
                                            tmpToken = token[j];
                                            // if token not itemName skipp all
                                            if (tmpToken.key !== undefined && tmpToken.key.split('.')[0] === itemName) {
                                                // save the attribute
                                                tmpToken.attr = attr;
                                                if (/\./.test(tmpToken.key)) {
                                                    tmpTokenSplit = tmpToken.key.split('.').slice(1).join('.');
                                                } else {
                                                    tmpTokenSplit = tmpToken.key;
                                                }
                                                if (typeof obj === 'object') {
                                                    tmpValue = getGlobalCall(tmpTokenSplit, obj);
                                                    if (typeof tmpValue === 'function') {
                                                        tmpToken.value = tmpValue(node);
                                                        tmpToken.node = node;
                                                    } else {
                                                        tmpToken.value = tmpValue;
                                                    }
                                                    value = tmpToken.value;
                                                } else if (typeof obj === 'string') {
                                                    value = obj;
                                                } else if (typeof obj === 'function') {
                                                    value = obj(node);
                                                }

                                            } else if (tmpToken.hasOwnProperty('key')) {
                                                // restore the expression - might be another whisker instance will
                                                // needs this
                                                value = '{{' + tmpToken.key + '}}';
                                            } else {
                                                value = tmpToken.value;
                                            }
                                            endData.push({value : value, concat : tmpToken.concat});
                                        }
                                        attr.textContent = endData.map(function (d) {
                                            return d.concat ? d.value : ' ' + d.value;
                                        }).join('');
                                        return token;
                                    }());
                                    returnTokens = returnTokens.concat(rTokens);
                                }
                            }
                        }
                    });
                }(containerNode.children));
                return returnTokens;
            }

            /**
             * do the magic for attributes or text nodes
             * 
             * TODO: bug if property doesn't exists in first execution it want work anymore for attributes and wk-bind
             *  See: whiskerSpecs.js > dynamicallyChangeDataWithInitialMissingProperties
             *
             * @param node
             * @param scopeName
             * @param data
             */
            function fillData(node, scopeName, data) {
                var tokens = [];
                if (typeof data === 'object') {
                    // handleEvents(node, data, scopeName);
                    tokens = tokens.concat(handleAttributes(node, data, scopeName));
                    // make sure that the compiler also updates the hidden element
                    tokens = tokens.concat(compile(node, data, scopeName));

                    tokens = tokens.concat(handleWKBindAttribute(node, data, scopeName));

                    // replace texts:
                    return tokens;
                } else {
                    console.error('whisker:handleAttributes detect none acceptable data argument', data);
                }
            }

            /**
             * helper function for updateData to update the DOM Elements
             * @param token
             * @param domElement DOMElement
             */
            function updateDOMElement(token, domElement) {
                token.node.parentNode.insertBefore(domElement, token.node);
                token.node.parentNode.removeChild(token.node);
                token.node = domElement;
            }
            /**
             * helper function for updateData to update the text nodes
             * @param token
             * @param val
             */
            function updateText(token, val) {
                var textNode;
                if (token.node instanceof HTMLElement) {
                    // convert back to textNode
                    textNode = document.createTextNode('');
                    token.node.parentNode.insertBefore(textNode, token.node);
                    token.node.parentNode.removeChild(token.node);
                    token.node = textNode;
                }
                if (typeof val === 'string' || typeof val === 'number') {
                    token.node.nodeValue = val;
                } else if (typeof val === 'boolean') {
                    // TODO test
                    token.node.nodeValue = val.toString();
                }
            }

            /**
             * helper function for updateData to update the attributes for a node
             * @param token
             * @param value
             */
            function updateAttributes(token, value) {
                var val;
                if (typeof value === 'function') {
                    val = value(token.node);
                } else {
                    val = value;
                }
                if (typeof val === 'string' || typeof val === 'number') {
                    var replaceText = token.attr.textContent;
                    if (replaceText) {
                        token.attr.textContent = replaceText.replace(token.value, val);
                    } else {
                        token.attr.textContent = replaceText + val;
                    }
                    token.value = val;
                } else if (typeof val === 'boolean') {
                    // TODO test (makes no sense for an attribute but needs to be handled correctly (think about what to do in this case)
                    token.node.nodeValue = val.toString();
                }
            }
            /**
             *
             * Call this to update the existing data's
             *
             * TODO test also boolean and function
             *
             * @param tokenObjList [{key : "scopeName.property", node}]
             * @param scopeName
             * @param obj
             */
            function updateData(tokenObjList, scopeName, obj) {
                tokenObjList.forEach(function (token) {
                    if (token && token.hasOwnProperty('key')) {
                        var tmp = token.key.split('.'), tokenObjectProperty, val;
                        if (tmp.length > 0 && tmp[0] === scopeName) {
                            tokenObjectProperty = tmp.slice(1).join('.');
                            if (typeof obj === 'object') {
                                val = getGlobalCall(tokenObjectProperty, obj);
                            } else {
                                val = obj;
                            }

                            if (val !== undefined) {
                                if (token.hasOwnProperty('attr')) {
                                    // handle attribute
                                    updateAttributes(token, val);
                                } else if (token.isWkBindToken) {
                                    (function () {
                                        var removeMeIfImFalse;
                                        if (val) {
                                            removeMeIfImFalse = val(token.node);
                                        }
                                        if (removeMeIfImFalse === false && token.hidden === false) {
                                            // remove node
                                            token.hidden = true;
                                            token.node.parentNode.replaceChild(token.shadowNode, token.node);
                                        } else if (removeMeIfImFalse !== false && token.hidden) {
                                            token.hidden = false;
                                            token.shadowNode.parentNode.replaceChild(token.node, token.shadowNode);
                                            // restore node
                                        }
                                    }());
                                } else {
                                    (function () {
                                        // a return result could also be a HTMLElement
                                        var res = typeof val === 'function' ? val(token.node) : val;
                                        if (res instanceof HTMLElement) {
                                            updateDOMElement(token, res);
                                        } else {
                                            updateText(token, res);
                                        }
                                    }(val))
                                }
                            }
                        }
                    }
                });
            }

            /**
             * TODO description
             * Create a new whisker instance and do the "magic".
             * @param node
             * @param scopeName
             * @param data
             */
            function exec(node, data, scopeName) {
                var currentScope = scopeName || 'item',
                    keyValueholder = {};
                if (typeof data === 'function') {
                    data(function (scope, data) {
                        var renderScope;
                        if (data !== undefined) {
                            renderScope = currentScope = scope || currentScope;
                        } else {
                            data = scope;
                            // otherwise use the scope from the initialisation
                            renderScope = currentScope;
                        }
                        if (keyValueholder.hasOwnProperty(renderScope)) {
                            updateData(keyValueholder[renderScope], renderScope, data);
                        } else {
                            keyValueholder[renderScope] = fillData(node, renderScope, data);
                        }
                    });
                } else {
                    fillData(node, currentScope, data)
                }
            }

            return {
                add : function (node, attr) {
                    var inPointer;
                    if (typeof attr === 'object') {
                        if (attr.to && attr.bind) {
                            if (typeof attr.to === 'string') {
                                // TODO replace window with this and also other instances could use the magic as closure
                                inPointer = getGlobalCall(attr.to, window);
                            } else {
                                inPointer = attr.to;
                            }
                        } else {
                            inPointer = attr;
                        }
                        exec(node, inPointer, attr.bind || 'item');
                    } else if (typeof attr === 'string') {
                        inPointer = getGlobalCall(attr, window);
                        if (typeof inPointer === 'function') {
                            exec(node, inPointer);
                        } else {
                            console.warn('whisker:add none acceptable attributes', attr);
                        }
                    } else {
                        exec(node, attr);
                    }
                }
            };
        }());

    function escapeRegex(str) {
        return str.replace(ESCAPE_RE, '\\$&');
    }

    function getRegex() {
        var open = escapeRegex(openChar),
            end  = escapeRegex(endChar);
        return new RegExp(open + open + open + '?(.+?)' + end + '?' + end + end);
    }

    /**
     * Read a property from a given string and object.
     * Returns the founded property pointer or undefined.
     * @param value
     * @param obj
     * @returns {*} or undefined
     */
    function getGlobalCall (value, obj) {
        var split = value.split('.'),
            rec = function (cur) {
                if (obj[cur] !== undefined) {
                    obj = obj[cur];
                    rec(split.shift());
                } else if (cur === value ) {
                    obj = undefined;
                }
            };
        rec(split.shift());
        return obj;
    }

    // export as module or bind to global
    if (typeof module !== 'undefined' && module.hasOwnProperty('exports')) {
        module.exports = whisker;
    } else {
        canny.add('whisker', whisker);
    }

}());

},{}],55:[function(require,module,exports){
(function (Buffer){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
exports.isArray = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
exports.isBoolean = isBoolean;

function isNull(arg) {
  return arg === null;
}
exports.isNull = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
exports.isNullOrUndefined = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
exports.isNumber = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
exports.isString = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
exports.isSymbol = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
exports.isUndefined = isUndefined;

function isRegExp(re) {
  return objectToString(re) === '[object RegExp]';
}
exports.isRegExp = isRegExp;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
exports.isObject = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
exports.isDate = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
exports.isError = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
exports.isFunction = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
exports.isPrimitive = isPrimitive;

exports.isBuffer = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

}).call(this,{"isBuffer":require("../../is-buffer/index.js")})

},{"../../is-buffer/index.js":67}],56:[function(require,module,exports){
var EventEmitter = require('events').EventEmitter;
var scrubber = require('./lib/scrub');
var objectKeys = require('./lib/keys');
var forEach = require('./lib/foreach');
var isEnumerable = require('./lib/is_enum');

module.exports = function (cons, opts) {
    return new Proto(cons, opts);
};

(function () { // browsers bleh
    for (var key in EventEmitter.prototype) {
        Proto.prototype[key] = EventEmitter.prototype[key];
    }
})();

function Proto (cons, opts) {
    var self = this;
    EventEmitter.call(self);
    if (!opts) opts = {};
    
    self.remote = {};
    self.callbacks = { local : [], remote : [] };
    self.wrap = opts.wrap;
    self.unwrap = opts.unwrap;
    
    self.scrubber = scrubber(self.callbacks.local);
    
    if (typeof cons === 'function') {
        self.instance = new cons(self.remote, self);
    }
    else self.instance = cons || {};
}

Proto.prototype.start = function () {
    this.request('methods', [ this.instance ]);
};

Proto.prototype.cull = function (id) {
    delete this.callbacks.remote[id];
    this.emit('request', {
        method : 'cull',
        arguments : [ id ]
    });
};

Proto.prototype.request = function (method, args) {
    var scrub = this.scrubber.scrub(args);
    
    this.emit('request', {
        method : method,
        arguments : scrub.arguments,
        callbacks : scrub.callbacks,
        links : scrub.links
    });
};

Proto.prototype.handle = function (req) {
    var self = this;
    var args = self.scrubber.unscrub(req, function (id) {
        if (self.callbacks.remote[id] === undefined) {
            // create a new function only if one hasn't already been created
            // for a particular id
            var cb = function () {
                self.request(id, [].slice.apply(arguments));
            };
            self.callbacks.remote[id] = self.wrap ? self.wrap(cb, id) : cb;
            return cb;
        }
        return self.unwrap
            ? self.unwrap(self.callbacks.remote[id], id)
            : self.callbacks.remote[id]
        ;
    });
    
    if (req.method === 'methods') {
        self.handleMethods(args[0]);
    }
    else if (req.method === 'cull') {
        forEach(args, function (id) {
            delete self.callbacks.local[id];
        });
    }
    else if (typeof req.method === 'string') {
        if (isEnumerable(self.instance, req.method)) {
            self.apply(self.instance[req.method], args);
        }
        else {
            self.emit('fail', new Error(
                'request for non-enumerable method: ' + req.method
            ));
        }
    }
    else if (typeof req.method == 'number') {
        var fn = self.callbacks.local[req.method];
        if (!fn) {
            self.emit('fail', new Error('no such method'));
        }
        else self.apply(fn, args);
    }
};

Proto.prototype.handleMethods = function (methods) {
    var self = this;
    if (typeof methods != 'object') {
        methods = {};
    }
    
    // copy since assignment discards the previous refs
    forEach(objectKeys(self.remote), function (key) {
        delete self.remote[key];
    });
    
    forEach(objectKeys(methods), function (key) {
        self.remote[key] = methods[key];
    });
    
    self.emit('remote', self.remote);
    self.emit('ready');
};

Proto.prototype.apply = function (f, args) {
    try { f.apply(undefined, args) }
    catch (err) { this.emit('error', err) }
};

},{"./lib/foreach":57,"./lib/is_enum":58,"./lib/keys":59,"./lib/scrub":60,"events":64}],57:[function(require,module,exports){
module.exports = function forEach (xs, f) {
    if (xs.forEach) return xs.forEach(f)
    for (var i = 0; i < xs.length; i++) {
        f.call(xs, xs[i], i);
    }
}

},{}],58:[function(require,module,exports){
var objectKeys = require('./keys');

module.exports = function (obj, key) {
    if (Object.prototype.propertyIsEnumerable) {
        return Object.prototype.propertyIsEnumerable.call(obj, key);
    }
    var keys = objectKeys(obj);
    for (var i = 0; i < keys.length; i++) {
        if (key === keys[i]) return true;
    }
    return false;
};

},{"./keys":59}],59:[function(require,module,exports){
module.exports = Object.keys || function (obj) {
    var keys = [];
    for (var key in obj) keys.push(key);
    return keys;
};

},{}],60:[function(require,module,exports){
var traverse = require('traverse');
var objectKeys = require('./keys');
var forEach = require('./foreach');

function indexOf (xs, x) {
    if (xs.indexOf) return xs.indexOf(x);
    for (var i = 0; i < xs.length; i++) if (xs[i] === x) return i;
    return -1;
}

// scrub callbacks out of requests in order to call them again later
module.exports = function (callbacks) {
    return new Scrubber(callbacks);
};

function Scrubber (callbacks) {
    this.callbacks = callbacks;
}

// Take the functions out and note them for future use
Scrubber.prototype.scrub = function (obj) {
    var self = this;
    var paths = {};
    var links = [];
    
    var args = traverse(obj).map(function (node) {
        if (typeof node === 'function') {
            var i = indexOf(self.callbacks, node);
            if (i >= 0 && !(i in paths)) {
                // Keep previous function IDs only for the first function
                // found. This is somewhat suboptimal but the alternatives
                // are worse.
                paths[i] = this.path;
            }
            else {
                var id = self.callbacks.length;
                self.callbacks.push(node);
                paths[id] = this.path;
            }
            
            this.update('[Function]');
        }
        else if (this.circular) {
            links.push({ from : this.circular.path, to : this.path });
            this.update('[Circular]');
        }
    });
    
    return {
        arguments : args,
        callbacks : paths,
        links : links
    };
};
 
// Replace callbacks. The supplied function should take a callback id and
// return a callback of its own.
Scrubber.prototype.unscrub = function (msg, f) {
    var args = msg.arguments || [];
    forEach(objectKeys(msg.callbacks || {}), function (sid) {
        var id = parseInt(sid, 10);
        var path = msg.callbacks[id];
        traverse.set(args, path, f(id));
    });
    
    forEach(msg.links || [], function (link) {
        var value = traverse.get(args, link.from);
        traverse.set(args, link.to, value);
    });
    
    return args;
};

},{"./foreach":57,"./keys":59,"traverse":96}],61:[function(require,module,exports){
var dnode = require('./lib/dnode');

module.exports = function (cons, opts) {
    return new dnode(cons, opts);
};

},{"./lib/dnode":62}],62:[function(require,module,exports){
(function (process){
var protocol = require('dnode-protocol');
var Stream = require('stream');
var json = typeof JSON === 'object' ? JSON : require('jsonify');

module.exports = dnode;
dnode.prototype = {};
(function () { // browsers etc
    for (var key in Stream.prototype) {
        dnode.prototype[key] = Stream.prototype[key];
    }
})();

function dnode (cons, opts) {
    Stream.call(this);
    var self = this;
    
    self.opts = opts || {};
    
    self.cons = typeof cons === 'function'
        ? cons
        : function () { return cons || {} }
    ;
    
    self.readable = true;
    self.writable = true;
    
    process.nextTick(function () {
        if (self._ended) return;
        self.proto = self._createProto();
        self.proto.start();
        
        if (!self._handleQueue) return;
        for (var i = 0; i < self._handleQueue.length; i++) {
            self.handle(self._handleQueue[i]);
        }
    });
}

dnode.prototype._createProto = function () {
    var self = this;
    var proto = protocol(function (remote) {
        if (self._ended) return;
        
        var ref = self.cons.call(this, remote, self);
        if (typeof ref !== 'object') ref = this;
        
        self.emit('local', ref, self);
        
        return ref;
    }, self.opts.proto);
    
    proto.on('remote', function (remote) {
        self.emit('remote', remote, self);
        self.emit('ready'); // backwards compatability, deprecated
    });
    
    proto.on('request', function (req) {
        if (!self.readable) return;
        
        if (self.opts.emit === 'object') {
            self.emit('data', req);
        }
        else self.emit('data', json.stringify(req) + '\n');
    });
    
    proto.on('fail', function (err) {
        // errors that the remote end was responsible for
        self.emit('fail', err);
    });
    
    proto.on('error', function (err) {
        // errors that the local code was responsible for
        self.emit('error', err);
    });
    
    return proto;
};

dnode.prototype.write = function (buf) {
    if (this._ended) return;
    var self = this;
    var row;
    
    if (buf && typeof buf === 'object'
    && buf.constructor && buf.constructor.name === 'Buffer'
    && buf.length
    && typeof buf.slice === 'function') {
        // treat like a buffer
        if (!self._bufs) self._bufs = [];
        
        // treat like a buffer
        for (var i = 0, j = 0; i < buf.length; i++) {
            if (buf[i] === 0x0a) {
                self._bufs.push(buf.slice(j, i));
                
                var line = '';
                for (var k = 0; k < self._bufs.length; k++) {
                    line += String(self._bufs[k]);
                }
                
                try { row = json.parse(line) }
                catch (err) { return self.end() }
                
                j = i + 1;
                
                self.handle(row);
                self._bufs = [];
            }
        }
        
        if (j < buf.length) self._bufs.push(buf.slice(j, buf.length));
    }
    else if (buf && typeof buf === 'object') {
        // .isBuffer() without the Buffer
        // Use self to pipe JSONStream.parse() streams.
        self.handle(buf);
    }
    else {
        if (typeof buf !== 'string') buf = String(buf);
        if (!self._line) self._line = '';
        
        for (var i = 0; i < buf.length; i++) {
            if (buf.charCodeAt(i) === 0x0a) {
                try { row = json.parse(self._line) }
                catch (err) { return self.end() }
                
                self._line = '';
                self.handle(row);
            }
            else self._line += buf.charAt(i)
        }
    }
};

dnode.prototype.handle = function (row) {
    if (!this.proto) {
        if (!this._handleQueue) this._handleQueue = [];
        this._handleQueue.push(row);
    }
    else this.proto.handle(row);
};

dnode.prototype.end = function () {
    if (this._ended) return;
    this._ended = true;
    this.writable = false;
    this.readable = false;
    this.emit('end');
};

dnode.prototype.destroy = function () {
    this.end();
};

}).call(this,require('_process'))

},{"_process":72,"dnode-protocol":56,"jsonify":68,"stream":80}],63:[function(require,module,exports){
/*global HTMLElement */
/*jslint browser: true */

var domOpts = {};

domOpts.params = (function () {
    "use strict";
    var params = {}, i, nv, parts;
    if (location.search) {
        parts = location.search.substring(1).split('&');
        for (i = 0; i < parts.length; i++) {
            nv = parts[i].split('=');
            if (nv[0]) {
                params[nv[0]] = nv[1] || true;
            }
        }
    }
    return params;
}());

domOpts.createElement = function (tag, id, classes) {
    "use strict";
    var newNode = document.createElement(tag);
    if (id) {newNode.setAttribute('id', id); }
    if (classes) {newNode.setAttribute('class', classes); }
    return newNode;
};
module.exports =  domOpts;

// dom operations:
HTMLElement.prototype.domAddClass = function (addClasses) {
    "use strict";
    var attrClass = this.getAttribute('class'),
        addClassesList = addClasses.split(' '), newClasses = [], i;
    for (i = 0; i < addClassesList.length; i++) {
        if (!this.domHasClass(addClassesList[i])) {
            newClasses.push(addClassesList[i]);
        }
    }
    this.setAttribute('class', attrClass !== null ? attrClass + ' ' + newClasses.join(' ') : newClasses.join(' '));
    return this;
};
// TODO remove all classes with same name
HTMLElement.prototype.domRemoveClass = function (removeableClasses) {
    "use strict";
    var removeClasses = (removeableClasses && removeableClasses.split(' ')) || this.getAttribute('class').split(' '),
        attrClass = this.getAttribute('class'),
        currentClasses,
        i,
        idx;
    if (attrClass !== null) {
        currentClasses = attrClass.split(' ');
        for (i = 0; i < removeClasses.length; i++) {
            idx = currentClasses.indexOf(removeClasses[i]);
            if (idx >= 0) {
                currentClasses = currentClasses.slice(0, idx).concat(currentClasses.slice(idx + 1, currentClasses.length - 1));
            }
        }
        this.setAttribute('class', currentClasses.join(' '));
    }
    return this;
};

// dom operations:
HTMLElement.prototype.domHasClass = function (className) {
    "use strict";
    var classes = this.getAttribute('class'), currentClasses, i;
    if (classes !== null) {
        currentClasses = classes.split(' ');
        for (i = 0; i < currentClasses.length; i++) {
            if (currentClasses[i] === className) {return true; }
        }
    }
    return false;
};

HTMLElement.prototype.domRemove = function () {
    "use strict";
    this.parentNode.removeChild(this);
};
/**
 * remove all child elements from node
 */
HTMLElement.prototype.domEmpty = function () {
    "use strict";
    Array.prototype.slice.call(this.children).forEach(function (child) {
        child.domRemove(this);
    });
};

HTMLElement.prototype.domAppendTo = function (elem) {
    "use strict";
    var node = elem;
    if (typeof node === 'string') {
        node = document.getElementById(node);
    }
    node.appendChild(this);
    return this;
};

HTMLElement.prototype.domAppendChild = function (elem) {
    "use strict";
    var node = elem;
    if (typeof node === 'string') {
        node = document.getElementById(node);
    }
    this.appendChild(node);
    return this;
};

HTMLElement.prototype.domChildTags = function (tag) {
    "use strict";
    var tags = [];
    Array.prototype.slice.call(this.children).forEach(function (e) {
        if (e.tagName.toLowerCase() === tag.toLowerCase()) {
            tags.push(e);
        }
    });
    return tags;
};
},{}],64:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

function EventEmitter() {
  this._events = this._events || {};
  this._maxListeners = this._maxListeners || undefined;
}
module.exports = EventEmitter;

// Backwards-compat with node 0.10.x
EventEmitter.EventEmitter = EventEmitter;

EventEmitter.prototype._events = undefined;
EventEmitter.prototype._maxListeners = undefined;

// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
EventEmitter.defaultMaxListeners = 10;

// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
EventEmitter.prototype.setMaxListeners = function(n) {
  if (!isNumber(n) || n < 0 || isNaN(n))
    throw TypeError('n must be a positive number');
  this._maxListeners = n;
  return this;
};

EventEmitter.prototype.emit = function(type) {
  var er, handler, len, args, i, listeners;

  if (!this._events)
    this._events = {};

  // If there is no 'error' event listener then throw.
  if (type === 'error') {
    if (!this._events.error ||
        (isObject(this._events.error) && !this._events.error.length)) {
      er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Uncaught, unspecified "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
    }
  }

  handler = this._events[type];

  if (isUndefined(handler))
    return false;

  if (isFunction(handler)) {
    switch (arguments.length) {
      // fast cases
      case 1:
        handler.call(this);
        break;
      case 2:
        handler.call(this, arguments[1]);
        break;
      case 3:
        handler.call(this, arguments[1], arguments[2]);
        break;
      // slower
      default:
        args = Array.prototype.slice.call(arguments, 1);
        handler.apply(this, args);
    }
  } else if (isObject(handler)) {
    args = Array.prototype.slice.call(arguments, 1);
    listeners = handler.slice();
    len = listeners.length;
    for (i = 0; i < len; i++)
      listeners[i].apply(this, args);
  }

  return true;
};

EventEmitter.prototype.addListener = function(type, listener) {
  var m;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events)
    this._events = {};

  // To avoid recursion in the case that type === "newListener"! Before
  // adding it to the listeners, first emit "newListener".
  if (this._events.newListener)
    this.emit('newListener', type,
              isFunction(listener.listener) ?
              listener.listener : listener);

  if (!this._events[type])
    // Optimize the case of one listener. Don't need the extra array object.
    this._events[type] = listener;
  else if (isObject(this._events[type]))
    // If we've already got an array, just append.
    this._events[type].push(listener);
  else
    // Adding the second element, need to change to array.
    this._events[type] = [this._events[type], listener];

  // Check for listener leak
  if (isObject(this._events[type]) && !this._events[type].warned) {
    if (!isUndefined(this._maxListeners)) {
      m = this._maxListeners;
    } else {
      m = EventEmitter.defaultMaxListeners;
    }

    if (m && m > 0 && this._events[type].length > m) {
      this._events[type].warned = true;
      console.error('(node) warning: possible EventEmitter memory ' +
                    'leak detected. %d listeners added. ' +
                    'Use emitter.setMaxListeners() to increase limit.',
                    this._events[type].length);
      if (typeof console.trace === 'function') {
        // not supported in IE 10
        console.trace();
      }
    }
  }

  return this;
};

EventEmitter.prototype.on = EventEmitter.prototype.addListener;

EventEmitter.prototype.once = function(type, listener) {
  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  var fired = false;

  function g() {
    this.removeListener(type, g);

    if (!fired) {
      fired = true;
      listener.apply(this, arguments);
    }
  }

  g.listener = listener;
  this.on(type, g);

  return this;
};

// emits a 'removeListener' event iff the listener was removed
EventEmitter.prototype.removeListener = function(type, listener) {
  var list, position, length, i;

  if (!isFunction(listener))
    throw TypeError('listener must be a function');

  if (!this._events || !this._events[type])
    return this;

  list = this._events[type];
  length = list.length;
  position = -1;

  if (list === listener ||
      (isFunction(list.listener) && list.listener === listener)) {
    delete this._events[type];
    if (this._events.removeListener)
      this.emit('removeListener', type, listener);

  } else if (isObject(list)) {
    for (i = length; i-- > 0;) {
      if (list[i] === listener ||
          (list[i].listener && list[i].listener === listener)) {
        position = i;
        break;
      }
    }

    if (position < 0)
      return this;

    if (list.length === 1) {
      list.length = 0;
      delete this._events[type];
    } else {
      list.splice(position, 1);
    }

    if (this._events.removeListener)
      this.emit('removeListener', type, listener);
  }

  return this;
};

EventEmitter.prototype.removeAllListeners = function(type) {
  var key, listeners;

  if (!this._events)
    return this;

  // not listening for removeListener, no need to emit
  if (!this._events.removeListener) {
    if (arguments.length === 0)
      this._events = {};
    else if (this._events[type])
      delete this._events[type];
    return this;
  }

  // emit removeListener for all listeners on all events
  if (arguments.length === 0) {
    for (key in this._events) {
      if (key === 'removeListener') continue;
      this.removeAllListeners(key);
    }
    this.removeAllListeners('removeListener');
    this._events = {};
    return this;
  }

  listeners = this._events[type];

  if (isFunction(listeners)) {
    this.removeListener(type, listeners);
  } else if (listeners) {
    // LIFO order
    while (listeners.length)
      this.removeListener(type, listeners[listeners.length - 1]);
  }
  delete this._events[type];

  return this;
};

EventEmitter.prototype.listeners = function(type) {
  var ret;
  if (!this._events || !this._events[type])
    ret = [];
  else if (isFunction(this._events[type]))
    ret = [this._events[type]];
  else
    ret = this._events[type].slice();
  return ret;
};

EventEmitter.prototype.listenerCount = function(type) {
  if (this._events) {
    var evlistener = this._events[type];

    if (isFunction(evlistener))
      return 1;
    else if (evlistener)
      return evlistener.length;
  }
  return 0;
};

EventEmitter.listenerCount = function(emitter, type) {
  return emitter.listenerCount(type);
};

function isFunction(arg) {
  return typeof arg === 'function';
}

function isNumber(arg) {
  return typeof arg === 'number';
}

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}

function isUndefined(arg) {
  return arg === void 0;
}

},{}],65:[function(require,module,exports){
exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = nBytes * 8 - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = (value * c - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}

},{}],66:[function(require,module,exports){
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    ctor.prototype = Object.create(superCtor.prototype, {
      constructor: {
        value: ctor,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    ctor.super_ = superCtor
    var TempCtor = function () {}
    TempCtor.prototype = superCtor.prototype
    ctor.prototype = new TempCtor()
    ctor.prototype.constructor = ctor
  }
}

},{}],67:[function(require,module,exports){
/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)
}

function isBuffer (obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer (obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))
}

},{}],68:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":69,"./lib/stringify":70}],69:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],70:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],71:[function(require,module,exports){
(function (process){
'use strict';

if (!process.version ||
    process.version.indexOf('v0.') === 0 ||
    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
  module.exports = nextTick;
} else {
  module.exports = process.nextTick;
}

function nextTick(fn, arg1, arg2, arg3) {
  if (typeof fn !== 'function') {
    throw new TypeError('"callback" argument must be a function');
  }
  var len = arguments.length;
  var args, i;
  switch (len) {
  case 0:
  case 1:
    return process.nextTick(fn);
  case 2:
    return process.nextTick(function afterTickOne() {
      fn.call(null, arg1);
    });
  case 3:
    return process.nextTick(function afterTickTwo() {
      fn.call(null, arg1, arg2);
    });
  case 4:
    return process.nextTick(function afterTickThree() {
      fn.call(null, arg1, arg2, arg3);
    });
  default:
    args = new Array(len - 1);
    i = 0;
    while (i < args.length) {
      args[i++] = arguments[i];
    }
    return process.nextTick(function afterTick() {
      fn.apply(null, args);
    });
  }
}

}).call(this,require('_process'))

},{"_process":72}],72:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],73:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],74:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],75:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],76:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":74,"./encode":75}],77:[function(require,module,exports){
/* eslint-disable node/no-deprecated-api */
var buffer = require('buffer')
var Buffer = buffer.Buffer

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key]
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports)
  exports.Buffer = SafeBuffer
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer)

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size)
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding)
    } else {
      buf.fill(fill)
    }
  } else {
    buf.fill(0)
  }
  return buf
}

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
}

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
}

},{"buffer":48}],78:[function(require,module,exports){
var Stream = require('stream');
var sockjs = require('sockjs-client');
var resolve = require('url').resolve;
var parse = require('url').parse;

module.exports = function (u, cb) {
    var uri = parse(u).protocol ? u : resolve(window.location.href, u);
    
    var stream = new Stream;
    stream.readable = true;
    stream.writable = true;
    
    var ready = false;
    var buffer = [];
    
    var sock = sockjs(uri);
    stream.sock = sock;
    
    stream.write = function (msg) {
        if (!ready || buffer.length) buffer.push(msg)
        else sock.send(msg)
    };
    
    stream.end = function (msg) {
        if (msg !== undefined) stream.write(msg);
        if (!ready) {
            stream._ended = true;
            return;
        }
        stream.writable = false;
        sock.close();
    };
    
    stream.destroy = function () {
        stream._ended = true;
        stream.writable = stream.readable = false;
        buffer.length = 0
        sock.close();
    };
    
    sock.onopen = function () {
        if (typeof cb === 'function') cb();
        ready = true;
        for (var i = 0; i < buffer.length; i++) {
            sock.send(buffer[i]);
        }
        buffer = [];
        stream.emit('connect');
        if (stream._ended) stream.end();
    };
    
    sock.onmessage = function (e) {
        stream.emit('data', e.data);
    };
    
    sock.onclose = function () {
        stream.emit('end');
        stream.writable = false;
        stream.readable = false;
    };
    
    return stream;
};

},{"sockjs-client":79,"stream":80,"url":97}],79:[function(require,module,exports){
/* SockJS client, version 0.3.1.7.ga67f.dirty, http://sockjs.org, MIT License

Copyright (c) 2011-2012 VMware, Inc.

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in
all copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
THE SOFTWARE.
*/

// JSON2 by Douglas Crockford (minified).
var JSON;JSON||(JSON={}),function(){function str(a,b){var c,d,e,f,g=gap,h,i=b[a];i&&typeof i=="object"&&typeof i.toJSON=="function"&&(i=i.toJSON(a)),typeof rep=="function"&&(i=rep.call(b,a,i));switch(typeof i){case"string":return quote(i);case"number":return isFinite(i)?String(i):"null";case"boolean":case"null":return String(i);case"object":if(!i)return"null";gap+=indent,h=[];if(Object.prototype.toString.apply(i)==="[object Array]"){f=i.length;for(c=0;c<f;c+=1)h[c]=str(c,i)||"null";e=h.length===0?"[]":gap?"[\n"+gap+h.join(",\n"+gap)+"\n"+g+"]":"["+h.join(",")+"]",gap=g;return e}if(rep&&typeof rep=="object"){f=rep.length;for(c=0;c<f;c+=1)typeof rep[c]=="string"&&(d=rep[c],e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e))}else for(d in i)Object.prototype.hasOwnProperty.call(i,d)&&(e=str(d,i),e&&h.push(quote(d)+(gap?": ":":")+e));e=h.length===0?"{}":gap?"{\n"+gap+h.join(",\n"+gap)+"\n"+g+"}":"{"+h.join(",")+"}",gap=g;return e}}function quote(a){escapable.lastIndex=0;return escapable.test(a)?'"'+a.replace(escapable,function(a){var b=meta[a];return typeof b=="string"?b:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+a+'"'}function f(a){return a<10?"0"+a:a}"use strict",typeof Date.prototype.toJSON!="function"&&(Date.prototype.toJSON=function(a){return isFinite(this.valueOf())?this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z":null},String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(a){return this.valueOf()});var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;typeof JSON.stringify!="function"&&(JSON.stringify=function(a,b,c){var d;gap="",indent="";if(typeof c=="number")for(d=0;d<c;d+=1)indent+=" ";else typeof c=="string"&&(indent=c);rep=b;if(!b||typeof b=="function"||typeof b=="object"&&typeof b.length=="number")return str("",{"":a});throw new Error("JSON.stringify")}),typeof JSON.parse!="function"&&(JSON.parse=function(text,reviver){function walk(a,b){var c,d,e=a[b];if(e&&typeof e=="object")for(c in e)Object.prototype.hasOwnProperty.call(e,c)&&(d=walk(e,c),d!==undefined?e[c]=d:delete e[c]);return reviver.call(a,b,e)}var j;text=String(text),cx.lastIndex=0,cx.test(text)&&(text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)}));if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver=="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")})}()


//     [*] Including lib/index.js
// Public object
var SockJS = (function(){
              var _document = document;
              var _window = window;
              var utils = {};


//         [*] Including lib/reventtarget.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

/* Simplified implementation of DOM2 EventTarget.
 *   http://www.w3.org/TR/DOM-Level-2-Events/events.html#Events-EventTarget
 */
var REventTarget = function() {};
REventTarget.prototype.addEventListener = function (eventType, listener) {
    if(!this._listeners) {
         this._listeners = {};
    }
    if(!(eventType in this._listeners)) {
        this._listeners[eventType] = [];
    }
    var arr = this._listeners[eventType];
    if(utils.arrIndexOf(arr, listener) === -1) {
        arr.push(listener);
    }
    return;
};

REventTarget.prototype.removeEventListener = function (eventType, listener) {
    if(!(this._listeners && (eventType in this._listeners))) {
        return;
    }
    var arr = this._listeners[eventType];
    var idx = utils.arrIndexOf(arr, listener);
    if (idx !== -1) {
        if(arr.length > 1) {
            this._listeners[eventType] = arr.slice(0, idx).concat( arr.slice(idx+1) );
        } else {
            delete this._listeners[eventType];
        }
        return;
    }
    return;
};

REventTarget.prototype.dispatchEvent = function (event) {
    var t = event.type;
    var args = Array.prototype.slice.call(arguments, 0);
    if (this['on'+t]) {
        this['on'+t].apply(this, args);
    }
    if (this._listeners && t in this._listeners) {
        for(var i=0; i < this._listeners[t].length; i++) {
            this._listeners[t][i].apply(this, args);
        }
    }
};
//         [*] End of lib/reventtarget.js


//         [*] Including lib/simpleevent.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SimpleEvent = function(type, obj) {
    this.type = type;
    if (typeof obj !== 'undefined') {
        for(var k in obj) {
            if (!obj.hasOwnProperty(k)) continue;
            this[k] = obj[k];
        }
    }
};

SimpleEvent.prototype.toString = function() {
    var r = [];
    for(var k in this) {
        if (!this.hasOwnProperty(k)) continue;
        var v = this[k];
        if (typeof v === 'function') v = '[function]';
        r.push(k + '=' + v);
    }
    return 'SimpleEvent(' + r.join(', ') + ')';
};
//         [*] End of lib/simpleevent.js


//         [*] Including lib/eventemitter.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventEmitter = function(events) {
    this.events = events || [];
};
EventEmitter.prototype.emit = function(type) {
    var that = this;
    var args = Array.prototype.slice.call(arguments, 1);
    if (!that.nuked && that['on'+type]) {
        that['on'+type].apply(that, args);
    }
    if (utils.arrIndexOf(that.events, type) === -1) {
        utils.log('Event ' + JSON.stringify(type) +
                  ' not listed ' + JSON.stringify(that.events) +
                  ' in ' + that);
    }
};

EventEmitter.prototype.nuke = function(type) {
    var that = this;
    that.nuked = true;
    for(var i=0; i<that.events.length; i++) {
        delete that[that.events[i]];
    }
};
//         [*] End of lib/eventemitter.js


//         [*] Including lib/utils.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var random_string_chars = 'abcdefghijklmnopqrstuvwxyz0123456789_';
utils.random_string = function(length, max) {
    max = max || random_string_chars.length;
    var i, ret = [];
    for(i=0; i < length; i++) {
        ret.push( random_string_chars.substr(Math.floor(Math.random() * max),1) );
    }
    return ret.join('');
};
utils.random_number = function(max) {
    return Math.floor(Math.random() * max);
};
utils.random_number_string = function(max) {
    var t = (''+(max - 1)).length;
    var p = Array(t+1).join('0');
    return (p + utils.random_number(max)).slice(-t);
};

// Assuming that url looks like: http://asdasd:111/asd
utils.getOrigin = function(url) {
    url += '/';
    var parts = url.split('/').slice(0, 3);
    return parts.join('/');
};

utils.isSameOriginUrl = function(url_a, url_b) {
    // location.origin would do, but it's not always available.
    if (!url_b) url_b = _window.location.href;

    return (url_a.split('/').slice(0,3).join('/')
                ===
            url_b.split('/').slice(0,3).join('/'));
};

utils.getParentDomain = function(url) {
    // ipv4 ip address
    if (/^[0-9.]*$/.test(url)) return url;
    // ipv6 ip address
    if (/^\[/.test(url)) return url;
    // no dots
    if (!(/[.]/.test(url))) return url;

    var parts = url.split('.').slice(1);
    return parts.join('.');
};

utils.objectExtend = function(dst, src) {
    for(var k in src) {
        if (src.hasOwnProperty(k)) {
            dst[k] = src[k];
        }
    }
    return dst;
};

var WPrefix = '_jp';

utils.polluteGlobalNamespace = function() {
    if (!(WPrefix in _window)) {
        _window[WPrefix] = {};
    }
};

utils.closeFrame = function (code, reason) {
    return 'c'+JSON.stringify([code, reason]);
};

utils.userSetCode = function (code) {
    return code === 1000 || (code >= 3000 && code <= 4999);
};

// See: http://www.erg.abdn.ac.uk/~gerrit/dccp/notes/ccid2/rto_estimator/
// and RFC 2988.
utils.countRTO = function (rtt) {
    var rto;
    if (rtt > 100) {
        rto = 3 * rtt; // rto > 300msec
    } else {
        rto = rtt + 200; // 200msec < rto <= 300msec
    }
    return rto;
}

utils.log = function() {
    if (_window.console && console.log && console.log.apply) {
        console.log.apply(console, arguments);
    }
};

utils.bind = function(fun, that) {
    if (fun.bind) {
        return fun.bind(that);
    } else {
        return function() {
            return fun.apply(that, arguments);
        };
    }
};

utils.flatUrl = function(url) {
    return url.indexOf('?') === -1 && url.indexOf('#') === -1;
};

utils.amendUrl = function(url) {
    var dl = _document.location;
    if (!url) {
        throw new Error('Wrong url for SockJS');
    }
    if (!utils.flatUrl(url)) {
        throw new Error('Only basic urls are supported in SockJS');
    }

    //  '//abc' --> 'http://abc'
    if (url.indexOf('//') === 0) {
        url = dl.protocol + url;
    }
    // '/abc' --> 'http://localhost:80/abc'
    if (url.indexOf('/') === 0) {
        url = dl.protocol + '//' + dl.host + url;
    }
    // strip trailing slashes
    url = url.replace(/[/]+$/,'');
    return url;
};

// IE doesn't support [].indexOf.
utils.arrIndexOf = function(arr, obj){
    for(var i=0; i < arr.length; i++){
        if(arr[i] === obj){
            return i;
        }
    }
    return -1;
};

utils.arrSkip = function(arr, obj) {
    var idx = utils.arrIndexOf(arr, obj);
    if (idx === -1) {
        return arr.slice();
    } else {
        var dst = arr.slice(0, idx);
        return dst.concat(arr.slice(idx+1));
    }
};

// Via: https://gist.github.com/1133122/2121c601c5549155483f50be3da5305e83b8c5df
utils.isArray = Array.isArray || function(value) {
    return {}.toString.call(value).indexOf('Array') >= 0
};

utils.delay = function(t, fun) {
    if(typeof t === 'function') {
        fun = t;
        t = 0;
    }
    return setTimeout(fun, t);
};


// Chars worth escaping, as defined by Douglas Crockford:
//   https://github.com/douglascrockford/JSON-js/blob/47a9882cddeb1e8529e07af9736218075372b8ac/json2.js#L196
var json_escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    json_lookup = {
"\u0000":"\\u0000","\u0001":"\\u0001","\u0002":"\\u0002","\u0003":"\\u0003",
"\u0004":"\\u0004","\u0005":"\\u0005","\u0006":"\\u0006","\u0007":"\\u0007",
"\b":"\\b","\t":"\\t","\n":"\\n","\u000b":"\\u000b","\f":"\\f","\r":"\\r",
"\u000e":"\\u000e","\u000f":"\\u000f","\u0010":"\\u0010","\u0011":"\\u0011",
"\u0012":"\\u0012","\u0013":"\\u0013","\u0014":"\\u0014","\u0015":"\\u0015",
"\u0016":"\\u0016","\u0017":"\\u0017","\u0018":"\\u0018","\u0019":"\\u0019",
"\u001a":"\\u001a","\u001b":"\\u001b","\u001c":"\\u001c","\u001d":"\\u001d",
"\u001e":"\\u001e","\u001f":"\\u001f","\"":"\\\"","\\":"\\\\",
"\u007f":"\\u007f","\u0080":"\\u0080","\u0081":"\\u0081","\u0082":"\\u0082",
"\u0083":"\\u0083","\u0084":"\\u0084","\u0085":"\\u0085","\u0086":"\\u0086",
"\u0087":"\\u0087","\u0088":"\\u0088","\u0089":"\\u0089","\u008a":"\\u008a",
"\u008b":"\\u008b","\u008c":"\\u008c","\u008d":"\\u008d","\u008e":"\\u008e",
"\u008f":"\\u008f","\u0090":"\\u0090","\u0091":"\\u0091","\u0092":"\\u0092",
"\u0093":"\\u0093","\u0094":"\\u0094","\u0095":"\\u0095","\u0096":"\\u0096",
"\u0097":"\\u0097","\u0098":"\\u0098","\u0099":"\\u0099","\u009a":"\\u009a",
"\u009b":"\\u009b","\u009c":"\\u009c","\u009d":"\\u009d","\u009e":"\\u009e",
"\u009f":"\\u009f","\u00ad":"\\u00ad","\u0600":"\\u0600","\u0601":"\\u0601",
"\u0602":"\\u0602","\u0603":"\\u0603","\u0604":"\\u0604","\u070f":"\\u070f",
"\u17b4":"\\u17b4","\u17b5":"\\u17b5","\u200c":"\\u200c","\u200d":"\\u200d",
"\u200e":"\\u200e","\u200f":"\\u200f","\u2028":"\\u2028","\u2029":"\\u2029",
"\u202a":"\\u202a","\u202b":"\\u202b","\u202c":"\\u202c","\u202d":"\\u202d",
"\u202e":"\\u202e","\u202f":"\\u202f","\u2060":"\\u2060","\u2061":"\\u2061",
"\u2062":"\\u2062","\u2063":"\\u2063","\u2064":"\\u2064","\u2065":"\\u2065",
"\u2066":"\\u2066","\u2067":"\\u2067","\u2068":"\\u2068","\u2069":"\\u2069",
"\u206a":"\\u206a","\u206b":"\\u206b","\u206c":"\\u206c","\u206d":"\\u206d",
"\u206e":"\\u206e","\u206f":"\\u206f","\ufeff":"\\ufeff","\ufff0":"\\ufff0",
"\ufff1":"\\ufff1","\ufff2":"\\ufff2","\ufff3":"\\ufff3","\ufff4":"\\ufff4",
"\ufff5":"\\ufff5","\ufff6":"\\ufff6","\ufff7":"\\ufff7","\ufff8":"\\ufff8",
"\ufff9":"\\ufff9","\ufffa":"\\ufffa","\ufffb":"\\ufffb","\ufffc":"\\ufffc",
"\ufffd":"\\ufffd","\ufffe":"\\ufffe","\uffff":"\\uffff"};

// Some extra characters that Chrome gets wrong, and substitutes with
// something else on the wire.
var extra_escapable = /[\x00-\x1f\ud800-\udfff\ufffe\uffff\u0300-\u0333\u033d-\u0346\u034a-\u034c\u0350-\u0352\u0357-\u0358\u035c-\u0362\u0374\u037e\u0387\u0591-\u05af\u05c4\u0610-\u0617\u0653-\u0654\u0657-\u065b\u065d-\u065e\u06df-\u06e2\u06eb-\u06ec\u0730\u0732-\u0733\u0735-\u0736\u073a\u073d\u073f-\u0741\u0743\u0745\u0747\u07eb-\u07f1\u0951\u0958-\u095f\u09dc-\u09dd\u09df\u0a33\u0a36\u0a59-\u0a5b\u0a5e\u0b5c-\u0b5d\u0e38-\u0e39\u0f43\u0f4d\u0f52\u0f57\u0f5c\u0f69\u0f72-\u0f76\u0f78\u0f80-\u0f83\u0f93\u0f9d\u0fa2\u0fa7\u0fac\u0fb9\u1939-\u193a\u1a17\u1b6b\u1cda-\u1cdb\u1dc0-\u1dcf\u1dfc\u1dfe\u1f71\u1f73\u1f75\u1f77\u1f79\u1f7b\u1f7d\u1fbb\u1fbe\u1fc9\u1fcb\u1fd3\u1fdb\u1fe3\u1feb\u1fee-\u1fef\u1ff9\u1ffb\u1ffd\u2000-\u2001\u20d0-\u20d1\u20d4-\u20d7\u20e7-\u20e9\u2126\u212a-\u212b\u2329-\u232a\u2adc\u302b-\u302c\uaab2-\uaab3\uf900-\ufa0d\ufa10\ufa12\ufa15-\ufa1e\ufa20\ufa22\ufa25-\ufa26\ufa2a-\ufa2d\ufa30-\ufa6d\ufa70-\ufad9\ufb1d\ufb1f\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40-\ufb41\ufb43-\ufb44\ufb46-\ufb4e\ufff0-\uffff]/g,
    extra_lookup;

// JSON Quote string. Use native implementation when possible.
var JSONQuote = (JSON && JSON.stringify) || function(string) {
    json_escapable.lastIndex = 0;
    if (json_escapable.test(string)) {
        string = string.replace(json_escapable, function(a) {
            return json_lookup[a];
        });
    }
    return '"' + string + '"';
};

// This may be quite slow, so let's delay until user actually uses bad
// characters.
var unroll_lookup = function(escapable) {
    var i;
    var unrolled = {}
    var c = []
    for(i=0; i<65536; i++) {
        c.push( String.fromCharCode(i) );
    }
    escapable.lastIndex = 0;
    c.join('').replace(escapable, function (a) {
        unrolled[ a ] = '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
        return '';
    });
    escapable.lastIndex = 0;
    return unrolled;
};

// Quote string, also taking care of unicode characters that browsers
// often break. Especially, take care of unicode surrogates:
//    http://en.wikipedia.org/wiki/Mapping_of_Unicode_characters#Surrogates
utils.quote = function(string) {
    var quoted = JSONQuote(string);

    // In most cases this should be very fast and good enough.
    extra_escapable.lastIndex = 0;
    if(!extra_escapable.test(quoted)) {
        return quoted;
    }

    if(!extra_lookup) extra_lookup = unroll_lookup(extra_escapable);

    return quoted.replace(extra_escapable, function(a) {
        return extra_lookup[a];
    });
}

var _all_protocols = ['websocket',
                      'xdr-streaming',
                      'xhr-streaming',
                      'iframe-eventsource',
                      'iframe-htmlfile',
                      'xdr-polling',
                      'xhr-polling',
                      'iframe-xhr-polling',
                      'jsonp-polling'];

utils.probeProtocols = function() {
    var probed = {};
    for(var i=0; i<_all_protocols.length; i++) {
        var protocol = _all_protocols[i];
        // User can have a typo in protocol name.
        probed[protocol] = SockJS[protocol] &&
                           SockJS[protocol].enabled();
    }
    return probed;
};

utils.detectProtocols = function(probed, protocols_whitelist, info) {
    var pe = {},
        protocols = [];
    if (!protocols_whitelist) protocols_whitelist = _all_protocols;
    for(var i=0; i<protocols_whitelist.length; i++) {
        var protocol = protocols_whitelist[i];
        pe[protocol] = probed[protocol];
    }
    var maybe_push = function(protos) {
        var proto = protos.shift();
        if (pe[proto]) {
            protocols.push(proto);
        } else {
            if (protos.length > 0) {
                maybe_push(protos);
            }
        }
    }

    // 1. Websocket
    if (info.websocket !== false) {
        maybe_push(['websocket']);
    }

    // 2. Streaming
    if (pe['xhr-streaming'] && !info.null_origin) {
        protocols.push('xhr-streaming');
    } else {
        if (pe['xdr-streaming'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-streaming');
        } else {
            maybe_push(['iframe-eventsource',
                        'iframe-htmlfile']);
        }
    }

    // 3. Polling
    if (pe['xhr-polling'] && !info.null_origin) {
        protocols.push('xhr-polling');
    } else {
        if (pe['xdr-polling'] && !info.cookie_needed && !info.null_origin) {
            protocols.push('xdr-polling');
        } else {
            maybe_push(['iframe-xhr-polling',
                        'jsonp-polling']);
        }
    }
    return protocols;
}
//         [*] End of lib/utils.js


//         [*] Including lib/dom.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// May be used by htmlfile jsonp and transports.
var MPrefix = '_sockjs_global';
utils.createHook = function() {
    var window_id = 'a' + utils.random_string(8);
    if (!(MPrefix in _window)) {
        var map = {};
        _window[MPrefix] = function(window_id) {
            if (!(window_id in map)) {
                map[window_id] = {
                    id: window_id,
                    del: function() {delete map[window_id];}
                };
            }
            return map[window_id];
        }
    }
    return _window[MPrefix](window_id);
};



utils.attachMessage = function(listener) {
    utils.attachEvent('message', listener);
};
utils.attachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.addEventListener(event, listener, false);
    } else {
        // IE quirks.
        // According to: http://stevesouders.com/misc/test-postmessage.php
        // the message gets delivered only to 'document', not 'window'.
        _document.attachEvent("on" + event, listener);
        // I get 'window' for ie8.
        _window.attachEvent("on" + event, listener);
    }
};

utils.detachMessage = function(listener) {
    utils.detachEvent('message', listener);
};
utils.detachEvent = function(event, listener) {
    if (typeof _window.addEventListener !== 'undefined') {
        _window.removeEventListener(event, listener, false);
    } else {
        _document.detachEvent("on" + event, listener);
        _window.detachEvent("on" + event, listener);
    }
};


var on_unload = {};
// Things registered after beforeunload are to be called immediately.
var after_unload = false;

var trigger_unload_callbacks = function() {
    for(var ref in on_unload) {
        on_unload[ref]();
        delete on_unload[ref];
    };
};

var unload_triggered = function() {
    if(after_unload) return;
    after_unload = true;
    trigger_unload_callbacks();
};

// Onbeforeunload alone is not reliable. We could use only 'unload'
// but it's not working in opera within an iframe. Let's use both.
utils.attachEvent('beforeunload', unload_triggered);
utils.attachEvent('unload', unload_triggered);

utils.unload_add = function(listener) {
    var ref = utils.random_string(8);
    on_unload[ref] = listener;
    if (after_unload) {
        utils.delay(trigger_unload_callbacks);
    }
    return ref;
};
utils.unload_del = function(ref) {
    if (ref in on_unload)
        delete on_unload[ref];
};


utils.createIframe = function (iframe_url, error_callback) {
    var iframe = _document.createElement('iframe');
    var tref, unload_ref;
    var unattach = function() {
        clearTimeout(tref);
        // Explorer had problems with that.
        try {iframe.onload = null;} catch (x) {}
        iframe.onerror = null;
    };
    var cleanup = function() {
        if (iframe) {
            unattach();
            // This timeout makes chrome fire onbeforeunload event
            // within iframe. Without the timeout it goes straight to
            // onunload.
            setTimeout(function() {
                if(iframe) {
                    iframe.parentNode.removeChild(iframe);
                }
                iframe = null;
            }, 0);
            utils.unload_del(unload_ref);
        }
    };
    var onerror = function(r) {
        if (iframe) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    iframe.src = iframe_url;
    iframe.style.display = 'none';
    iframe.style.position = 'absolute';
    iframe.onerror = function(){onerror('onerror');};
    iframe.onload = function() {
        // `onload` is triggered before scripts on the iframe are
        // executed. Give it few seconds to actually load stuff.
        clearTimeout(tref);
        tref = setTimeout(function(){onerror('onload timeout');}, 2000);
    };
    _document.body.appendChild(iframe);
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};

utils.createHtmlfile = function (iframe_url, error_callback) {
    var doc = new ActiveXObject('htmlfile');
    var tref, unload_ref;
    var iframe;
    var unattach = function() {
        clearTimeout(tref);
    };
    var cleanup = function() {
        if (doc) {
            unattach();
            utils.unload_del(unload_ref);
            iframe.parentNode.removeChild(iframe);
            iframe = doc = null;
            CollectGarbage();
        }
    };
    var onerror = function(r)  {
        if (doc) {
            cleanup();
            error_callback(r);
        }
    };
    var post = function(msg, origin) {
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (iframe && iframe.contentWindow) {
                iframe.contentWindow.postMessage(msg, origin);
            }
        } catch (x) {};
    };

    doc.open();
    doc.write('<html><s' + 'cript>' +
              'document.domain="' + document.domain + '";' +
              '</s' + 'cript></html>');
    doc.close();
    doc.parentWindow[WPrefix] = _window[WPrefix];
    var c = doc.createElement('div');
    doc.body.appendChild(c);
    iframe = doc.createElement('iframe');
    c.appendChild(iframe);
    iframe.src = iframe_url;
    tref = setTimeout(function(){onerror('timeout');}, 15000);
    unload_ref = utils.unload_add(cleanup);
    return {
        post: post,
        cleanup: cleanup,
        loaded: unattach
    };
};
//         [*] End of lib/dom.js


//         [*] Including lib/dom2.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AbstractXHRObject = function(){};
AbstractXHRObject.prototype = new EventEmitter(['chunk', 'finish']);

AbstractXHRObject.prototype._start = function(method, url, payload, opts) {
    var that = this;

    try {
        that.xhr = new XMLHttpRequest();
    } catch(x) {};

    if (!that.xhr) {
        try {
            that.xhr = new _window.ActiveXObject('Microsoft.XMLHTTP');
        } catch(x) {};
    }
    if (_window.ActiveXObject || _window.XDomainRequest) {
        // IE8 caches even POSTs
        url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);
    }

    // Explorer tends to keep connection open, even after the
    // tab gets closed: http://bugs.jquery.com/ticket/5280
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        that.xhr.open(method, url, true);
    } catch(e) {
        // IE raises an exception on wrong port.
        that.emit('finish', 0, '');
        that._cleanup();
        return;
    };

    if (!opts || !opts.no_credentials) {
        // Mozilla docs says https://developer.mozilla.org/en/XMLHttpRequest :
        // "This never affects same-site requests."
        that.xhr.withCredentials = 'true';
    }
    if (opts && opts.headers) {
        for(var key in opts.headers) {
            that.xhr.setRequestHeader(key, opts.headers[key]);
        }
    }

    that.xhr.onreadystatechange = function() {
        if (that.xhr) {
            var x = that.xhr;
            switch (x.readyState) {
            case 3:
                // IE doesn't like peeking into responseText or status
                // on Microsoft.XMLHTTP and readystate=3
                try {
                    var status = x.status;
                    var text = x.responseText;
                } catch (x) {};
                // IE does return readystate == 3 for 404 answers.
                if (text && text.length > 0) {
                    that.emit('chunk', status, text);
                }
                break;
            case 4:
                that.emit('finish', x.status, x.responseText);
                that._cleanup(false);
                break;
            }
        }
    };
    that.xhr.send(payload);
};

AbstractXHRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xhr) return;
    utils.unload_del(that.unload_ref);

    // IE needs this field to be a function
    that.xhr.onreadystatechange = function(){};

    if (abort) {
        try {
            that.xhr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xhr = null;
};

AbstractXHRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

var XHRCorsObject = utils.XHRCorsObject = function() {
    var that = this, args = arguments;
    utils.delay(function(){that._start.apply(that, args);});
};
XHRCorsObject.prototype = new AbstractXHRObject();

var XHRLocalObject = utils.XHRLocalObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){
        that._start(method, url, payload, {
            no_credentials: true
        });
    });
};
XHRLocalObject.prototype = new AbstractXHRObject();



// References:
//   http://ajaxian.com/archives/100-line-ajax-wrapper
//   http://msdn.microsoft.com/en-us/library/cc288060(v=VS.85).aspx
var XDRObject = utils.XDRObject = function(method, url, payload) {
    var that = this;
    utils.delay(function(){that._start(method, url, payload);});
};
XDRObject.prototype = new EventEmitter(['chunk', 'finish']);
XDRObject.prototype._start = function(method, url, payload) {
    var that = this;
    var xdr = new XDomainRequest();
    // IE caches even POSTs
    url += ((url.indexOf('?') === -1) ? '?' : '&') + 't='+(+new Date);

    var onerror = xdr.ontimeout = xdr.onerror = function() {
        that.emit('finish', 0, '');
        that._cleanup(false);
    };
    xdr.onprogress = function() {
        that.emit('chunk', 200, xdr.responseText);
    };
    xdr.onload = function() {
        that.emit('finish', 200, xdr.responseText);
        that._cleanup(false);
    };
    that.xdr = xdr;
    that.unload_ref = utils.unload_add(function(){that._cleanup(true);});
    try {
        // Fails with AccessDenied if port number is bogus
        that.xdr.open(method, url);
        that.xdr.send(payload);
    } catch(x) {
        onerror();
    }
};

XDRObject.prototype._cleanup = function(abort) {
    var that = this;
    if (!that.xdr) return;
    utils.unload_del(that.unload_ref);

    that.xdr.ontimeout = that.xdr.onerror = that.xdr.onprogress =
        that.xdr.onload = null;
    if (abort) {
        try {
            that.xdr.abort();
        } catch(x) {};
    }
    that.unload_ref = that.xdr = null;
};

XDRObject.prototype.close = function() {
    var that = this;
    that.nuke();
    that._cleanup(true);
};

// 1. Is natively via XHR
// 2. Is natively via XDR
// 3. Nope, but postMessage is there so it should work via the Iframe.
// 4. Nope, sorry.
utils.isXHRCorsCapable = function() {
    if (_window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest()) {
        return 1;
    }
    // XDomainRequest doesn't work if page is served from file://
    if (_window.XDomainRequest && _document.domain) {
        return 2;
    }
    if (IframeTransport.enabled()) {
        return 3;
    }
    return 4;
};
//         [*] End of lib/dom2.js


//         [*] Including lib/sockjs.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var SockJS = function(url, dep_protocols_whitelist, options) {
    if (this === window) {
        // makes `new` optional
        return new SockJS(url, dep_protocols_whitelist, options);
    }
    
    var that = this, protocols_whitelist;
    that._options = {devel: false, debug: false, protocols_whitelist: [],
                     info: undefined, rtt: undefined};
    if (options) {
        utils.objectExtend(that._options, options);
    }
    that._base_url = utils.amendUrl(url);
    that._server = that._options.server || utils.random_number_string(1000);
    if (that._options.protocols_whitelist &&
        that._options.protocols_whitelist.length) {
        protocols_whitelist = that._options.protocols_whitelist;
    } else {
        // Deprecated API
        if (typeof dep_protocols_whitelist === 'string' &&
            dep_protocols_whitelist.length > 0) {
            protocols_whitelist = [dep_protocols_whitelist];
        } else if (utils.isArray(dep_protocols_whitelist)) {
            protocols_whitelist = dep_protocols_whitelist
        } else {
            protocols_whitelist = null;
        }
        if (protocols_whitelist) {
            that._debug('Deprecated API: Use "protocols_whitelist" option ' +
                        'instead of supplying protocol list as a second ' +
                        'parameter to SockJS constructor.');
        }
    }
    that._protocols = [];
    that.protocol = null;
    that.readyState = SockJS.CONNECTING;
    that._ir = createInfoReceiver(that._base_url);
    that._ir.onfinish = function(info, rtt) {
        that._ir = null;
        if (info) {
            if (that._options.info) {
                // Override if user supplies the option
                info = utils.objectExtend(info, that._options.info);
            }
            if (that._options.rtt) {
                rtt = that._options.rtt;
            }
            that._applyInfo(info, rtt, protocols_whitelist);
            that._didClose();
        } else {
            that._didClose(1002, 'Can\'t connect to server', true);
        }
    };
};
// Inheritance
SockJS.prototype = new REventTarget();

SockJS.version = "0.3.1.7.ga67f.dirty";

SockJS.CONNECTING = 0;
SockJS.OPEN = 1;
SockJS.CLOSING = 2;
SockJS.CLOSED = 3;

SockJS.prototype._debug = function() {
    if (this._options.debug)
        utils.log.apply(utils, arguments);
};

SockJS.prototype._dispatchOpen = function() {
    var that = this;
    if (that.readyState === SockJS.CONNECTING) {
        if (that._transport_tref) {
            clearTimeout(that._transport_tref);
            that._transport_tref = null;
        }
        that.readyState = SockJS.OPEN;
        that.dispatchEvent(new SimpleEvent("open"));
    } else {
        // The server might have been restarted, and lost track of our
        // connection.
        that._didClose(1006, "Server lost session");
    }
};

SockJS.prototype._dispatchMessage = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
            return;
    that.dispatchEvent(new SimpleEvent("message", {data: data}));
};

SockJS.prototype._dispatchHeartbeat = function(data) {
    var that = this;
    if (that.readyState !== SockJS.OPEN)
        return;
    that.dispatchEvent(new SimpleEvent('heartbeat', {}));
};

SockJS.prototype._didClose = function(code, reason, force) {
    var that = this;
    if (that.readyState !== SockJS.CONNECTING &&
        that.readyState !== SockJS.OPEN &&
        that.readyState !== SockJS.CLOSING)
            throw new Error('INVALID_STATE_ERR');
    if (that._ir) {
        that._ir.nuke();
        that._ir = null;
    }

    if (that._transport) {
        that._transport.doCleanup();
        that._transport = null;
    }

    var close_event = new SimpleEvent("close", {
        code: code,
        reason: reason,
        wasClean: utils.userSetCode(code)});

    if (!utils.userSetCode(code) &&
        that.readyState === SockJS.CONNECTING && !force) {
        if (that._try_next_protocol(close_event)) {
            return;
        }
        close_event = new SimpleEvent("close", {code: 2000,
                                                reason: "All transports failed",
                                                wasClean: false,
                                                last_event: close_event});
    }
    that.readyState = SockJS.CLOSED;

    utils.delay(function() {
                   that.dispatchEvent(close_event);
                });
};

SockJS.prototype._didMessage = function(data) {
    var that = this;
    var type = data.slice(0, 1);
    switch(type) {
    case 'o':
        that._dispatchOpen();
        break;
    case 'a':
        var payload = JSON.parse(data.slice(1) || '[]');
        for(var i=0; i < payload.length; i++){
            that._dispatchMessage(payload[i]);
        }
        break;
    case 'm':
        var payload = JSON.parse(data.slice(1) || 'null');
        that._dispatchMessage(payload);
        break;
    case 'c':
        var payload = JSON.parse(data.slice(1) || '[]');
        that._didClose(payload[0], payload[1]);
        break;
    case 'h':
        that._dispatchHeartbeat();
        break;
    }
};

SockJS.prototype._try_next_protocol = function(close_event) {
    var that = this;
    if (that.protocol) {
        that._debug('Closed transport:', that.protocol, ''+close_event);
        that.protocol = null;
    }
    if (that._transport_tref) {
        clearTimeout(that._transport_tref);
        that._transport_tref = null;
    }

    while(1) {
        var protocol = that.protocol = that._protocols.shift();
        if (!protocol) {
            return false;
        }
        // Some protocols require access to `body`, what if were in
        // the `head`?
        if (SockJS[protocol] &&
            SockJS[protocol].need_body === true &&
            (!_document.body ||
             (typeof _document.readyState !== 'undefined'
              && _document.readyState !== 'complete'))) {
            that._protocols.unshift(protocol);
            that.protocol = 'waiting-for-load';
            utils.attachEvent('load', function(){
                that._try_next_protocol();
            });
            return true;
        }

        if (!SockJS[protocol] ||
              !SockJS[protocol].enabled(that._options)) {
            that._debug('Skipping transport:', protocol);
        } else {
            var roundTrips = SockJS[protocol].roundTrips || 1;
            var to = ((that._options.rto || 0) * roundTrips) || 5000;
            that._transport_tref = utils.delay(to, function() {
                if (that.readyState === SockJS.CONNECTING) {
                    // I can't understand how it is possible to run
                    // this timer, when the state is CLOSED, but
                    // apparently in IE everythin is possible.
                    that._didClose(2007, "Transport timeouted");
                }
            });

            var connid = utils.random_string(8);
            var trans_url = that._base_url + '/' + that._server + '/' + connid;
            that._debug('Opening transport:', protocol, ' url:'+trans_url,
                        ' RTO:'+that._options.rto);
            that._transport = new SockJS[protocol](that, trans_url,
                                                   that._base_url);
            return true;
        }
    }
};

SockJS.prototype.close = function(code, reason) {
    var that = this;
    if (code && !utils.userSetCode(code))
        throw new Error("INVALID_ACCESS_ERR");
    if(that.readyState !== SockJS.CONNECTING &&
       that.readyState !== SockJS.OPEN) {
        return false;
    }
    that.readyState = SockJS.CLOSING;
    that._didClose(code || 1000, reason || "Normal closure");
    return true;
};

SockJS.prototype.send = function(data) {
    var that = this;
    if (that.readyState === SockJS.CONNECTING)
        throw new Error('INVALID_STATE_ERR');
    if (that.readyState === SockJS.OPEN) {
        that._transport.doSend(utils.quote('' + data));
    }
    return true;
};

SockJS.prototype._applyInfo = function(info, rtt, protocols_whitelist) {
    var that = this;
    that._options.info = info;
    that._options.rtt = rtt;
    that._options.rto = utils.countRTO(rtt);
    that._options.info.null_origin = !_document.domain;
    var probed = utils.probeProtocols();
    that._protocols = utils.detectProtocols(probed, protocols_whitelist, info);
};
//         [*] End of lib/sockjs.js


//         [*] Including lib/trans-websocket.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var WebSocketTransport = SockJS.websocket = function(ri, trans_url) {
    var that = this;
    var url = trans_url + '/websocket';
    if (url.slice(0, 5) === 'https') {
        url = 'wss' + url.slice(5);
    } else {
        url = 'ws' + url.slice(4);
    }
    that.ri = ri;
    that.url = url;
    var Constructor = _window.WebSocket || _window.MozWebSocket;

    that.ws = new Constructor(that.url);
    that.ws.onmessage = function(e) {
        that.ri._didMessage(e.data);
    };
    // Firefox has an interesting bug. If a websocket connection is
    // created after onbeforeunload, it stays alive even when user
    // navigates away from the page. In such situation let's lie -
    // let's not open the ws connection at all. See:
    // https://github.com/sockjs/sockjs-client/issues/28
    // https://bugzilla.mozilla.org/show_bug.cgi?id=696085
    that.unload_ref = utils.unload_add(function(){that.ws.close()});
    that.ws.onclose = function() {
        that.ri._didMessage(utils.closeFrame(1006, "WebSocket connection broken"));
    };
};

WebSocketTransport.prototype.doSend = function(data) {
    this.ws.send('[' + data + ']');
};

WebSocketTransport.prototype.doCleanup = function() {
    var that = this;
    var ws = that.ws;
    if (ws) {
        ws.onmessage = ws.onclose = null;
        ws.close();
        utils.unload_del(that.unload_ref);
        that.unload_ref = that.ri = that.ws = null;
    }
};

WebSocketTransport.enabled = function() {
    return !!(_window.WebSocket || _window.MozWebSocket);
};

// In theory, ws should require 1 round trip. But in chrome, this is
// not very stable over SSL. Most likely a ws connection requires a
// separate SSL connection, in which case 2 round trips are an
// absolute minumum.
WebSocketTransport.roundTrips = 2;
//         [*] End of lib/trans-websocket.js


//         [*] Including lib/trans-sender.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var BufferedSender = function() {};
BufferedSender.prototype.send_constructor = function(sender) {
    var that = this;
    that.send_buffer = [];
    that.sender = sender;
};
BufferedSender.prototype.doSend = function(message) {
    var that = this;
    that.send_buffer.push(message);
    if (!that.send_stop) {
        that.send_schedule();
    }
};

// For polling transports in a situation when in the message callback,
// new message is being send. If the sending connection was started
// before receiving one, it is possible to saturate the network and
// timeout due to the lack of receiving socket. To avoid that we delay
// sending messages by some small time, in order to let receiving
// connection be started beforehand. This is only a halfmeasure and
// does not fix the big problem, but it does make the tests go more
// stable on slow networks.
BufferedSender.prototype.send_schedule_wait = function() {
    var that = this;
    var tref;
    that.send_stop = function() {
        that.send_stop = null;
        clearTimeout(tref);
    };
    tref = utils.delay(25, function() {
        that.send_stop = null;
        that.send_schedule();
    });
};

BufferedSender.prototype.send_schedule = function() {
    var that = this;
    if (that.send_buffer.length > 0) {
        var payload = '[' + that.send_buffer.join(',') + ']';
        that.send_stop = that.sender(that.trans_url,
                                     payload,
                                     function() {
                                         that.send_stop = null;
                                         that.send_schedule_wait();
                                     });
        that.send_buffer = [];
    }
};

BufferedSender.prototype.send_destructor = function() {
    var that = this;
    if (that._send_stop) {
        that._send_stop();
    }
    that._send_stop = null;
};

var jsonPGenericSender = function(url, payload, callback) {
    var that = this;

    if (!('_send_form' in that)) {
        var form = that._send_form = _document.createElement('form');
        var area = that._send_area = _document.createElement('textarea');
        area.name = 'd';
        form.style.display = 'none';
        form.style.position = 'absolute';
        form.method = 'POST';
        form.enctype = 'application/x-www-form-urlencoded';
        form.acceptCharset = "UTF-8";
        form.appendChild(area);
        _document.body.appendChild(form);
    }
    var form = that._send_form;
    var area = that._send_area;
    var id = 'a' + utils.random_string(8);
    form.target = id;
    form.action = url + '/jsonp_send?i=' + id;

    var iframe;
    try {
        // ie6 dynamic iframes with target="" support (thanks Chris Lambacher)
        iframe = _document.createElement('<iframe name="'+ id +'">');
    } catch(x) {
        iframe = _document.createElement('iframe');
        iframe.name = id;
    }
    iframe.id = id;
    form.appendChild(iframe);
    iframe.style.display = 'none';

    try {
        area.value = payload;
    } catch(e) {
        utils.log('Your browser is seriously broken. Go home! ' + e.message);
    }
    form.submit();

    var completed = function(e) {
        if (!iframe.onerror) return;
        iframe.onreadystatechange = iframe.onerror = iframe.onload = null;
        // Opera mini doesn't like if we GC iframe
        // immediately, thus this timeout.
        utils.delay(500, function() {
                       iframe.parentNode.removeChild(iframe);
                       iframe = null;
                   });
        area.value = '';
        callback();
    };
    iframe.onerror = iframe.onload = completed;
    iframe.onreadystatechange = function(e) {
        if (iframe.readyState == 'complete') completed();
    };
    return completed;
};

var createAjaxSender = function(AjaxObject) {
    return function(url, payload, callback) {
        var xo = new AjaxObject('POST', url + '/xhr_send', payload);
        xo.onfinish = function(status, text) {
            callback(status);
        };
        return function(abort_reason) {
            callback(0, abort_reason);
        };
    };
};
//         [*] End of lib/trans-sender.js


//         [*] Including lib/trans-jsonp-receiver.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Parts derived from Socket.io:
//    https://github.com/LearnBoost/socket.io/blob/0.6.17/lib/socket.io/transports/jsonp-polling.js
// and jQuery-JSONP:
//    https://code.google.com/p/jquery-jsonp/source/browse/trunk/core/jquery.jsonp.js
var jsonPGenericReceiver = function(url, callback) {
    var tref;
    var script = _document.createElement('script');
    var script2;  // Opera synchronous load trick.
    var close_script = function(frame) {
        if (script2) {
            script2.parentNode.removeChild(script2);
            script2 = null;
        }
        if (script) {
            clearTimeout(tref);
            script.parentNode.removeChild(script);
            script.onreadystatechange = script.onerror =
                script.onload = script.onclick = null;
            script = null;
            callback(frame);
            callback = null;
        }
    };

    // IE9 fires 'error' event after orsc or before, in random order.
    var loaded_okay = false;
    var error_timer = null;

    script.id = 'a' + utils.random_string(8);
    script.src = url;
    script.type = 'text/javascript';
    script.charset = 'UTF-8';
    script.onerror = function(e) {
        if (!error_timer) {
            // Delay firing close_script.
            error_timer = setTimeout(function() {
                if (!loaded_okay) {
                    close_script(utils.closeFrame(
                        1006,
                        "JSONP script loaded abnormally (onerror)"));
                }
            }, 1000);
        }
    };
    script.onload = function(e) {
        close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onload)"));
    };

    script.onreadystatechange = function(e) {
        if (/loaded|closed/.test(script.readyState)) {
            if (script && script.htmlFor && script.onclick) {
                loaded_okay = true;
                try {
                    // In IE, actually execute the script.
                    script.onclick();
                } catch (x) {}
            }
            if (script) {
                close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (onreadystatechange)"));
            }
        }
    };
    // IE: event/htmlFor/onclick trick.
    // One can't rely on proper order for onreadystatechange. In order to
    // make sure, set a 'htmlFor' and 'event' properties, so that
    // script code will be installed as 'onclick' handler for the
    // script object. Later, onreadystatechange, manually execute this
    // code. FF and Chrome doesn't work with 'event' and 'htmlFor'
    // set. For reference see:
    //   http://jaubourg.net/2010/07/loading-script-as-onclick-handler-of.html
    // Also, read on that about script ordering:
    //   http://wiki.whatwg.org/wiki/Dynamic_Script_Execution_Order
    if (typeof script.async === 'undefined' && _document.attachEvent) {
        // According to mozilla docs, in recent browsers script.async defaults
        // to 'true', so we may use it to detect a good browser:
        // https://developer.mozilla.org/en/HTML/Element/script
        if (!/opera/i.test(navigator.userAgent)) {
            // Naively assume we're in IE
            try {
                script.htmlFor = script.id;
                script.event = "onclick";
            } catch (x) {}
            script.async = true;
        } else {
            // Opera, second sync script hack
            script2 = _document.createElement('script');
            script2.text = "try{var a = document.getElementById('"+script.id+"'); if(a)a.onerror();}catch(x){};";
            script.async = script2.async = false;
        }
    }
    if (typeof script.async !== 'undefined') {
        script.async = true;
    }

    // Fallback mostly for Konqueror - stupid timer, 35 seconds shall be plenty.
    tref = setTimeout(function() {
                          close_script(utils.closeFrame(1006, "JSONP script loaded abnormally (timeout)"));
                      }, 35000);

    var head = _document.getElementsByTagName('head')[0];
    head.insertBefore(script, head.firstChild);
    if (script2) {
        head.insertBefore(script2, head.firstChild);
    }
    return close_script;
};
//         [*] End of lib/trans-jsonp-receiver.js


//         [*] Including lib/trans-jsonp-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// The simplest and most robust transport, using the well-know cross
// domain hack - JSONP. This transport is quite inefficient - one
// mssage could use up to one http request. But at least it works almost
// everywhere.
// Known limitations:
//   o you will get a spinning cursor
//   o for Konqueror a dumb timer is needed to detect errors


var JsonPTransport = SockJS['jsonp-polling'] = function(ri, trans_url) {
    utils.polluteGlobalNamespace();
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(jsonPGenericSender);
    that._schedule_recv();
};

// Inheritnace
JsonPTransport.prototype = new BufferedSender();

JsonPTransport.prototype._schedule_recv = function() {
    var that = this;
    var callback = function(data) {
        that._recv_stop = null;
        if (data) {
            // no data - heartbeat;
            if (!that._is_closing) {
                that.ri._didMessage(data);
            }
        }
        // The message can be a close message, and change is_closing state.
        if (!that._is_closing) {
            that._schedule_recv();
        }
    };
    that._recv_stop = jsonPReceiverWrapper(that.trans_url + '/jsonp',
                                           jsonPGenericReceiver, callback);
};

JsonPTransport.enabled = function() {
    return true;
};

JsonPTransport.need_body = true;


JsonPTransport.prototype.doCleanup = function() {
    var that = this;
    that._is_closing = true;
    if (that._recv_stop) {
        that._recv_stop();
    }
    that.ri = that._recv_stop = null;
    that.send_destructor();
};


// Abstract away code that handles global namespace pollution.
var jsonPReceiverWrapper = function(url, constructReceiver, user_callback) {
    var id = 'a' + utils.random_string(6);
    var url_id = url + '?c=' + escape(WPrefix + '.' + id);
    // Callback will be called exactly once.
    var callback = function(frame) {
        delete _window[WPrefix][id];
        user_callback(frame);
    };

    var close_script = constructReceiver(url_id, callback);
    _window[WPrefix][id] = close_script;
    var stop = function() {
        if (_window[WPrefix][id]) {
            _window[WPrefix][id](utils.closeFrame(1000, "JSONP user aborted read"));
        }
    };
    return stop;
};
//         [*] End of lib/trans-jsonp-polling.js


//         [*] Including lib/trans-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var AjaxBasedTransport = function() {};
AjaxBasedTransport.prototype = new BufferedSender();

AjaxBasedTransport.prototype.run = function(ri, trans_url,
                                            url_suffix, Receiver, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.trans_url = trans_url;
    that.send_constructor(createAjaxSender(AjaxObject));
    that.poll = new Polling(ri, Receiver,
                            trans_url + url_suffix, AjaxObject);
};

AjaxBasedTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.poll) {
        that.poll.abort();
        that.poll = null;
    }
};

// xhr-streaming
var XhrStreamingTransport = SockJS['xhr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XHRCorsObject);
};

XhrStreamingTransport.prototype = new AjaxBasedTransport();

XhrStreamingTransport.enabled = function() {
    // Support for CORS Ajax aka Ajax2? Opera 12 claims CORS but
    // doesn't do streaming.
    return (_window.XMLHttpRequest &&
            'withCredentials' in new XMLHttpRequest() &&
            (!/opera/i.test(navigator.userAgent)));
};
XhrStreamingTransport.roundTrips = 2; // preflight, ajax

// Safari gets confused when a streaming ajax request is started
// before onload. This causes the load indicator to spin indefinetely.
XhrStreamingTransport.need_body = true;


// According to:
//   http://stackoverflow.com/questions/1641507/detect-browser-support-for-cross-domain-xmlhttprequests
//   http://hacks.mozilla.org/2009/07/cross-site-xmlhttprequest-with-cors/


// xdr-streaming
var XdrStreamingTransport = SockJS['xdr-streaming'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr_streaming', XhrReceiver, utils.XDRObject);
};

XdrStreamingTransport.prototype = new AjaxBasedTransport();

XdrStreamingTransport.enabled = function() {
    return !!_window.XDomainRequest;
};
XdrStreamingTransport.roundTrips = 2; // preflight, ajax



// xhr-polling
var XhrPollingTransport = SockJS['xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRCorsObject);
};

XhrPollingTransport.prototype = new AjaxBasedTransport();

XhrPollingTransport.enabled = XhrStreamingTransport.enabled;
XhrPollingTransport.roundTrips = 2; // preflight, ajax


// xdr-polling
var XdrPollingTransport = SockJS['xdr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XDRObject);
};

XdrPollingTransport.prototype = new AjaxBasedTransport();

XdrPollingTransport.enabled = XdrStreamingTransport.enabled;
XdrPollingTransport.roundTrips = 2; // preflight, ajax
//         [*] End of lib/trans-xhr.js


//         [*] Including lib/trans-iframe.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// Few cool transports do work only for same-origin. In order to make
// them working cross-domain we shall use iframe, served form the
// remote domain. New browsers, have capabilities to communicate with
// cross domain iframe, using postMessage(). In IE it was implemented
// from IE 8+, but of course, IE got some details wrong:
//    http://msdn.microsoft.com/en-us/library/cc197015(v=VS.85).aspx
//    http://stevesouders.com/misc/test-postmessage.php

var IframeTransport = function() {};

IframeTransport.prototype.i_constructor = function(ri, trans_url, base_url) {
    var that = this;
    that.ri = ri;
    that.origin = utils.getOrigin(base_url);
    that.base_url = base_url;
    that.trans_url = trans_url;

    var iframe_url = base_url + '/iframe.html';
    if (that.ri._options.devel) {
        iframe_url += '?t=' + (+new Date);
    }
    that.window_id = utils.random_string(8);
    iframe_url += '#' + that.window_id;

    that.iframeObj = utils.createIframe(iframe_url, function(r) {
                                            that.ri._didClose(1006, "Unable to load an iframe (" + r + ")");
                                        });

    that.onmessage_cb = utils.bind(that.onmessage, that);
    utils.attachMessage(that.onmessage_cb);
};

IframeTransport.prototype.doCleanup = function() {
    var that = this;
    if (that.iframeObj) {
        utils.detachMessage(that.onmessage_cb);
        try {
            // When the iframe is not loaded, IE raises an exception
            // on 'contentWindow'.
            if (that.iframeObj.iframe.contentWindow) {
                that.postMessage('c');
            }
        } catch (x) {}
        that.iframeObj.cleanup();
        that.iframeObj = null;
        that.onmessage_cb = that.iframeObj = null;
    }
};

IframeTransport.prototype.onmessage = function(e) {
    var that = this;
    if (e.origin !== that.origin) return;
    var window_id = e.data.slice(0, 8);
    var type = e.data.slice(8, 9);
    var data = e.data.slice(9);

    if (window_id !== that.window_id) return;

    switch(type) {
    case 's':
        that.iframeObj.loaded();
        that.postMessage('s', JSON.stringify([SockJS.version, that.protocol, that.trans_url, that.base_url]));
        break;
    case 't':
        that.ri._didMessage(data);
        break;
    }
};

IframeTransport.prototype.postMessage = function(type, data) {
    var that = this;
    that.iframeObj.post(that.window_id + type + (data || ''), that.origin);
};

IframeTransport.prototype.doSend = function (message) {
    this.postMessage('m', message);
};

IframeTransport.enabled = function() {
    // postMessage misbehaves in konqueror 4.6.5 - the messages are delivered with
    // huge delay, or not at all.
    var konqueror = navigator && navigator.userAgent && navigator.userAgent.indexOf('Konqueror') !== -1;
    return ((typeof _window.postMessage === 'function' ||
            typeof _window.postMessage === 'object') && (!konqueror));
};
//         [*] End of lib/trans-iframe.js


//         [*] Including lib/trans-iframe-within.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var curr_window_id;

var postMessage = function (type, data) {
    if(parent !== _window) {
        parent.postMessage(curr_window_id + type + (data || ''), '*');
    } else {
        utils.log("Can't postMessage, no parent window.", type, data);
    }
};

var FacadeJS = function() {};
FacadeJS.prototype._didClose = function (code, reason) {
    postMessage('t', utils.closeFrame(code, reason));
};
FacadeJS.prototype._didMessage = function (frame) {
    postMessage('t', frame);
};
FacadeJS.prototype._doSend = function (data) {
    this._transport.doSend(data);
};
FacadeJS.prototype._doCleanup = function () {
    this._transport.doCleanup();
};

utils.parent_origin = undefined;

SockJS.bootstrap_iframe = function() {
    var facade;
    curr_window_id = _document.location.hash.slice(1);
    var onMessage = function(e) {
        if(e.source !== parent) return;
        if(typeof utils.parent_origin === 'undefined')
            utils.parent_origin = e.origin;
        if (e.origin !== utils.parent_origin) return;

        var window_id = e.data.slice(0, 8);
        var type = e.data.slice(8, 9);
        var data = e.data.slice(9);
        if (window_id !== curr_window_id) return;
        switch(type) {
        case 's':
            var p = JSON.parse(data);
            var version = p[0];
            var protocol = p[1];
            var trans_url = p[2];
            var base_url = p[3];
            if (version !== SockJS.version) {
                utils.log("Incompatibile SockJS! Main site uses:" +
                          " \"" + version + "\", the iframe:" +
                          " \"" + SockJS.version + "\".");
            }
            if (!utils.flatUrl(trans_url) || !utils.flatUrl(base_url)) {
                utils.log("Only basic urls are supported in SockJS");
                return;
            }

            if (!utils.isSameOriginUrl(trans_url) ||
                !utils.isSameOriginUrl(base_url)) {
                utils.log("Can't connect to different domain from within an " +
                          "iframe. (" + JSON.stringify([_window.location.href, trans_url, base_url]) +
                          ")");
                return;
            }
            facade = new FacadeJS();
            facade._transport = new FacadeJS[protocol](facade, trans_url, base_url);
            break;
        case 'm':
            facade._doSend(data);
            break;
        case 'c':
            if (facade)
                facade._doCleanup();
            facade = null;
            break;
        }
    };

    // alert('test ticker');
    // facade = new FacadeJS();
    // facade._transport = new FacadeJS['w-iframe-xhr-polling'](facade, 'http://host.com:9999/ticker/12/basd');

    utils.attachMessage(onMessage);

    // Start
    postMessage('s');
};
//         [*] End of lib/trans-iframe-within.js


//         [*] Including lib/info.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var InfoReceiver = function(base_url, AjaxObject) {
    var that = this;
    utils.delay(function(){that.doXhr(base_url, AjaxObject);});
};

InfoReceiver.prototype = new EventEmitter(['finish']);

InfoReceiver.prototype.doXhr = function(base_url, AjaxObject) {
    var that = this;
    var t0 = (new Date()).getTime();
    var xo = new AjaxObject('GET', base_url + '/info');

    var tref = utils.delay(8000,
                           function(){xo.ontimeout();});

    xo.onfinish = function(status, text) {
        clearTimeout(tref);
        tref = null;
        if (status === 200) {
            var rtt = (new Date()).getTime() - t0;
            var info = JSON.parse(text);
            if (typeof info !== 'object') info = {};
            that.emit('finish', info, rtt);
        } else {
            that.emit('finish');
        }
    };
    xo.ontimeout = function() {
        xo.close();
        that.emit('finish');
    };
};

var InfoReceiverIframe = function(base_url) {
    var that = this;
    var go = function() {
        var ifr = new IframeTransport();
        ifr.protocol = 'w-iframe-info-receiver';
        var fun = function(r) {
            if (typeof r === 'string' && r.substr(0,1) === 'm') {
                var d = JSON.parse(r.substr(1));
                var info = d[0], rtt = d[1];
                that.emit('finish', info, rtt);
            } else {
                that.emit('finish');
            }
            ifr.doCleanup();
            ifr = null;
        };
        var mock_ri = {
            _options: {},
            _didClose: fun,
            _didMessage: fun
        };
        ifr.i_constructor(mock_ri, base_url, base_url);
    }
    if(!_document.body) {
        utils.attachEvent('load', go);
    } else {
        go();
    }
};
InfoReceiverIframe.prototype = new EventEmitter(['finish']);


var InfoReceiverFake = function() {
    // It may not be possible to do cross domain AJAX to get the info
    // data, for example for IE7. But we want to run JSONP, so let's
    // fake the response, with rtt=2s (rto=6s).
    var that = this;
    utils.delay(function() {
        that.emit('finish', {}, 2000);
    });
};
InfoReceiverFake.prototype = new EventEmitter(['finish']);

var createInfoReceiver = function(base_url) {
    if (utils.isSameOriginUrl(base_url)) {
        // If, for some reason, we have SockJS locally - there's no
        // need to start up the complex machinery. Just use ajax.
        return new InfoReceiver(base_url, utils.XHRLocalObject);
    }
    switch (utils.isXHRCorsCapable()) {
    case 1:
        return new InfoReceiver(base_url, utils.XHRCorsObject);
    case 2:
        return new InfoReceiver(base_url, utils.XDRObject);
    case 3:
        // Opera
        return new InfoReceiverIframe(base_url);
    default:
        // IE 7
        return new InfoReceiverFake();
    };
};


var WInfoReceiverIframe = FacadeJS['w-iframe-info-receiver'] = function(ri, _trans_url, base_url) {
    var ir = new InfoReceiver(base_url, utils.XHRLocalObject);
    ir.onfinish = function(info, rtt) {
        ri._didMessage('m'+JSON.stringify([info, rtt]));
        ri._didClose();
    }
};
WInfoReceiverIframe.prototype.doCleanup = function() {};
//         [*] End of lib/info.js


//         [*] Including lib/trans-iframe-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceIframeTransport = SockJS['iframe-eventsource'] = function () {
    var that = this;
    that.protocol = 'w-iframe-eventsource';
    that.i_constructor.apply(that, arguments);
};

EventSourceIframeTransport.prototype = new IframeTransport();

EventSourceIframeTransport.enabled = function () {
    return ('EventSource' in _window) && IframeTransport.enabled();
};

EventSourceIframeTransport.need_body = true;
EventSourceIframeTransport.roundTrips = 3; // html, javascript, eventsource


// w-iframe-eventsource
var EventSourceTransport = FacadeJS['w-iframe-eventsource'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/eventsource', EventSourceReceiver, utils.XHRLocalObject);
}
EventSourceTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-eventsource.js


//         [*] Including lib/trans-iframe-xhr-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrPollingIframeTransport = SockJS['iframe-xhr-polling'] = function () {
    var that = this;
    that.protocol = 'w-iframe-xhr-polling';
    that.i_constructor.apply(that, arguments);
};

XhrPollingIframeTransport.prototype = new IframeTransport();

XhrPollingIframeTransport.enabled = function () {
    return _window.XMLHttpRequest && IframeTransport.enabled();
};

XhrPollingIframeTransport.need_body = true;
XhrPollingIframeTransport.roundTrips = 3; // html, javascript, xhr


// w-iframe-xhr-polling
var XhrPollingITransport = FacadeJS['w-iframe-xhr-polling'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/xhr', XhrReceiver, utils.XHRLocalObject);
};

XhrPollingITransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-xhr-polling.js


//         [*] Including lib/trans-iframe-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// This transport generally works in any browser, but will cause a
// spinning cursor to appear in any browser other than IE.
// We may test this transport in all browsers - why not, but in
// production it should be only run in IE.

var HtmlFileIframeTransport = SockJS['iframe-htmlfile'] = function () {
    var that = this;
    that.protocol = 'w-iframe-htmlfile';
    that.i_constructor.apply(that, arguments);
};

// Inheritance.
HtmlFileIframeTransport.prototype = new IframeTransport();

HtmlFileIframeTransport.enabled = function() {
    return IframeTransport.enabled();
};

HtmlFileIframeTransport.need_body = true;
HtmlFileIframeTransport.roundTrips = 3; // html, javascript, htmlfile


// w-iframe-htmlfile
var HtmlFileTransport = FacadeJS['w-iframe-htmlfile'] = function(ri, trans_url) {
    this.run(ri, trans_url, '/htmlfile', HtmlfileReceiver, utils.XHRLocalObject);
};
HtmlFileTransport.prototype = new AjaxBasedTransport();
//         [*] End of lib/trans-iframe-htmlfile.js


//         [*] Including lib/trans-polling.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var Polling = function(ri, Receiver, recv_url, AjaxObject) {
    var that = this;
    that.ri = ri;
    that.Receiver = Receiver;
    that.recv_url = recv_url;
    that.AjaxObject = AjaxObject;
    that._scheduleRecv();
};

Polling.prototype._scheduleRecv = function() {
    var that = this;
    var poll = that.poll = new that.Receiver(that.recv_url, that.AjaxObject);
    var msg_counter = 0;
    poll.onmessage = function(e) {
        msg_counter += 1;
        that.ri._didMessage(e.data);
    };
    poll.onclose = function(e) {
        that.poll = poll = poll.onmessage = poll.onclose = null;
        if (!that.poll_is_closing) {
            if (e.reason === 'permanent') {
                that.ri._didClose(1006, 'Polling error (' + e.reason + ')');
            } else {
                that._scheduleRecv();
            }
        }
    };
};

Polling.prototype.abort = function() {
    var that = this;
    that.poll_is_closing = true;
    if (that.poll) {
        that.poll.abort();
    }
};
//         [*] End of lib/trans-polling.js


//         [*] Including lib/trans-receiver-eventsource.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var EventSourceReceiver = function(url) {
    var that = this;
    var es = new EventSource(url);
    es.onmessage = function(e) {
        that.dispatchEvent(new SimpleEvent('message',
                                           {'data': unescape(e.data)}));
    };
    that.es_close = es.onerror = function(e, abort_reason) {
        // ES on reconnection has readyState = 0 or 1.
        // on network error it's CLOSED = 2
        var reason = abort_reason ? 'user' :
            (es.readyState !== 2 ? 'network' : 'permanent');
        that.es_close = es.onmessage = es.onerror = null;
        // EventSource reconnects automatically.
        es.close();
        es = null;
        // Safari and chrome < 15 crash if we close window before
        // waiting for ES cleanup. See:
        //   https://code.google.com/p/chromium/issues/detail?id=89155
        utils.delay(200, function() {
                        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
                    });
    };
};

EventSourceReceiver.prototype = new REventTarget();

EventSourceReceiver.prototype.abort = function() {
    var that = this;
    if (that.es_close) {
        that.es_close({}, true);
    }
};
//         [*] End of lib/trans-receiver-eventsource.js


//         [*] Including lib/trans-receiver-htmlfile.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var _is_ie_htmlfile_capable;
var isIeHtmlfileCapable = function() {
    if (_is_ie_htmlfile_capable === undefined) {
        if ('ActiveXObject' in _window) {
            try {
                _is_ie_htmlfile_capable = !!new ActiveXObject('htmlfile');
            } catch (x) {}
        } else {
            _is_ie_htmlfile_capable = false;
        }
    }
    return _is_ie_htmlfile_capable;
};


var HtmlfileReceiver = function(url) {
    var that = this;
    utils.polluteGlobalNamespace();

    that.id = 'a' + utils.random_string(6, 26);
    url += ((url.indexOf('?') === -1) ? '?' : '&') +
        'c=' + escape(WPrefix + '.' + that.id);

    var constructor = isIeHtmlfileCapable() ?
        utils.createHtmlfile : utils.createIframe;

    var iframeObj;
    _window[WPrefix][that.id] = {
        start: function () {
            iframeObj.loaded();
        },
        message: function (data) {
            that.dispatchEvent(new SimpleEvent('message', {'data': data}));
        },
        stop: function () {
            that.iframe_close({}, 'network');
        }
    };
    that.iframe_close = function(e, abort_reason) {
        iframeObj.cleanup();
        that.iframe_close = iframeObj = null;
        delete _window[WPrefix][that.id];
        that.dispatchEvent(new SimpleEvent('close', {reason: abort_reason}));
    };
    iframeObj = constructor(url, function(e) {
                                that.iframe_close({}, 'permanent');
                            });
};

HtmlfileReceiver.prototype = new REventTarget();

HtmlfileReceiver.prototype.abort = function() {
    var that = this;
    if (that.iframe_close) {
        that.iframe_close({}, 'user');
    }
};
//         [*] End of lib/trans-receiver-htmlfile.js


//         [*] Including lib/trans-receiver-xhr.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

var XhrReceiver = function(url, AjaxObject) {
    var that = this;
    var buf_pos = 0;

    that.xo = new AjaxObject('POST', url, null);
    that.xo.onchunk = function(status, text) {
        if (status !== 200) return;
        while (1) {
            var buf = text.slice(buf_pos);
            var p = buf.indexOf('\n');
            if (p === -1) break;
            buf_pos += p+1;
            var msg = buf.slice(0, p);
            that.dispatchEvent(new SimpleEvent('message', {data: msg}));
        }
    };
    that.xo.onfinish = function(status, text) {
        that.xo.onchunk(status, text);
        that.xo = null;
        var reason = status === 200 ? 'network' : 'permanent';
        that.dispatchEvent(new SimpleEvent('close', {reason: reason}));
    }
};

XhrReceiver.prototype = new REventTarget();

XhrReceiver.prototype.abort = function() {
    var that = this;
    if (that.xo) {
        that.xo.close();
        that.dispatchEvent(new SimpleEvent('close', {reason: 'user'}));
        that.xo = null;
    }
};
//         [*] End of lib/trans-receiver-xhr.js


//         [*] Including lib/test-hooks.js
/*
 * ***** BEGIN LICENSE BLOCK *****
 * Copyright (c) 2011-2012 VMware, Inc.
 *
 * For the license see COPYING.
 * ***** END LICENSE BLOCK *****
 */

// For testing
SockJS.getUtils = function(){
    return utils;
};

SockJS.getIframeTransport = function(){
    return IframeTransport;
};
//         [*] End of lib/test-hooks.js

                  return SockJS;
          })();
if ('_sockjs_onload' in window) setTimeout(_sockjs_onload, 1);

// AMD compliance
if (typeof define === 'function' && define.amd) {
    define('sockjs', [], function(){return SockJS;});
}

if (typeof module === 'object' && module && module.exports) {
    module.exports = SockJS;
}
//     [*] End of lib/index.js

// [*] End of lib/all.js


},{}],80:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

module.exports = Stream;

var EE = require('events').EventEmitter;
var inherits = require('inherits');

inherits(Stream, EE);
Stream.Readable = require('readable-stream/readable.js');
Stream.Writable = require('readable-stream/writable.js');
Stream.Duplex = require('readable-stream/duplex.js');
Stream.Transform = require('readable-stream/transform.js');
Stream.PassThrough = require('readable-stream/passthrough.js');

// Backwards-compat with node 0.4.x
Stream.Stream = Stream;



// old-style streams.  Note that the pipe method (the only relevant
// part of this class) is overridden in the Readable class.

function Stream() {
  EE.call(this);
}

Stream.prototype.pipe = function(dest, options) {
  var source = this;

  function ondata(chunk) {
    if (dest.writable) {
      if (false === dest.write(chunk) && source.pause) {
        source.pause();
      }
    }
  }

  source.on('data', ondata);

  function ondrain() {
    if (source.readable && source.resume) {
      source.resume();
    }
  }

  dest.on('drain', ondrain);

  // If the 'end' option is not supplied, dest.end() will be called when
  // source gets the 'end' or 'close' events.  Only dest.end() once.
  if (!dest._isStdio && (!options || options.end !== false)) {
    source.on('end', onend);
    source.on('close', onclose);
  }

  var didOnEnd = false;
  function onend() {
    if (didOnEnd) return;
    didOnEnd = true;

    dest.end();
  }


  function onclose() {
    if (didOnEnd) return;
    didOnEnd = true;

    if (typeof dest.destroy === 'function') dest.destroy();
  }

  // don't leave dangling pipes when there are errors.
  function onerror(er) {
    cleanup();
    if (EE.listenerCount(this, 'error') === 0) {
      throw er; // Unhandled stream error in pipe.
    }
  }

  source.on('error', onerror);
  dest.on('error', onerror);

  // remove all the event listeners that were added.
  function cleanup() {
    source.removeListener('data', ondata);
    dest.removeListener('drain', ondrain);

    source.removeListener('end', onend);
    source.removeListener('close', onclose);

    source.removeListener('error', onerror);
    dest.removeListener('error', onerror);

    source.removeListener('end', cleanup);
    source.removeListener('close', cleanup);

    dest.removeListener('close', cleanup);
  }

  source.on('end', cleanup);
  source.on('close', cleanup);

  dest.on('close', cleanup);

  dest.emit('pipe', source);

  // Allow for unix-like usage: A.pipe(B).pipe(C)
  return dest;
};

},{"events":64,"inherits":66,"readable-stream/duplex.js":82,"readable-stream/passthrough.js":91,"readable-stream/readable.js":92,"readable-stream/transform.js":93,"readable-stream/writable.js":94}],81:[function(require,module,exports){
var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};

},{}],82:[function(require,module,exports){
module.exports = require('./lib/_stream_duplex.js');

},{"./lib/_stream_duplex.js":83}],83:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a duplex stream is just a stream that is both readable and writable.
// Since JS doesn't have multiple prototypal inheritance, this class
// prototypally inherits from Readable, and then parasitically from
// Writable.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

/*<replacement>*/
var objectKeys = Object.keys || function (obj) {
  var keys = [];
  for (var key in obj) {
    keys.push(key);
  }return keys;
};
/*</replacement>*/

module.exports = Duplex;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

var Readable = require('./_stream_readable');
var Writable = require('./_stream_writable');

util.inherits(Duplex, Readable);

var keys = objectKeys(Writable.prototype);
for (var v = 0; v < keys.length; v++) {
  var method = keys[v];
  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
}

function Duplex(options) {
  if (!(this instanceof Duplex)) return new Duplex(options);

  Readable.call(this, options);
  Writable.call(this, options);

  if (options && options.readable === false) this.readable = false;

  if (options && options.writable === false) this.writable = false;

  this.allowHalfOpen = true;
  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;

  this.once('end', onend);
}

// the no-half-open enforcer
function onend() {
  // if we allow half-open state, or if the writable side ended,
  // then we're ok.
  if (this.allowHalfOpen || this._writableState.ended) return;

  // no more data can be written.
  // But allow more writes to happen in this tick.
  processNextTick(onEndNT, this);
}

function onEndNT(self) {
  self.end();
}

Object.defineProperty(Duplex.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined || this._writableState === undefined) {
      return false;
    }
    return this._readableState.destroyed && this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (this._readableState === undefined || this._writableState === undefined) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
    this._writableState.destroyed = value;
  }
});

Duplex.prototype._destroy = function (err, cb) {
  this.push(null);
  this.end();

  processNextTick(cb, err);
};

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}
},{"./_stream_readable":85,"./_stream_writable":87,"core-util-is":55,"inherits":66,"process-nextick-args":71}],84:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a passthrough stream.
// basically just the most minimal sort of Transform stream.
// Every written chunk gets output as-is.

'use strict';

module.exports = PassThrough;

var Transform = require('./_stream_transform');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(PassThrough, Transform);

function PassThrough(options) {
  if (!(this instanceof PassThrough)) return new PassThrough(options);

  Transform.call(this, options);
}

PassThrough.prototype._transform = function (chunk, encoding, cb) {
  cb(null, chunk);
};
},{"./_stream_transform":86,"core-util-is":55,"inherits":66}],85:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Readable;

/*<replacement>*/
var isArray = require('isarray');
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Readable.ReadableState = ReadableState;

/*<replacement>*/
var EE = require('events').EventEmitter;

var EElistenerCount = function (emitter, type) {
  return emitter.listeners(type).length;
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

// TODO(bmeurer): Change this back to const once hole checks are
// properly optimized away early in Ignition+TurboFan.
/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var debugUtil = require('util');
var debug = void 0;
if (debugUtil && debugUtil.debuglog) {
  debug = debugUtil.debuglog('stream');
} else {
  debug = function () {};
}
/*</replacement>*/

var BufferList = require('./internal/streams/BufferList');
var destroyImpl = require('./internal/streams/destroy');
var StringDecoder;

util.inherits(Readable, Stream);

var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];

function prependListener(emitter, event, fn) {
  // Sadly this is not cacheable as some libraries bundle their own
  // event emitter implementation with them.
  if (typeof emitter.prependListener === 'function') {
    return emitter.prependListener(event, fn);
  } else {
    // This is a hack to make sure that our error handler is attached before any
    // userland ones.  NEVER DO THIS. This is here only because this code needs
    // to continue to work with older versions of Node.js that do not include
    // the prependListener() method. The goal is to eventually remove this hack.
    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
  }
}

function ReadableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag. Used to make read(n) ignore n and to
  // make all the buffer merging and length checks go away
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;

  // the point at which it stops calling _read() to fill the buffer
  // Note: 0 is a valid value, means "don't call _read preemptively ever"
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // A linked list is used to store data chunks instead of an array because the
  // linked list can remove elements from the beginning faster than
  // array.shift()
  this.buffer = new BufferList();
  this.length = 0;
  this.pipes = null;
  this.pipesCount = 0;
  this.flowing = null;
  this.ended = false;
  this.endEmitted = false;
  this.reading = false;

  // a flag to be able to tell if the event 'readable'/'data' is emitted
  // immediately, or on a later tick.  We set this to true at first, because
  // any actions that shouldn't happen until "later" should generally also
  // not happen before the first read call.
  this.sync = true;

  // whenever we return null, then we set a flag to say
  // that we're awaiting a 'readable' event emission.
  this.needReadable = false;
  this.emittedReadable = false;
  this.readableListening = false;
  this.resumeScheduled = false;

  // has it been destroyed
  this.destroyed = false;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // the number of writers that are awaiting a drain event in .pipe()s
  this.awaitDrain = 0;

  // if true, a maybeReadMore has been scheduled
  this.readingMore = false;

  this.decoder = null;
  this.encoding = null;
  if (options.encoding) {
    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
    this.decoder = new StringDecoder(options.encoding);
    this.encoding = options.encoding;
  }
}

function Readable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  if (!(this instanceof Readable)) return new Readable(options);

  this._readableState = new ReadableState(options, this);

  // legacy
  this.readable = true;

  if (options) {
    if (typeof options.read === 'function') this._read = options.read;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;
  }

  Stream.call(this);
}

Object.defineProperty(Readable.prototype, 'destroyed', {
  get: function () {
    if (this._readableState === undefined) {
      return false;
    }
    return this._readableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._readableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._readableState.destroyed = value;
  }
});

Readable.prototype.destroy = destroyImpl.destroy;
Readable.prototype._undestroy = destroyImpl.undestroy;
Readable.prototype._destroy = function (err, cb) {
  this.push(null);
  cb(err);
};

// Manually shove something into the read() buffer.
// This returns true if the highWaterMark has not been hit yet,
// similar to how Writable.write() returns true if you should
// write() some more.
Readable.prototype.push = function (chunk, encoding) {
  var state = this._readableState;
  var skipChunkCheck;

  if (!state.objectMode) {
    if (typeof chunk === 'string') {
      encoding = encoding || state.defaultEncoding;
      if (encoding !== state.encoding) {
        chunk = Buffer.from(chunk, encoding);
        encoding = '';
      }
      skipChunkCheck = true;
    }
  } else {
    skipChunkCheck = true;
  }

  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
};

// Unshift should *always* be something directly out of read()
Readable.prototype.unshift = function (chunk) {
  return readableAddChunk(this, chunk, null, true, false);
};

function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
  var state = stream._readableState;
  if (chunk === null) {
    state.reading = false;
    onEofChunk(stream, state);
  } else {
    var er;
    if (!skipChunkCheck) er = chunkInvalid(state, chunk);
    if (er) {
      stream.emit('error', er);
    } else if (state.objectMode || chunk && chunk.length > 0) {
      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
        chunk = _uint8ArrayToBuffer(chunk);
      }

      if (addToFront) {
        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
      } else if (state.ended) {
        stream.emit('error', new Error('stream.push() after EOF'));
      } else {
        state.reading = false;
        if (state.decoder && !encoding) {
          chunk = state.decoder.write(chunk);
          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
        } else {
          addChunk(stream, state, chunk, false);
        }
      }
    } else if (!addToFront) {
      state.reading = false;
    }
  }

  return needMoreData(state);
}

function addChunk(stream, state, chunk, addToFront) {
  if (state.flowing && state.length === 0 && !state.sync) {
    stream.emit('data', chunk);
    stream.read(0);
  } else {
    // update the buffer info.
    state.length += state.objectMode ? 1 : chunk.length;
    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);

    if (state.needReadable) emitReadable(stream);
  }
  maybeReadMore(stream, state);
}

function chunkInvalid(state, chunk) {
  var er;
  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  return er;
}

// if it's past the high water mark, we can push in some more.
// Also, if we have no data yet, we can stand some
// more bytes.  This is to work around cases where hwm=0,
// such as the repl.  Also, if the push() triggered a
// readable event, and the user called read(largeNumber) such that
// needReadable was set, then we ought to push more, so that another
// 'readable' event will be triggered.
function needMoreData(state) {
  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
}

Readable.prototype.isPaused = function () {
  return this._readableState.flowing === false;
};

// backwards compatibility.
Readable.prototype.setEncoding = function (enc) {
  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;
  this._readableState.decoder = new StringDecoder(enc);
  this._readableState.encoding = enc;
  return this;
};

// Don't raise the hwm > 8MB
var MAX_HWM = 0x800000;
function computeNewHighWaterMark(n) {
  if (n >= MAX_HWM) {
    n = MAX_HWM;
  } else {
    // Get the next highest power of 2 to prevent increasing hwm excessively in
    // tiny amounts
    n--;
    n |= n >>> 1;
    n |= n >>> 2;
    n |= n >>> 4;
    n |= n >>> 8;
    n |= n >>> 16;
    n++;
  }
  return n;
}

// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function howMuchToRead(n, state) {
  if (n <= 0 || state.length === 0 && state.ended) return 0;
  if (state.objectMode) return 1;
  if (n !== n) {
    // Only flow one buffer at a time
    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
  }
  // If we're asking for more than the current hwm, then raise the hwm.
  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
  if (n <= state.length) return n;
  // Don't have enough
  if (!state.ended) {
    state.needReadable = true;
    return 0;
  }
  return state.length;
}

// you can override either this method, or the async _read(n) below.
Readable.prototype.read = function (n) {
  debug('read', n);
  n = parseInt(n, 10);
  var state = this._readableState;
  var nOrig = n;

  if (n !== 0) state.emittedReadable = false;

  // if we're doing read(0) to trigger a readable event, but we
  // already have a bunch of data in the buffer, then just trigger
  // the 'readable' event and move on.
  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
    debug('read: emitReadable', state.length, state.ended);
    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
    return null;
  }

  n = howMuchToRead(n, state);

  // if we've ended, and we're now clear, then finish it up.
  if (n === 0 && state.ended) {
    if (state.length === 0) endReadable(this);
    return null;
  }

  // All the actual chunk generation logic needs to be
  // *below* the call to _read.  The reason is that in certain
  // synthetic stream cases, such as passthrough streams, _read
  // may be a completely synchronous operation which may change
  // the state of the read buffer, providing enough data when
  // before there was *not* enough.
  //
  // So, the steps are:
  // 1. Figure out what the state of things will be after we do
  // a read from the buffer.
  //
  // 2. If that resulting state will trigger a _read, then call _read.
  // Note that this may be asynchronous, or synchronous.  Yes, it is
  // deeply ugly to write APIs this way, but that still doesn't mean
  // that the Readable class should behave improperly, as streams are
  // designed to be sync/async agnostic.
  // Take note if the _read call is sync or async (ie, if the read call
  // has returned yet), so that we know whether or not it's safe to emit
  // 'readable' etc.
  //
  // 3. Actually pull the requested chunks out of the buffer and return.

  // if we need a readable event, then we need to do some reading.
  var doRead = state.needReadable;
  debug('need readable', doRead);

  // if we currently have less than the highWaterMark, then also read some
  if (state.length === 0 || state.length - n < state.highWaterMark) {
    doRead = true;
    debug('length less than watermark', doRead);
  }

  // however, if we've ended, then there's no point, and if we're already
  // reading, then it's unnecessary.
  if (state.ended || state.reading) {
    doRead = false;
    debug('reading or ended', doRead);
  } else if (doRead) {
    debug('do read');
    state.reading = true;
    state.sync = true;
    // if the length is currently zero, then we *need* a readable event.
    if (state.length === 0) state.needReadable = true;
    // call internal read method
    this._read(state.highWaterMark);
    state.sync = false;
    // If _read pushed data synchronously, then `reading` will be false,
    // and we need to re-evaluate how much data we can return to the user.
    if (!state.reading) n = howMuchToRead(nOrig, state);
  }

  var ret;
  if (n > 0) ret = fromList(n, state);else ret = null;

  if (ret === null) {
    state.needReadable = true;
    n = 0;
  } else {
    state.length -= n;
  }

  if (state.length === 0) {
    // If we have nothing in the buffer, then we want to know
    // as soon as we *do* get something into the buffer.
    if (!state.ended) state.needReadable = true;

    // If we tried to read() past the EOF, then emit end on the next tick.
    if (nOrig !== n && state.ended) endReadable(this);
  }

  if (ret !== null) this.emit('data', ret);

  return ret;
};

function onEofChunk(stream, state) {
  if (state.ended) return;
  if (state.decoder) {
    var chunk = state.decoder.end();
    if (chunk && chunk.length) {
      state.buffer.push(chunk);
      state.length += state.objectMode ? 1 : chunk.length;
    }
  }
  state.ended = true;

  // emit 'readable' now to make sure it gets picked up.
  emitReadable(stream);
}

// Don't emit readable right away in sync mode, because this can trigger
// another read() call => stack overflow.  This way, it might trigger
// a nextTick recursion warning, but that's not so bad.
function emitReadable(stream) {
  var state = stream._readableState;
  state.needReadable = false;
  if (!state.emittedReadable) {
    debug('emitReadable', state.flowing);
    state.emittedReadable = true;
    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);
  }
}

function emitReadable_(stream) {
  debug('emit readable');
  stream.emit('readable');
  flow(stream);
}

// at this point, the user has presumably seen the 'readable' event,
// and called read() to consume some data.  that may have triggered
// in turn another _read(n) call, in which case reading = true if
// it's in progress.
// However, if we're not ended, or reading, and the length < hwm,
// then go ahead and try to read some more preemptively.
function maybeReadMore(stream, state) {
  if (!state.readingMore) {
    state.readingMore = true;
    processNextTick(maybeReadMore_, stream, state);
  }
}

function maybeReadMore_(stream, state) {
  var len = state.length;
  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
    debug('maybeReadMore read 0');
    stream.read(0);
    if (len === state.length)
      // didn't get any data, stop spinning.
      break;else len = state.length;
  }
  state.readingMore = false;
}

// abstract method.  to be overridden in specific implementation classes.
// call cb(er, data) where data is <= n in length.
// for virtual (non-string, non-buffer) streams, "length" is somewhat
// arbitrary, and perhaps not very meaningful.
Readable.prototype._read = function (n) {
  this.emit('error', new Error('_read() is not implemented'));
};

Readable.prototype.pipe = function (dest, pipeOpts) {
  var src = this;
  var state = this._readableState;

  switch (state.pipesCount) {
    case 0:
      state.pipes = dest;
      break;
    case 1:
      state.pipes = [state.pipes, dest];
      break;
    default:
      state.pipes.push(dest);
      break;
  }
  state.pipesCount += 1;
  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);

  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;

  var endFn = doEnd ? onend : unpipe;
  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);

  dest.on('unpipe', onunpipe);
  function onunpipe(readable, unpipeInfo) {
    debug('onunpipe');
    if (readable === src) {
      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
        unpipeInfo.hasUnpiped = true;
        cleanup();
      }
    }
  }

  function onend() {
    debug('onend');
    dest.end();
  }

  // when the dest drains, it reduces the awaitDrain counter
  // on the source.  This would be more elegant with a .once()
  // handler in flow(), but adding and removing repeatedly is
  // too slow.
  var ondrain = pipeOnDrain(src);
  dest.on('drain', ondrain);

  var cleanedUp = false;
  function cleanup() {
    debug('cleanup');
    // cleanup event handlers once the pipe is broken
    dest.removeListener('close', onclose);
    dest.removeListener('finish', onfinish);
    dest.removeListener('drain', ondrain);
    dest.removeListener('error', onerror);
    dest.removeListener('unpipe', onunpipe);
    src.removeListener('end', onend);
    src.removeListener('end', unpipe);
    src.removeListener('data', ondata);

    cleanedUp = true;

    // if the reader is waiting for a drain event from this
    // specific writer, then it would cause it to never start
    // flowing again.
    // So, if this is awaiting a drain, then we just call it now.
    // If we don't know, then assume that we are waiting for one.
    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
  }

  // If the user pushes more data while we're writing to dest then we'll end up
  // in ondata again. However, we only want to increase awaitDrain once because
  // dest will only emit one 'drain' event for the multiple writes.
  // => Introduce a guard on increasing awaitDrain.
  var increasedAwaitDrain = false;
  src.on('data', ondata);
  function ondata(chunk) {
    debug('ondata');
    increasedAwaitDrain = false;
    var ret = dest.write(chunk);
    if (false === ret && !increasedAwaitDrain) {
      // If the user unpiped during `dest.write()`, it is possible
      // to get stuck in a permanently paused state if that write
      // also returned false.
      // => Check whether `dest` is still a piping destination.
      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
        debug('false write response, pause', src._readableState.awaitDrain);
        src._readableState.awaitDrain++;
        increasedAwaitDrain = true;
      }
      src.pause();
    }
  }

  // if the dest has an error, then stop piping into it.
  // however, don't suppress the throwing behavior for this.
  function onerror(er) {
    debug('onerror', er);
    unpipe();
    dest.removeListener('error', onerror);
    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
  }

  // Make sure our error handler is attached before userland ones.
  prependListener(dest, 'error', onerror);

  // Both close and finish should trigger unpipe, but only once.
  function onclose() {
    dest.removeListener('finish', onfinish);
    unpipe();
  }
  dest.once('close', onclose);
  function onfinish() {
    debug('onfinish');
    dest.removeListener('close', onclose);
    unpipe();
  }
  dest.once('finish', onfinish);

  function unpipe() {
    debug('unpipe');
    src.unpipe(dest);
  }

  // tell the dest that it's being piped to
  dest.emit('pipe', src);

  // start the flow if it hasn't been started already.
  if (!state.flowing) {
    debug('pipe resume');
    src.resume();
  }

  return dest;
};

function pipeOnDrain(src) {
  return function () {
    var state = src._readableState;
    debug('pipeOnDrain', state.awaitDrain);
    if (state.awaitDrain) state.awaitDrain--;
    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
      state.flowing = true;
      flow(src);
    }
  };
}

Readable.prototype.unpipe = function (dest) {
  var state = this._readableState;
  var unpipeInfo = { hasUnpiped: false };

  // if we're not piping anywhere, then do nothing.
  if (state.pipesCount === 0) return this;

  // just one destination.  most common case.
  if (state.pipesCount === 1) {
    // passed in one, but it's not the right one.
    if (dest && dest !== state.pipes) return this;

    if (!dest) dest = state.pipes;

    // got a match.
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;
    if (dest) dest.emit('unpipe', this, unpipeInfo);
    return this;
  }

  // slow case. multiple pipe destinations.

  if (!dest) {
    // remove all.
    var dests = state.pipes;
    var len = state.pipesCount;
    state.pipes = null;
    state.pipesCount = 0;
    state.flowing = false;

    for (var i = 0; i < len; i++) {
      dests[i].emit('unpipe', this, unpipeInfo);
    }return this;
  }

  // try to find the right one.
  var index = indexOf(state.pipes, dest);
  if (index === -1) return this;

  state.pipes.splice(index, 1);
  state.pipesCount -= 1;
  if (state.pipesCount === 1) state.pipes = state.pipes[0];

  dest.emit('unpipe', this, unpipeInfo);

  return this;
};

// set up data events if they are asked for
// Ensure readable listeners eventually get something
Readable.prototype.on = function (ev, fn) {
  var res = Stream.prototype.on.call(this, ev, fn);

  if (ev === 'data') {
    // Start flowing on next tick if stream isn't explicitly paused
    if (this._readableState.flowing !== false) this.resume();
  } else if (ev === 'readable') {
    var state = this._readableState;
    if (!state.endEmitted && !state.readableListening) {
      state.readableListening = state.needReadable = true;
      state.emittedReadable = false;
      if (!state.reading) {
        processNextTick(nReadingNextTick, this);
      } else if (state.length) {
        emitReadable(this);
      }
    }
  }

  return res;
};
Readable.prototype.addListener = Readable.prototype.on;

function nReadingNextTick(self) {
  debug('readable nexttick read 0');
  self.read(0);
}

// pause() and resume() are remnants of the legacy readable stream API
// If the user uses them, then switch into old mode.
Readable.prototype.resume = function () {
  var state = this._readableState;
  if (!state.flowing) {
    debug('resume');
    state.flowing = true;
    resume(this, state);
  }
  return this;
};

function resume(stream, state) {
  if (!state.resumeScheduled) {
    state.resumeScheduled = true;
    processNextTick(resume_, stream, state);
  }
}

function resume_(stream, state) {
  if (!state.reading) {
    debug('resume read 0');
    stream.read(0);
  }

  state.resumeScheduled = false;
  state.awaitDrain = 0;
  stream.emit('resume');
  flow(stream);
  if (state.flowing && !state.reading) stream.read(0);
}

Readable.prototype.pause = function () {
  debug('call pause flowing=%j', this._readableState.flowing);
  if (false !== this._readableState.flowing) {
    debug('pause');
    this._readableState.flowing = false;
    this.emit('pause');
  }
  return this;
};

function flow(stream) {
  var state = stream._readableState;
  debug('flow', state.flowing);
  while (state.flowing && stream.read() !== null) {}
}

// wrap an old-style stream as the async data source.
// This is *not* part of the readable stream interface.
// It is an ugly unfortunate mess of history.
Readable.prototype.wrap = function (stream) {
  var state = this._readableState;
  var paused = false;

  var self = this;
  stream.on('end', function () {
    debug('wrapped end');
    if (state.decoder && !state.ended) {
      var chunk = state.decoder.end();
      if (chunk && chunk.length) self.push(chunk);
    }

    self.push(null);
  });

  stream.on('data', function (chunk) {
    debug('wrapped data');
    if (state.decoder) chunk = state.decoder.write(chunk);

    // don't skip over falsy values in objectMode
    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;

    var ret = self.push(chunk);
    if (!ret) {
      paused = true;
      stream.pause();
    }
  });

  // proxy all the other methods.
  // important when wrapping filters and duplexes.
  for (var i in stream) {
    if (this[i] === undefined && typeof stream[i] === 'function') {
      this[i] = function (method) {
        return function () {
          return stream[method].apply(stream, arguments);
        };
      }(i);
    }
  }

  // proxy certain important events.
  for (var n = 0; n < kProxyEvents.length; n++) {
    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));
  }

  // when we try to consume some more bytes, simply unpause the
  // underlying stream.
  self._read = function (n) {
    debug('wrapped _read', n);
    if (paused) {
      paused = false;
      stream.resume();
    }
  };

  return self;
};

// exposed for testing purposes only.
Readable._fromList = fromList;

// Pluck off n bytes from an array of buffers.
// Length is the combined lengths of all the buffers in the list.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromList(n, state) {
  // nothing buffered
  if (state.length === 0) return null;

  var ret;
  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
    // read it all, truncate the list
    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
    state.buffer.clear();
  } else {
    // read part of list
    ret = fromListPartial(n, state.buffer, state.decoder);
  }

  return ret;
}

// Extracts only enough buffered data to satisfy the amount requested.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function fromListPartial(n, list, hasStrings) {
  var ret;
  if (n < list.head.data.length) {
    // slice is the same for buffers and strings
    ret = list.head.data.slice(0, n);
    list.head.data = list.head.data.slice(n);
  } else if (n === list.head.data.length) {
    // first chunk is a perfect match
    ret = list.shift();
  } else {
    // result spans more than one buffer
    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
  }
  return ret;
}

// Copies a specified amount of characters from the list of buffered data
// chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBufferString(n, list) {
  var p = list.head;
  var c = 1;
  var ret = p.data;
  n -= ret.length;
  while (p = p.next) {
    var str = p.data;
    var nb = n > str.length ? str.length : n;
    if (nb === str.length) ret += str;else ret += str.slice(0, n);
    n -= nb;
    if (n === 0) {
      if (nb === str.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = str.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

// Copies a specified amount of bytes from the list of buffered data chunks.
// This function is designed to be inlinable, so please take care when making
// changes to the function body.
function copyFromBuffer(n, list) {
  var ret = Buffer.allocUnsafe(n);
  var p = list.head;
  var c = 1;
  p.data.copy(ret);
  n -= p.data.length;
  while (p = p.next) {
    var buf = p.data;
    var nb = n > buf.length ? buf.length : n;
    buf.copy(ret, ret.length - n, 0, nb);
    n -= nb;
    if (n === 0) {
      if (nb === buf.length) {
        ++c;
        if (p.next) list.head = p.next;else list.head = list.tail = null;
      } else {
        list.head = p;
        p.data = buf.slice(nb);
      }
      break;
    }
    ++c;
  }
  list.length -= c;
  return ret;
}

function endReadable(stream) {
  var state = stream._readableState;

  // If we get here before consuming all the bytes, then that is a
  // bug in node.  Should never happen.
  if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');

  if (!state.endEmitted) {
    state.ended = true;
    processNextTick(endReadableNT, state, stream);
  }
}

function endReadableNT(state, stream) {
  // Check that we didn't get one last unshift.
  if (!state.endEmitted && state.length === 0) {
    state.endEmitted = true;
    stream.readable = false;
    stream.emit('end');
  }
}

function forEach(xs, f) {
  for (var i = 0, l = xs.length; i < l; i++) {
    f(xs[i], i);
  }
}

function indexOf(xs, x) {
  for (var i = 0, l = xs.length; i < l; i++) {
    if (xs[i] === x) return i;
  }
  return -1;
}
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":83,"./internal/streams/BufferList":88,"./internal/streams/destroy":89,"./internal/streams/stream":90,"_process":72,"core-util-is":55,"events":64,"inherits":66,"isarray":81,"process-nextick-args":71,"safe-buffer":77,"string_decoder/":95,"util":47}],86:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// a transform stream is a readable/writable stream where you do
// something with the data.  Sometimes it's called a "filter",
// but that's not a great name for it, since that implies a thing where
// some bits pass through, and others are simply ignored.  (That would
// be a valid example of a transform, of course.)
//
// While the output is causally related to the input, it's not a
// necessarily symmetric or synchronous transformation.  For example,
// a zlib stream might take multiple plain-text writes(), and then
// emit a single compressed chunk some time in the future.
//
// Here's how this works:
//
// The Transform stream has all the aspects of the readable and writable
// stream classes.  When you write(chunk), that calls _write(chunk,cb)
// internally, and returns false if there's a lot of pending writes
// buffered up.  When you call read(), that calls _read(n) until
// there's enough pending readable data buffered up.
//
// In a transform stream, the written data is placed in a buffer.  When
// _read(n) is called, it transforms the queued up data, calling the
// buffered _write cb's as it consumes chunks.  If consuming a single
// written chunk would result in multiple output chunks, then the first
// outputted bit calls the readcb, and subsequent chunks just go into
// the read buffer, and will cause it to emit 'readable' if necessary.
//
// This way, back-pressure is actually determined by the reading side,
// since _read has to be called to start processing a new chunk.  However,
// a pathological inflate type of transform can cause excessive buffering
// here.  For example, imagine a stream where every byte of input is
// interpreted as an integer from 0-255, and then results in that many
// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
// 1kb of data being output.  In this case, you could write a very small
// amount of input, and end up with a very large amount of output.  In
// such a pathological inflating mechanism, there'd be no way to tell
// the system to stop doing the transform.  A single 4MB write could
// cause the system to run out of memory.
//
// However, even in such a pathological case, only a single written chunk
// would be consumed, and then the rest would wait (un-transformed) until
// the results of the previous transformed chunk were consumed.

'use strict';

module.exports = Transform;

var Duplex = require('./_stream_duplex');

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

util.inherits(Transform, Duplex);

function TransformState(stream) {
  this.afterTransform = function (er, data) {
    return afterTransform(stream, er, data);
  };

  this.needTransform = false;
  this.transforming = false;
  this.writecb = null;
  this.writechunk = null;
  this.writeencoding = null;
}

function afterTransform(stream, er, data) {
  var ts = stream._transformState;
  ts.transforming = false;

  var cb = ts.writecb;

  if (!cb) {
    return stream.emit('error', new Error('write callback called multiple times'));
  }

  ts.writechunk = null;
  ts.writecb = null;

  if (data !== null && data !== undefined) stream.push(data);

  cb(er);

  var rs = stream._readableState;
  rs.reading = false;
  if (rs.needReadable || rs.length < rs.highWaterMark) {
    stream._read(rs.highWaterMark);
  }
}

function Transform(options) {
  if (!(this instanceof Transform)) return new Transform(options);

  Duplex.call(this, options);

  this._transformState = new TransformState(this);

  var stream = this;

  // start out asking for a readable event once data is transformed.
  this._readableState.needReadable = true;

  // we have implemented the _read method, and done the other things
  // that Readable wants before the first _read call, so unset the
  // sync guard flag.
  this._readableState.sync = false;

  if (options) {
    if (typeof options.transform === 'function') this._transform = options.transform;

    if (typeof options.flush === 'function') this._flush = options.flush;
  }

  // When the writable side finishes, then flush out anything remaining.
  this.once('prefinish', function () {
    if (typeof this._flush === 'function') this._flush(function (er, data) {
      done(stream, er, data);
    });else done(stream);
  });
}

Transform.prototype.push = function (chunk, encoding) {
  this._transformState.needTransform = false;
  return Duplex.prototype.push.call(this, chunk, encoding);
};

// This is the part where you do stuff!
// override this function in implementation classes.
// 'chunk' is an input chunk.
//
// Call `push(newChunk)` to pass along transformed output
// to the readable side.  You may call 'push' zero or more times.
//
// Call `cb(err)` when you are done with this chunk.  If you pass
// an error, then that'll put the hurt on the whole operation.  If you
// never call cb(), then you'll never get another chunk.
Transform.prototype._transform = function (chunk, encoding, cb) {
  throw new Error('_transform() is not implemented');
};

Transform.prototype._write = function (chunk, encoding, cb) {
  var ts = this._transformState;
  ts.writecb = cb;
  ts.writechunk = chunk;
  ts.writeencoding = encoding;
  if (!ts.transforming) {
    var rs = this._readableState;
    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
  }
};

// Doesn't matter what the args are here.
// _transform does all the work.
// That we got here means that the readable side wants more data.
Transform.prototype._read = function (n) {
  var ts = this._transformState;

  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
    ts.transforming = true;
    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
  } else {
    // mark that we need a transform, so that any data that comes in
    // will get processed, now that we've asked for it.
    ts.needTransform = true;
  }
};

Transform.prototype._destroy = function (err, cb) {
  var _this = this;

  Duplex.prototype._destroy.call(this, err, function (err2) {
    cb(err2);
    _this.emit('close');
  });
};

function done(stream, er, data) {
  if (er) return stream.emit('error', er);

  if (data !== null && data !== undefined) stream.push(data);

  // if there's nothing in the write buffer, then that means
  // that nothing more will ever be provided
  var ws = stream._writableState;
  var ts = stream._transformState;

  if (ws.length) throw new Error('Calling transform done when ws.length != 0');

  if (ts.transforming) throw new Error('Calling transform done when still transforming');

  return stream.push(null);
}
},{"./_stream_duplex":83,"core-util-is":55,"inherits":66}],87:[function(require,module,exports){
(function (process,global){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// A bit simpler than readable streams.
// Implement an async ._write(chunk, encoding, cb), and it'll handle all
// the drain event emission and buffering.

'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

module.exports = Writable;

/* <replacement> */
function WriteReq(chunk, encoding, cb) {
  this.chunk = chunk;
  this.encoding = encoding;
  this.callback = cb;
  this.next = null;
}

// It seems a linked list but it is not
// there will be only 2 of these for each stream
function CorkedRequest(state) {
  var _this = this;

  this.next = null;
  this.entry = null;
  this.finish = function () {
    onCorkedFinish(_this, state);
  };
}
/* </replacement> */

/*<replacement>*/
var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;
/*</replacement>*/

/*<replacement>*/
var Duplex;
/*</replacement>*/

Writable.WritableState = WritableState;

/*<replacement>*/
var util = require('core-util-is');
util.inherits = require('inherits');
/*</replacement>*/

/*<replacement>*/
var internalUtil = {
  deprecate: require('util-deprecate')
};
/*</replacement>*/

/*<replacement>*/
var Stream = require('./internal/streams/stream');
/*</replacement>*/

/*<replacement>*/
var Buffer = require('safe-buffer').Buffer;
var OurUint8Array = global.Uint8Array || function () {};
function _uint8ArrayToBuffer(chunk) {
  return Buffer.from(chunk);
}
function _isUint8Array(obj) {
  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
}
/*</replacement>*/

var destroyImpl = require('./internal/streams/destroy');

util.inherits(Writable, Stream);

function nop() {}

function WritableState(options, stream) {
  Duplex = Duplex || require('./_stream_duplex');

  options = options || {};

  // object stream flag to indicate whether or not this stream
  // contains buffers or objects.
  this.objectMode = !!options.objectMode;

  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;

  // the point at which write() starts returning false
  // Note: 0 is a valid value, means that we always return false if
  // the entire buffer is not flushed immediately on write()
  var hwm = options.highWaterMark;
  var defaultHwm = this.objectMode ? 16 : 16 * 1024;
  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;

  // cast to ints.
  this.highWaterMark = Math.floor(this.highWaterMark);

  // if _final has been called
  this.finalCalled = false;

  // drain event flag.
  this.needDrain = false;
  // at the start of calling end()
  this.ending = false;
  // when end() has been called, and returned
  this.ended = false;
  // when 'finish' is emitted
  this.finished = false;

  // has it been destroyed
  this.destroyed = false;

  // should we decode strings into buffers before passing to _write?
  // this is here so that some node-core streams can optimize string
  // handling at a lower level.
  var noDecode = options.decodeStrings === false;
  this.decodeStrings = !noDecode;

  // Crypto is kind of old and crusty.  Historically, its default string
  // encoding is 'binary' so we have to make this configurable.
  // Everything else in the universe uses 'utf8', though.
  this.defaultEncoding = options.defaultEncoding || 'utf8';

  // not an actual buffer we keep track of, but a measurement
  // of how much we're waiting to get pushed to some underlying
  // socket or file.
  this.length = 0;

  // a flag to see when we're in the middle of a write.
  this.writing = false;

  // when true all writes will be buffered until .uncork() call
  this.corked = 0;

  // a flag to be able to tell if the onwrite cb is called immediately,
  // or on a later tick.  We set this to true at first, because any
  // actions that shouldn't happen until "later" should generally also
  // not happen before the first write call.
  this.sync = true;

  // a flag to know if we're processing previously buffered items, which
  // may call the _write() callback in the same tick, so that we don't
  // end up in an overlapped onwrite situation.
  this.bufferProcessing = false;

  // the callback that's passed to _write(chunk,cb)
  this.onwrite = function (er) {
    onwrite(stream, er);
  };

  // the callback that the user supplies to write(chunk,encoding,cb)
  this.writecb = null;

  // the amount that is being written when _write is called.
  this.writelen = 0;

  this.bufferedRequest = null;
  this.lastBufferedRequest = null;

  // number of pending user-supplied write callbacks
  // this must be 0 before 'finish' can be emitted
  this.pendingcb = 0;

  // emit prefinish if the only thing we're waiting for is _write cbs
  // This is relevant for synchronous Transform streams
  this.prefinished = false;

  // True if the error was already emitted and should not be thrown again
  this.errorEmitted = false;

  // count buffered requests
  this.bufferedRequestCount = 0;

  // allocate the first CorkedRequest, there is always
  // one allocated and free to use, and we maintain at most two
  this.corkedRequestsFree = new CorkedRequest(this);
}

WritableState.prototype.getBuffer = function getBuffer() {
  var current = this.bufferedRequest;
  var out = [];
  while (current) {
    out.push(current);
    current = current.next;
  }
  return out;
};

(function () {
  try {
    Object.defineProperty(WritableState.prototype, 'buffer', {
      get: internalUtil.deprecate(function () {
        return this.getBuffer();
      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
    });
  } catch (_) {}
})();

// Test _writableState for inheritance to account for Duplex streams,
// whose prototype chain only points to Readable.
var realHasInstance;
if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
  realHasInstance = Function.prototype[Symbol.hasInstance];
  Object.defineProperty(Writable, Symbol.hasInstance, {
    value: function (object) {
      if (realHasInstance.call(this, object)) return true;

      return object && object._writableState instanceof WritableState;
    }
  });
} else {
  realHasInstance = function (object) {
    return object instanceof this;
  };
}

function Writable(options) {
  Duplex = Duplex || require('./_stream_duplex');

  // Writable ctor is applied to Duplexes, too.
  // `realHasInstance` is necessary because using plain `instanceof`
  // would return false, as no `_writableState` property is attached.

  // Trying to use the custom `instanceof` for Writable here will also break the
  // Node.js LazyTransform implementation, which has a non-trivial getter for
  // `_writableState` that would lead to infinite recursion.
  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
    return new Writable(options);
  }

  this._writableState = new WritableState(options, this);

  // legacy.
  this.writable = true;

  if (options) {
    if (typeof options.write === 'function') this._write = options.write;

    if (typeof options.writev === 'function') this._writev = options.writev;

    if (typeof options.destroy === 'function') this._destroy = options.destroy;

    if (typeof options.final === 'function') this._final = options.final;
  }

  Stream.call(this);
}

// Otherwise people can pipe Writable streams, which is just wrong.
Writable.prototype.pipe = function () {
  this.emit('error', new Error('Cannot pipe, not readable'));
};

function writeAfterEnd(stream, cb) {
  var er = new Error('write after end');
  // TODO: defer error events consistently everywhere, not just the cb
  stream.emit('error', er);
  processNextTick(cb, er);
}

// Checks that a user-supplied chunk is valid, especially for the particular
// mode the stream is in. Currently this means that `null` is never accepted
// and undefined/non-string values are only allowed in object mode.
function validChunk(stream, state, chunk, cb) {
  var valid = true;
  var er = false;

  if (chunk === null) {
    er = new TypeError('May not write null values to stream');
  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
    er = new TypeError('Invalid non-string/buffer chunk');
  }
  if (er) {
    stream.emit('error', er);
    processNextTick(cb, er);
    valid = false;
  }
  return valid;
}

Writable.prototype.write = function (chunk, encoding, cb) {
  var state = this._writableState;
  var ret = false;
  var isBuf = _isUint8Array(chunk) && !state.objectMode;

  if (isBuf && !Buffer.isBuffer(chunk)) {
    chunk = _uint8ArrayToBuffer(chunk);
  }

  if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;

  if (typeof cb !== 'function') cb = nop;

  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
    state.pendingcb++;
    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
  }

  return ret;
};

Writable.prototype.cork = function () {
  var state = this._writableState;

  state.corked++;
};

Writable.prototype.uncork = function () {
  var state = this._writableState;

  if (state.corked) {
    state.corked--;

    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
  }
};

Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
  // node::ParseEncoding() requires lower case.
  if (typeof encoding === 'string') encoding = encoding.toLowerCase();
  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
  this._writableState.defaultEncoding = encoding;
  return this;
};

function decodeChunk(state, chunk, encoding) {
  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
    chunk = Buffer.from(chunk, encoding);
  }
  return chunk;
}

// if we're already writing something, then just put this
// in the queue, and wait our turn.  Otherwise, call _write
// If we return false, then we need a drain event, so set that flag.
function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
  if (!isBuf) {
    var newChunk = decodeChunk(state, chunk, encoding);
    if (chunk !== newChunk) {
      isBuf = true;
      encoding = 'buffer';
      chunk = newChunk;
    }
  }
  var len = state.objectMode ? 1 : chunk.length;

  state.length += len;

  var ret = state.length < state.highWaterMark;
  // we must ensure that previous needDrain will not be reset to false.
  if (!ret) state.needDrain = true;

  if (state.writing || state.corked) {
    var last = state.lastBufferedRequest;
    state.lastBufferedRequest = {
      chunk: chunk,
      encoding: encoding,
      isBuf: isBuf,
      callback: cb,
      next: null
    };
    if (last) {
      last.next = state.lastBufferedRequest;
    } else {
      state.bufferedRequest = state.lastBufferedRequest;
    }
    state.bufferedRequestCount += 1;
  } else {
    doWrite(stream, state, false, len, chunk, encoding, cb);
  }

  return ret;
}

function doWrite(stream, state, writev, len, chunk, encoding, cb) {
  state.writelen = len;
  state.writecb = cb;
  state.writing = true;
  state.sync = true;
  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
  state.sync = false;
}

function onwriteError(stream, state, sync, er, cb) {
  --state.pendingcb;

  if (sync) {
    // defer the callback if we are being called synchronously
    // to avoid piling up things on the stack
    processNextTick(cb, er);
    // this can emit finish, and it will always happen
    // after error
    processNextTick(finishMaybe, stream, state);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
  } else {
    // the caller expect this to happen before if
    // it is async
    cb(er);
    stream._writableState.errorEmitted = true;
    stream.emit('error', er);
    // this can emit finish, but finish must
    // always follow error
    finishMaybe(stream, state);
  }
}

function onwriteStateUpdate(state) {
  state.writing = false;
  state.writecb = null;
  state.length -= state.writelen;
  state.writelen = 0;
}

function onwrite(stream, er) {
  var state = stream._writableState;
  var sync = state.sync;
  var cb = state.writecb;

  onwriteStateUpdate(state);

  if (er) onwriteError(stream, state, sync, er, cb);else {
    // Check if we're actually ready to finish, but don't emit yet
    var finished = needFinish(state);

    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
      clearBuffer(stream, state);
    }

    if (sync) {
      /*<replacement>*/
      asyncWrite(afterWrite, stream, state, finished, cb);
      /*</replacement>*/
    } else {
      afterWrite(stream, state, finished, cb);
    }
  }
}

function afterWrite(stream, state, finished, cb) {
  if (!finished) onwriteDrain(stream, state);
  state.pendingcb--;
  cb();
  finishMaybe(stream, state);
}

// Must force callback to be called on nextTick, so that we don't
// emit 'drain' before the write() consumer gets the 'false' return
// value, and has a chance to attach a 'drain' listener.
function onwriteDrain(stream, state) {
  if (state.length === 0 && state.needDrain) {
    state.needDrain = false;
    stream.emit('drain');
  }
}

// if there's something in the buffer waiting, then process it
function clearBuffer(stream, state) {
  state.bufferProcessing = true;
  var entry = state.bufferedRequest;

  if (stream._writev && entry && entry.next) {
    // Fast case, write everything using _writev()
    var l = state.bufferedRequestCount;
    var buffer = new Array(l);
    var holder = state.corkedRequestsFree;
    holder.entry = entry;

    var count = 0;
    var allBuffers = true;
    while (entry) {
      buffer[count] = entry;
      if (!entry.isBuf) allBuffers = false;
      entry = entry.next;
      count += 1;
    }
    buffer.allBuffers = allBuffers;

    doWrite(stream, state, true, state.length, buffer, '', holder.finish);

    // doWrite is almost always async, defer these to save a bit of time
    // as the hot path ends with doWrite
    state.pendingcb++;
    state.lastBufferedRequest = null;
    if (holder.next) {
      state.corkedRequestsFree = holder.next;
      holder.next = null;
    } else {
      state.corkedRequestsFree = new CorkedRequest(state);
    }
  } else {
    // Slow case, write chunks one-by-one
    while (entry) {
      var chunk = entry.chunk;
      var encoding = entry.encoding;
      var cb = entry.callback;
      var len = state.objectMode ? 1 : chunk.length;

      doWrite(stream, state, false, len, chunk, encoding, cb);
      entry = entry.next;
      // if we didn't call the onwrite immediately, then
      // it means that we need to wait until it does.
      // also, that means that the chunk and cb are currently
      // being processed, so move the buffer counter past them.
      if (state.writing) {
        break;
      }
    }

    if (entry === null) state.lastBufferedRequest = null;
  }

  state.bufferedRequestCount = 0;
  state.bufferedRequest = entry;
  state.bufferProcessing = false;
}

Writable.prototype._write = function (chunk, encoding, cb) {
  cb(new Error('_write() is not implemented'));
};

Writable.prototype._writev = null;

Writable.prototype.end = function (chunk, encoding, cb) {
  var state = this._writableState;

  if (typeof chunk === 'function') {
    cb = chunk;
    chunk = null;
    encoding = null;
  } else if (typeof encoding === 'function') {
    cb = encoding;
    encoding = null;
  }

  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);

  // .end() fully uncorks
  if (state.corked) {
    state.corked = 1;
    this.uncork();
  }

  // ignore unnecessary end() calls.
  if (!state.ending && !state.finished) endWritable(this, state, cb);
};

function needFinish(state) {
  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
}
function callFinal(stream, state) {
  stream._final(function (err) {
    state.pendingcb--;
    if (err) {
      stream.emit('error', err);
    }
    state.prefinished = true;
    stream.emit('prefinish');
    finishMaybe(stream, state);
  });
}
function prefinish(stream, state) {
  if (!state.prefinished && !state.finalCalled) {
    if (typeof stream._final === 'function') {
      state.pendingcb++;
      state.finalCalled = true;
      processNextTick(callFinal, stream, state);
    } else {
      state.prefinished = true;
      stream.emit('prefinish');
    }
  }
}

function finishMaybe(stream, state) {
  var need = needFinish(state);
  if (need) {
    prefinish(stream, state);
    if (state.pendingcb === 0) {
      state.finished = true;
      stream.emit('finish');
    }
  }
  return need;
}

function endWritable(stream, state, cb) {
  state.ending = true;
  finishMaybe(stream, state);
  if (cb) {
    if (state.finished) processNextTick(cb);else stream.once('finish', cb);
  }
  state.ended = true;
  stream.writable = false;
}

function onCorkedFinish(corkReq, state, err) {
  var entry = corkReq.entry;
  corkReq.entry = null;
  while (entry) {
    var cb = entry.callback;
    state.pendingcb--;
    cb(err);
    entry = entry.next;
  }
  if (state.corkedRequestsFree) {
    state.corkedRequestsFree.next = corkReq;
  } else {
    state.corkedRequestsFree = corkReq;
  }
}

Object.defineProperty(Writable.prototype, 'destroyed', {
  get: function () {
    if (this._writableState === undefined) {
      return false;
    }
    return this._writableState.destroyed;
  },
  set: function (value) {
    // we ignore the value if the stream
    // has not been initialized yet
    if (!this._writableState) {
      return;
    }

    // backward compatibility, the user is explicitly
    // managing destroyed
    this._writableState.destroyed = value;
  }
});

Writable.prototype.destroy = destroyImpl.destroy;
Writable.prototype._undestroy = destroyImpl.undestroy;
Writable.prototype._destroy = function (err, cb) {
  this.end();
  cb(err);
};
}).call(this,require('_process'),typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{"./_stream_duplex":83,"./internal/streams/destroy":89,"./internal/streams/stream":90,"_process":72,"core-util-is":55,"inherits":66,"process-nextick-args":71,"safe-buffer":77,"util-deprecate":99}],88:[function(require,module,exports){
'use strict';

/*<replacement>*/

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Buffer = require('safe-buffer').Buffer;
/*</replacement>*/

function copyBuffer(src, target, offset) {
  src.copy(target, offset);
}

module.exports = function () {
  function BufferList() {
    _classCallCheck(this, BufferList);

    this.head = null;
    this.tail = null;
    this.length = 0;
  }

  BufferList.prototype.push = function push(v) {
    var entry = { data: v, next: null };
    if (this.length > 0) this.tail.next = entry;else this.head = entry;
    this.tail = entry;
    ++this.length;
  };

  BufferList.prototype.unshift = function unshift(v) {
    var entry = { data: v, next: this.head };
    if (this.length === 0) this.tail = entry;
    this.head = entry;
    ++this.length;
  };

  BufferList.prototype.shift = function shift() {
    if (this.length === 0) return;
    var ret = this.head.data;
    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
    --this.length;
    return ret;
  };

  BufferList.prototype.clear = function clear() {
    this.head = this.tail = null;
    this.length = 0;
  };

  BufferList.prototype.join = function join(s) {
    if (this.length === 0) return '';
    var p = this.head;
    var ret = '' + p.data;
    while (p = p.next) {
      ret += s + p.data;
    }return ret;
  };

  BufferList.prototype.concat = function concat(n) {
    if (this.length === 0) return Buffer.alloc(0);
    if (this.length === 1) return this.head.data;
    var ret = Buffer.allocUnsafe(n >>> 0);
    var p = this.head;
    var i = 0;
    while (p) {
      copyBuffer(p.data, ret, i);
      i += p.data.length;
      p = p.next;
    }
    return ret;
  };

  return BufferList;
}();
},{"safe-buffer":77}],89:[function(require,module,exports){
'use strict';

/*<replacement>*/

var processNextTick = require('process-nextick-args');
/*</replacement>*/

// undocumented cb() API, needed for core, not for public API
function destroy(err, cb) {
  var _this = this;

  var readableDestroyed = this._readableState && this._readableState.destroyed;
  var writableDestroyed = this._writableState && this._writableState.destroyed;

  if (readableDestroyed || writableDestroyed) {
    if (cb) {
      cb(err);
    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
      processNextTick(emitErrorNT, this, err);
    }
    return;
  }

  // we set destroyed to true before firing error callbacks in order
  // to make it re-entrance safe in case destroy() is called within callbacks

  if (this._readableState) {
    this._readableState.destroyed = true;
  }

  // if this is a duplex stream mark the writable part as destroyed as well
  if (this._writableState) {
    this._writableState.destroyed = true;
  }

  this._destroy(err || null, function (err) {
    if (!cb && err) {
      processNextTick(emitErrorNT, _this, err);
      if (_this._writableState) {
        _this._writableState.errorEmitted = true;
      }
    } else if (cb) {
      cb(err);
    }
  });
}

function undestroy() {
  if (this._readableState) {
    this._readableState.destroyed = false;
    this._readableState.reading = false;
    this._readableState.ended = false;
    this._readableState.endEmitted = false;
  }

  if (this._writableState) {
    this._writableState.destroyed = false;
    this._writableState.ended = false;
    this._writableState.ending = false;
    this._writableState.finished = false;
    this._writableState.errorEmitted = false;
  }
}

function emitErrorNT(self, err) {
  self.emit('error', err);
}

module.exports = {
  destroy: destroy,
  undestroy: undestroy
};
},{"process-nextick-args":71}],90:[function(require,module,exports){
module.exports = require('events').EventEmitter;

},{"events":64}],91:[function(require,module,exports){
module.exports = require('./readable').PassThrough

},{"./readable":92}],92:[function(require,module,exports){
exports = module.exports = require('./lib/_stream_readable.js');
exports.Stream = exports;
exports.Readable = exports;
exports.Writable = require('./lib/_stream_writable.js');
exports.Duplex = require('./lib/_stream_duplex.js');
exports.Transform = require('./lib/_stream_transform.js');
exports.PassThrough = require('./lib/_stream_passthrough.js');

},{"./lib/_stream_duplex.js":83,"./lib/_stream_passthrough.js":84,"./lib/_stream_readable.js":85,"./lib/_stream_transform.js":86,"./lib/_stream_writable.js":87}],93:[function(require,module,exports){
module.exports = require('./readable').Transform

},{"./readable":92}],94:[function(require,module,exports){
module.exports = require('./lib/_stream_writable.js');

},{"./lib/_stream_writable.js":87}],95:[function(require,module,exports){
'use strict';

var Buffer = require('safe-buffer').Buffer;

var isEncoding = Buffer.isEncoding || function (encoding) {
  encoding = '' + encoding;
  switch (encoding && encoding.toLowerCase()) {
    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
      return true;
    default:
      return false;
  }
};

function _normalizeEncoding(enc) {
  if (!enc) return 'utf8';
  var retried;
  while (true) {
    switch (enc) {
      case 'utf8':
      case 'utf-8':
        return 'utf8';
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return 'utf16le';
      case 'latin1':
      case 'binary':
        return 'latin1';
      case 'base64':
      case 'ascii':
      case 'hex':
        return enc;
      default:
        if (retried) return; // undefined
        enc = ('' + enc).toLowerCase();
        retried = true;
    }
  }
};

// Do not cache `Buffer.isEncoding` when checking encoding names as some
// modules monkey-patch it to support additional encodings
function normalizeEncoding(enc) {
  var nenc = _normalizeEncoding(enc);
  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
  return nenc || enc;
}

// StringDecoder provides an interface for efficiently splitting a series of
// buffers into a series of JS strings without breaking apart multi-byte
// characters.
exports.StringDecoder = StringDecoder;
function StringDecoder(encoding) {
  this.encoding = normalizeEncoding(encoding);
  var nb;
  switch (this.encoding) {
    case 'utf16le':
      this.text = utf16Text;
      this.end = utf16End;
      nb = 4;
      break;
    case 'utf8':
      this.fillLast = utf8FillLast;
      nb = 4;
      break;
    case 'base64':
      this.text = base64Text;
      this.end = base64End;
      nb = 3;
      break;
    default:
      this.write = simpleWrite;
      this.end = simpleEnd;
      return;
  }
  this.lastNeed = 0;
  this.lastTotal = 0;
  this.lastChar = Buffer.allocUnsafe(nb);
}

StringDecoder.prototype.write = function (buf) {
  if (buf.length === 0) return '';
  var r;
  var i;
  if (this.lastNeed) {
    r = this.fillLast(buf);
    if (r === undefined) return '';
    i = this.lastNeed;
    this.lastNeed = 0;
  } else {
    i = 0;
  }
  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
  return r || '';
};

StringDecoder.prototype.end = utf8End;

// Returns only complete characters in a Buffer
StringDecoder.prototype.text = utf8Text;

// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
StringDecoder.prototype.fillLast = function (buf) {
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
  this.lastNeed -= buf.length;
};

// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
// continuation byte.
function utf8CheckByte(byte) {
  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
  return -1;
}

// Checks at most 3 bytes at the end of a Buffer in order to detect an
// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
// needed to complete the UTF-8 character (if applicable) are returned.
function utf8CheckIncomplete(self, buf, i) {
  var j = buf.length - 1;
  if (j < i) return 0;
  var nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 1;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) self.lastNeed = nb - 2;
    return nb;
  }
  if (--j < i) return 0;
  nb = utf8CheckByte(buf[j]);
  if (nb >= 0) {
    if (nb > 0) {
      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
    }
    return nb;
  }
  return 0;
}

// Validates as many continuation bytes for a multi-byte UTF-8 character as
// needed or are available. If we see a non-continuation byte where we expect
// one, we "replace" the validated continuation bytes we've seen so far with
// UTF-8 replacement characters ('\ufffd'), to match v8's UTF-8 decoding
// behavior. The continuation byte check is included three times in the case
// where all of the continuation bytes for a character exist in the same buffer.
// It is also done this way as a slight performance increase instead of using a
// loop.
function utf8CheckExtraBytes(self, buf, p) {
  if ((buf[0] & 0xC0) !== 0x80) {
    self.lastNeed = 0;
    return '\ufffd'.repeat(p);
  }
  if (self.lastNeed > 1 && buf.length > 1) {
    if ((buf[1] & 0xC0) !== 0x80) {
      self.lastNeed = 1;
      return '\ufffd'.repeat(p + 1);
    }
    if (self.lastNeed > 2 && buf.length > 2) {
      if ((buf[2] & 0xC0) !== 0x80) {
        self.lastNeed = 2;
        return '\ufffd'.repeat(p + 2);
      }
    }
  }
}

// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
function utf8FillLast(buf) {
  var p = this.lastTotal - this.lastNeed;
  var r = utf8CheckExtraBytes(this, buf, p);
  if (r !== undefined) return r;
  if (this.lastNeed <= buf.length) {
    buf.copy(this.lastChar, p, 0, this.lastNeed);
    return this.lastChar.toString(this.encoding, 0, this.lastTotal);
  }
  buf.copy(this.lastChar, p, 0, buf.length);
  this.lastNeed -= buf.length;
}

// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
// partial character, the character's bytes are buffered until the required
// number of bytes are available.
function utf8Text(buf, i) {
  var total = utf8CheckIncomplete(this, buf, i);
  if (!this.lastNeed) return buf.toString('utf8', i);
  this.lastTotal = total;
  var end = buf.length - (total - this.lastNeed);
  buf.copy(this.lastChar, 0, end);
  return buf.toString('utf8', i, end);
}

// For UTF-8, a replacement character for each buffered byte of a (partial)
// character needs to be added to the output.
function utf8End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + '\ufffd'.repeat(this.lastTotal - this.lastNeed);
  return r;
}

// UTF-16LE typically needs two bytes per character, but even if we have an even
// number of bytes available, we need to check if we end on a leading/high
// surrogate. In that case, we need to wait for the next two bytes in order to
// decode the last character properly.
function utf16Text(buf, i) {
  if ((buf.length - i) % 2 === 0) {
    var r = buf.toString('utf16le', i);
    if (r) {
      var c = r.charCodeAt(r.length - 1);
      if (c >= 0xD800 && c <= 0xDBFF) {
        this.lastNeed = 2;
        this.lastTotal = 4;
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
        return r.slice(0, -1);
      }
    }
    return r;
  }
  this.lastNeed = 1;
  this.lastTotal = 2;
  this.lastChar[0] = buf[buf.length - 1];
  return buf.toString('utf16le', i, buf.length - 1);
}

// For UTF-16LE we do not explicitly append special replacement characters if we
// end on a partial character, we simply let v8 handle that.
function utf16End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) {
    var end = this.lastTotal - this.lastNeed;
    return r + this.lastChar.toString('utf16le', 0, end);
  }
  return r;
}

function base64Text(buf, i) {
  var n = (buf.length - i) % 3;
  if (n === 0) return buf.toString('base64', i);
  this.lastNeed = 3 - n;
  this.lastTotal = 3;
  if (n === 1) {
    this.lastChar[0] = buf[buf.length - 1];
  } else {
    this.lastChar[0] = buf[buf.length - 2];
    this.lastChar[1] = buf[buf.length - 1];
  }
  return buf.toString('base64', i, buf.length - n);
}

function base64End(buf) {
  var r = buf && buf.length ? this.write(buf) : '';
  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
  return r;
}

// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
function simpleWrite(buf) {
  return buf.toString(this.encoding);
}

function simpleEnd(buf) {
  return buf && buf.length ? this.write(buf) : '';
}
},{"safe-buffer":77}],96:[function(require,module,exports){
var traverse = module.exports = function (obj) {
    return new Traverse(obj);
};

function Traverse (obj) {
    this.value = obj;
}

Traverse.prototype.get = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            node = undefined;
            break;
        }
        node = node[key];
    }
    return node;
};

Traverse.prototype.has = function (ps) {
    var node = this.value;
    for (var i = 0; i < ps.length; i ++) {
        var key = ps[i];
        if (!node || !hasOwnProperty.call(node, key)) {
            return false;
        }
        node = node[key];
    }
    return true;
};

Traverse.prototype.set = function (ps, value) {
    var node = this.value;
    for (var i = 0; i < ps.length - 1; i ++) {
        var key = ps[i];
        if (!hasOwnProperty.call(node, key)) node[key] = {};
        node = node[key];
    }
    node[ps[i]] = value;
    return value;
};

Traverse.prototype.map = function (cb) {
    return walk(this.value, cb, true);
};

Traverse.prototype.forEach = function (cb) {
    this.value = walk(this.value, cb, false);
    return this.value;
};

Traverse.prototype.reduce = function (cb, init) {
    var skip = arguments.length === 1;
    var acc = skip ? this.value : init;
    this.forEach(function (x) {
        if (!this.isRoot || !skip) {
            acc = cb.call(this, acc, x);
        }
    });
    return acc;
};

Traverse.prototype.paths = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.path); 
    });
    return acc;
};

Traverse.prototype.nodes = function () {
    var acc = [];
    this.forEach(function (x) {
        acc.push(this.node);
    });
    return acc;
};

Traverse.prototype.clone = function () {
    var parents = [], nodes = [];
    
    return (function clone (src) {
        for (var i = 0; i < parents.length; i++) {
            if (parents[i] === src) {
                return nodes[i];
            }
        }
        
        if (typeof src === 'object' && src !== null) {
            var dst = copy(src);
            
            parents.push(src);
            nodes.push(dst);
            
            forEach(objectKeys(src), function (key) {
                dst[key] = clone(src[key]);
            });
            
            parents.pop();
            nodes.pop();
            return dst;
        }
        else {
            return src;
        }
    })(this.value);
};

function walk (root, cb, immutable) {
    var path = [];
    var parents = [];
    var alive = true;
    
    return (function walker (node_) {
        var node = immutable ? copy(node_) : node_;
        var modifiers = {};
        
        var keepGoing = true;
        
        var state = {
            node : node,
            node_ : node_,
            path : [].concat(path),
            parent : parents[parents.length - 1],
            parents : parents,
            key : path.slice(-1)[0],
            isRoot : path.length === 0,
            level : path.length,
            circular : null,
            update : function (x, stopHere) {
                if (!state.isRoot) {
                    state.parent.node[state.key] = x;
                }
                state.node = x;
                if (stopHere) keepGoing = false;
            },
            'delete' : function (stopHere) {
                delete state.parent.node[state.key];
                if (stopHere) keepGoing = false;
            },
            remove : function (stopHere) {
                if (isArray(state.parent.node)) {
                    state.parent.node.splice(state.key, 1);
                }
                else {
                    delete state.parent.node[state.key];
                }
                if (stopHere) keepGoing = false;
            },
            keys : null,
            before : function (f) { modifiers.before = f },
            after : function (f) { modifiers.after = f },
            pre : function (f) { modifiers.pre = f },
            post : function (f) { modifiers.post = f },
            stop : function () { alive = false },
            block : function () { keepGoing = false }
        };
        
        if (!alive) return state;
        
        function updateState() {
            if (typeof state.node === 'object' && state.node !== null) {
                if (!state.keys || state.node_ !== state.node) {
                    state.keys = objectKeys(state.node)
                }
                
                state.isLeaf = state.keys.length == 0;
                
                for (var i = 0; i < parents.length; i++) {
                    if (parents[i].node_ === node_) {
                        state.circular = parents[i];
                        break;
                    }
                }
            }
            else {
                state.isLeaf = true;
                state.keys = null;
            }
            
            state.notLeaf = !state.isLeaf;
            state.notRoot = !state.isRoot;
        }
        
        updateState();
        
        // use return values to update if defined
        var ret = cb.call(state, state.node);
        if (ret !== undefined && state.update) state.update(ret);
        
        if (modifiers.before) modifiers.before.call(state, state.node);
        
        if (!keepGoing) return state;
        
        if (typeof state.node == 'object'
        && state.node !== null && !state.circular) {
            parents.push(state);
            
            updateState();
            
            forEach(state.keys, function (key, i) {
                path.push(key);
                
                if (modifiers.pre) modifiers.pre.call(state, state.node[key], key);
                
                var child = walker(state.node[key]);
                if (immutable && hasOwnProperty.call(state.node, key)) {
                    state.node[key] = child.node;
                }
                
                child.isLast = i == state.keys.length - 1;
                child.isFirst = i == 0;
                
                if (modifiers.post) modifiers.post.call(state, child);
                
                path.pop();
            });
            parents.pop();
        }
        
        if (modifiers.after) modifiers.after.call(state, state.node);
        
        return state;
    })(root).node;
}

function copy (src) {
    if (typeof src === 'object' && src !== null) {
        var dst;
        
        if (isArray(src)) {
            dst = [];
        }
        else if (isDate(src)) {
            dst = new Date(src.getTime ? src.getTime() : src);
        }
        else if (isRegExp(src)) {
            dst = new RegExp(src);
        }
        else if (isError(src)) {
            dst = { message: src.message };
        }
        else if (isBoolean(src)) {
            dst = new Boolean(src);
        }
        else if (isNumber(src)) {
            dst = new Number(src);
        }
        else if (isString(src)) {
            dst = new String(src);
        }
        else if (Object.create && Object.getPrototypeOf) {
            dst = Object.create(Object.getPrototypeOf(src));
        }
        else if (src.constructor === Object) {
            dst = {};
        }
        else {
            var proto =
                (src.constructor && src.constructor.prototype)
                || src.__proto__
                || {}
            ;
            var T = function () {};
            T.prototype = proto;
            dst = new T;
        }
        
        forEach(objectKeys(src), function (key) {
            dst[key] = src[key];
        });
        return dst;
    }
    else return src;
}

var objectKeys = Object.keys || function keys (obj) {
    var res = [];
    for (var key in obj) res.push(key)
    return res;
};

function toS (obj) { return Object.prototype.toString.call(obj) }
function isDate (obj) { return toS(obj) === '[object Date]' }
function isRegExp (obj) { return toS(obj) === '[object RegExp]' }
function isError (obj) { return toS(obj) === '[object Error]' }
function isBoolean (obj) { return toS(obj) === '[object Boolean]' }
function isNumber (obj) { return toS(obj) === '[object Number]' }
function isString (obj) { return toS(obj) === '[object String]' }

var isArray = Array.isArray || function isArray (xs) {
    return Object.prototype.toString.call(xs) === '[object Array]';
};

var forEach = function (xs, fn) {
    if (xs.forEach) return xs.forEach(fn)
    else for (var i = 0; i < xs.length; i++) {
        fn(xs[i], i, xs);
    }
};

forEach(objectKeys(Traverse.prototype), function (key) {
    traverse[key] = function (obj) {
        var args = [].slice.call(arguments, 1);
        var t = new Traverse(obj);
        return t[key].apply(t, args);
    };
});

var hasOwnProperty = Object.hasOwnProperty || function (obj, key) {
    return key in obj;
};

},{}],97:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":98,"punycode":73,"querystring":76}],98:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],99:[function(require,module,exports){
(function (global){

/**
 * Module exports.
 */

module.exports = deprecate;

/**
 * Mark that a method should not be used.
 * Returns a modified function which warns once by default.
 *
 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
 *
 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
 * will throw an Error when invoked.
 *
 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
 * will invoke `console.trace()` instead of `console.error()`.
 *
 * @param {Function} fn - the function to deprecate
 * @param {String} msg - the string to print to the console when `fn` is invoked
 * @returns {Function} a new "deprecated" version of `fn`
 * @api public
 */

function deprecate (fn, msg) {
  if (config('noDeprecation')) {
    return fn;
  }

  var warned = false;
  function deprecated() {
    if (!warned) {
      if (config('throwDeprecation')) {
        throw new Error(msg);
      } else if (config('traceDeprecation')) {
        console.trace(msg);
      } else {
        console.warn(msg);
      }
      warned = true;
    }
    return fn.apply(this, arguments);
  }

  return deprecated;
}

/**
 * Checks `localStorage` for boolean values for the given `name`.
 *
 * @param {String} name
 * @returns {Boolean}
 * @api private
 */

function config (name) {
  // accessing global.localStorage can trigger a DOMException in sandboxed iframes
  try {
    if (!global.localStorage) return false;
  } catch (_) {
    return false;
  }
  var val = global.localStorage[name];
  if (null == val) return false;
  return String(val).toLowerCase() === 'true';
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[18])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvY2xpZW50L2pzL0NPTlNULmpzIiwibGliL2NsaWVudC9qcy9Ub2FzdC5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9KTUJGVXBsb2FkZXJDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL0pzb25JbXBvcnRDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL2F1dGhDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL2JyZWFkY3J1bWJDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL2NyZWF0ZU5ld1Byb2plY3RDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL21lbnVSaWdodENvbnRyb2xsZXIuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvcGFnZUhlYWRlckNvbnRyb2xsZXIuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvcHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci9wcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3RleHRFZGl0b3JDb250cm9sbGVyLmpzIiwibGliL2NsaWVudC9qcy9jb250cm9sbGVyL3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXIuanMiLCJsaWIvY2xpZW50L2pzL2NvbnRyb2xsZXIvdXBsb2FkQ29udHJvbGxlci5qcyIsImxpYi9jbGllbnQvanMvY29udHJvbGxlci91cmxNYW5pcHVsYXRvci5qcyIsImxpYi9jbGllbnQvanMvZXZlbnRzLmpzIiwibGliL2NsaWVudC9qcy9oYW5kbGVTZXNzaW9uVGltZU91dC5qcyIsImxpYi9jbGllbnQvanMvbWFpbi5qcyIsImxpYi9jbGllbnQvanMvdGV4dEVkaXRvci5qcyIsImxpYi9jbGllbnQvanMvdHJhZGUuanMiLCJsaWIvY2xpZW50L2pzL3VpRXZlbnRNYW5hZ2VyLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvSk1CRlVwbG9hZGVyLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvSnNvbkltcG9ydC5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2FuY2hvck1lbnUuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9hdXRoLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvYnJlYWRjcnVtYi5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2Nvbm5lY3Rpb25Mb3N0L2luZGV4Lmh0bWwiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9jb25uZWN0aW9uTG9zdC9pbmRleC5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2NyZWF0ZU5ld1Byb2plY3QuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9kaXNwbGF5TWFuYWdlci5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2ZsYWcuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9pbWFnZVZpZXdlci5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL2lucHV0RWRpdE1hbmFnZXIuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9tZW51UmlnaHQuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy9vdmVybGF5LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvcHJvamVjdE1haW5OYXZpZ2F0aW9uLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvcHJvamVjdE92ZXJ2aWV3LmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvdGV4dHMuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXcuanMiLCJsaWIvY2xpZW50L2pzL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXdEZXNjcmlwdGlvbi5qcyIsImxpYi9jbGllbnQvanMvdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkLmpzIiwibGliL2NsaWVudC9qcy91aU1vZHVsZXMvdXBsb2FkLmpzIiwibGliL2NsaWVudC9qcy91bmljb2RlLmpzIiwibGliL2NsaWVudC9qcy91dGlsL3VybC5qcyIsImxpYi9jbGllbnQvanMvdXRpbC93b3JkQ291bnRlci5qcyIsIm5vZGVfbW9kdWxlcy9iYXNlNjQtanMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2J1ZmZlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ueS1jb29raWVNYW5hZ2VyLWxpYi9jb29raWVNYW5hZ2VyLmpzIiwibm9kZV9tb2R1bGVzL2Nhbm55L2Nhbm55LmpzIiwibm9kZV9tb2R1bGVzL2Nhbm55L21vZC9hc3luYy5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ueS9tb2QvZmxvd0NvbnRyb2wuanMiLCJub2RlX21vZHVsZXMvY2FubnkvbW9kL3JlcGVhdC5qcyIsIm5vZGVfbW9kdWxlcy9jYW5ueS9tb2Qvd2hpc2tlci5qcyIsIm5vZGVfbW9kdWxlcy9jb3JlLXV0aWwtaXMvbGliL3V0aWwuanMiLCJub2RlX21vZHVsZXMvZG5vZGUtcHJvdG9jb2wvaW5kZXguanMiLCJub2RlX21vZHVsZXMvZG5vZGUtcHJvdG9jb2wvbGliL2ZvcmVhY2guanMiLCJub2RlX21vZHVsZXMvZG5vZGUtcHJvdG9jb2wvbGliL2lzX2VudW0uanMiLCJub2RlX21vZHVsZXMvZG5vZGUtcHJvdG9jb2wvbGliL2tleXMuanMiLCJub2RlX21vZHVsZXMvZG5vZGUtcHJvdG9jb2wvbGliL3NjcnViLmpzIiwibm9kZV9tb2R1bGVzL2Rub2RlL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvZG5vZGUvbGliL2Rub2RlLmpzIiwibm9kZV9tb2R1bGVzL2RvbS1vcHRzL2RvbU9wdHMuanMiLCJub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9pZWVlNzU0L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2luaGVyaXRzL2luaGVyaXRzX2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2pzb25pZnkvaW5kZXguanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvcGFyc2UuanMiLCJub2RlX21vZHVsZXMvanNvbmlmeS9saWIvc3RyaW5naWZ5LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MtbmV4dGljay1hcmdzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9wdW55Y29kZS9wdW55Y29kZS5qcyIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZy1lczMvZGVjb2RlLmpzIiwibm9kZV9tb2R1bGVzL3F1ZXJ5c3RyaW5nLWVzMy9lbmNvZGUuanMiLCJub2RlX21vZHVsZXMvcXVlcnlzdHJpbmctZXMzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NhZmUtYnVmZmVyL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3Nob2UvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zaG9lL25vZGVfbW9kdWxlcy9zb2NranMtY2xpZW50L3NvY2tqcy5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvaXNhcnJheS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2R1cGxleC1icm93c2VyLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fZHVwbGV4LmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvX3N0cmVhbV9yZWFkYWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vbGliL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdC5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL2xpYi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3kuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3JlYWRhYmxlLXN0cmVhbS9saWIvaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0tYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzIiwibm9kZV9tb2R1bGVzL3N0cmVhbS1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9yZWFkYWJsZS1zdHJlYW0vcmVhZGFibGUtYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcyIsIm5vZGVfbW9kdWxlcy9zdHJlYW0tYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvcmVhZGFibGUtc3RyZWFtL3dyaXRhYmxlLWJyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvc3RyZWFtLWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3N0cmluZ19kZWNvZGVyL2xpYi9zdHJpbmdfZGVjb2Rlci5qcyIsIm5vZGVfbW9kdWxlcy90cmF2ZXJzZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91cmwvdXJsLmpzIiwibm9kZV9tb2R1bGVzL3VybC91dGlsLmpzIiwibm9kZV9tb2R1bGVzL3V0aWwtZGVwcmVjYXRlL2Jyb3dzZXIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FBLElBQUksSUFBSTtBQUNKLGtCQUFlO0FBQ1gsb0JBQWE7QUFDVCxtQkFBUSxPQURDO0FBRVQsa0JBQVE7QUFGQyxTQURGO0FBS1gsa0JBQVc7QUFDUCxtQkFBUSxRQUREO0FBRVAsa0JBQU87QUFGQTtBQUxBLEtBRFg7QUFXSixhQUFVO0FBQ04sZ0NBQXdCLE9BQU87QUFEekI7QUFYTixDQUFSOztBQWdCQSxPQUFPLE9BQVAsR0FBaUIsQ0FBakI7Ozs7O0FDaEJBOzs7Ozs7QUFNQSxJQUFJLFFBQVEsSUFBSyxTQUFTLEtBQVQsQ0FBZSxFQUFmLEVBQWtCO0FBQy9CLFFBQUksUUFBUSxJQUFaO0FBQUEsUUFDQSxtQkFBbUIsSUFEbkI7QUFBQSxRQUVBLHNCQUFzQixDQUZ0QjtBQUFBLFFBR0EsWUFBWSxTQUFTLGNBQVQsQ0FBd0IsRUFBeEIsQ0FIWjtBQUFBLFFBSUEsdUJBQXVCLElBSnZCO0FBQUEsUUFLQSxhQUFhLElBTGI7QUFBQSxRQU1BLFlBQVksU0FBWixTQUFZLEdBQVU7QUFDbEIsWUFBSSxXQUFXLFNBQVMsb0JBQVQsQ0FBOEIsTUFBOUIsRUFBc0MsQ0FBdEMsQ0FBZjtBQUNBLG9CQUFZLFNBQVMsYUFBVCxDQUF1QixLQUF2QixDQUFaO0FBQ0Esa0JBQVUsRUFBVixHQUFlLEVBQWY7QUFDQSxrQkFBVSxLQUFWLENBQWdCLE9BQWhCLEdBQTBCLGtSQUExQjtBQUNBLGlCQUFTLFdBQVQsQ0FBcUIsU0FBckI7QUFDSCxLQVpEO0FBQUEsUUFhQSxRQUFRO0FBQ0osaUJB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xyREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeE5BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDelZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDbGtCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOVNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7O0FDRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDalJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbnhFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9IQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTs7QUNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDOUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5K0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNyTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN2cEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDekVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2RUE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTs7QUNEQTtBQUNBOztBQ0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL1FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNXRCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCJ2YXIgQyA9IHtcbiAgICBGSUxFX01BTkFHRVIgOiB7XG4gICAgICAgIEZJTEVfVFlQRVMgOiB7XG4gICAgICAgICAgICBJTUFHRSA6ICdpbWFnZScsXG4gICAgICAgICAgICBGSUxFICA6ICdmaWxlJ1xuICAgICAgICB9LFxuICAgICAgICBFTkNPRElORyA6IHtcbiAgICAgICAgICAgIGltYWdlIDogJ2Jhc2U2NCcsXG4gICAgICAgICAgICBmaWxlIDogJ3V0ZjgnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIFNFU1NJT04gOiB7XG4gICAgICAgIHJlbmV3YWxfaW50ZXJ2YWxfaW5fbXM6IDEwMDAgKiAxNVxuICAgIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzID0gQztcbiIsIi8qKlxuICogVE9ETyBmYWRlIG91dCB3aGVuIG1heExlbmd0aE9mTWVzc2FnZXMgZXhjZWVkZWQgbG9va3Mgbm90IHNvIG5pY2VcbiAqIEBwYXJhbSBpZFxuICogQHJldHVybiB7T2JqZWN0fVxuICogQGNvbnN0cnVjdG9yXG4gKi9cbnZhciB0b2FzdCA9IG5ldyAoZnVuY3Rpb24gVG9hc3QoaWQpe1xuICAgIHZhciBERUxBWSA9IDQwMDAsXG4gICAgb3BhY2l0eUZhZGVTdGVwcyA9IDAuMDQsXG4gICAgbWF4TGVuZ3RoT2ZNZXNzYWdlcyA9IDQsXG4gICAgdG9hc3ROb2RlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaWQpLFxuICAgIGlzUmVhZHlGb3JTdGFydEFnYWluID0gdHJ1ZSxcbiAgICBuZXdNZXNzYWdlID0gdHJ1ZSxcbiAgICBpbml0VG9hc3QgPSBmdW5jdGlvbigpe1xuICAgICAgICB2YXIgcm9vdE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYm9keScpWzBdO1xuICAgICAgICB0b2FzdE5vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgdG9hc3ROb2RlLmlkID0gaWQ7XG4gICAgICAgIHRvYXN0Tm9kZS5zdHlsZS5jc3NUZXh0ID0gXCJwb3NpdGlvbjpmaXhlZDt6LWluZGV4Ojk5OTt0b3A6NC41ZW07cmlnaHQ6MmVtO2JvcmRlci1yYWRpdXM6NXB4O2NvbG9yOiNmZmY7Zm9udC1zaXplOjEuMmVtO2ZvbnQtd2VpZ2h0OmJvbGQ7YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDYzLDE0MywyNTEsMC45KTtwYWRkaW5nOiAxZW0gMC41ZW07IGJveC1zaXppbmc6IGJvcmRlci1ib3g7IG1heC13aWR0aDogNTAlOyB0ZXh0LWFsaWduOiBjZW50ZXI7IHdvcmQtd3JhcDogYnJlYWstd29yZDsgYnJlYWstd29yZDogYnJlYWstYWxsO1wiXG4gICAgICAgIHJvb3ROb2RlLmFwcGVuZENoaWxkKHRvYXN0Tm9kZSk7XG4gICAgfSxcbiAgICB0b2FzdCA9IHtcbiAgICAgICAgZmFkZU91dCA6IGZ1bmN0aW9uKF9ub2RlLF9kb25lKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IF9ub2RlO1xuICAgICAgICAgICAgdmFyIGRvbmUgPSBfZG9uZTtcbiAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gMTtcbiAgICAgICAgICAgIChmdW5jdGlvbiBkZWNyZW1lbnRPcGFjaXR5KCl7XG4gICAgICAgICAgICAgICAgaWYgKG9wYWNpdHkgPiBvcGFjaXR5RmFkZVN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wYWNpdHkgPSBvcGFjaXR5IC0gb3BhY2l0eUZhZGVTdGVwcztcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5vcGFjaXR5ID0gb3BhY2l0eTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpe1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVjcmVtZW50T3BhY2l0eSgpO1xuICAgICAgICAgICAgICAgICAgICB9LDQwKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnUEFSRU5UIE5PREU6Jyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhub2RlLnBhcmVudE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBpZihub2RlLnBhcmVudE5vZGUgIT0gbnVsbCl7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNob3dNZXNzYWdlIDogZnVuY3Rpb24obXNnKSB7XG4gICAgICAgICAgICBpZighdG9hc3ROb2RlKXtcbiAgICAgICAgICAgICAgICBpbml0VG9hc3QoKVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgdmFyIHAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdwJyk7XG4gICAgICAgICAgICBwLnN0eWxlLmNzc1RleHQgPSBcInBhZGRpbmc6MHB4IDEwcHhcIjtcbiAgICAgICAgICAgIHAuaW5uZXJIVE1MID0gbXNnO1xuICAgICAgICAgICAgdG9hc3ROb2RlLmluc2VydEJlZm9yZShwLCB0b2FzdE5vZGUuZmlyc3RDaGlsZCk7XG4gICAgICAgICAgICAoZnVuY3Rpb24gZmFkZU91dFRvTXVjaE1lc3NhZ2VzKCkge1xuICAgICAgICAgICAgICAgIGlmICh0b2FzdE5vZGUuY2hpbGROb2Rlcy5sZW5ndGggPiBtYXhMZW5ndGhPZk1lc3NhZ2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0LmZhZGVPdXQodG9hc3ROb2RlLmNoaWxkcmVuW3RvYXN0Tm9kZS5jaGlsZHJlbi5sZW5ndGgtMV0sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmFkZU91dFRvTXVjaE1lc3NhZ2VzKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICB2YXIgdGltZU91dCA9IERFTEFZO1xuICAgICAgICAgICAgbmV3TWVzc2FnZSA9IHRydWU7XG4gICAgICAgICAgICBmdW5jdGlvbiBmYWRlT3V0KF9mYyl7XG4gICAgICAgICAgICAgICAgdmFyIGZjID0gX2ZjO1xuICAgICAgICAgICAgICAgIHZhciBvcGFjaXR5ID0gdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHk7XG4gICAgICAgICAgICAgICAgaWYgKG9wYWNpdHkgPiBvcGFjaXR5RmFkZVN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKG5ld01lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc2V0TWVzc2FnZVxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3TWVzc2FnZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dCA9IERFTEFZO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHkgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9ZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGFjaXR5ID0gb3BhY2l0eS1vcGFjaXR5RmFkZVN0ZXBzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3ROb2RlLnN0eWxlLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dCA9IDQwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IHRpbWVyXG4gICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVPdXQoZmMpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lT3V0KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3aGlsZSAoIHRvYXN0Tm9kZS5maXJzdENoaWxkICkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3ROb2RlLnJlbW92ZUNoaWxkKCB0b2FzdE5vZGUuZmlyc3RDaGlsZCApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRvYXN0Tm9kZS5zdHlsZS5vcGFjaXR5ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgZmModHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYoaXNSZWFkeUZvclN0YXJ0QWdhaW4pe1xuICAgICAgICAgICAgICAgIGlzUmVhZHlGb3JTdGFydEFnYWluID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGltZU91dCA9IERFTEFZO1xuICAgICAgICAgICAgICAgIGZhZGVPdXQoZnVuY3Rpb24oX2Ipe1xuICAgICAgICAgICAgICAgICAgICBpc1JlYWR5Rm9yU3RhcnRBZ2FpbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiB0b2FzdDtcbn0pKCd0b2FzdCcpO1xuXG5pZih0eXBlb2YgbW9kdWxlICE9IFwidW5kZWZpbmVkXCIpe1xuICAgIGNvbnNvbGUubG9nKCdleHBvcnRzJyk7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSB0b2FzdDtcbn1lbHNlIHtcbiAgICBjb25zb2xlLmxvZygnYXNpZ24gdG8gZ2xvYmFsIHNjb3BlJyk7XG4gICAgd2luZG93LnRvYXN0ID0gdG9hc3Q7XG59IiwiLyoqXG4gKiBjb250cm9sbGVyIGZvciB0aGUgaW1hZ2UgdXBsYW9kZXIgdmlldyAtIGNhbGxzIHRoZSBzZXJ2ZXIgdG8gdXBsb2FkIGEgaW1hZ2UgYW5kIG5vdGlmaWVyIHRoZSB1aSBldmVudCBoYW5kbGVyXG4gKiBAdHlwZSB7e319XG4gKi9cbnZhciBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JyksXG4gICAgSk1CRlVwbG9hZGVyID0gY2FubnkuSk1CRlVwbG9hZGVyLFxuICAgIGRpc3BsYXlNYW5hZ2VyID0gY2FubnkuZGlzcGxheU1hbmFnZXIsXG4gICAgdWlFdmVudHMgPSByZXF1aXJlKCcuLi91aUV2ZW50TWFuYWdlci5qcycpLFxuICAgIHVwbG9hZElkLFxuICAgIHByb2plY3RJbmZvO1xuLyoqXG4gKiBDYWxsIHRoaXMgZm9yIGVhY2ggZmlsZSAtIHdpbGwgY2FsbCBhIGNhbGwgYmFjayB3aXRoIHRoZSBzZXJ2ZXIgYW5zd2VyXG4gKiBAcGFyYW0gZmlsZVxuICovXG5mdW5jdGlvbiBzZW5kRmlsZShmaWxlLCBkaXJlY3RDYWxsYmFjaykge1xuICAgIHZhciB1cmkgPSAnL3VwbG9hZEpNQkZGaWxlP3Byb2plY3RJZD0nICsgcHJvamVjdEluZm8uaWQgKyAnJnByb2plY3Q9JyArIHByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgeGhyLm9wZW4oXCJQT1NUXCIsIHVyaSwgdHJ1ZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgZGF0YTtcbiAgICAgICAgaWYgKHhoci5yZWFkeVN0YXRlID09IDQgJiYgeGhyLnN0YXR1cyA9PSAyMDApIHtcbiAgICAgICAgICAgIC8vIEhhbmRsZSByZXNwb25zZS5cbiAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgZGlyZWN0Q2FsbGJhY2sgJiYgZGlyZWN0Q2FsbGJhY2soZGF0YSk7IC8vIGhhbmRsZSByZXNwb25zZS5cbiAgICAgICAgICAgIC8vIHtmaWxlOiBcIi8vc3ViL3N1YjEvc3ViMV9ibHVlX2Nva2UuanBnXCIsIG5hbWU6IFwic3ViMV9ibHVlX2Nva2UuanBnXCIsIHR5cGU6IFwiaW1hZ2UvanBnXCJ9XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhkYXRhKTtcbiAgICAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdKTUJGRmlsZVVwbG9hZGVkJywgcHJvamVjdEluZm8uaWQsIHVwbG9hZElkLCBkYXRhLm5hbWUpXG4gICAgICAgIH0gZWxzZSBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCAmJiB4aHIuc3RhdHVzID09PSA0MDYpIHtcbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdVcGxvYWQgZmFpbHVyZS4gVGhlIGZpbGUgbGFuZ3VhZ2UgaXMgbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBmZC5hcHBlbmQoJ215RmlsZScsIGZpbGUpO1xuICAgIC8vIEluaXRpYXRlIGEgbXVsdGlwYXJ0L2Zvcm0tZGF0YSB1cGxvYWRcbiAgICB4aHIuc2VuZChmZCk7XG59XG5cbi8qKlxuICogU2F2ZSBkYXRhIGluIG1lbWJlciB2YXJpYWJsZSB1c2VkIGJ5IGZ1cnRoZXIgdXBsb2FkIG9wZXJhdGlvbnNcbiAqIEBwYXJhbSBkYXRhOiBQcm9qZWN0IGRhdGFcbiAqL1xuZnVuY3Rpb24gYXBwbHlQcm9qZWN0RGF0YShkYXRhLCBwcm9qZWN0KSB7XG4gICAgcHJvamVjdEluZm8gPSBwcm9qZWN0XG59XG5cbnVpRXZlbnRzLmFkZFVpRXZlbnRMaXN0ZW5lcih7XG4gICAgc2hvd0pNQkZVcGxvYWRlciA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdKTUJGVXBsb2FkZXJWaWV3Jyk7XG4gICAgfVxufSk7XG5cbkpNQkZVcGxvYWRlci5vblVwbG9hZChmdW5jdGlvbiAoZmlsZSkge1xuICAgIC8vIFRPRE8gYWRkaXRpb25hbCB0byB0aGUgdXBsb2FkIGlkIHdlIG5lZWQgdGhlIHByb2plY3QgSURcbiAgICBjb25zb2xlLmxvZygndXBsb2FkQ29udHJvbGxlcjp1cGxvYWQgaWQ6IGZpbGU6JywgdXBsb2FkSWQsIGZpbGUpO1xuICAgIHNlbmRGaWxlKGZpbGUpO1xufSk7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTG9hZFByb2plY3QgOiBhcHBseVByb2plY3REYXRhXG59OyIsInZhciBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JyksXG4gICAgSnNvbkltcG9ydCA9IGNhbm55Lkpzb25JbXBvcnQsXG4gICAgZGlzcGxheU1hbmFnZXIgPSBjYW5ueS5kaXNwbGF5TWFuYWdlcixcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyLmpzJyksXG4gICAgdXBsb2FkSWQsXG4gICAgcHJvamVjdEluZm87XG5cbmZ1bmN0aW9uIHNlbmRGaWxlKGZpbGUpIHtcbiAgICB2YXIgdXJpID0gJy9pbXBvcnRKU09OP3Byb2plY3RJZD0nICsgcHJvamVjdEluZm8uaWQgKyAnJnByb2plY3Q9JyArIHByb2plY3RJbmZvLm5hbWUsXG4gICAgICAgIHhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpLFxuICAgICAgICBmZCA9IG5ldyBGb3JtRGF0YSgpO1xuXG4gICAgeGhyLm9wZW4oXCJQT1NUXCIsIHVyaSwgdHJ1ZSk7XG4gICAgeGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoeGhyLnJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKHhoci5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgaWYgKHhoci5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICAgICAgLy8gZGF0YS5uYW1lIGRvZXMgbm90IGV4aXN0IC0gYW5kIGlzIGFsc28gbm90IHVzZWQsIGlzIGl0ID9cbiAgICAgICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnanNvbkltcG9ydGVkJywgcHJvamVjdEluZm8uaWQsIHVwbG9hZElkLCBkYXRhLm5hbWUpXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhoci5zdGF0dXMgPT09IDQwNikge1xuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdVcGxvYWQgZmFpbHVyZS4gVGhlcmUgaXMgYW4gZXJyb3I6PGJyIC8+JyArIGRhdGEubXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgZmQuYXBwZW5kKCdteUZpbGUnLCBmaWxlKTtcbiAgICB4aHIuc2VuZChmZCk7XG59XG5cbmZ1bmN0aW9uIGFwcGx5UHJvamVjdERhdGEoZGF0YSwgcHJvamVjdCkge1xuICAgIHByb2plY3RJbmZvID0gcHJvamVjdDtcbn1cblxudWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICBzaG93SlNPTkltcG9ydCA6IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdKU09OSW1wb3J0VmlldycpO1xuICAgIH1cbn0pO1xuXG5Kc29uSW1wb3J0Lm9uVXBsb2FkKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgc2VuZEZpbGUoZmlsZSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgb25Mb2FkUHJvamVjdCA6IGFwcGx5UHJvamVjdERhdGFcbn07IiwidmFyIGFzeW5jID0gcmVxdWlyZSgnY2FubnkvbW9kL2FzeW5jJyksXG4gICAgYXV0aCA9IHJlcXVpcmUoJ2Nhbm55JykuYXV0aDtcblxuYXV0aC5vbkxvZ291dChmdW5jdGlvbiAoKSB7XG4gICAgYXN5bmMuZG9BamF4KHtcbiAgICAgICAgcGF0aCA6ICcvbG9nb3V0JyxcbiAgICAgICAgb25TdWNjZXNzIDogZnVuY3Rpb24gKHJlc3BvbnNlKSB7XG4gICAgICAgICAgICBsb2NhdGlvbi5yZWxvYWQoKTtcbiAgICAgICAgfVxuICAgIH0pXG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7fTsiLCJ2YXIgYnJlYWRjcnVtYiA9IHJlcXVpcmUoJy4uL3VpTW9kdWxlcy9icmVhZGNydW1iJyksXG4gICAgY2FubnkgPSByZXF1aXJlKCdjYW5ueScpLFxuICAgIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUnKSxcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyJyk7XG5cbmNhbm55LmFkZCgnYnJlYWRjcnVtYicsIGJyZWFkY3J1bWIpXG5cbmJyZWFkY3J1bWIub25DbGljayhmdW5jdGlvbiAoZGlyZWN0b3J5SWQpIHtcbiAgICB0cmFkZS5nZXREaXJlY3RvcnkoZGlyZWN0b3J5SWQsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyciAhPT0gZmFsc2UgKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGNhbGwgdGhlXG4gICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnc2hvd092ZXJ2aWV3UGFnZScpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ2JyZWFkY3J1bWJDb250cm9sbGVyOmdldERpcmVjdG9yeSBjYW4gbm90IGxvYWQgcHJvamVjdCBmb3IgZGlyZWN0b3J5IG5hbWU6JywgZGlyZWN0b3J5SWQpO1xuICAgICAgICB9XG4gICAgfSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2V0UGF0aCA6ICh1cmwpID0+IHtcbiAgICAgICAgbGV0IHBhdGggPSAnLydcbiAgICAgICAgaWYgKHVybCA9PT0gJy8nKVxuICAgICAgICAgICAgcmV0dXJuIGJyZWFkY3J1bWIudXBkYXRlRm9sZGVycyhbeyBpZDogJy8nICwgbmFtZTogJycgfV0pXG4gICAgICAgIFxuICAgICAgICBicmVhZGNydW1iLnVwZGF0ZUZvbGRlcnModXJsLnNwbGl0KCcvJykubWFwKGZvbGRlciA9PiB7XG4gICAgICAgICAgICAgICAgcGF0aCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXSAhPT0gJy8nID8gcGF0aCArICcvJyArIGZvbGRlciA6IHBhdGggKyBmb2xkZXJcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpZDogcGF0aCAsIG5hbWU6IGZvbGRlclxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgKSlcbiAgICB9LFxuICAgIGdldERpcmVjdG9yeTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2JyZWFkY3J1bWJDb250cm9sbGVyOnBhcmVudERpcmVjdG9yaWVzJywgZGF0YS5wYXJlbnREaXJlY3Rvcmllcyk7XG4gICAgICAgIGJyZWFkY3J1bWIudXBkYXRlRm9sZGVycyhkYXRhLnBhcmVudERpcmVjdG9yaWVzKTtcbiAgICB9XG59O1xuIiwidmFyIGNyZWF0ZU5ld1Byb2plY3QgPSByZXF1aXJlKCdjYW5ueScpLmNyZWF0ZU5ld1Byb2plY3QsXG4gICAgZGlzcGxheU1hbmFnZXIgPSByZXF1aXJlKCdjYW5ueScpLmRpc3BsYXlNYW5hZ2VyLFxuICAgIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUnKTtcblxudmFyIGN1cnJlbnREaXJlY3Rvcnk7XG5cbmNyZWF0ZU5ld1Byb2plY3Qub25DcmVhdGVOZXdQcm9qZWN0KGZ1bmN0aW9uKHByb2plY3ROYW1lKSB7XG4gICAgdHJhZGUuY3JlYXRlTmV3UHJvamVjdChwcm9qZWN0TmFtZSwgY3VycmVudERpcmVjdG9yeSk7XG4gICAgZGlzcGxheU1hbmFnZXIuaGlkZSgnY3JlYXRlTmV3UHJvamVjdFZpZXcnKTtcbn0pO1xuXG5jcmVhdGVOZXdQcm9qZWN0Lm9uQ3JlYXRlTmV3RGlyZWN0b3koZnVuY3Rpb24oZGlyZWN0b3J5TmFtZSkge1xuICAgIHRyYWRlLmNyZWF0ZU5ld0RpcmVjdG9yeShkaXJlY3RvcnlOYW1lLCBjdXJyZW50RGlyZWN0b3J5KTtcbiAgICBkaXNwbGF5TWFuYWdlci5oaWRlKCdjcmVhdGVOZXdEaXJlY3RvcnlWaWV3Jyk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLy8gVE9ETyBpbnRyb2R1Y2UgbmV3IGV2ZW50OiBvbkRpcmVjdG9yeUNoYW5nZWQgLSBiZWNhdXNlIGEgXCJnZXREaXJlY3RvcnlcIiBldmVudCBkb2VzIG5vdCByZWFsbHkgZXhwbGFpbiB3aGF0J3NcbiAgICAvLyBoYXBwZW5pbmcgaGVyZVxuICAgIGdldERpcmVjdG9yeSA6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgY3VycmVudERpcmVjdG9yeSA9IGRhdGEuY3VycmVudERpcmVjdG9yeTtcbiAgICB9XG59O1xuIiwidmFyIGFuY2hvck1lbnUgPSByZXF1aXJlKCdjYW5ueScpLmFuY2hvck1lbnUsXG4gICAgdHJhbnNsYXRpb25WaWV3Q29uZmlnID0gcmVxdWlyZSgnLi4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlldycpLmNvbmZpZyxcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyJyk7XG5cbi8qKlxuICogTmljZSBhcHByb2FjaCBidXQgdGhlIG9yZGVyIGlzIGRpZmZlcmVudCBmcm9tIHRoZSBET00uXG4gKiBUT0RPIEl0IHdvdWxkIGJlIGJldHRlciB0byByZWFkIHRoZSBlbGVtZW50cyBmcm9tIHRoZSBET01cbiAqICAxLiBpdCdzIGVhc2llciB0byByZWluaXRpYWxpemUgaWYgYSBrZXkgaXMgcmVuYW1lZCBvciBjcmVhdGVkIG5ldyAoWSlcbiAqICAyLiB0aGUgb3JkZXIgd2lsbCBiZSBzYW1lIGFzIGluIHRoZSBET00gKFkpXG4gKiAgY29uOiB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgdGhlIERPTSBpcyByZW5kZXJlZCAtIG90aGVyd2lzZSBlbGVtZW50cyB3aWxsIGJlIG1pc3NpbmdcbiAqXG4gKiAgV2UgbmVlZDpcbiAqICAqIERPTSByZW5kZXIgc3VjY2VzcyBldmVudCAodGhlIHRyYW5zbGF0aW9uVmlldyBjb250cm9sbGVyIGhhcyB0byB0aHJvdyBpdCkgKHNvIGZhciB0aGUgY29udHJvbGxlciBpcyBhZGRlZCBhZnRlciB0aGUgdHJhbnNsYXRpb25Db250cm9sbGVyIGl0IGxvb2tzIGxpa2UgdGhhdCB0aGlzIGlzIG5vdCBhbiBpc3N1ZSlcbiAqICAqIGFuIGEgaWYgYW5jaG9yIGlzIGNsaWNrZWQgKGluIHZpZXcpIGV2ZW50IDsgdGhlbiBhbHNvIGZvY3VzIHRoZSBjb3JyZWN0IG1lbnUgcmlnaHQgZWxlbWVudFxuICogICogdGhlIHJpZ2h0IG1lbnUgZWxlbWVudCBpbnRlcmFjdCBvbmx5IGFzIHNjcm9sbCBvdmVydmlldyAtIG5vdCBhcyBhbmNob3IgaGVscGVyIGFzIGl0IGlzIHJpZ2h0IG5vd1xuICpcbiAqIEBwYXJhbSBrZXlzXG4gKi9cblxuYW5jaG9yTWVudS5vblNlbGVjdChmdW5jdGlvbiAoaWQpIHtcbiAgICB2YXIgZG9tID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCArIGlkKTtcbiAgICBpZiAoZG9tKSB7XG4gICAgICAgIHZhciBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgICAgICBlbGVtUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgIG9mZnNldCA9IGVsZW1SZWN0LnRvcCAtIGJvZHlSZWN0LnRvcDtcbiAgICAgICAgd2luZG93LnNjcm9sbFRvKDAsIG9mZnNldCAtIDYwKTtcbiAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2FuY2hvckZvY3VzJywgJyMnICsgaWQpO1xuICAgIH1cbn0pO1xuXG51aUV2ZW50cy5hZGRVaUV2ZW50TGlzdGVuZXIoe1xuICAgIGFuY2hvckZvY3VzIDogZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgIGFuY2hvck1lbnUuZm9jdXNFbGVtZW50KGlkLnJlcGxhY2UoJyMnLCAnJykpO1xuICAgIH1cbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICByZW5hbWVDYXRlZ29yeSA6IGZ1bmN0aW9uIChvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgIGFuY2hvck1lbnUucmVuZGVyTWVudSgpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2F0ZWdvcnk6IGZ1bmN0aW9uKGNhdGVnb3J5TmFtZSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIHJlbmFtZUtleSA6IGZ1bmN0aW9uIChvbGRLZXksIG5ld0tleSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIHJlbW92ZUtleSA6IGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgYW5jaG9yTWVudS5yZW5kZXJNZW51KCk7XG4gICAgfSxcbiAgICBvbkNyZWF0ZUtleSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYW5jaG9yTWVudS5yZW5kZXJNZW51KCk7XG4gICAgfSxcbiAgICBvbktleUNsb25lZCA6IGZ1bmN0aW9uKHByb2plY3RJZCwgZGF0YSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIFdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIGNvbXBsZXRlIEpTT04gb2JqZWN0IGZyb20gYSBzcGVjaWZpYyBwcm9qZWN0XG4gICAgICogQHBhcmFtIHByb2plY3REYXRhXG4gICAgICovXG4gICAgb25Mb2FkUHJvamVjdCA6IGZ1bmN0aW9uIChwcm9qZWN0RGF0YSkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9LFxuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICBhbmNob3JNZW51LnJlbmRlck1lbnUoKTtcbiAgICB9XG59OyIsInZhciBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55Jyk7XG5cbi8qKlxuICoganVzdCB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhbGxiYWNrc1xuICovXG5cbi8qKlxuICogQXBwbHkgcHJvamVjdCBkZXNjcmlwdGlvbiBkYXRhIHRvIGRvbSBlbGVtZW50c1xuICogQHBhcmFtIGRhdGE6IFByb2plY3QgY29uZmlndXJhdGlvbiBkYXRhXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UHJvamVjdERhdGEoZGF0YSwgcHJvamVjdCkge1xuICAgIGlmIChwcm9qZWN0Lmhhc093blByb3BlcnR5KCduYW1lJykpIHtcbiAgICAgICAgLy8gcHJvamVjdCBzcGVjaWZpYyBjb25maWdcbiAgICAgICAgY2FubnkudGV4dHMuc2V0VGV4dHMoe3Byb2plY3ROYW1lIDogcHJvamVjdC5uYW1lfSlcbiAgICB9XG5cbiAgICAvLyBGSVhNRTogQ2F0ZWdvcmllcyBzaG91bGQgbm90IGJlIG5hbWVkIFwiX19kZXNjcmlwdGlvblwiIGFzIHRoZXkgd291bGQgb3ZlcnJpZGUgdGhlIHByb2plY3QgZGVzY3JpcHRpb25cbiAgICBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgna2V5RGVzY3JpcHRpb25zJykpIHtcbiAgICAgICAgLy8gcHJvamVjdCBzcGVjaWZpYyBjb25maWcgLSBpZiBwcm9wZXJ0eSBpcyBwcmVzZW50XG4gICAgICAgIGNhbm55LnRleHRzLnNldFRleHRzKHtcbiAgICAgICAgICAgIHByb2plY3REZXNjcmlwdGlvbiA6IChkYXRhLmtleURlc2NyaXB0aW9uc1snX19kZXNjcmlwdGlvbiddID8gZGF0YS5rZXlEZXNjcmlwdGlvbnNbJ19fZGVzY3JpcHRpb24nXSA6ICcnKVxuICAgICAgICB9KTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTG9hZFByb2plY3QgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTmV3RGlyZWN0b3J5Q3JlYXRlZCA6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgY2FubnkudGV4dHMuc2V0VGV4dHMoe1xuICAgICAgICAgICAgcHJvamVjdE5hbWUgOiBkYXRhLmRpcmVjdG9yeUlkXG4gICAgICAgIH0pO1xuICAgIH1cbn07IiwidmFyIGNhbm55ID0gcmVxdWlyZSgnY2FubnknKSxcbiAgICBkb21PcHRzID0gcmVxdWlyZSgnZG9tLW9wdHMnKSxcbiAgICB0cmFkZSA9IHJlcXVpcmUoJy4uL3RyYWRlLmpzJyksXG4gICAgZXZlbnRzID0gcmVxdWlyZSgnLi4vZXZlbnRzLmpzJyksXG4gICAgdWlFdmVudHMgPSByZXF1aXJlKCcuLi91aUV2ZW50TWFuYWdlci5qcycpLFxuICAgIGtleVZhbHVlQ291bnRlciA9IHtcbiAgICAgICAgcHJvamVjdE1hcCA6IHt9LFxuICAgICAgICBnZXRDb3VudE9iaiA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAga2V5TWFwIDoge30sIC8vIGp1c3QgY29sbGVjdCBhbGwgdW5pcXVlIGtleXMgZm9yIGdldHRpbmcgdG90YWwgbnVtYmVyIG9mIGV4aXN0aW5nIGtleXNcbiAgICAgICAgICAgICAgICBsYW5nTWFwIDoge30gICAvLyBzYXZlIGZvciBlYWNoIGxhbmd1YWdlIGFsbCBcInZhbGlkXCIga2V5c1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSxcbiAgICBwcm9qZWN0Q29uZmlnID0ge30sXG4gICAgcHJvamVjdEluZm8gPSB7fSxcbiAgICBhdmFpbGFibGVMYW5ndWFnZXMgPSBbXTtcblxuY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLm9uTGFuZ3VhZ2VTZWxlY3QoZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBldmVudE5hbWU7XG4gICAgaWYgKG9iai5pc0FjdGl2ZSkge1xuICAgICAgICAgZXZlbnROYW1lID0gb2JqLmlzSW5hY3RpdmUgPyAnZGVBY3RpdmF0ZUxhbmd1YWdlJyA6ICdhY3RpdmF0ZUxhbmd1YWdlJztcbiAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KGV2ZW50TmFtZSwgb2JqLmxhbmd1YWdlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2FkZExhbmd1YWdlJywgb2JqLmxhbmd1YWdlKTtcbiAgICB9XG4gICAgY29uc29sZS5sb2coJ0NsaWNrIG9uIGxhbmd1YWdlJywgb2JqKTtcbn0pO1xuXG4oZnVuY3Rpb24gKCkge1xuICAgIHZhciBlZGl0b3JNb2RlRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLm9uRW5hYmxlRWRpdG9yTW9kZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOm9uRW5hYmxlRWRpdG9yTW9kZSBzaG93IEpTT04gZm9ybWF0IGluIG5ldyB0YWIuJyk7XG4gICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdlbmFibGVFZGl0b3JNb2RlJywgIWVkaXRvck1vZGVFbmFibGVkKTtcbiAgICB9KTtcbiAgICAvL21heWJlIHNvbWVvbmUgZWxzZSBjYWxscyB0aGlzIHRvb1xuICAgIHVpRXZlbnRzLmFkZFVpRXZlbnRMaXN0ZW5lcih7XG4gICAgICAgIGVuYWJsZUVkaXRvck1vZGUgOiBmdW5jdGlvbiAoZW5hYmxlZCkge1xuICAgICAgICAgICAgZWRpdG9yTW9kZUVuYWJsZWQgPSBlbmFibGVkO1xuICAgICAgICB9XG4gICAgfSk7XG5cbn0oKSk7XG5cbihmdW5jdGlvbigpIHtcbiAgICB2YXIgd29yZENvdW50RW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLm9uVG9nZ2xlV29yZENvdW50KGZ1bmN0aW9uKCkge1xuICAgICAgICB3b3JkQ291bnRFbmFibGVkID0gIXdvcmRDb3VudEVuYWJsZWQ7XG4gICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCd0b2dnbGVXb3JkQ291bnQnLCB3b3JkQ291bnRFbmFibGVkKTtcbiAgICB9KTtcbn0oKSk7XG5cbmNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5vblNob3dKU09OKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpvblNob3dKU09OIHNob3cgSlNPTiBmb3JtYXQgaW4gbmV3IHRhYi4nKTtcbiAgICB3aW5kb3cub3BlbihcbiAgICAgICAgJy8nICsgcHJvamVjdEluZm8uaWQgKyAnLmpzb24/Y2F0ZWdvcnk9dHJ1ZScsXG4gICAgICAgICdfYmxhbmsnIC8vIDwtIFRoaXMgaXMgd2hhdCBtYWtlcyBpdCBvcGVuIGluIGEgbmV3IHdpbmRvdy5cbiAgICApO1xufSk7XG5cbmNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5vblNob3dKTUJGVXBsb2FkZXIoZnVuY3Rpb24gKCkge1xuICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOm9uU2hvd0pNQkZVcGxvYWRlciBzaG93IG1lc3NhZ2UgYnVuZGxlIHVwbG9hZGVyJyk7XG4gICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3Nob3dKTUJGVXBsb2FkZXInKVxufSk7XG5cbmNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5vblNob3dKU09OSW1wb3J0KGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpvblNob3dKU09OSW1wb3J0IHNob3cgSlNPTiBpbXBvcnQgb3ZlcmxheScpO1xuICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdzaG93SlNPTkltcG9ydCcpO1xufSk7XG5cbmNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5vblNob3dKTUJGKGZ1bmN0aW9uICgpIHtcbiAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpvblNob3dKTUJGIHNob3cgSk1CRiBmb3JtYXQgaW4gbmV3IHRhYi4nKTtcblxuICAgIHZhciBsYW5nID0gd2luZG93LnByb21wdCgnRW50ZXIgYSBsYW5ndWFnZSBjb2RlLiBFLmcuOiAnICsgIChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdMYW5ndWFnZXMgPSBbXTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKHByb2plY3RDb25maWcua2V5cykuZm9yRWFjaChmdW5jdGlvbiAobGFuZykge1xuICAgICAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ10pLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdMYW5ndWFnZXMucHVzaChsYW5nKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nTGFuZ3VhZ2VzO1xuICAgICAgICB9KCkpLmpvaW4oJywgJykpO1xuXG4gICAgaWYgKGxhbmcgIT09IG51bGwpIHtcbiAgICAgICAgd2luZG93Lm9wZW4oXG4gICAgICAgICAgICAnLycgKyBwcm9qZWN0SW5mby5pZCArICcucHJvcGVydGllcycgKyAobGFuZyAhPT0gJycgPyAnP2xhbmc9JyArIGxhbmcgOiAnJyksXG4gICAgICAgICAgICAnX2JsYW5rJyAvLyA8LSBUaGlzIGlzIHdoYXQgbWFrZXMgaXQgb3BlbiBpbiBhIG5ldyB3aW5kb3cuXG4gICAgICAgICk7XG4gICAgfVxufSk7XG5cbi8qKlxuICogc2VydmVyIGV2ZW50IGxpc3RlbmVyXG4gKi9cbmV2ZW50cy5hZGRTZXJ2ZXJMaXN0ZW5lcignbmV3UHJvamVjdFdhc0NyZWF0ZWQnLCBmdW5jdGlvbiAocHJvamVjdE5hbWUpIHtcbiAgICB0b2FzdC5zaG93TWVzc2FnZSgnQSBuZXcgcHJvamVjdCB3aXRoIG5hbWU6IFwiJyArIHByb2plY3ROYW1lICsgJ1wiIHdhcyBjcmVhdGVkLicpO1xufSk7XG4vKipcbiAqIHNlcnZlciBldmVudCBsaXN0ZW5lclxuICovXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ2tleVVwZGF0ZWQnLCBmdW5jdGlvbiAocHJvamVjdElkLCBsYW5ndWFnZSwga2V5TmFtZSwga2V5VmFsdWUpIHtcbiAgICAvLyBUT0RPIG1vcmUgY2xpZW50IGNoYW5nZXMgYXJlIGNvbWluZywgd2UnbGwgZmluaXNoIHRoZSBjb2RlIGJlbG93IHRoZW5cbiAgICAvL2lmIChwcm9qZWN0SWQgPT09IGN1cnJlbnRQcm9qZWN0SWQpIHtcbiAgICAvLyAgICB2YXIgcHJvamVjdE5hbWUgPSBwcm9qZWN0SWQuc3Vic3RyaW5nKHByb2plY3RJZC5sYXN0SW5kZXhPZignLycpICsgMSk7XG4gICAgLy8gICAgdXBkYXRlS2V5VG9Qcm9qZWN0TWFwKHByb2plY3ROYW1lLCBsYW5ndWFnZSwga2V5TmFtZSwga2V5VmFsdWUpO1xuICAgIC8vICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOnVwZGF0ZUtleScsIHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleU5hbWUsIGtleVZhbHVlKTtcbiAgICAvL31cbn0pO1xuLyoqXG4gKiBzZXJ2ZXIgZXZlbnQgbGlzdGVuZXJcbiAqL1xuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdrZXlEZWxldGVkJywgZnVuY3Rpb24gKGJ1bmRsZU5hbWUsIG9iaikge1xuICAgIC8vIFRPRE8gbW9yZSBjbGllbnQgY2hhbmdlcyBhcmUgY29taW5nLCB3ZSdsbCBmaW5pc2ggdGhlIGNvZGUgYmVsb3cgdGhlblxuICAgIC8vaWYgKGJ1bmRsZU5hbWUgPT09IHByb2plY3RDb25maWcucHJvamVjdCkge1xuICAgIC8vICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOmtleVJlbmFtZWQnLCBidW5kbGVOYW1lLCBvYmopO1xuICAgIC8vICAgIC8vIFRPRE8gdXBkYXRlIHRoZSBzdGF0aXN0aWNzLi4uXG4gICAgLy99XG59KTtcblxuLyoqXG4gKlxuICogQHBhcmFtIHByb2plY3ROYW1lXG4gKiBAcGFyYW0gbGFuZ1xuICogQHBhcmFtIGtleVxuICogQHBhcmFtIHZhbHVlXG4gKi9cbmZ1bmN0aW9uIHNhdmVLZXlUb1Byb2plY3RNYXAocHJvamVjdE5hbWUsIGxhbmcsIGtleSwgdmFsdWUpIHtcblxuICAgIC8vIGp1c3QgY29sbGVjdCBhbGwga2V5cyAob25seSB0aGUgdW5pcXVlIGtleXMgYXJlIHJlbGV2YW50KVxuICAgIGlmIChrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpzYXZlS2V5VG9Qcm9qZWN0TWFwIHByb2plY3QgbmFtZSBub3QgZXhpc3RzOicsIHByb2plY3ROYW1lKTtcbiAgICAgICAga2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdID0ga2V5VmFsdWVDb3VudGVyLmdldENvdW50T2JqKCk7XG4gICAgfVxuXG4gICAga2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdLmtleU1hcFtrZXldID0gdHJ1ZTtcbiAgICBpZiAoa2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdLmxhbmdNYXBbbGFuZ10gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0ubGFuZ01hcFtsYW5nXSA9IHt9O1xuICAgIH1cbiAgICAvLyBvbmx5IHNhdmUgdGhlIGtleXMgYXMgb2JqZWN0IGlmIGl0IGlzIGEgdmFsaWQga2V5IG90aGVyd2lzZSBkZWxldGUgaXRcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgICAga2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdLmxhbmdNYXBbbGFuZ11ba2V5XSA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0ubGFuZ01hcFtsYW5nXVtrZXldKSB7XG4gICAgICAgIC8vIGlmIHRoaXMga2V5IGV4aXN0cyB0aGFuIHJlbW92ZSBpdFxuICAgICAgICBkZWxldGUga2V5VmFsdWVDb3VudGVyLnByb2plY3RNYXBbcHJvamVjdE5hbWVdLmxhbmdNYXBbbGFuZ11ba2V5XTtcbiAgICB9XG59XG5cbi8vIFRPRE8gc2hvdWxkIHVzZSBwcm9qZWN0SWQsIG5vdCBwcm9qZWN0TmFtZVxuZnVuY3Rpb24gdXBkYXRlS2V5VG9Qcm9qZWN0TWFwKHByb2plY3ROYW1lLCBsYW5nLCBrZXksIHZhbHVlKSB7XG4gICAgc2F2ZUtleVRvUHJvamVjdE1hcChwcm9qZWN0TmFtZSwgbGFuZywga2V5LCB2YWx1ZSk7XG4gICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLnNldE51bWJlck9mVHJhbnNsYXRlZExhbmd1YWdlS2V5KE9iamVjdC5rZXlzKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3ROYW1lXS5sYW5nTWFwW2xhbmddKS5sZW5ndGgsIGxhbmcpO1xuICAgIGNhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5zZXROdW1iZXJPZlRyYW5zbGF0aW9uTWF4S2V5cyhPYmplY3Qua2V5cyhrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0TmFtZV0ua2V5TWFwKS5sZW5ndGgpO1xufVxuXG4vLyByZWdpc3RlciBsaXN0ZW5lciBmdW5jdGlvbiB0byB0aGUgdWkgZXZlbnRzXG51aUV2ZW50cy5hZGRVaUV2ZW50TGlzdGVuZXIoe1xuICAgIC8qKlxuICAgICAqIHRoZSBpbnRlcm5hbCB1cGRhdGVLZXkgZXZlbnQgLSB0aGUgc2VydmVyIHdpbGwgbm90IHRyaWdnZXIgdGhlIHVwZGF0ZUtleSBmb3IgdGhlIG93biBjbGllbnRcbiAgICAgKi9cbiAgICB1cGRhdGVLZXkgOiBmdW5jdGlvbiAocHJvamVjdE5hbWUsIGxhbmcsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6dXBkYXRlS2V5JywgcHJvamVjdE5hbWUsIGxhbmcsIGtleSwgdmFsdWUpO1xuICAgICAgICB1cGRhdGVLZXlUb1Byb2plY3RNYXAocHJvamVjdE5hbWUsIGxhbmcsIGtleSwgdmFsdWUpO1xuICAgIH0sXG4gICAgcHJvamVjdFNlbGVjdGVkIDogZnVuY3Rpb24gKHByb2plY3RJZCkge1xuICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpwcm9qZWN0U2VsZWN0ZWQgQ2xpY2sgb24gcHJvamVjdCcsIHByb2plY3RJZCk7XG4gICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KHByb2plY3RJZCwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6bG9hZFByb2plY3QgZmFpbHMgZm9yIHByb2plY3RJZDonLCBwcm9qZWN0SWQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGFjdGl2YXRlTGFuZ3VhZ2UgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uYWN0aXZhdGVMYW5nKGxhbmcpO1xuICAgIH0sXG4gICAgZGVBY3RpdmF0ZUxhbmd1YWdlIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLmRlQWN0aXZhdGVMYW5nKGxhbmcpO1xuICAgIH0sXG4gICAgYWRkTGFuZ3VhZ2UgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uYWN0aXZhdGVMYW5nKGxhbmcpO1xuICAgIH1cbn0pO1xuXG5mdW5jdGlvbiBjb21wdXRlVG90YWxUcmFuc2xhdGlvblByb2dyZWUodHJhbnNsYXRpb25zKSB7XG4gICAgdmFyIHRvdGFsUHJvZ3Jlc3MgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnNbbGFuZ10pLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgdG90YWxQcm9ncmVzc1trZXldID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModG90YWxQcm9ncmVzcykubGVuZ3RoO1xuXG59XG5cbmZ1bmN0aW9uIGNvbXB1dGVUcmFuc2xhdGlvblByb2dyZXNzKHRyYW5zbGF0aW9ucykge1xuICAgIHZhciBwcm9ncmVzc0J5TGFuZ3VhZ2UgPSB7fTtcbiAgICBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnMpLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICBwcm9ncmVzc0J5TGFuZ3VhZ2VbbGFuZ10gPSBPYmplY3Qua2V5cyh0cmFuc2xhdGlvbnNbbGFuZ10pLmxlbmd0aDtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJvZ3Jlc3NCeUxhbmd1YWdlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIHRoZSBvbkxvYWRQcm9qZWN0ICYgb25OZXdQcm9qZWN0Q3JlYXRlZFxuICogQHBhcmFtIHByb2plY3REYXRhIChzZWUgcHJvamVjdCBKU09OIGZpbGUpXG4gKi9cbmZ1bmN0aW9uIGFwcGx5UHJvamVjdERhdGEoZGF0YSwgcHJvamVjdCkge1xuICAgIHByb2plY3RDb25maWcgPSBkYXRhO1xuICAgIHByb2plY3RJbmZvID0gcHJvamVjdFxuXG4gICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLnNldEF2YWlsYWJsZUxhbmd1YWdlcyhkYXRhLmF2YWlsYWJsZUxhbmd1YWdlcyk7XG5cbiAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uc2V0QWN0aXZhdGVkUHJvamVjdExhbmd1YWdlcyhcbiAgICAgICAgY29tcHV0ZVRvdGFsVHJhbnNsYXRpb25Qcm9ncmVlKGRhdGEua2V5cyksIGNvbXB1dGVUcmFuc2xhdGlvblByb2dyZXNzKGRhdGEua2V5cykpO1xuXG4gICAgT2JqZWN0LmtleXMoZGF0YS5rZXlzKS5mb3JFYWNoKGZ1bmN0aW9uIChsYW5nKSB7XG4gICAgICAgIGlmIChPYmplY3Qua2V5cyhkYXRhLmtleXNbbGFuZ10pLmxlbmd0aCA+IDAgJiYgYXZhaWxhYmxlTGFuZ3VhZ2VzLmluZGV4T2YobGFuZykgIT09IC0xKSB7XG5cbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGRhdGEua2V5c1tsYW5nXSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgc2F2ZUtleVRvUHJvamVjdE1hcChkYXRhLnByb2plY3QsIGxhbmcsIGtleSwgZGF0YS5rZXlzW2xhbmddW2tleV0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIGlmIChrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtkYXRhLnByb2plY3RdLmxhbmdNYXBbbGFuZ10pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uQ29udHJvbGxlcjpvbkxvYWRQcm9qZWN0ICcsIGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW2RhdGEucHJvamVjdF0ubGFuZ01hcFtsYW5nXSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3Byb2plY3RNYWluTmF2aWdhdGlvbkNvbnRyb2xsZXI6b25Mb2FkUHJvamVjdCBtYXhLZXlzIGFyZScsIE9iamVjdC5rZXlzKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW2RhdGEucHJvamVjdF0ua2V5TWFwKS5sZW5ndGgpO1xuXHRcdFx0XHQvL2Nhbm55LnByb2plY3RNYWluTmF2aWdhdGlvbi5zZXROdW1iZXJPZlRyYW5zbGF0aW9uTWF4S2V5cyhPYmplY3Qua2V5cyhrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtwcm9qZWN0RGF0YS5wcm9qZWN0XS5rZXlNYXApLmxlbmd0aCk7XG5cdFx0XHRcdC8vY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLnNldE51bWJlck9mVHJhbnNsYXRlZExhbmd1YWdlS2V5KE9iamVjdC5rZXlzKGtleVZhbHVlQ291bnRlci5wcm9qZWN0TWFwW3Byb2plY3REYXRhLnByb2plY3RdLmxhbmdNYXBbbGFuZ10pLmxlbmd0aCwgbGFuZyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZWZhY3RvciB0aGlzIGFuZCBtYWtlIG9uZSBjYWxsIDspXG4gICAgICAgICAgICAgICAgY2FubnkucHJvamVjdE1haW5OYXZpZ2F0aW9uLmFjdGl2YXRlTGFuZyhsYW5nKTtcbiAgICAgICAgICAgICAgICBjYW5ueS5wcm9qZWN0TWFpbk5hdmlnYXRpb24uZGVBY3RpdmF0ZUxhbmcobGFuZyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyOm9uTG9hZFByb2plY3QgZ2V0IGxhbmd1YWdlIHdpdGhvdXQgYW55IGtleXMgZm9yIGxvY2FsZTonLCBsYW5nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gcmVzZXQgb3IgcmVpbml0aWFsaXplIG9yIGluaXRpYWxpemUgdGhlIGtleSB2YWx1ZSBjb3VudGVyIChvdGhlcndpc2UgdGhlIGNvdW50ZXIgY2FuJ3QgZGV0ZWN0IGRlbGV0ZWQga2V5cy4gRS5nLiBmcm9tIHRoZSBlZGl0b3IgbW9kZSlcbiAgICBrZXlWYWx1ZUNvdW50ZXIucHJvamVjdE1hcFtkYXRhLnByb2plY3RdID0ga2V5VmFsdWVDb3VudGVyLmdldENvdW50T2JqKCk7XG4gICAgLy8gc2hvdyBkZWZhdWx0IGxhbmd1YWdlIGFzIHNlbGVjdGVkIGxhbmd1YWdlIGluIG1lbnVcbiAgICAvLyBUT0RPIGNoZWNrIHdobyBkZWNpZGVzIHRvIHNob3cgd2hpY2ggbGFuZ3VhZ2UgYXMgZGVmYXVsdCAtIGFuZCB0aGVuIGNhbGwgdGhpcyBldmVudCBmcm9tIHRoZXJlXG4gICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ2FjdGl2YXRlTGFuZ3VhZ2UnLCBkYXRhLmRlZmF1bHRMYW5ndWFnZSk7XG59XG5cbi8qKlxuICogdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjYWxsYmFja3NcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25OZXdQcm9qZWN0Q3JlYXRlZCA6IGFwcGx5UHJvamVjdERhdGEsXG4gICAgb25Mb2FkUHJvamVjdCA6IGFwcGx5UHJvamVjdERhdGFcbn07IiwidmFyIHByb2plY3RPdmVydmlldyA9IHJlcXVpcmUoJ2Nhbm55JykucHJvamVjdE92ZXJ2aWV3LFxuICAgIGRpc3BsYXlNYW5hZ2VyID0gcmVxdWlyZSgnY2FubnknKS5kaXNwbGF5TWFuYWdlcixcbiAgICB0cmFkZSA9IHJlcXVpcmUoJy4uL3RyYWRlLmpzJyksXG4gICAgdWlFdmVudHMgPSByZXF1aXJlKCcuLi91aUV2ZW50TWFuYWdlci5qcycpLFxuICAgIGNhbm55ID0gcmVxdWlyZSgnY2FubnknKSxcbiAgICB0b2FzdCA9IHJlcXVpcmUoJy4uL1RvYXN0LmpzJyksXG4gICAgZXZlbnRzID0gcmVxdWlyZSgnLi4vZXZlbnRzLmpzJyk7XG5cbnZhciBwcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyID0gKGZ1bmN0aW9uKCkge1xuXG4gICAgdmFyIGN1cnJlbnRQYXJlbnREaXJlY3RvcnksXG4gICAgICAgIGN1cnJlbnREaXJlY3RvcnksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNYXBzIHByb2plY3QgbmFtZXMgdG8gcHJvamVjdHMgSURzXG4gICAgICAgICAqL1xuICAgICAgICBwcm9qZWN0cyxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE1hcHMgZGlyZWN0b3J5IG5hbWVzIHRvIGRpcmVjdG9yeSBJRHNcbiAgICAgICAgICovXG4gICAgICAgIGRpcmVjdG9yaWVzO1xuXG4gICAgdWlFdmVudHMuYWRkVWlFdmVudExpc3RlbmVyKHtcbiAgICAgICAgc2hvd092ZXJ2aWV3UGFnZSA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3Byb2plY3RzT3ZlcnZpZXcnKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uUGFyZW50RGlyZWN0b3J5U2VsZWN0ZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChjdXJyZW50UGFyZW50RGlyZWN0b3J5ICE9PSBjdXJyZW50RGlyZWN0b3J5KSB7XG4gICAgICAgICAgICB0cmFkZS5nZXREaXJlY3RvcnkoY3VycmVudFBhcmVudERpcmVjdG9yeSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnTm8gcGFyZW50IGRpcmVjdG9yeScpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICBwcm9qZWN0T3ZlcnZpZXcub25Qcm9qZWN0U2VsZWN0ZWQoZnVuY3Rpb24ocHJvamVjdE5hbWUpIHtcbiAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3Byb2plY3RTZWxlY3RlZCcsIHByb2plY3RzW3Byb2plY3ROYW1lXSk7XG4gICAgfSk7XG5cbiAgICBwcm9qZWN0T3ZlcnZpZXcub25EaXJlY3RvcnlTZWxlY3RlZChmdW5jdGlvbihkaXJlY3RvcnlOYW1lKSB7XG4gICAgICAgIHZhciBkaXJlY3RvcnlJZCA9IGRpcmVjdG9yaWVzW2RpcmVjdG9yeU5hbWVdO1xuICAgICAgICB0cmFkZS5nZXREaXJlY3RvcnkoZGlyZWN0b3J5SWQsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwcm9qZWN0T3ZlcnZpZXdDb250cm9sbGVyOmNhbiBub3QgbG9hZCBwcm9qZWN0IGZvciBkaXJlY3RvcnkgbmFtZTonLCBkaXJlY3RvcnlJZCk7XG4gICAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgcHJvamVjdE92ZXJ2aWV3Lm9uQ3JlYXRlUHJvamVjdFByZXNzZWQoZnVuY3Rpb24oKSB7XG4gICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ2NyZWF0ZU5ld1Byb2plY3RWaWV3Jyk7XG4gICAgfSk7XG5cbiAgICBwcm9qZWN0T3ZlcnZpZXcub25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkKGZ1bmN0aW9uKCkge1xuICAgICAgICBkaXNwbGF5TWFuYWdlci5zaG93KCdjcmVhdGVOZXdEaXJlY3RvcnlWaWV3Jyk7XG4gICAgfSk7XG5cbiAgICBwcm9qZWN0T3ZlcnZpZXcub25EZWxldGVGb2xkZXJQcmVzc2VkKGZ1bmN0aW9uKGRpck5hbWUpIHtcbiAgICAgICAgdHJhZGUuZGVsZXRlRm9sZGVyKGRpck5hbWUsIGN1cnJlbnREaXJlY3RvcnksIGZ1bmN0aW9uKGVyciwgZGlyTmFtZSkge1xuICAgICAgICAgICAgdmFyIHRvYXN0TWVzc2FnZTtcbiAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgcHJvamVjdE92ZXJ2aWV3LmRlbGV0ZVByb2plY3RMaXN0Tm9kZShkaXJOYW1lKTtcbiAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UgPSAnRm9sZGVyIFwiJyArIGRpck5hbWUgKyAnXCIgaGFzIGJlZW4gZGVsZXRlZC4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UgPSAnVGhlcmUgd2FzIGFuIGVycm9yOiBcIicgKyBlcnIubWVzc2FnZSArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSh0b2FzdE1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIHByb2plY3RPdmVydmlldy5vbkRlbGV0ZVByb2plY3RQcmVzc2VkKGZ1bmN0aW9uKHByb2plY3ROYW1lKSB7XG4gICAgICAgIHRyYWRlLmRlbGV0ZVByb2plY3QocHJvamVjdHNbcHJvamVjdE5hbWVdLCBmdW5jdGlvbihlcnIsIHByb2plY3QpIHtcbiAgICAgICAgICAgIHZhciB0b2FzdE1lc3NhZ2U7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIHByb2plY3RPdmVydmlldy5kZWxldGVQcm9qZWN0TGlzdE5vZGUocHJvamVjdC5uYW1lKTtcbiAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UgPSAnUHJvamVjdCBcIicgKyBwcm9qZWN0Lm5hbWUgKyAnXCIgaGFzIGJlZW4gZGVsZXRlZC4nO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0b2FzdE1lc3NhZ2UgPSAnVGhlcmUgd2FzIGFuIGVycm9yOiBcIicgKyBlcnIubWVzc2FnZSArICdcIic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSh0b2FzdE1lc3NhZ2UpO1xuICAgICAgICB9KTtcbiAgICB9KTtcblxuICAgIGV2ZW50cy5hZGRTZXJ2ZXJMaXN0ZW5lcignbmV3RGlyZWN0b3J5Q3JlYXRlZCcsIGZ1bmN0aW9uIChkaXJlY3RvcnlJZCkge1xuICAgICAgICB2YXIgbGFzdERpclNlcElkeCA9IGRpcmVjdG9yeUlkLmxhc3RJbmRleE9mKCcvJyk7XG4gICAgICAgIHZhciBwYXJlbnREaXJlY3RvcnkgPSBkaXJlY3RvcnlJZC5zdWJzdHJpbmcoMCwgbGFzdERpclNlcElkeCArIDEpO1xuICAgICAgICBpZiAocGFyZW50RGlyZWN0b3J5ID09PSBjdXJyZW50UGFyZW50RGlyZWN0b3J5KSB7XG4gICAgICAgICAgICB2YXIgZGlyZWN0b3J5TmFtZSA9IGRpcmVjdG9yeUlkLnN1YnN0cmluZyhsYXN0RGlyU2VwSWR4ICsgMSk7XG4gICAgICAgICAgICBkaXJlY3Rvcmllc1tkaXJlY3RvcnlOYW1lXSA9IGRpcmVjdG9yeUlkO1xuICAgICAgICAgICAgLy8gVE9ETyBzaG93IG1lc3NhZ2Ugb25seSBpZiBwcm9qZWN0T3ZlcnZpZXcgaXMgY3VycmVudGx5IHZpc2libGUgLSBidXQgY2FubnkuZmxvd2NvbnRyb2wgY3VycmVudGx5IGRvZXMgbm90XG4gICAgICAgICAgICAvLyBoYXZlIGFueXRoaW5nIHRvIGZpbmQgb3V0IHdoaWNoIHZpZXcgaXMgdGhlIGFjdGl2ZSBvbmVcbiAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdBIG5ldyBkaXJlY3RvcnkgXCInICsgZGlyZWN0b3J5TmFtZSArICdcIiBoYXMgYmVlbiBjcmVhdGVkIGJ5IGFub3RoZXIgdXNlci4nKTtcbiAgICAgICAgICAgIHByb2plY3RPdmVydmlldy5zZXRQcm9qZWN0c0FuZERpcmVjdG9yaWVzKE9iamVjdC5rZXlzKHByb2plY3RzKSwgT2JqZWN0LmtleXMoZGlyZWN0b3JpZXMpKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxiYWNrIGZyb20gdGhlIHNlcnZlciB3aGljaCBoYW5kbGVzIGEgZnJlc2ggZGlyZWN0b3J5L3Byb2plY3RzIGxpc3RcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHt7Y3VycmVudERpcmVjdG9yeTpzdHJpbmcsIGRpcnM6W3tuYW1lLCBpZH1dLCBwYXJlbnREaXJlY3Rvcmllczpbe25hbWUsIGlkfV0sIHBhcmVudERpcmVjdG9yeTpzdHJpbmcsIHByb2plY3RzOlt7bmFtZSwgaWR9XSB9fSBkYXRhIC0gYW4gb2JqZWN0IHdpdGggMiBwcm9wZXJ0aWVzIFwicHJvamVjdHNcIiBhbmQgXCJkaXJlY3Rvcmllc1wiLCBlYWNoIGxpc3RpbmcgcHJvamVjdC9kaXJlY3RvcnkgbmFtZXMuXG4gICAgICAgICAqL1xuICAgICAgICBnZXREaXJlY3Rvcnk6IGZ1bmN0aW9uIChkYXRhLCBwcm9qZWN0KSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnUHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlci5nZXREaXJlY3Rvcnk6ICcsIGRhdGEpO1xuICAgICAgICAgICAgaWYgKGRhdGEgPT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIlNlcnZlciBjYWxsIGZhaWxlZFwiKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZGF0YS5oYXNPd25Qcm9wZXJ0eSgncHJvamVjdHMnKSAmJiBkYXRhLmhhc093blByb3BlcnR5KCdkaXJzJykpIHtcblxuICAgICAgICAgICAgICAgIHByb2plY3RzID0ge307XG4gICAgICAgICAgICAgICAgZGF0YS5wcm9qZWN0cy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2plY3RzW2VudHJ5Lm5hbWVdID0gZW50cnkuaWQ7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICBkaXJlY3RvcmllcyA9IHt9O1xuICAgICAgICAgICAgICAgIGRhdGEuZGlycy5mb3JFYWNoKGZ1bmN0aW9uKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgICAgZGlyZWN0b3JpZXNbZW50cnkubmFtZV0gPSBlbnRyeS5pZDtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHByb2plY3RPdmVydmlldy5zZXRQcm9qZWN0c0FuZERpcmVjdG9yaWVzKE9iamVjdC5rZXlzKHByb2plY3RzKSwgT2JqZWN0LmtleXMoZGlyZWN0b3JpZXMpKTtcbiAgICAgICAgICAgICAgICBjdXJyZW50UGFyZW50RGlyZWN0b3J5ID0gZGF0YS5wYXJlbnREaXJlY3Rvcnk7XG4gICAgICAgICAgICAgICAgY3VycmVudERpcmVjdG9yeSA9IGRhdGEuY3VycmVudERpcmVjdG9yeTtcblxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ0RhdGEgcmN2ZCBmcm9tIHNlcnZlciBpcyBtaXNzaW5nIGV4cGVjdGVkIHByb3BlcnRpZXMgKFwicHJvamVjdHNcIiwgXCJkaXJzXCIpJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIG9uTmV3RGlyZWN0b3J5Q3JlYXRlZCA6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3Byb2plY3RzT3ZlcnZpZXcnKTtcbiAgICAgICAgICAgIHRyYWRlLmdldERpcmVjdG9yeShkYXRhLmRpcmVjdG9yeUlkLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE92ZXJ2aWV3Q29udHJvbGxlci5vbk5ld0RpcmVjdG9yeUNyZWF0ZWQ6IHRyYWRlIGNhbGxiYWNrJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2plY3RPdmVydmlld0NvbnRyb2xsZXI7XG4iLCJ2YXIgdGV4dEVkaXRvciA9IHJlcXVpcmUoJ2Nhbm55JykudGV4dEVkaXRvcixcbiAgICB0cmFkZSA9IHJlcXVpcmUoJy4uL3RyYWRlLmpzJyksXG4gICAgdG9hc3QgPSByZXF1aXJlKCcuLi9Ub2FzdC5qcycpLFxuICAgIGV2ZW50cyA9IHJlcXVpcmUoJy4uL2V2ZW50cy5qcycpLFxuICAgIGN1cnJlbnRQcm9qZWN0SWQ7XG4vKipcbiAqIHJldHVybnMgdGhlIGxhbmd1YWdlIG9yIGZhbHNlXG4gKiBAcGFyYW0gZmlsZU5hbWVcbiAqIEByZXR1cm5zIHsqfVxuICovXG5mdW5jdGlvbiBnZXRMYW5ndWFnZUZyb21GaWxlTmFtZShmaWxlTmFtZSkge1xuICAgIHZhciByZWcgPSAvbWVzc2FnZXNfKC4qKVxcLi4qLi9nLmV4ZWMoZmlsZU5hbWUpO1xuICAgIGlmIChyZWcgJiYgcmVnLmxlbmd0aCA9PT0gMikge1xuICAgICAgICByZXR1cm4gcmVnWzFdO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8qKlxuICogaGFuZGxlIHRoZSBjaGFuZ2UgcHJvamVjdCBkZXNjcmlwdGlvbiBldmVudCBpbiB0aGUgdmlld1xuICovXG50ZXh0RWRpdG9yLm9uQ2hhbmdlKGZ1bmN0aW9uIChpZCwgdmFsdWUsIGZjKSB7XG4gICAgY29uc29sZS5sb2coJ3RleHRFZGl0b3JDb250cm9sbGVyOm9uQ2hhbmdlJywgdmFsdWUpO1xuICAgIGlmIChjdXJyZW50UHJvamVjdElkKSB7XG4gICAgICAgIGlmICghaWQpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gdG8ga2VlcCBiYWNrd2FyZCBmdW5jdGlvbmFsaXR5IHRoaXMgaXMgdGhlIFwibWFpblwiIHByb2plY3QgZGVzY3JpcHRpb24gLSB3aWxsIGJlIGNoYW5nZWQgaW4gZnV0dXJlXG4gICAgICAgICAgICBpZCA9ICdfX2Rlc2NyaXB0aW9uJztcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPIHJlbW92ZSB0aGUgdHZfIGZyb20gdGhlIGlkXG4gICAgICAgIHRyYWRlLnNhdmVQcm9qZWN0RGVzY3JpcHRpb24oY3VycmVudFByb2plY3RJZCwgaWQsIHZhbHVlLCBmdW5jdGlvbiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBmYyh0cnVlKTtcbiAgICAgICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSgnUHJvamVjdCBkZXNjcmlwdGlvbiBjaGFuZ2VkIGZvciBwcm9qZWN0ICcgKyBjdXJyZW50UHJvamVjdElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMoZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59KTtcbi8qKlxuICoganVzdCB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhlIGNhbGxiYWNrc1xuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25Mb2FkUHJvamVjdCA6IGZ1bmN0aW9uIChkYXRhLCB7aWQsIG5hbWUsIHVybH0pIHtcbiAgICAgICAgaWYgKGlkKSBjdXJyZW50UHJvamVjdElkID0gaWRcbiAgICB9XG59OyIsInZhciBjYW5ueSA9IHJlcXVpcmUoXCJjYW5ueVwiKSxcbiAgICB0cmFuc2xhdGlvblZpZXcgPSByZXF1aXJlKCcuLi91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3JyksXG4gICAgdHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQgPSByZXF1aXJlKCcuLi91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQnKSxcbiAgICB3b3JkQ291bnRlciA9IHJlcXVpcmUoJy4uL3V0aWwvd29yZENvdW50ZXInKSxcbiAgICBkb21PcHRzID0gcmVxdWlyZSgnZG9tLW9wdHMnKSxcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyLmpzJyksXG4gICAgZXZlbnRzID0gcmVxdWlyZSgnLi4vZXZlbnRzLmpzJyksXG4gICAgdHJhZGUgPSByZXF1aXJlKCcuLi90cmFkZS5qcycpLFxuICAgIHVybCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsJyksXG4gICAgc29ydEJ5S2V5ID0gZnVuY3Rpb24oYSwgYikge1xuICAgICAgICBpZiAoYS5rZXkgPCBiLmtleSkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhLmtleSA+IGIua2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gMTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9LFxuICAgIHByb2plY3RDb25maWcsXG4gICAgcHJvamVjdEluZm8sXG4gICAgYXZhaWxhYmxlTGFuZ3VhZ2VzID0gW10sXG4gICAgLyoqXG4gICAgICogQW4gb2JqZWN0ICh1c2VkIGFzIGEgc2V0IGRhdGFzdHJ1Y3R1cmUgaGVyZSkgaG9sZGluZyBhbGwgZXhpc3Rpbmcga2V5cyBvZiB0aGUgcHJvamVjdCAobm8gbWF0dGVyIGZvciBob3cgbWFueVxuICAgICAqIGxhbmd1YWdlcyBpdCBpcyB1c2VkKS4gSXQgaXMgbmVlZGVkIHdoZW4gYWRkaW5nIGEgbmV3IGxhbmd1YWdlLCBzZWUgdGhlIGZ1bmN0aW9uIGZvciBhZGRMYW5ndWFnZSB3aGljaCBpcyBhZGRlZFxuICAgICAqIHRvIHVpRXZlbnRzLlxuICAgICAqIEB0eXBlIHt7fX1cbiAgICAgKi9cbiAgICBleGlzdGluZ0tleXMgPSB7fTtcblxudHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQub25VcGxvYWRCdXR0b24oZnVuY3Rpb24oaWQpIHtcbiAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnc2hvd0ZpbGVVcGxvYWQnLCBpZCk7XG59KTtcblxudHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQub25EZWxldGVCdXR0b24oZnVuY3Rpb24oaWQpIHtcbiAgICBpZiAoY29uZmlybSgnRGVsZXRlIHRoZSBpbWFnZSBmb3IgY2F0ZWdvcnkgwrsgJyArIGlkICsgJyDCqyBmb3JldmVyPycpKSB7XG4gICAgICAgIHRyYWRlLnJlbW92ZUltYWdlKHByb2plY3RDb25maWcucHJvamVjdElkLCBpZCk7XG4gICAgfVxufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vbkNhdGVnb3J5Q2xpY2tlZChmdW5jdGlvbihpZCkge1xuICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCdhbmNob3JGb2N1cycsICcjJyArIGlkKTtcbn0pO1xuLyoqXG4gKiBTZXR1cCB0aGUgVUkgZXZlbnRzIGFuZCBtYW5hZ2UgdGhlIGxvZ2ljIGZvciB0aGVtLlxuICpcbiAqIFRPRE8gcmVwbGFjZSBidW5kbGUgd2l0aCBsb2NhbGUgYW5kIHJlZmFjdG9yIHRoZSBjYWxscyBmcm9tIHRyYW5zbGF0aW9uVmlld1xuICovXG50cmFuc2xhdGlvblZpZXcub25TYXZlS2V5KGZ1bmN0aW9uKGtleSwgbGFuZywgdmFsdWUpIHtcblxuICAgIC8vIFRPRE86IENvdW50IHdvcmRzIGFuZCB0ZWxsIHdvcmQgY291bnQgbGFiZWwgdG8gdXBkYXRlXG5cbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvblNhdmVWYWx1ZScsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgdHJhZGUuc2F2ZUtleShcbiAgICAgICAgcHJvamVjdENvbmZpZy5wcm9qZWN0SWQsXG4gICAgICAgIGxhbmcgfHwgcHJvamVjdENvbmZpZy5kZWZhdWx0TGFuZ3VhZ2UsXG4gICAgICAgIHtcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlIHx8IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICBmdW5jdGlvbihwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICB2YXIgY2F0SWQ7XG5cbiAgICAgICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHByb2plY3RDb25maWcucHJvamVjdElkKSB7IC8vIHByZXZlbnQgYXBwbHlpbmcgdGhlIGNhbGxiYWNrIGlmIHByb2plY3QgaGFzIGJlZW4gY2hhbmdlZCBpbiB0aGUgbWVhbnRpbWVcbiAgICAgICAgICAgICAgICBjYXRJZCA9IGtleS5zcGxpdCgnXycpWzBdO1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nS2V5c1trZXldID0gdW5kZWZpbmVkOyAvLyBzYXZlIHRoZSBrZXlcbiAgICAgICAgICAgICAgICBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ11ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uVmlldy5wcmludEJ1bmRsZVRlbXBsYXRlKFt7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgJydcbiAgICAgICAgICAgICAgICB9XSwgbGFuZ3VhZ2UsIGF2YWlsYWJsZUxhbmd1YWdlcywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHVwZGF0ZUNhdGVnb3J5V29yZENvdW50KGNhdElkLCBsYW5ndWFnZSk7XG4gICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSgnQXV0byBzYXZlOiBcIicgKyBrZXkgKyAnXCIgKHN1Y2Nlc3MpJyk7XG5cbiAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblZpZXcuc2VuZFN1Y2Nlc3Moa2V5LCAndmFsdWVfJyk7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyBub3Qgc3VyZSBpZiB0aGlzIGlzIG5lZWRlZFxuICAgICAgICAgICAgICAgIHVpRXZlbnRzLmNhbGxVaWV2ZW50KCd1cGRhdGVLZXknLCBwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXksIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG59KTtcblxuLyoqXG4gKiBTZXR1cCB0aGUgVUkgZXZlbnRzIGFuZCBtYW5hZ2UgdGhlIGxvZ2ljIGZvciB0aGVtLlxuICpcbiAqIFRPRE8gcmVwbGFjZSBidW5kbGUgd2l0aCBsb2NhbGUgYW5kIHJlZmFjdG9yIHRoZSBjYWxscyBmcm9tIHRyYW5zbGF0aW9uVmlld1xuICovXG50cmFuc2xhdGlvblZpZXcub25DcmVhdGVLZXkoZnVuY3Rpb24oa2V5LCBsYW5nLCB2YWx1ZSkge1xuICAgIGNvbnNvbGUubG9nKCd0cmFuc2xhdGlvblZpZXdDb250cm9sbGVyOm9uU2F2ZVZhbHVlJywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICB0cmFkZS5jcmVhdGVLZXkoXG4gICAgICAgIHByb2plY3RDb25maWcucHJvamVjdElkLFxuICAgICAgICBsYW5nIHx8IHByb2plY3RDb25maWcuZGVmYXVsdExhbmd1YWdlLFxuICAgICAgICB7XG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSB8fCB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24ocHJvamVjdElkLCBsYW5ndWFnZSwga2V5LCB2YWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNhdElkID0ga2V5LnNwbGl0KCdfJylbMF07XG4gICAgICAgICAgICBpZiAocHJvamVjdElkID09PSBwcm9qZWN0Q29uZmlnLnByb2plY3RJZCkgeyAvLyBwcmV2ZW50IGFwcGx5aW5nIHRoZSBjYWxsYmFjayBpZiBwcm9qZWN0IGhhcyBiZWVuIGNoYW5nZWQgaW4gdGhlIG1lYW50aW1lXG4gICAgICAgICAgICAgICAgZXhpc3RpbmdLZXlzW2tleV0gPSB1bmRlZmluZWQ7IC8vIHNhdmUgdGhlIGtleVxuICAgICAgICAgICAgICAgIHByb2plY3RDb25maWcua2V5c1tsYW5ndWFnZV0gPSBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ3VhZ2VdID8gcHJvamVjdENvbmZpZy5rZXlzW2xhbmd1YWdlXSA6IHt9O1xuICAgICAgICAgICAgICAgIHByb2plY3RDb25maWcua2V5c1tsYW5ndWFnZV1ba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uVmlldy5wcmludEJ1bmRsZVRlbXBsYXRlKFt7XG4gICAgICAgICAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWUgfHwgJycsXG4gICAgICAgICAgICAgICAgICAgIHdvcmRzOiAwXG4gICAgICAgICAgICAgICAgfV0sIGxhbmd1YWdlLCBhdmFpbGFibGVMYW5ndWFnZXMsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudChjYXRJZCwgbGFuZ3VhZ2UpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdBdXRvIHNhdmU6IFwiJyArIGtleSArICdcIiAoc3VjY2VzcyknKTtcblxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uVmlldy5zZW5kU3VjY2VzcyhrZXksICd2YWx1ZV8nKTtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG5vdCBzdXJlIGlmIHRoaXMgaXMgbmVlZGVkXG4gICAgICAgICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3VwZGF0ZUtleScsIHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbn0pO1xuXG50cmFuc2xhdGlvblZpZXcub25DbG9uZUtleShmdW5jdGlvbihrZXlJZCwga2V5TmFtZSwgZnJvbUNhdGVnb3J5LCB0b0NhdGVnb3J5KSB7XG4gICAgdHJhZGUuY2xvbmVLZXkoXG4gICAgICAgIHByb2plY3RDb25maWcucHJvamVjdElkLFxuICAgICAgICB7XG4gICAgICAgICAgICBpZDoga2V5SWQsXG4gICAgICAgICAgICBrZXk6IGtleU5hbWUsXG4gICAgICAgICAgICBzb3VyY2VDYXRlZ29yeTogZnJvbUNhdGVnb3J5LFxuICAgICAgICAgICAgdGFyZ2V0Q2F0ZWdvcnk6IHRvQ2F0ZWdvcnlcbiAgICAgICAgfSxcbiAgICAgICAgZnVuY3Rpb24oZXJyLCBwcm9qZWN0SWQsIGRhdGEpIHtcbiAgICAgICAgICAgIHZhciB0ZXh0cztcbiAgICAgICAgICAgIGlmIChwcm9qZWN0SWQgPT09IHByb2plY3RDb25maWcucHJvamVjdElkKSB7XG4gICAgICAgICAgICAgICAgZXhpc3RpbmdLZXlzW2RhdGEua2V5XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB0ZXh0cyA9IGRhdGEudmFsdWVzO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGxhbmcgaW4gdGV4dHMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRleHRzLmhhc093blByb3BlcnR5KGxhbmcpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ11bZGF0YS5rZXldID0gdGV4dHNbbGFuZ107XG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc2xhdGlvblZpZXcucHJpbnRCdW5kbGVUZW1wbGF0ZShbe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleTogZGF0YS5rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IHRleHRzW2xhbmddIHx8ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICB9XSwgbGFuZywgYXZhaWxhYmxlTGFuZ3VhZ2VzLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudCh0b0NhdGVnb3J5LCBsYW5nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbm55LnRyYW5zbGF0aW9uVmlld0Rlc2NyaXB0aW9uLmFkZERlc2NyaXB0aW9ucyhkYXRhLmtleURlc2NyaXB0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICApO1xufSk7XG5cbi8qKlxuICogUmVhZCB0aGUgZnJvbSBwYXJhbSBhcyBkZWZhdWx0IGxhbmd1YWdlIG90aGVyd2lzZSB0YWtlIGl0IGZyb20gdGhlIHByb2plY3QuanNvblxuICogQHBhcmFtIGNvbmZpZ1xuICovXG5mdW5jdGlvbiBzYXZlUHJvamVjdENvbmZpZyhjb25maWcsIHByb2plY3QpIHtcbiAgICB2YXIgaWR4LFxuICAgICAgICAvLyB0aGUgZnJvbSBwYXJhbWV0ZXIgY2FuIG92ZXJ3cml0ZSB0aGUgZGVmYXVsdCBsYW5ndWFnZSAobGVnYWN5KVxuICAgICAgICBkZWZhdWx0TGFuZ3VhZ2UgPSBkb21PcHRzLnBhcmFtcy5mcm9tID8gZG9tT3B0cy5wYXJhbXMuZnJvbSA6IGNvbmZpZy5kZWZhdWx0TGFuZ3VhZ2U7XG4gICAgcHJvamVjdENvbmZpZyA9IGNvbmZpZztcbiAgICBwcm9qZWN0SW5mbyA9IHByb2plY3Q7XG5cbiAgICAvLyBTZXQgJHsgZGVmYXVsdExhbmd1YWdlIH0gYXMgZGVmYXVsdCBpbiBjYXNlIGEgcHJvamVjdCB3YXMganVzdCBjcmVhdGVkIChpLmUuIGRvZXMgbm90IGNvbnRhaW4gYW55IGtleXMgeWV0KVxuICAgIC8vIFRPRE86IEJldHRlciBjcmVhdGUgLyBhZGQgY2hlY2sgb2Ygb2JqZWN0IHRvIGZ1bmN0aW9uYWwgaGVscGVyIG9iamVjdCBpbnN0ZWFkID9cbiAgICBhdmFpbGFibGVMYW5ndWFnZXMgPVxuICAgICAgICBPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXMpLmxlbmd0aCA9PT0gMCAmJiBKU09OLnN0cmluZ2lmeShwcm9qZWN0Q29uZmlnLmtleXMpID09PSBKU09OLnN0cmluZ2lmeSh7fSkgP1xuICAgICAgICAgICAgW2RlZmF1bHRMYW5ndWFnZV0gOiBPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXMpO1xuXG4gICAgaWR4ID0gYXZhaWxhYmxlTGFuZ3VhZ2VzLmluZGV4T2YoZGVmYXVsdExhbmd1YWdlKTtcblxuICAgIGlmIChpZHggIT09IC0xICYmIGlkeCAhPT0gMCkge1xuICAgICAgICAvLyBtb3ZlIGRlZmF1bHQgdG8gdGhlIGJlZ2luIG9mIHRoZSBsaXN0ICh0aGlzIGRlZmluZXMgdGhlIG9yZGVyIGhvdyB0aGUgdHJhbnNsYXRpb24gbGFuZ3VhZ2VzIGFyZSBzaG93bilcbiAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VzLnNwbGljZSgwLCAwLCBhdmFpbGFibGVMYW5ndWFnZXMuc3BsaWNlKGlkeCwgMSlbMF0pO1xuICAgIH1cbn1cblxuLy8vKipcbi8vICogVE9ETyByZXBsYWNlIGJ1bmRsZSB3aXRoIGxvY2FsZSBhbmQgcmVmYWN0b3IgdGhlIGNhbGxzIGZyb20gdHJhbnNsYXRpb25WaWV3XG4vLyAqIFRPRE8gdGhpcyBjb2RlIGlzIG5vdCBjYWxsZWQhP1xuLy8gKi9cbi8vdHJhbnNsYXRpb25WaWV3Lm9uQWRkTmV3S2V5KGZ1bmN0aW9uIChsYW5nLCBrZXksIHZhbHVlLCBjYikge1xuLy8gICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6b25BZGROZXdLZXknLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykpO1xuLy8gICAgYWxlcnQoJ2h1aHUnKTtcbi8vICAgIHRyYWRlLnNlbmRSZXNvdXJjZSh7XG4vLyAgICAgICAgYnVuZGxlOiBwcm9qZWN0Q29uZmlnLnByb2plY3QsXG4vLyAgICAgICAgbG9jYWxlOiBsYW5nXG4vLyAgICB9LCB7XG4vLyAgICAgICAga2V5OiBrZXksXG4vLyAgICAgICAgdmFsdWU6IHZhbHVlXG4vLyAgICB9LCBmdW5jdGlvbiAoa2V5KSB7XG4vLyAgICAgICAgY2Ioa2V5KVxuLy8gICAgfSk7XG4vL30pO1xuXG50cmFuc2xhdGlvblZpZXcub25DcmVhdGVOZXdQcm9qZWN0KGZ1bmN0aW9uKHByak5hbWUsIG9iaikge1xuICAgIHRyYWRlLmNyZWF0ZU5ld1Byb2plY3QocHJqTmFtZSwgb2JqKTtcbn0pO1xuXG50cmFuc2xhdGlvblZpZXcub25SZW1vdmVDYXRlZ29yeShmdW5jdGlvbihvYmopIHtcbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvblJlbW92ZUNhdGVnb3J5Jywgb2JqLCBwcm9qZWN0Q29uZmlnLnByb2plY3RJZCk7XG4gICAgdHJhZGUucmVtb3ZlQ2F0ZWdvcnkocHJvamVjdENvbmZpZy5wcm9qZWN0SWQsIG9iai5jYXRlZ29yeSk7XG59KTtcblxudHJhbnNsYXRpb25WaWV3Lm9uUmVuYW1lQ2F0ZWdvcnkoZnVuY3Rpb24ob2JqKSB7XG4gICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6b25SZW5hbWVDYXRlZ29yeScsIG9iaiwgcHJvamVjdENvbmZpZy5wcm9qZWN0SWQpO1xuICAgIHRyYWRlLnJlbmFtZUNhdGVnb3J5KHByb2plY3RDb25maWcucHJvamVjdElkLCBvYmoub2xkTmFtZSwgb2JqLm5ld05hbWUpO1xufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vblJlbmFtZUtleShmdW5jdGlvbihvYmopIHtcbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvblJlbmFtZUtleScsIG9iaiwgcHJvamVjdENvbmZpZy5wcm9qZWN0SWQpO1xuICAgIHRyYWRlLnJlbmFtZUtleShwcm9qZWN0Q29uZmlnLnByb2plY3RJZCwge1xuICAgICAgICBuZXdLZXk6IG9iai5uZXdLZXksXG4gICAgICAgIG9sZEtleTogb2JqLm9sZEtleVxuICAgIH0pO1xufSk7XG5cbnRyYW5zbGF0aW9uVmlldy5vblJlbW92ZUtleShmdW5jdGlvbihvYmopIHtcbiAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpvblJlbW92ZUtleScsIG9iaiwgcHJvamVjdENvbmZpZy5wcm9qZWN0SWQpO1xuICAgIHRyYWRlLnJlbW92ZUtleShwcm9qZWN0Q29uZmlnLnByb2plY3RJZCwgb2JqLmtleSwgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHZhciBjYXROYW1lID0ga2V5LnNwbGl0KCdfJylbMF07XG4gICAgICAgIGZvcih2YXIgbGFuZyBpbiBwcm9qZWN0Q29uZmlnLmtleXMpIHtcbiAgICAgICAgICAgIGlmIChwcm9qZWN0Q29uZmlnLmtleXMuaGFzT3duUHJvcGVydHkobGFuZykpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcHJvamVjdENvbmZpZy5rZXlzW2xhbmddW2tleV07XG4gICAgICAgICAgICAgICAgdXBkYXRlQ2F0ZWdvcnlXb3JkQ291bnQoY2F0TmFtZSwgbGFuZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KTtcbn0pO1xuXG4vLyByZWdpc3RlciBsaXN0ZW5lciBmdW5jdGlvbiB0byB0aGUgdWkgZXZlbnRzXG51aUV2ZW50cy5hZGRVaUV2ZW50TGlzdGVuZXIoe1xuICAgIGFjdGl2YXRlTGFuZ3VhZ2U6IGZ1bmN0aW9uKGxhbmcpIHtcbi8vICAgICAgICB0cmFuc2xhdGlvblZpZXdIZWFkZXIuc2hvd0xhbmcobGFuZyk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5zaG93TGFuZyhsYW5nKTtcbiAgICB9LFxuICAgIGRlQWN0aXZhdGVMYW5ndWFnZTogZnVuY3Rpb24obGFuZykge1xuLy8gICAgICAgIHRyYW5zbGF0aW9uVmlld0hlYWRlci5oaWRlTGFuZyhsYW5nKTtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LmhpZGVMYW5nKGxhbmcpO1xuICAgIH0sXG4gICAgdG9nZ2xlV29yZENvdW50OiBmdW5jdGlvbihhY3RpdmUpIHtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LnRvZ2dsZVdvcmRDb3VudChhY3RpdmUpO1xuICAgIH0sXG4gICAgLy8gVE9ETyAgZG9uJ3QgdHJpZ2dlciBpdCB0d2ljZSBmb3IgdGhlIHNhbWUgbGFuZ3VhZ2VcbiAgICBhZGRMYW5ndWFnZTogZnVuY3Rpb24obGFuZykge1xuICAgICAgICBhdmFpbGFibGVMYW5ndWFnZXMucHVzaChsYW5nKTtcbiAgICAgICAgcHJvamVjdENvbmZpZy5rZXlzW2xhbmddID0ge307XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5hZGRMYW5ndWFnZShPYmplY3Qua2V5cyhleGlzdGluZ0tleXMpLCBsYW5nKTtcbi8vICAgICAgICB0cmFuc2xhdGlvblZpZXdIZWFkZXIuc2hvd0xhbmcobGFuZyk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5zaG93TGFuZyhsYW5nKTtcbiAgICB9LFxuICAgIGVuYWJsZUVkaXRvck1vZGU6IGZ1bmN0aW9uKGVuYWJsZWQpIHtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LmVuYWJsZUVkaXRvck1vZGUoZW5hYmxlZCk7XG4gICAgfSxcbiAgICBmaWxlVXBsb2FkZWQ6IGZ1bmN0aW9uKHByb2plY3RJZCwga2V5LCBmaWxlTmFtZSwgdXJsKSB7XG4gICAgICAgIGNhbm55LnRyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkLmFwcGVuZEltYWdlKHByb2plY3RDb25maWcucHJvamVjdElkLCBrZXksIGZpbGVOYW1lLCB1cmwpO1xuICAgIH0sXG4gICAgSk1CRkZpbGVVcGxvYWRlZDogZnVuY3Rpb24ocHJvamVjdElkKSB7XG4gICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KHByb2plY3RJZCwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjpsb2FkUHJvamVjdCBmYWlscyBmb3IgcHJvamVjdElkOicsIHByai5wcm9qZWN0SWQpO1xuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGpzb25JbXBvcnRlZDogZnVuY3Rpb24ocHJvamVjdElkKSB7XG4gICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KHByb2plY3RJZCwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAgIGlmIChlcnJvciA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1Byb2plY3Qgd2l0aCBpZCAnICsgcHJvamVjdElkICsgJyBjb3VsZCBub3QgYmUgbG9hZGVkLicpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn0pO1xuXG4vKipcbiAqIHNlcnZlciBldmVudCBsaXN0ZW5lclxuICovXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ2tleVVwZGF0ZWQnLCBmdW5jdGlvbigpIHtcbiAgICAvLyBUT0RPIG1vcmUgY2xpZW50IGNoYW5nZXMgYXJlIGNvbWluZywgd2UnbGwgZmluaXNoIHRoZSBjb2RlIGJlbG93IHRoZW5cbiAgICAvL2lmIChwcm9qZWN0SWQgPT09IHByb2plY3RDb25maWcucHJvamVjdElkKSB7XG4gICAgLy8gICAgZXhpc3RpbmdLZXlzW2tleU5hbWVdID0gdW5kZWZpbmVkOyAvLyBzYXZlIHRoZSBrZXkgLy8gd2hhdCdzIGhhcHBlbmluZyBoZXJlP1xuICAgIC8vICAgIHZhciBkYXRhID0ge307XG4gICAgLy8gICAgZGF0YVtrZXlOYW1lXSA9IGtleVZhbHVlO1xuICAgIC8vICAgIHRyYW5zbGF0aW9uVmlldy5wcmludEJ1bmRsZVRlbXBsYXRlKFtkYXRhXSwgbGFuZ3VhZ2UsIGF2YWlsYWJsZUxhbmd1YWdlcywgcHJvamVjdENvbmZpZy5wcm9qZWN0KTtcbiAgICAvL31cbn0pO1xuXG4vKipcbiAqIHNlcnZlciBldmVudCBsaXN0ZW5lclxuICogYWxsIHVzZXJzIHdpbGwgYmUgbm90aWZpZWQgb2YgY2hhbmdlc1xuICovXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ29uS2V5Q2xvbmVkJywgZnVuY3Rpb24oKSB7XG4gICAgY29uc29sZS5sb2coJ2V2ZW50cy5saXN0ZW5lcjo6b25LZXlDbG9uZWQnICsgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbn0pO1xuXG4vKipcbiAqIHNlcnZlciBldmVudCBsaXN0ZW5lclxuICovXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ2tleURlbGV0ZWQnLCBmdW5jdGlvbihidW5kbGVOYW1lLCBvYmopIHtcbiAgICAvLyBUT0RPIG1vcmUgY2xpZW50IGNoYW5nZXMgYXJlIGNvbWluZywgd2UnbGwgZmluaXNoIHRoZSBjb2RlIGJlbG93IHRoZW5cbiAgICAvL2lmIChidW5kbGVOYW1lID09PSBwcm9qZWN0Q29uZmlnLnByb2plY3QpIHtcbiAgICAvLyAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlcjprZXlSZW5hbWVkJywgYnVuZGxlTmFtZSwgb2JqKTtcbiAgICAvLyAgICB0b2FzdC5zaG93TWVzc2FnZSgnS2V5IGRlbGV0ZWQhJyArIG9iai5rZXkpO1xuICAgIC8vICAgIHRyYW5zbGF0aW9uVmlldy5tYXJrS2V5QXNSZW1vdmVkKG9iai5rZXkpO1xuICAgIC8vfVxufSk7XG5cbmV2ZW50cy5hZGRTZXJ2ZXJMaXN0ZW5lcignY2F0ZWdvcnlEZWxldGVkJywgZnVuY3Rpb24oYnVuZGxlTmFtZSwgb2JqKSB7XG4gICAgY29uc29sZS5sb2coJ2V2ZW50cy5saXN0ZW5lcjo6Y2F0ZWdvcnlEZWxldGVkJyArIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG59KTtcblxuZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdjYXRlZ29yeVJlbmFtZWQnLCBmdW5jdGlvbihidW5kbGVOYW1lLCBvYmopIHtcbiAgICBjb25zb2xlLmxvZygnZXZlbnRzLmxpc3RlbmVyOjpjYXRlZ29yeVJlbmFtZWQnICsgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbn0pO1xuXG4vKipcbiAqIHNlcnZlciBldmVudCBsaXN0ZW5lclxuICovXG5ldmVudHMuYWRkU2VydmVyTGlzdGVuZXIoJ2ltYWdlUmVtb3ZlZCcsIGZ1bmN0aW9uKGJ1bmRsZU5hbWUsIGNhdGVnb3J5TmFtZSkge1xuICAgIGlmIChidW5kbGVOYW1lID09PSBwcm9qZWN0Q29uZmlnLnByb2plY3RJZCkge1xuICAgICAgICB0b2FzdC5zaG93TWVzc2FnZSgnSW1hZ2UgcmVtb3ZlZCBmb3IgY2F0ZWdvcnk6ICcgKyBjYXRlZ29yeU5hbWUpO1xuICAgICAgICB0cmFuc2xhdGlvblZpZXcucmVtb3ZlSW1hZ2UoY2F0ZWdvcnlOYW1lKTtcbiAgICB9XG59KTtcblxuLyoqXG4gKiBHZXQgd29yZCBjb3VudCBmb3IgZ2l2ZW4gY2F0ZWdvcnkgYW5kIGxhbmd1YWdlXG4gKiBAcGFyYW0gY2F0ZWdvcnlcbiAqIEBwYXJhbSBsYW5nXG4gKiBAcmV0dXJucyBOdW1iZXJcbiAqL1xuZnVuY3Rpb24gY291bnRXb3Jkc0luQ2F0ZWdvcnkoY2F0ZWdvcnksIGxhbmcpIHtcbiAgICBsZXQgd29yZENvdW50ID0gMDtcbiAgICBPYmplY3Qua2V5cyhwcm9qZWN0Q29uZmlnLmtleXNbbGFuZ10pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkuc3BsaXQoJ18nKVswXSA9PT0gY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIHdvcmRDb3VudCArPSB3b3JkQ291bnRlci5jb3VudFdvcmRzSW5TdHJpbmcocHJvamVjdENvbmZpZy5rZXlzW2xhbmddW2tleV0pO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHdvcmRDb3VudDtcbn1cblxuLyoqXG4gKiBVcGRhdGUgb3ZlcmFsbCB3b3JkLWNvdW50IHZpZXcgZm9yIGNhdGVnb3J5IGxhbmd1YWdlXG4gKiBAcGFyYW0gY2F0SWRcbiAqIEBwYXJhbSBsYW5nXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZUNhdGVnb3J5V29yZENvdW50KGNhdElkLCBsYW5nKSB7XG4gICAgdHJhbnNsYXRpb25WaWV3LnVwZGF0ZUNhdGVnb3J5V29yZENvdW50KHtcbiAgICAgICAgaWQ6IGNhdElkLFxuICAgICAgICBsYW5ndWFnZTogbGFuZyxcbiAgICAgICAgd29yZHM6IGNvdW50V29yZHNJbkNhdGVnb3J5KGNhdElkLCBsYW5nKVxuICAgIH0pO1xufVxuXG4vKipcbiAqIEZpbHRlciBjYXRlZ29yeSBuYW1lcyBieSBpdGVyYXRpbmcgdGhyb3VnaCBwcm9qZWN0IGtleXNcbiAqIEBwYXJhbSBrZXlzXG4gKiBAcmV0dXJucyBBcnJheVxuICovXG5mdW5jdGlvbiBnZXRDYXRlZ29yaWVzQnlLZXlzKGtleXMpIHtcbiAgICB2YXIgY3VycmVudENhdE5hbWUsXG4gICAgICAgIGRlZmF1bHRLZXlzLFxuICAgICAgICBjYXRlZ29yaWVzID0gW107XG4gICAgZm9yICh2YXIgbGFuZyBpbiBrZXlzKSB7XG4gICAgICAgIGlmIChrZXlzLmhhc093blByb3BlcnR5KGxhbmcpKSB7XG4gICAgICAgICAgICBkZWZhdWx0S2V5cyA9IGtleXNbbGFuZ107XG4gICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGVmYXVsdEtleXMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZGVmYXVsdEtleXMuaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2F0TmFtZSA9IGtleS5zcGxpdCgnXycpWzBdO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2F0ZWdvcmllcy5pbmRleE9mKGN1cnJlbnRDYXROYW1lKSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMucHVzaChjdXJyZW50Q2F0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhdGVnb3JpZXM7XG59XG5cblxuLyoqXG4gKiBSZW1vdmVzIGNhdGVnb3J5IHJlbGF0ZWQga2V5cyBmcm9tIFwic2Vzc2lvblwiIGRhdGEgLSBzdG9yZWQgaW4gcHJvamVjdENvbmZpZy5rZXlzXG4gKiAobWVtYmVyIHZhciBkZWNsYXJlZCBvbiB0b3Agb2YgdGhpcyBmaWxlKVxuICogSW52b2tlZCBieSBjYXRlZ29yeSB3YXMgcmVtb3ZlZFxuICogQHBhcmFtIGNhdGVnb3J5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNhdGVnb3J5RGF0YShjYXRlZ29yeSkge1xuICAgIE9iamVjdC5rZXlzKHByb2plY3RDb25maWcua2V5cykuZm9yRWFjaChmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgIHZhciBsYW5nRGF0YSA9IHByb2plY3RDb25maWcua2V5c1tsYW5nXTtcbiAgICAgICAgT2JqZWN0LmtleXMobGFuZ0RhdGEpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBpZiAoa2V5LnNwbGl0KCdfJylbMF0gPT09IGNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIGxhbmdEYXRhW2tleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVOZXdQcm9qZWN0Q29uZmlnKG5ld1Byb2plY3RDb25maWcsIHByb2plY3QpIHtcbiAgICAvLyBwcm9qZWN0IHNwZWNpZmljIGNvbmZpZ1xuICAgIGNvbnNvbGUubG9nKCd0cmFuc2xhdGlvblZpZXdDb250cm9sbGVyIGdldCBuZXcgY29uZmlnJywgbmV3UHJvamVjdENvbmZpZyk7XG4gICAgLy8gbi5iLiBub3RoaW5nIGlzIHNhdmVkIGhlcmUgLSBcInNhdmluZ1wiIG9ubHkgaGFwcGVucyBhcyBpbiBcInN0b3JlIGluIG91ciBkYXRhIHN0cnVjdHVyZVwiXG4gICAgc2F2ZVByb2plY3RDb25maWcobmV3UHJvamVjdENvbmZpZywgcHJvamVjdCk7XG4gICAgLy8gYmVmb3JlIHRoZXJlIHdhcyBhIGNoZWNrIGRvIG5vdCBjbGVhciB0aGUgdmlldyBpZiB0aGUgYWN0dWFsIHByb2plY3QgaXMgdGhlIHNhbWUuXG4gICAgLy8gVGhlIHByb2JsZW0gaXMgaWYgeW91IHJlbW92ZSBhIGtleSBpbiB0aGUgZWRpdG9yIHZpZXcgdGhhbiB0aGUgdHJhbnNsYXRpb24gdmlldyBjYW4ndFxuICAgIC8vIGRldGVjdCB0aGlzLlxuICAgIHRyYW5zbGF0aW9uVmlldy5jbGVhclZpZXcoKTtcbiAgICBjYW5ueS5mbG93Q29udHJvbC5zaG93KCdyZXNvdXJjZUJ1bmRsZScpO1xufVxuXG5mdW5jdGlvbiByZW5kZXJQcm9qZWN0KHByb2plY3REYXRhLCBwcm9qZWN0LCBjYikge1xuICAgIHZhciBjYXRlZ29yaWVzID0gZ2V0Q2F0ZWdvcmllc0J5S2V5cyhwcm9qZWN0RGF0YS5rZXlzKTtcblxuICAgIGhhbmRsZU5ld1Byb2plY3RDb25maWcocHJvamVjdERhdGEsIHByb2plY3QpO1xuXG4gICAgT2JqZWN0LmtleXMocHJvamVjdERhdGEua2V5cykuZm9yRWFjaChmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgIHZhciBzb3J0ZWQsIGRhdGFzID0gW107XG4gICAgICAgIE9iamVjdC5rZXlzKHByb2plY3REYXRhLmtleXNbbGFuZ10pLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICBkYXRhcy5wdXNoKHtcbiAgICAgICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgICAgICB2YWx1ZTogcHJvamVjdERhdGEua2V5c1tsYW5nXVtrZXldXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHNvcnRlZCA9IGRhdGFzLnNvcnQoc29ydEJ5S2V5KTtcblxuICAgICAgICBzb3J0ZWQuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICBleGlzdGluZ0tleXNbZGF0YS5rZXldID0gdW5kZWZpbmVkO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBUT0RPIHByb2plY3RDb25maWcucHJvamVjdCB3aWxsIGJlIHJlbW92ZWQgaWYgdGhlIHRyYWRlIGNhbGwgbW92ZWQgdG8gdGhpcyBjb250cm9sbGVyXG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5wcmludEJ1bmRsZVRlbXBsYXRlKHNvcnRlZCwgbGFuZywgYXZhaWxhYmxlTGFuZ3VhZ2VzLCBjYiB8fCBmdW5jdGlvbigpIHt9KTtcblxuICAgICAgICBjYXRlZ29yaWVzLmZvckVhY2goZnVuY3Rpb24oY2F0ZWdvcnkpIHtcbiAgICAgICAgICAgIHVwZGF0ZUNhdGVnb3J5V29yZENvdW50KGNhdGVnb3J5LCBsYW5nKTtcbiAgICAgICAgfSk7XG4gICAgfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIHJlbmFtZUNhdGVnb3J5OiBmdW5jdGlvbihvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdSZW5hbWVkIGNhdGVnb3J5ICcgKyBvbGROYW1lICsgJyB0byAnICsgbmV3TmFtZSArICchJyk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5yZW5hbWVDYXRlZ29yeShvbGROYW1lLCBuZXdOYW1lLCBhdmFpbGFibGVMYW5ndWFnZXMpO1xuICAgIH0sXG4gICAgcmVtb3ZlQ2F0ZWdvcnk6IGZ1bmN0aW9uKGNhdE5hbWUpIHtcbiAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ1JlbW92ZWQgY2F0ZWdvcnkgJyArIGNhdE5hbWUgKyAnIScpO1xuICAgICAgICByZW1vdmVDYXRlZ29yeURhdGEoY2F0TmFtZSk7XG4gICAgICAgIHRyYW5zbGF0aW9uVmlldy5yZW1vdmVDYXRlZ29yeShjYXROYW1lKTtcbiAgICB9LFxuICAgIC8qKlxuICAgICAqIGlzIGNhbGxlZCBpZiB0aGUgdXNlciByZW5hbWUga2V5IHJlcXVlc3Qgd2FzIHN1Y2Nlc3NmdWxcbiAgICAgKiBAcGFyYW0gbmV3S2V5XG4gICAgICogQHBhcmFtIG9sZEtleVxuICAgICAqL1xuICAgIHJlbmFtZUtleTogZnVuY3Rpb24ob2xkS2V5LCBuZXdLZXkpIHtcbiAgICAgICAgaWYgKG9sZEtleSkge1xuICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0tleSByZW5hbWVkIHN1Y2Nlc3NmdWwhIEZyb20gJyArIG9sZEtleSArICcgdG8gJyArIG5ld0tleSk7XG4gICAgICAgICAgICB0cmFuc2xhdGlvblZpZXcucmVuYW1lS2V5KG9sZEtleSwgbmV3S2V5LCBhdmFpbGFibGVMYW5ndWFnZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0tleSByZW5hbWVkIGZhaWxlZCEnKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgcmVtb3ZlS2V5OiBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0tleSByZW1vdmVkIHN1Y2Nlc3NmdWwhJywga2V5KTtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LnJlbW92ZUtleShrZXkpO1xuICAgIH0sXG4gICAgaW1hZ2VSZW1vdmVkOiBmdW5jdGlvbihjYXRlZ29yeU5hbWUpIHtcbiAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoJ0ltYWdlIHJlbW92ZWQgZm9yIGNhdGVnb3J5OiAnICsgY2F0ZWdvcnlOYW1lKTtcbiAgICAgICAgdHJhbnNsYXRpb25WaWV3LnJlbW92ZUltYWdlKGNhdGVnb3J5TmFtZSk7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBXaWxsIGJlIGNhbGxlZCB3aXRoIHRoZSBjb21wbGV0ZSBKU09OIG9iamVjdCBmcm9tIGEgc3BlY2lmaWMgcHJvamVjdFxuICAgICAqIEBwYXJhbSBwcm9qZWN0RGF0YVxuICAgICAqL1xuICAgIG9uTG9hZFByb2plY3Q6IGZ1bmN0aW9uKHByb2plY3REYXRhLCBwcm9qZWN0KSB7XG4gICAgICAgIHZhciBhbmNob3IgPSB1cmwuaGFzQW5jaG9yKCkgPyB1cmwuZ2V0QW5jaG9yKCkucmVwbGFjZSgnIycsICcnKSA6IGZhbHNlO1xuICAgICAgICByZW5kZXJQcm9qZWN0KHByb2plY3REYXRhLCBwcm9qZWN0LCBmdW5jdGlvbih2aWV3SWQpIHtcbiAgICAgICAgICAgIGlmIChhbmNob3IpIHtcbiAgICAgICAgICAgICAgICBpZiAodmlld0lkID09PSBhbmNob3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRyYW5zbGF0aW9uVmlldy5jb25maWcucm93UHJlZml4ICsgdmlld0lkKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZG8gdGhlIGVsZW1lbnQgZXhpc3RzP1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnYW5jaG9yRm9jdXMnLCB1cmwuZ2V0QW5jaG9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgYm9keVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbGVtUmVjdCA9IGRvbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2Zmc2V0ID0gZWxlbVJlY3QudG9wIC0gYm9keVJlY3QudG9wO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdpbmRvdy5zY3JvbGxUbygwLCBvZmZzZXQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSwgMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBhZGQgdGhlIGRlc2NyaXB0aW9uc1xuICAgICAgICBjYW5ueS50cmFuc2xhdGlvblZpZXdEZXNjcmlwdGlvbi5hZGREZXNjcmlwdGlvbnMocHJvamVjdERhdGEua2V5RGVzY3JpcHRpb25zKTtcbiAgICAgICAgT2JqZWN0LmtleXMocHJvamVjdERhdGEuaW1hZ2VzKS5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgY2FubnkudHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQuYXBwZW5kSW1hZ2UocHJvamVjdC5pZCwga2V5LCBwcm9qZWN0RGF0YS5pbWFnZXNba2V5XSk7XG4gICAgICAgIH0pXG4gICAgfSxcbiAgICBvbk5ld1Byb2plY3RDcmVhdGVkOiBmdW5jdGlvbihwcm9qZWN0RGF0YSwgcHJvamVjdCkge1xuICAgICAgICBjb25zb2xlLmxvZygndHJhbnNsYXRpb25WaWV3Q29udHJvbGxlci5vbk5ld1Byb2plY3RDcmVhdGVkJyk7XG4gICAgICAgIHJlbmRlclByb2plY3QocHJvamVjdERhdGEsIHByb2plY3QpO1xuICAgIH1cbn07IiwiXG4vKipcbiAqIGNvbnRyb2xsZXIgZm9yIHRoZSBpbWFnZSB1cGxhb2RlciB2aWV3IC0gY2FsbHMgdGhlIHNlcnZlciB0byB1cGxvYWQgYSBpbWFnZSBhbmQgbm90aWZpZXIgdGhlIHVpIGV2ZW50IGhhbmRsZXJcbiAqIEB0eXBlIHt7fX1cbiAqL1xudmFyIGNhbm55ID0gcmVxdWlyZSgnY2FubnknKSxcbiAgICB1cGxvYWQgPSBjYW5ueS51cGxvYWQsXG4gICAgZGlzcGxheU1hbmFnZXIgPSBjYW5ueS5kaXNwbGF5TWFuYWdlcixcbiAgICB1aUV2ZW50cyA9IHJlcXVpcmUoJy4uL3VpRXZlbnRNYW5hZ2VyLmpzJyksXG4gICAgdXBsb2FkSWQsXG4gICAgcHJvamVjdEluZm87XG4vKipcbiAqIENhbGwgdGhpcyBmb3IgZWFjaCBmaWxlIC0gd2lsbCBjYWxsIGEgY2FsbCBiYWNrIHdpdGggdGhlIHNlcnZlciBhbnN3ZXJcbiAqIEBwYXJhbSBmaWxlXG4gKi9cbmZ1bmN0aW9uIHNlbmRGaWxlKGZpbGUsIGRpcmVjdENhbGxiYWNrKSB7XG4gICAgdmFyIHVyaSA9ICcvdXBsb2FkRmlsZT9wcm9qZWN0SWQ9JyArIHByb2plY3RJbmZvLmlkICsgJyZrZXk9JyArIHVwbG9hZElkICsgJyZwcm9qZWN0PScgKyBwcm9qZWN0SW5mby5uYW1lLFxuICAgICAgICB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKSxcbiAgICAgICAgZmQgPSBuZXcgRm9ybURhdGEoKTtcblxuICAgIHhoci5vcGVuKFwiUE9TVFwiLCB1cmksIHRydWUpO1xuICAgIHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGRhdGE7XG4gICAgICAgIGlmICh4aHIucmVhZHlTdGF0ZSA9PSA0ICYmIHhoci5zdGF0dXMgPT0gMjAwKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgcmVzcG9uc2UuXG4gICAgICAgICAgICBkYXRhID0gSlNPTi5wYXJzZSh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgIGRpcmVjdENhbGxiYWNrICYmIGRpcmVjdENhbGxiYWNrKGRhdGEpOyAvLyBoYW5kbGUgcmVzcG9uc2UuXG4gICAgICAgICAgICAvLyB7ZmlsZTogXCIvL3N1Yi9zdWIxL3N1YjFfYmx1ZV9jb2tlLmpwZ1wiLCBuYW1lOiBcInN1YjFfYmx1ZV9jb2tlLmpwZ1wiLCB0eXBlOiBcImltYWdlL2pwZ1wifVxuICAgICAgICAgICAgY29uc29sZS5sb2coZGF0YSk7XG4gICAgICAgICAgICB1aUV2ZW50cy5jYWxsVWlldmVudCgnZmlsZVVwbG9hZGVkJywgcHJvamVjdEluZm8uaWQsIHVwbG9hZElkLCBkYXRhLmZpbGUpXG4gICAgICAgIH1cbiAgICB9O1xuICAgIGZkLmFwcGVuZCgnbXlGaWxlJywgZmlsZSk7XG4gICAgLy8gSW5pdGlhdGUgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIHVwbG9hZFxuICAgIHhoci5zZW5kKGZkKTtcbn1cblxuLyoqXG4gKiBTYXZlIGRhdGEgaW4gbWVtYmVyIHZhcmlhYmxlIHVzZWQgYnkgZnVydGhlciB1cGxvYWQgb3BlcmF0aW9uc1xuICogQHBhcmFtIGRhdGE6IFByb2plY3QgZGF0YVxuICovXG5mdW5jdGlvbiBhcHBseVByb2plY3REYXRhKGRhdGEsIHByb2plY3QpIHtcbiAgICBwcm9qZWN0SW5mbyA9IHByb2plY3Q7XG59XG5cbnVpRXZlbnRzLmFkZFVpRXZlbnRMaXN0ZW5lcih7XG4gICAgc2hvd0ZpbGVVcGxvYWQgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdXBsb2FkSWQgPSBpZDtcbiAgICAgICAgZGlzcGxheU1hbmFnZXIuc2hvdygndXBsb2FkVmlldycpO1xuICAgIH1cbn0pO1xuXG51cGxvYWQub25VcGxvYWQoZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAvLyBUT0RPIGFkZGl0aW9uYWwgdG8gdGhlIHVwbG9hZCBpZCB3ZSBuZWVkIHRoZSBwcm9qZWN0IElEXG4gICAgY29uc29sZS5sb2coJ3VwbG9hZENvbnRyb2xsZXI6dXBsb2FkIGlkOiBmaWxlOicsIHVwbG9hZElkLCBmaWxlKTtcbiAgICBzZW5kRmlsZShmaWxlKTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvbk5ld1Byb2plY3RDcmVhdGVkIDogYXBwbHlQcm9qZWN0RGF0YSxcbiAgICBvbkxvYWRQcm9qZWN0IDogYXBwbHlQcm9qZWN0RGF0YVxufTsiLCJ2YXIgdHJhZGUgPSByZXF1aXJlKCcuLi90cmFkZScpLFxuICAgIHVpRXZlbnRzID0gcmVxdWlyZSgnLi4vdWlFdmVudE1hbmFnZXInKSxcbiAgICB1cmwgPSByZXF1aXJlKCcuLi91dGlsL3VybCcpO1xuLyoqXG4gKiBUT0RPIGhhbmRsZSB0aGUgYnJvd3NlciBiYWNrIGFuZCBuZXh0IGJ1dHRvbiBhbmQgbG9hZCB0aGUgY29ycmVjdCB2aWV3XG4gKi9cbmZ1bmN0aW9uIHByb2Nlc3NBamF4RGF0YShyZXNwb25zZSwgdXJsUGF0aCl7XG4gICAgZG9jdW1lbnQudGl0bGUgPSByZXNwb25zZS5wYWdlVGl0bGU7XG4gICAgd2luZG93Lmhpc3RvcnkucHVzaFN0YXRlKHtcbiAgICAgICAgXCJodG1sXCI6IHJlc3BvbnNlLmh0bWwsXG4gICAgICAgIFwicGFnZVRpdGxlXCI6IHJlc3BvbnNlLnBhZ2VUaXRsZSxcbiAgICAgICAgaWQgOiByZXNwb25zZS5pZCxcbiAgICAgICAgaXNQcm9qZWN0IDogcmVzcG9uc2UuaXNQcm9qZWN0XG4gICAgfSxcIlwiLCB1cmxQYXRoICsgdXJsLmdldEFuY2hvcigpKTtcbn1cblxuLyoqXG4gKiBNYW5pcHVsYXRlIGJyb3dzZXIgaGlzdG9yeSAvIGxvY2F0aW9uIHdpdGggZ2l2ZW4gcHJvamVjdCBkYXRhXG4gKiBAcGFyYW0gZGF0YTogUHJvamVjdCByZWxhdGVkIGRhdGFcbiAqL1xuZnVuY3Rpb24gYXBwbHlQcm9qZWN0RGF0YShkYXRhLCBwcm9qZWN0KSB7XG4gICAgLy8gYWRkIHRoZSBwcm9qZWN0IHBhdGggdG8gdGhlIFVSTFxuICAgIGlmIChwcm9qZWN0Lm5hbWUpIHtcbiAgICAgICAgcHJvY2Vzc0FqYXhEYXRhKHtcbiAgICAgICAgICAgIHBhZ2VUaXRsZSA6IHByb2plY3QuaWQsXG4gICAgICAgICAgICBodG1sOicnLFxuICAgICAgICAgICAgaWQgOiBwcm9qZWN0LmlkLFxuICAgICAgICAgICAgaXNQcm9qZWN0IDogdHJ1ZVxuICAgICAgICAgICAgLy8gdG8gcGVyc2lzdHMgdGhlIGxpbmtzIHdlIHNhdmUgdGhlIGlkIGluIFVSTCAtIGl0J3Mgbm90IGh1bWFuIHJlYWRhYmxlIGJ1dCBsaW5rcyB3aWxsIHdvcmsgZm9yZXZlclxuICAgICAgICB9LCAnLycgKyBwcm9qZWN0LmlkICsgJy5wcmonKTtcbiAgICB9XG59XG5cbnVpRXZlbnRzLmFkZFVpRXZlbnRMaXN0ZW5lcih7XG4gICAgYW5jaG9yRm9jdXMgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgLy8gc2V0IHRoZSBhbmNob3IgdG8gdGhlIFVSTFxuICAgICAgICB3aW5kb3cuaGlzdG9yeS5wdXNoU3RhdGUobnVsbCwgbnVsbCwgaWQpXG4gICAgfVxufSk7XG5cbndpbmRvdy5vbnBvcHN0YXRlID0gZnVuY3Rpb24gKGUpIHtcbi8vICAgIGNvbnNvbGUubG9nKCdvbnBvcHN0YXRlJywgZS5zdGF0ZS5pZCk7XG4gICAgaWYgKGUuc3RhdGUpIHtcbiAgICAgICAgaWYgKGUuc3RhdGUuaXNQcm9qZWN0KSB7XG4gICAgICAgICAgICB0cmFkZS5sb2FkUHJvamVjdChlLnN0YXRlLmlkLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyciA9PT0gZmFsc2UpXG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3VybE1hbmlwdWxhdG9yOmxvYWRQcm9qZWN0IGZhaWxzIGZvciBwcm9qZWN0SWQ6JywgZS5zdGF0ZS5pZClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cmFkZS5nZXREaXJlY3RvcnkoZS5zdGF0ZS5pZCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIgIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2FsbCB0aGVcbiAgICAgICAgICAgICAgICAgICAgdWlFdmVudHMuY2FsbFVpZXZlbnQoJ3Nob3dPdmVydmlld1BhZ2UnKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndXJsTWFuaXB1bGF0b3I6Z2V0RGlyZWN0b3J5IGNhbiBub3QgbG9hZCBwcm9qZWN0IGZvciBkaXJlY3RvcnkgbmFtZTonLCBlLnN0YXRlLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBUT0RPIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIGFjdGl2YXRpbmcgdGhlIHByb2plY3QgdmlldyBvciB0aGUgb3ZlcnZpZXcgcGFnZS4uLlxuICpcbiAqIGp1c3QgdGhlIGltcGxlbWVudGF0aW9uIG9mIHRoZSBjYWxsYmFja3NcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uTG9hZFByb2plY3QgOiBhcHBseVByb2plY3REYXRhLFxuICAgIG9uTmV3UHJvamVjdENyZWF0ZWQgOiBhcHBseVByb2plY3REYXRhLFxuICAgIGdldERpcmVjdG9yeTogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcHJvY2Vzc0FqYXhEYXRhKHtcbiAgICAgICAgICAgIHBhZ2VUaXRsZSA6ICd0cmFuc2xhdHJvbiBvdmVydmlldycsXG4gICAgICAgICAgICBodG1sOicnLFxuICAgICAgICAgICAgaWQgOiBkYXRhLmN1cnJlbnREaXJlY3RvcnksXG4gICAgICAgICAgICBpc1Byb2plY3QgOiBmYWxzZVxuICAgICAgICB9LCBkYXRhLmN1cnJlbnREaXJlY3RvcnkpO1xuICAgIH1cbn07IiwiLyoqXG4gKiBDcmVhdGVkIGJ5IGVpZ2h0eWZvdXIuXG4gKlxuICogQWxsIHNlcnZlciBldmVudHMuIE11bHRpcGxlIGNsaWVudHMgY2FuIHJlZ2lzdGVyIG9uIGVhY2ggZXZlbnRcbiAqIGFuZCB3aWxsIGJlIG5vdGlmaWVkIGlmIG1ldGhvZCBpcyBjYWxsZWQgZnJvbSBzZXJ2ZXIuXG4gKlxuICogVE9ETyBSRU5BTUUgRklMRVxuICogVE9ETyB0byB3aGF0PyA6KVxuICogV2hhdCBhYm91dCBcImV4dGVybmFsQ2hhbmdlTm90aWZpY2F0aW9uc1wiP1xuICpcbiAqIFRCRCB3aHkgZG9uJ3Qgd2UgaW50ZWdyYXRlIHRoaXMgb25lIHdpdGggdWkgZXZlbnRzPyB0aGF0IHdvdWxkIGN1dCBkb3duIG9uIHRoZSBudW1iZXIgb2YgY29tcG9uZW50cyB3ZSBoYXZlIGFuZCB3ZSBcIm9ubHlcIiAoPylcbiAqIGhhdmUgdG8gZG8gc29tZSBzZW5zaWJsZSByZW5hbWluZyBvZiBldmVudHMsIGxpa2UgcmVuYW1pbmcgYWxsIGV2ZW50cyBoYW5kbGVkIGhlcmUgYnkgYWRkaW5nIFwiZXh0ZXJuYWxcIiBvciBzaW1pbGFyXG4gKiAoZS5nLiBcImtleVVwZGF0ZWRcIiBiZWNvbWVzIFwia2V5VXBkYXRlZEV4dGVybmFsbHlcIikuXG4gKi9cbnZhciBldmVudHMgPSAoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBldmVudFF1ZXVlID0ge30sXG4gICAgICAgIGNhbGxRdWV1ZSA9IGZ1bmN0aW9uIChuYW1lLCBhcmdzKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ290IG5vdGlmaWNhdGlvbiBmb3IgJywgbmFtZSwgJ3dpdGggcGF5bG9hZCcsIGFyZ3MpO1xuICAgICAgICAgICAgaWYgKGV2ZW50UXVldWUuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICBldmVudFF1ZXVlW25hbWVdLm1hcChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgZmMuYXBwbHkobnVsbCwgYXJncyk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc2VydmVyRXZlbnRzIDoge1xuICAgICAgICAgICAgLy8gVEJEIGNhbiBiZSByZW1vdmVkP1xuICAgICAgICAgICAgc2VuZEZpbGUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdzZW5kRmlsZScsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLy8gVEJEIGNhbiBiZSByZW1vdmVkP1xuICAgICAgICAgICAgc2VuZFBhdGhMaXN0IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgnc2VuZFBhdGhMaXN0JywgW10uc2xpY2UuY2FsbChhcmd1bWVudHMpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBrZXlVcGRhdGVkIDogZnVuY3Rpb24gKHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleU5hbWUsIGtleVZhbHVlKSB7XG4gICAgICAgICAgICAgICAgY2FsbFF1ZXVlKCdrZXlVcGRhdGVkJywgWyBwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXlOYW1lLCBrZXlWYWx1ZSBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbktleUNsb25lZCA6IGZ1bmN0aW9uKHByb2plY3RJZCwgZGF0YSkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgnb25LZXlDbG9uZWQnLCBbcHJvamVjdElkLCBkYXRhXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5UmVuYW1lZCA6IGZ1bmN0aW9uKHByb2plY3RJZCwgb2xkS2V5TmFtZSwgbmV3S2V5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgna2V5UmVuYW1lZCcsIFsgcHJvamVjdElkLCBvbGRLZXlOYW1lLCBuZXdLZXlOYW1lIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogQHBhcmFtIGJ1bmRsZU9iaiB7bG9jYWxlOiBzdHJpbmcsIGJ1bmRsZTogc3RyaW5nfVxuICAgICAgICAgICAgICogQHBhcmFtIGRhdGEge29sZEtleTpzdHJpbmcsIG5ld0tleTogc3RyaW5nfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBrZXlEZWxldGVkIDogZnVuY3Rpb24gKHByb2plY3RJZCwga2V5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgna2V5RGVsZXRlZCcsIFsgcHJvamVjdElkLCBrZXlOYW1lIF0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGltYWdlUmVtb3ZlZCA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIGNhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgnaW1hZ2VSZW1vdmVkJywgWyBwcm9qZWN0SWQsIGNhdGVnb3J5TmFtZSBdKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBuZXdQcm9qZWN0V2FzQ3JlYXRlZCA6IGZ1bmN0aW9uIChwcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICBjYWxsUXVldWUoJ25ld1Byb2plY3RXYXNDcmVhdGVkJywgWyBwcm9qZWN0SWQgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnlSZW5hbWVkIDogZnVuY3Rpb24gKHByb2plY3RJZCwgb2xkTmFtZSwgbmV3TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgnY2F0ZWdvcnlSZW5hbWVkJywgWyBwcm9qZWN0SWQsIG9sZE5hbWUsIG5ld05hbWUgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2F0ZWdvcnlEZWxldGVkIDogZnVuY3Rpb24gKHByb2plY3RJZCwgY2F0TmFtZSkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgnY2F0ZWdvcnlEZWxldGVkJywgWyBwcm9qZWN0SWQsIGNhdE5hbWUgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbmV3RGlyZWN0b3J5Q3JlYXRlZCA6IGZ1bmN0aW9uIChkaXJlY3RvcnlJZCkge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgnbmV3RGlyZWN0b3J5Q3JlYXRlZCcsIFsgZGlyZWN0b3J5SWQgXSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvamVjdERlc2NyaXB0aW9uVXBkYXRlZCA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIGlkLCBkZXNjcmlwdGlvbikge1xuICAgICAgICAgICAgICAgIGNhbGxRdWV1ZSgncHJvamVjdERlc2NyaXB0aW9uVXBkYXRlZCcsIFsgcHJvamVjdElkLCBpZCwgZGVzY3JpcHRpb24gXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZFNlcnZlckxpc3RlbmVyIDogZnVuY3Rpb24gKG5hbWUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoZXZlbnRRdWV1ZS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIGV2ZW50UXVldWVbbmFtZV0ucHVzaChjYik7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGV2ZW50UXVldWVbbmFtZV0gPSBbY2JdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZXZlbnRzOyIsImNvbnN0IEMgPSByZXF1aXJlKCcuL0NPTlNUJylcbmNvbnN0IGNvbm5lY3Rpb25Mb3N0ID0gcmVxdWlyZSgnLi91aU1vZHVsZXMvY29ubmVjdGlvbkxvc3QnKVxuXG4vKipcbiAqIFJlZnJlc2ggdGhlIHVzZXIgc2Vzc2lvbiBhbmQgZGV0ZWN0cyBpZiB0aGUgdXNlciBpcyBub3QgYXV0aGVudGljYXRlZCBhbnltb3JlXG4gKiB1c2VmdWwgZm9yOlxuICogICogc2Vzc2lvbiBrZWVwIGFsaXZlXG4gKiAgKiBkZXRlY3QgaWYgdGhlIHVzZXIgaXMgbm90IGF1dGhlbnRpY2F0ZWQgYW55bW9yZVxuICogICogZGV0ZWN0cyBzZXJ2ZXIgc2h1dCBkb3duXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGFuZGxlU2Vzc2lvblRpbWVPdXQoKSB7XG4gICAgY29uc3QgY29ubmVjdGlvbkxvc3RVaSA9IGNvbm5lY3Rpb25Mb3N0KHtcbiAgICAgICAgb25SZWxvYWQgOiAoKSA9PiBsb2NhdGlvbi5yZWxvYWQoKSxcbiAgICAgICAgb25DbG9zZSA6ICgpID0+IGNvbm5lY3Rpb25Mb3N0VWkuZGVzdHJveSgpXG4gICAgfSlcbiAgICBjb25zdCBpbnRlcnZhbCA9IHNldEludGVydmFsKGZ1bmN0aW9uKCkge1xuICAgICAgICBmZXRjaChsb2NhdGlvbi5wcm90b2NvbCArICcvLycgKyBsb2NhdGlvbi5ob3N0ICsgJy90b3VjaFNlc3Npb24nLCB7XG4gICAgICAgICAgICBjcmVkZW50aWFsczogXCJzYW1lLW9yaWdpblwiXG4gICAgICAgIH0pLnRoZW4oZCA9PiB7XG4gICAgICAgICAgICBpZiAoZC5zdGF0dXMgPT09IDQwMSkge1xuICAgICAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwoaW50ZXJ2YWwpXG4gICAgICAgICAgICAgICAgLy8gd2hvb3BzIHNlcnZlciBoYXMgbm8gYXV0aGVudGljYXRpb24gYW55bW9yZS4uLlxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdBVVRIJylcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2goZSA9PiB7XG4gICAgICAgICAgICBjbGVhckludGVydmFsKGludGVydmFsKVxuICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ1NFUlZFUl9ET1dOJywgJ01heWJlIGEgc2VydmVyIHJlc3RhcnQgaGFwcGVucy4gUGxlYXNlIHRyeSB0byBsb2dpbiBhZ2FpbiBpbiBmZXcgbWludXRlcycpXG4gICAgICAgIH0pXG4gICAgfSwgQy5TRVNTSU9OLnJlbmV3YWxfaW50ZXJ2YWxfaW5fbXMpXG59IiwiLypnbG9iYWwgZG9tT3B0cyAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSAqL1xuY29uc3QgdW5pY29kZSA9IHJlcXVpcmUoJy4vdW5pY29kZS5qcycpXG5jb25zdCB0b2FzdCA9IHJlcXVpcmUoJy4vVG9hc3QuanMnKVxuY29uc3QgY2FubnkgPSByZXF1aXJlKCdjYW5ueScpXG5jb25zdCB0cmFkZSA9IHJlcXVpcmUoJy4vdHJhZGUuanMnKVxuY29uc3QgaGFuZGxlU2Vzc2lvblRpbWVPdXQgPSByZXF1aXJlKCcuL2hhbmRsZVNlc3Npb25UaW1lT3V0JylcbmNvbnN0IGJyZWFkQ3J1bWJDb250cm9sbGVyID0gcmVxdWlyZSgnLi9jb250cm9sbGVyL2JyZWFkY3J1bWJDb250cm9sbGVyLmpzJylcblxud2luZG93LmRvbU9wdHMgPSB3aW5kb3cuZG9tT3B0cyB8fCByZXF1aXJlKCdkb20tb3B0cycpO1xuLy8gbWFkZSBpdCBwdWJsaWMgLSBqdXN0IGZvciBkZXZlbG9wbWVudFxud2luZG93LmNhbm55ID0gY2Fubnk7XG5cbmNhbm55LmFkZCgncmVwZWF0JywgICAgICAgICByZXF1aXJlKCdjYW5ueS9tb2QvcmVwZWF0JykpO1xuY2FubnkuYWRkKCd3aGlza2VyJywgICAgICAgIHJlcXVpcmUoJ2Nhbm55L21vZC93aGlza2VyJykpO1xuY2FubnkuYWRkKCdhc3luYycsICAgICAgICAgIHJlcXVpcmUoJ2Nhbm55L21vZC9hc3luYycpKTtcbmNhbm55LmFkZCgnZmxvd0NvbnRyb2wnLCAgICByZXF1aXJlKCdjYW5ueS9tb2QvZmxvd0NvbnRyb2wnKSgnZmxvd0NvbnRyb2wnKSk7XG5jYW5ueS5hZGQoJ2Rpc3BsYXlNYW5hZ2VyJywgcmVxdWlyZSgnLi91aU1vZHVsZXMvZGlzcGxheU1hbmFnZXIuanMnKSk7XG5jYW5ueS5hZGQoJ3RleHRFZGl0b3InLCAgICAgcmVxdWlyZSgnLi90ZXh0RWRpdG9yLmpzJykpO1xuY2FubnkuYWRkKCdjb29raWVNYW5hZ2VyJywgIHJlcXVpcmUoJ2Nhbm55LWNvb2tpZU1hbmFnZXItbGliJykpO1xuXG5jYW5ueS5hZGQoJ3RleHRzJywgICAgICAgICAgICAgICAgICByZXF1aXJlKCcuL3VpTW9kdWxlcy90ZXh0cy5qcycpKTtcbmNhbm55LmFkZCgnYXV0aCcsICAgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL2F1dGguanMnKSk7XG5jYW5ueS5hZGQoJ3Byb2plY3RNYWluTmF2aWdhdGlvbicsICByZXF1aXJlKCcuL3VpTW9kdWxlcy9wcm9qZWN0TWFpbk5hdmlnYXRpb24uanMnKSk7XG5jYW5ueS5hZGQoJ3RyYW5zbGF0aW9uVmlldycsICAgICAgICByZXF1aXJlKCcuL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXcuanMnKSk7XG5jYW5ueS5hZGQoJ3RyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkJywgcmVxdWlyZSgnLi91aU1vZHVsZXMvdHJhbnNsYXRpb25WaWV3SW1hZ2VVcGxvYWQuanMnKSk7XG4vL2Nhbm55LmFkZCgndHJhbnNsYXRpb25WaWV3SGVhZGVyJywgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3RyYW5zbGF0aW9uVmlld0hlYWRlci5qcycpKTtcbmNhbm55LmFkZCgnaW1hZ2VWaWV3ZXInLCAgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL2ltYWdlVmlld2VyLmpzJykpO1xuY2FubnkuYWRkKCdwcm9qZWN0T3ZlcnZpZXcnLCAgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvcHJvamVjdE92ZXJ2aWV3LmpzJykpO1xuY2FubnkuYWRkKCdjcmVhdGVOZXdQcm9qZWN0JywgICAgICAgcmVxdWlyZSgnLi91aU1vZHVsZXMvY3JlYXRlTmV3UHJvamVjdC5qcycpKTtcbmNhbm55LmFkZCgnbWVudVJpZ2h0JywgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL21lbnVSaWdodC5qcycpKTtcbmNhbm55LmFkZCgnYW5jaG9yTWVudScsICAgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL2FuY2hvck1lbnUuanMnKSk7XG5cbmNhbm55LmFkZCgndHJhbnNsYXRpb25WaWV3RGVzY3JpcHRpb24nLCByZXF1aXJlKCcuL3VpTW9kdWxlcy90cmFuc2xhdGlvblZpZXdEZXNjcmlwdGlvbi5qcycpKTtcbmNhbm55LmFkZCgndXBsb2FkJywgICAgICAgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL3VwbG9hZC5qcycpKTtcbmNhbm55LmFkZCgnSk1CRlVwbG9hZGVyJywgICAgICAgICAgIHJlcXVpcmUoJy4vdWlNb2R1bGVzL0pNQkZVcGxvYWRlci5qcycpKTtcbmNhbm55LmFkZCgnSnNvbkltcG9ydCcsICAgICAgICAgICByZXF1aXJlKCcuL3VpTW9kdWxlcy9Kc29uSW1wb3J0LmpzJykpO1xuXG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci9wcm9qZWN0TWFpbk5hdmlnYXRpb25Db250cm9sbGVyLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvcGFnZUhlYWRlckNvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci90cmFuc2xhdGlvblZpZXdDb250cm9sbGVyLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvdGV4dEVkaXRvckNvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci91cmxNYW5pcHVsYXRvci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL3Byb2plY3RPdmVydmlld0NvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci9jcmVhdGVOZXdQcm9qZWN0Q29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIoYnJlYWRDcnVtYkNvbnRyb2xsZXIpO1xudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvYXV0aENvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci9tZW51UmlnaHRDb250cm9sbGVyLmpzJykpO1xudHJhZGUuYWRkQ29udHJvbGxlcihyZXF1aXJlKCcuL2NvbnRyb2xsZXIvdXBsb2FkQ29udHJvbGxlci5qcycpKTtcbnRyYWRlLmFkZENvbnRyb2xsZXIocmVxdWlyZSgnLi9jb250cm9sbGVyL0pNQkZVcGxvYWRlckNvbnRyb2xsZXIuanMnKSk7XG50cmFkZS5hZGRDb250cm9sbGVyKHJlcXVpcmUoJy4vY29udHJvbGxlci9Kc29uSW1wb3J0Q29udHJvbGxlci5qcycpKTtcblxuY2FubnkucmVhZHkoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIC8vIGNyZWF0ZSB3ZWJzb2NrZXQgY29ubmVjdGlvbiB2aWEgdHJhZGVcbiAgICB0cmFkZS5pbml0aWFsaXplKGZ1bmN0aW9uICh1c2VyT2JqZWN0LCBzZXNzaW9uc0VuYWJsZWQpIHtcblxuICAgICAgICBpZiAodXNlck9iamVjdCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgYWxlcnQoJ0EgZmF0YWwgZXJyb3IgaGFwcGVucyB3aGlsZSBsb2FkaW5nIHRoZSB2aWV3JylcbiAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpXG4gICAgICAgICAgICByZXR1cm5cbiAgICAgICAgfVxuICAgICAgICBjYW5ueS50ZXh0cy5zZXRUZXh0cyh7dXNlck5hbWU6IHVzZXJPYmplY3QubmFtZX0pO1xuXG4gICAgICAgIGlmICh1c2VyT2JqZWN0LmlzQWRtaW4pIHtcbiAgICAgICAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgnaXNBZG1pbicpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHNlc3Npb25zRW5hYmxlZCkge1xuICAgICAgICAgICAgLy8gdHJpZ2dlciBhIFwic2Vzc2lvbiBrZWVwIGFsaXZlXCIgYW5kIGRldGVjdHMgaWYgdGhlIHVzZXIgaXMgbm90IGF1dGhlbnRpY2F0ZWQgYW55bW9yZSBvciB0aGUgc2VydmVyIGlzIGRvd25cbiAgICAgICAgICAgIGhhbmRsZVNlc3Npb25UaW1lT3V0KClcbiAgICAgICAgfVxuXG4gICAgfSk7XG59KTtcblxud2luZG93LmNhbm55ID0gY2Fubnk7XG53aW5kb3cuZG9tT3B0cyA9IHJlcXVpcmUoJ2RvbS1vcHRzJyk7XG53aW5kb3cudW5pY29kZSA9IHVuaWNvZGU7XG53aW5kb3cudG9hc3QgPSB0b2FzdDtcblxuLy8gUVVFU1RJT046IGNhbiBpdCBoYXBwZW4gdGhhdCB0aGUgYWJvdmUgY2FsbCB0byB0cmFkZS5pbml0aWFsaXplIChpbiBjYW5ueS5yZWFkeSkgZmluaXNoZXMgZWFybGllciB0aGFuIHRoZSBuZXh0IGxpbmVzP1xuLy8gaS5lLiB0aGUgY2FsbGJhY2sgZm9yIHRyYWRlLnJlYWR5IHdpbGwgbmV2ZXIgYmUgZXhlY3V0ZWQ/IGlmIHllczogd2h5IG5vdCBwYXNzIHRoZSBjYWxsYmFjayBhbHJlYWR5IHRvIHRyYWRlLmluaXRpYWxpemU/XG50cmFkZS5yZWFkeShmdW5jdGlvbiAoKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuICAgIHZhciBwcmogPSAoZnVuY3Rpb24gZ2V0UHJvamVjdE5hbWVBbmRQYXRoRnJvbVVSTCgpIHtcbiAgICAgICAgdmFyIHNwbGl0ID0gbG9jYXRpb24ucGF0aG5hbWUuc3BsaXQoJy8nKSxcbiAgICAgICAgICAgIHBhdGggPSBsb2NhdGlvbi5wYXRobmFtZSxcbiAgICAgICAgICAgIHByak5hbWU7XG4gICAgICAgIGlmICgvXFwucHJqLy50ZXN0KHNwbGl0W3NwbGl0Lmxlbmd0aCAtIDFdKSkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIC5wcmogZXh0ZW5zaW9uIGFuZCBmaXJzdCBzbGFzaFxuICAgICAgICAgICAgcHJqTmFtZSA9IHBhdGgucmVwbGFjZSgnLnByaicsICcnKS5yZXBsYWNlKCcvJywgJycpO1xuICAgICAgICAgICAgcGF0aCA9IHNwbGl0LnNsaWNlKDAsIC0xKS5qb2luKCcvJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhdGhbMF0gIT09ICcvJykge1xuICAgICAgICAgICAgcGF0aCA9ICcvJyArIHBhdGg7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBwYXRoIDogcGF0aCxcbiAgICAgICAgICAgIHByb2plY3RJZCA6IHByak5hbWVcbiAgICAgICAgfTtcbiAgICB9KCkpO1xuXG4gICAgLy8gUVVFU1RJT046IHNpbmNlIHRoaXMgaXMgd29ya2luZyBvbiB0aGUgVVJMIHRoZSBhcHBsaWNhdGlvbiB3YXMgbG9hZGVkIHdpdGggYW5kIHRoaXMgVVJMIGNhbiBiZSBlaXRoZXIgYSBkaXJlY3RvcnkgVVJMXG4gICAgLy8gb3IgYSBwcm9qZWN0IFVSTDogd2h5IGNhbid0IHdlIGRlY2lkZSBmaXJzdCB3aGF0IHdlIGFjdHVhbGx5IGhhdmUgaW4gdGhlIFVSTCBhbmQgdGhlbiBlaXRoZXIgY2FsbCBnZXREaXJlY3RvcnlcbiAgICAvLyBvciBsb2FkUHJvamVjdD8gQU5TV0VSOiBkZXBlbmRzLiBpZiB0aGUgVVJMIHBvaW50cyB0byBhIGRpcmVjdG9yeSwgd2Ugb25seSBoYXZlIHRvIGRvIHRoZSBnZXREaXJlY3RvcnkgY2FsbC5cbiAgICAvLyBpZiB0aGUgVVJMIGlzIGEgcHJvamVjdCwgdHdvIGNhbGxzIGhhdmUgdG8gYmUgbWFkZTogb25lIGxvYWRQcm9qZWN0IGNhbGwgYW5kIG9uZSBleHRyYSBnZXREaXJlY3RvcnkgY2FsbCBmb3IgdGhlXG4gICAgLy8gcGFyZW50IG9mIHRoZSBwcm9qZWN0IChtYWlubHkgZm9yIG5hdmlnYXRpb24gY29tcG9uZW50IHdoaWNoIG5lZWRzIHRvIGtub3cgdGhlIHNpYmxpbmdzIG9mIHRoZSBwcm9qZWN0KS4gQnV0OiB0YWtlXG4gICAgLy8gY2FyZSB0aGF0IHRoaXMgZXh0cmEgZ2V0RGlyZWN0b3J5IG11c3QgKm5vdCogY2hhbmdlIHRoZSBzdGF0ZSBvZiB0aGUgYnJlYWRjcnVtYiB0cmFpbCAodGhhdCBvbmUgc2hvdWxkIHN0aWxsIHNob3dcbiAgICAvLyB0aGUgc2VsZWN0ZWQgcHJvamVjdClcbiAgICBcbiAgICBcbiAgICBpZiAocHJqLnByb2plY3RJZCkge1xuICAgICAgICAvLyB0aGlzIGlzIHRoZSBpbml0aWFsIGNhbGwgdG8gdHJpZ2dlciBhIHByb2plY3QgbG9hZCAtIHlvdSB3aWxsIGdldFxuICAgICAgICAvLyB0aGUgcHJvamVjdC5qc29uIGFuZCBhbGwgdHJhbnNsYXRpb25zXG4gICAgICAgIHRyYWRlLmxvYWRQcm9qZWN0KHByai5wcm9qZWN0SWQsIGZ1bmN0aW9uIChlcnIsIGRhdGEsIHByb2plY3QpIHtcbiAgICAgICAgICAgIC8vIGNhbGxiYWNrIGlzIG9ubHkgY2FsbGVkIGlmIGFuIGVycm9yIG9jY3Vyc1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdMb2FkaW5nIHByb2plY3QgXFwnJyArIHByai5wcm9qZWN0SWQgKyAnXFwnIGZhaWxlZCAtIHByb2plY3QgZG9lc25cXCd0IGV4aXN0cycpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyYW5zbGF0aW9uVmlld0NvbnRyb2xsZXI6bG9hZFByb2plY3QgZmFpbHMgZm9yIHByb2plY3RJZDonLCBwcmoucHJvamVjdElkKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gcmVxdWlyZWQgZm9yIHRoZSBicmVhZGNydW1iXG4gICAgICAgICAgICAgICAgYnJlYWRDcnVtYkNvbnRyb2xsZXIuc2V0UGF0aChwcm9qZWN0LnVybClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9IGVsc2Uge1xuICAgICAgICB0cmFkZS5nZXREaXJlY3RvcnkocHJqLnBhdGgsIGZ1bmN0aW9uIChvYmopIHsgfSk7XG4gICAgfVxuICAgIFxufSk7IiwiLyoqXG4gKiB0ZXh0RWRpdG9yXG4gKi9cbihmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgdGV4dEVkaXRvciA9IChmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgdmFyIHRleHRzID0ge1xuICAgICAgICAgICAgb3JpZ2luVGV4dCA6ICdEb3VibGUgY2xpY2sgdG8gZWRpdCB0aGlzIHRleHQnLFxuICAgICAgICAgICAgZWRpdEJ0biA6ICdFZGl0JyxcbiAgICAgICAgICAgIGNhbmNlbEJ0biA6ICdDYW5jZWwnLFxuICAgICAgICAgICAgY2hhbmdlQnRuIDogJ1NhdmUgY2hhbmdlcydcbiAgICAgICAgfSxcbiAgICAgICAgb25DaGFuZ2VBbGxMaXN0ID0gW107XG5cbiAgICAgICAgZnVuY3Rpb24gZmluZENsb3Nlc3RBbmNlc3RvcldpdGhJZChlbGVtZW50KSB7XG4gICAgICAgICAgICB3aGlsZSAoKGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQpICYmICFlbGVtZW50LmlkKSB7fVxuICAgICAgICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjYWxsQ2hhbmdlTGlzdChpZCwgdmFsdWUsIGZjKSB7XG4gICAgICAgICAgICBvbkNoYW5nZUFsbExpc3QuZm9yRWFjaChmdW5jdGlvbiAoY2IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2IoaWQsIHZhbHVlLCBmYyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVkaXRXaXRoVGV4dGFyZWEobm9kZSwgYnV0dG9uV3JhcCwgb2JqKSB7XG4gICAgICAgICAgICB2YXIgb3BlbiA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIGRpdldyYXBwZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICBidXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICBjYW5jZWxCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICBhcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGV4dGFyZWEnKSxcbiAgICAgICAgICAgICAgICBqc1RleHROO1xuXG4gICAgICAgICAgICBpZiAob2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgncGxhY2Vob2xkZXInKSkge1xuICAgICAgICAgICAgICAgIGFyZWEuc2V0QXR0cmlidXRlKCdwbGFjZWhvbGRlcicsIG9iai5wbGFjZWhvbGRlcik7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNsb3NlKCkge1xuICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgndGV4dEVkaXRvci1oaWRlJyk7XG4gICAgICAgICAgICAgICAgb3BlbiA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBmdW5jdGlvbiBlZGl0KCkge1xuICAgICAgICAgICAgICAgIGlmICghb3Blbikge1xuICAgICAgICAgICAgICAgICAgICBqc1RleHROID0gbm9kZS5xdWVyeVNlbGVjdG9yKCcuanMtdGV4dCcpO1xuICAgICAgICAgICAgICAgICAgICBvcGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYXJlYS52YWx1ZSA9IGpzVGV4dE4uaW5uZXJIVE1MO1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgndGV4dEVkaXRvci1oaWRlJylcbiAgICAgICAgICAgICAgICAgICAgfSwgMTAwKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHNldCBjbGFzc2VzXG4gICAgICAgICAgICBjYW5jZWxCdXR0b24uY2xhc3NOYW1lID0gJ3RleHRFZGl0b3ItYnV0dG9uIHRleHRFZGl0b3ItYnV0dG9uLWNhbmNlbCBvY3RpY29uIG9jdGljb24teCc7XG4gICAgICAgICAgICBidXR0b24uY2xhc3NOYW1lID0gJ3RleHRFZGl0b3ItYnV0dG9uIHRleHRFZGl0b3ItYnV0dG9uLWNoYW5nZSBvY3RpY29uIG9jdGljb24tY2hlY2snO1xuICAgICAgICAgICAgYXJlYS5jbGFzc05hbWUgPSAndGV4dEVkaXRvci1hcmVhJztcbiAgICAgICAgICAgIGRpdldyYXBwZXIuY2xhc3NOYW1lID0gJ3RleHRFZGl0b3Itd3JhcC1hcmVhJztcbiAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgndGV4dEVkaXRvci1oaWRlJyk7XG5cbiAgICAgICAgICAgIC8vIHJlZ2lzdGVyIGxpc3RlbmVyc1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgY2xvc2UpO1xuICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciB2YWwgPSBhcmVhLnZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBpZCA9IGZpbmRDbG9zZXN0QW5jZXN0b3JXaXRoSWQodGhpcykuaWQsXG4gICAgICAgICAgICAgICAgICAgIHJldCA9IGNhbGxDaGFuZ2VMaXN0KGlkLCB2YWwsIGZ1bmN0aW9uIChzdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGpzVGV4dE4uaW5uZXJIVE1MID0gdmFsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigndGV4dEVkaXRvcjp0b1RleHRhcmVhTm9kZSB0ZXh0IG5vdCBhY2NlcHRlZCEgSWdub3JlIGNoYW5nZXMuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2RibGNsaWNrJywgZWRpdCk7XG5cbiAgICAgICAgICAgIC8vIHNldCB0aXRsZXNcbiAgICAgICAgICAgIG5vZGUuc2V0QXR0cmlidXRlKCd0aXRsZScsIHRleHRzLm9yaWdpblRleHQpO1xuICAgICAgICAgICAgY2FuY2VsQnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0ZXh0cy5jYW5jZWxCdG4pO1xuICAgICAgICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZSgndGl0bGUnLCB0ZXh0cy5jaGFuZ2VCdG4pO1xuXG4gICAgICAgICAgICAvLyBhcHBlbmQgdG8gd3JhcHBlciBkaXZcbiAgICAgICAgICAgIGRpdldyYXBwZXIuYXBwZW5kQ2hpbGQoYXJlYSk7XG4gICAgICAgICAgICBidXR0b25XcmFwLmFwcGVuZENoaWxkKGNhbmNlbEJ1dHRvbik7XG4gICAgICAgICAgICBidXR0b25XcmFwLmFwcGVuZENoaWxkKGJ1dHRvbik7XG5cbiAgICAgICAgICAgIC8vIGFwcGVuZCB0byBwYXJlbnRcbiAgICAgICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGl2V3JhcHBlcik7XG5cbiAgICAgICAgICAgIC8vIHJldHVybiBjbGljayBmdW5jdGlvblxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIW9wZW4pIHsgLy8gc2hvdyBpbnB1dFxuICAgICAgICAgICAgICAgICAgICBlZGl0KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHsgLy8gc2hvdyB0ZXh0XG4gICAgICAgICAgICAgICAgICAgIGNsb3NlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVnaXN0ZXIgYSBmdW5jdGlvbiB0byBhIHNwZWNpZmljIGVkaXRvci5cbiAgICAgICAgICAgICAqIElmIHRoZSBmdW5jdGlvbiByZXR1cm5zIHVuZGVmaW5lZCB0aGFuIHRoZSBlZGl0b3IgZXhwZWN0IHRoYXQgdGhlIHBhc3NlZCBjYWxsYmFja1xuICAgICAgICAgICAgICogaXMgY2FsbGVkIHdpdGggdHJ1ZSBvciBmYWxzZS4gSWYgdGhlIG1ldGhvZCByZXR1cm5zIHRydWUgdGhlIHRleHQgd2lsbCBjaGFuZ2UuXG4gICAgICAgICAgICAgKiBJZiB0aGUgbWV0aG9kIHJldHVybnMgZmFsc2UgdGhlIHRleHQgaXMgbm90IGNoYW5nZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIGlkXG4gICAgICAgICAgICAgKiBAcGFyYW0gZmMgPC0gaXMgY2FsbGVkIHdpdGggKHRleHRWYWx1ZSwgY2FsbGJhY2tGdW5jdGlvbikgY2FuIHJldHVybiB1bmRlZmluZWQsIGZhbHNlIGFuZCB0cnVlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIG9uQ2hhbmdlIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgb25DaGFuZ2VBbGxMaXN0LnB1c2goZmMpO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBpZFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgb2JqKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1dHRvbldyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSxcbiAgICAgICAgICAgICAgICAgICAgZWRpdEljb25CdXR0b24gPSAgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgYnV0dG9uV3JhcC5jbGFzc05hbWUgPSd0ZXh0RWRpdG9yLWJ1dHRvbldyYXAnO1xuICAgICAgICAgICAgICAgIGVkaXRJY29uQnV0dG9uLmNsYXNzTmFtZSA9ICd0ZXh0RWRpdG9yLWJ1dHRvbiB0ZXh0RWRpdG9yLWJ1dHRvbi1lZGl0IG9jdGljb24gb2N0aWNvbi1wZW5jaWwnO1xuICAgICAgICAgICAgICAgIGVkaXRJY29uQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZWRpdFdpdGhUZXh0YXJlYShub2RlLCBidXR0b25XcmFwLCBvYmopKTtcbiAgICAgICAgICAgICAgICBlZGl0SWNvbkJ1dHRvbi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgdGV4dHMuZWRpdEJ0bik7XG4gICAgICAgICAgICAgICAgLy8gYXBwZW5kIGVkaXRJY29uQnV0dG9uIHRvIHBhcmVudFxuICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgndGV4dEVkaXRvci1tYWluLXdyYXAnKTtcbiAgICAgICAgICAgICAgICBidXR0b25XcmFwLmFwcGVuZENoaWxkKGVkaXRJY29uQnV0dG9uKTtcbiAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGJ1dHRvbldyYXApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSgpKTtcblxuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHsgbW9kdWxlLmV4cG9ydHMgPSB0ZXh0RWRpdG9yOyB9IGVsc2Uge2Nhbm55LmFkZCgndGV4dEVkaXRvcicsIHRleHRFZGl0b3IpOyB9XG5cbn0oKSk7IiwiLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSAqL1xuLyoqXG4gKiBoYW5kbGUgdGhlIGNvbm5lY3Rpb24gYmV0d2VlbiBzZXJ2ZXIgYW5kIGNsaWVudFxuICovXG5jb25zdCBjYW5ueSA9IHJlcXVpcmUoJ2Nhbm55JylcbmNvbnN0IGV2ZW50cyA9IHJlcXVpcmUoJy4vZXZlbnRzLmpzJylcbmNvbnN0IHNob2UgPSByZXF1aXJlKCdzaG9lJylcbmNvbnN0IGRub2RlID0gcmVxdWlyZSgnZG5vZGUnKVxuY29uc3QgY29ubmVjdGlvbkxvc3QgPSByZXF1aXJlKCcuL3VpTW9kdWxlcy9jb25uZWN0aW9uTG9zdC9pbmRleC5qcycpXG5cbndpbmRvdy5kb21PcHRzID0gd2luZG93LmRvbU9wdHMgfHwgcmVxdWlyZSgnZG9tLW9wdHMnKTtcblxuLyoqXG4gKiBTb21lIG9mIHRoZSBjYWxsYmFja3MgYXJlIGhhbmRsZWQgdmlhIHRoZSByZWdpc3RlcmVkIGNvbnRyb2xsZXIgLSBhZGRDb250cm9sbGVyIG1ldGhvZC5cbiAqL1xudmFyIHRyYWRlID0gKGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICAvLyByZWFkeSBxdWV1ZSBjYWxsIHJlZ2lzdGVyZWQgY2FsbCBiYWNrcyB3aGVuIHRyYWRlIGlzIHJlYWR5XG4gICAgdmFyIGNicyA9IFtdLFxuICAgICAgICBzZXJ2ZXIsXG4gICAgICAgIHJlZ2lzdGVyZWRDb250cm9sbGVyID0gW10sXG4gICAgICAgIC8vIHRoaXMgZmxhZyBzaG91bGQgYmUgdHJ1ZSBpZiB0aGVyZSBpcyBhIHN0YWJsZSBzZXJ2ZXIgY29ubmVjdGlvblxuICAgICAgICBoYXNTZXJ2ZXJDb25uZWN0aW9uID0gZmFsc2UsXG4gICAgICAgIHRyeVRvUmVjb25uZWN0ID0gZmFsc2UsXG4gICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkgPSBjb25uZWN0aW9uTG9zdCh7XG4gICAgICAgICAgICBvblJlbG9hZCA6ICgpID0+IGxvY2F0aW9uLnJlbG9hZCgpLFxuICAgICAgICAgICAgb25SZWNvbm5lY3QgOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdHJ5VG9SZWNvbm5lY3QgPSB0cnVlXG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5zaG93UHJvZ3Jlc3MoKVxuICAgICAgICAgICAgICAgIHN0cmVhbSA9IHNob2UoJy90cmFkZScpXG4gICAgICAgICAgICAgICAgY3JlYXRlQ29ubmVjdGlvbigodXNlck9iamVjdCwgc2Vzc2lvbnNFbmFibGVkKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyT2JqZWN0ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0aGlzIGlzIHRoZSBjYXNlIHdoZW4gdGhlIHNlc3Npb24gZW5kcyBvbiBzZXJ2ZXIgc2lkZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ1JFQ09OTkVDVF9GQUlMJylcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkuZGVzdHJveSgpXG4gICAgICAgICAgICAgICAgICAgICAgICB0cnlUb1JlY29ubmVjdCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2xvc2UgOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5kZXN0cm95KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICBsZXQgc3RyZWFtID0gc2hvZSgnL3RyYWRlJylcbiAgICBsZXQgZFxuXG4gICAgZnVuY3Rpb24gaW5pdChzLCBmYykge1xuICAgICAgICBzZXJ2ZXIgPSBzO1xuXG4gICAgICAgIGlmIChzZXJ2ZXIuc2V0VXNlclJpZ2h0cykge1xuICAgICAgICAgICAgc2VydmVyLnNldFVzZXJSaWdodHMoY2FubnkuY29va2llTWFuYWdlci5mb3JTZXNzaW9uQ29va2llKCd0cmFuc2xhdHJvbl9zZXNzaW9uJykuZ2V0VmFsdWVzKCksIGZjKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGZjKHtuYW1lOidMb2dvdXQnLCBpc0FkbWluOiB0cnVlfSwgZmFsc2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgc2VydmVyLmF0dGFjaENsaWVudENhbGxiYWNrcyhldmVudHMuc2VydmVyRXZlbnRzKTtcbiAgICAgICAgLy8gY2FsbCByZWFkeSBxdWV1ZVxuICAgICAgICBjYnMubWFwKGZ1bmN0aW9uIChjYikge1xuICAgICAgICAgICAgY2IgJiYgY2IoKTtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVDb25uZWN0aW9uKGZjKSB7XG4gICAgICAgIGQgPSBkbm9kZSgpXG4gICAgICAgIGQub24oJ3JlbW90ZScsIGZ1bmN0aW9uIChzZXJ2ZXIpIHtcbiAgICAgICAgICAgIGhhc1NlcnZlckNvbm5lY3Rpb24gPSB0cnVlXG4gICAgICAgICAgICBpbml0KHNlcnZlciwgZmMpO1xuICAgICAgICB9KVxuICAgICAgICBkLm9uKCdmYWlsJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY29uc29sZS5sb2coZXJyKVxuICAgICAgICAgICAgaGFzU2VydmVyQ29ubmVjdGlvbiA9IGZhbHNlXG4gICAgICAgICAgICBjb25uZWN0aW9uTG9zdFVpLnJlbmRlcignQ09OTkVDVElPTl9GQUlMJylcbiAgICAgICAgfSlcbiAgICAgICAgZC5vbignZXJyb3InLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnIpXG4gICAgICAgICAgICAvLyBzb21ldGhpbmcgaGFwcGVuc1xuICAgICAgICAgICAgLy8gZS5nLiBhIFVJIHVwZGF0ZSB0aHJvd3MgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICBoYXNTZXJ2ZXJDb25uZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdFWENFUFRJT04nLCBlcnIubmFtZSlcbiAgICAgICAgfSlcbiAgICAgICAgZC5vbignZW5kJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgLy8gdGhpcyBpcyBjYWxsZWQgaWYgdGhlIGNvbm5lY3Rpb24gaXMgY2xvc2VzIGZyb20gc2VydmVyXG4gICAgICAgICAgICBoYXNTZXJ2ZXJDb25uZWN0aW9uID0gZmFsc2VcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3RyYWRlOmVuZCcsIGVycik7XG4gICAgICAgICAgICAvLyB0aGUgc2V0VGltZW91dCBpcyBmb3IgYXZvaWQgZmxpY2tlcmluZyBpZiBwYWdlIHJlbG9hZCB2aWEgZS5nLiBGNVxuICAgICAgICAgICAgaWYgKHRyeVRvUmVjb25uZWN0KVxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdSRUNPTk5FQ1RfRkFJTCcpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiBjb25uZWN0aW9uTG9zdFVpLnJlbmRlcignQ09OTkVDVElPTl9FTkQnKSwgMTAwMClcbiAgICAgICAgfSlcbiAgICAgICAgZC5waXBlKHN0cmVhbSkucGlwZShkKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgaWYgY29ubmVjdGlvbiBpcyBhdmFpbGFibGUgLSBvdGhlcndpc2Ugc2VuZCB2aWV3IGVycm9yXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNDb25uZWN0ZWQoKSB7XG4gICAgICAgIGlmIChoYXNTZXJ2ZXJDb25uZWN0aW9uKVxuICAgICAgICAgICAgcmV0dXJuIHRydWVcbiAgICAgICAgY29ubmVjdGlvbkxvc3RVaS5yZW5kZXIoJ1JFQ09OTkVDVCcpXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGZ1bmN0aW9uTmFtZSB0aGUgZnVuY3Rpb24gdG8gY2FsbFxuICAgICAqIEBwYXJhbSBhcmdzIGFuIGFycmF5IG9mIHBhcmFtZXRlcnMgd2hpY2ggYXJlIHBhc3NlZCB0byB0aGUgZnVuY3Rpb25cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYWxsQ29udHJvbGxlcihmdW5jdGlvbk5hbWUsIGFyZ3MpIHtcbiAgICAgICAgcmVnaXN0ZXJlZENvbnRyb2xsZXIuZm9yRWFjaChmdW5jdGlvbiAoY29udHJvbGxlcikge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2xsZXIuaGFzT3duUHJvcGVydHkoZnVuY3Rpb25OYW1lKSkge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdjb250cm9sbGVyOicsIGZ1bmN0aW9uTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcltmdW5jdGlvbk5hbWVdLmFwcGx5KG51bGwsIGFyZ3MpXG4gICAgICAgICAgICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25Mb3N0VWkucmVuZGVyKCdGQVRBTCcsIGUubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIGluaXRpYWxpemUgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgIGNyZWF0ZUNvbm5lY3Rpb24oZmMpXG4gICAgICAgIH0sXG4gICAgICAgIGFkZENvbnRyb2xsZXIgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICByZWdpc3RlcmVkQ29udHJvbGxlci5wdXNoKG9iaik7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBMb2FkIHRoZSB3aG9sZSBwcm9qZWN0IGZpbGVzIHdpdGggYWxsIHJlcXVpcmVkIGRhdGEgKHByb2plY3Qgc3BlY2lmaWMganNvbilcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgbG9hZFByb2plY3QgOiBmdW5jdGlvbiAocHJvamVjdElkLCBjYikge1xuICAgICAgICAgICAgc2VydmVyLmxvYWRQcm9qZWN0KHByb2plY3RJZCwgZnVuY3Rpb24gKGRhdGEsIHtpZCwgbmFtZSwgdXJsfSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG92ZXJ3cml0ZSBwcm9qZWN0IGlkXG4gICAgICAgICAgICAgICAgICAgIGRhdGEucHJvamVjdElkID0gaWRcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5wcm9qZWN0ID0gbmFtZVxuICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignb25Mb2FkUHJvamVjdCcsIFtkYXRhLCB7aWQsIG5hbWUsIHVybH1dKTtcbiAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IobnVsbCwgZGF0YSwge2lkLCBuYW1lLCB1cmx9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBjYWxsYmFjayBhIGVycm9yIHNvIHRoZSBjYWxsZXIgaGFzIHRoZSBjb250cm9sIGFib3V0IGVycm9yIGhhbmRsaW5nXG4gICAgICAgICAgICAgICAgICAgIGNiICYmIGNiKGZhbHNlKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogYWN0dWFsbHkgc2FtZSBhcyBzYXZlS2V5IGJ1dCB0aGUgaW50ZXJuYWwgY29udHJvbGxlciBjYWxsIGlzIGRpZmZlcmVudFxuICAgICAgICAgKiBAcGFyYW0gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSBsYW5ndWFnZVxuICAgICAgICAgKiBAcGFyYW0ga2V5QW5kVmFsdWVcbiAgICAgICAgICogQHBhcmFtIGNiXG4gICAgICAgICAqL1xuICAgICAgICBjcmVhdGVLZXkgOiBmdW5jdGlvbiAocHJvamVjdElkLCBsYW5ndWFnZSwga2V5QW5kVmFsdWUsIGNiKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuc2F2ZUtleShwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXlBbmRWYWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyLCBrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSBlcnJvciBjYXNlXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdvbkNyZWF0ZUtleScsIFtwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXksIHZhbHVlXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSB7e2lkIDpzdHJpbmcsIHNvdXJjZUNhdGVnb3J5OnN0cmluZywgdGFyZ2V0Q2F0ZWdvcnk6c3RyaW5nfX0ga2V5QW5kVmFsdWVcbiAgICAgICAgICogQHBhcmFtIGNiXG4gICAgICAgICAqL1xuICAgICAgICBjbG9uZUtleTogZnVuY3Rpb24ocHJvamVjdElkLCBrZXlBbmRWYWx1ZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5jbG9uZUtleShwcm9qZWN0SWQsIGtleUFuZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIsIHByb2plY3RJZCwgZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2IoZXJyLCBwcm9qZWN0SWQsIGRhdGEpXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignb25LZXlDbG9uZWQnLCBbcHJvamVjdElkLCBkYXRhXSlcbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFNhdmUgY2hhbmdlcyB0byBhIGtleSdzIHZhbHVlLiBDaGFuZ2Ugd2lsbCBiZSBicm9hZGNhc3QgdG8gb3RoZXIgY2xpZW50cy5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ3VhZ2VcbiAgICAgICAgICogQHBhcmFtIHt7a2V5OnN0cmluZywgdmFsdWU6c3RyaW5nfX0ga2V5QW5kVmFsdWVcbiAgICAgICAgICogQHBhcmFtIHtmdW5jdGlvbn0gY2IgLSBjYWxsYmFjayB0byBleGVjdXRlIGFmdGVyIHNhdmluZ1xuICAgICAgICAgKi9cbiAgICAgICAgc2F2ZUtleSA6IGZ1bmN0aW9uIChwcm9qZWN0SWQsIGxhbmd1YWdlLCBrZXlBbmRWYWx1ZSwgY2IpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5zYXZlS2V5KHByb2plY3RJZCwgbGFuZ3VhZ2UsIGtleUFuZFZhbHVlLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGVycm9yIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IocHJvamVjdElkLCBsYW5ndWFnZSwga2V5LCB2YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0TmFtZVxuICAgICAgICAgKiBAcGFyYW0gY3VycmVudERpcklkIGlmIG9mIHRoZSBkaXJlY3RvcnkgaW4gd2hpY2ggdGhlIG5ldyBwcm9qZWN0IHdpbGwgYmUgY3JlYXRlZFxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTmV3UHJvamVjdCA6IGZ1bmN0aW9uIChwcm9qZWN0TmFtZSwgY3VycmVudERpcklkKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuY3JlYXRlTmV3UHJvamVjdChjdXJyZW50RGlySWQsIHByb2plY3ROYW1lLCB7fSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyLCBwcm9qZWN0RGF0YSwgcHJvamVjdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBoYW5kbGUgZXJyb3IgY2FzZVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignb25OZXdQcm9qZWN0Q3JlYXRlZCcsIFtwcm9qZWN0RGF0YSwgcHJvamVjdF0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gZGlyZWN0b3J5TmFtZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudERpcmVjdG9yeVxuICAgICAgICAgKi9cbiAgICAgICAgY3JlYXRlTmV3RGlyZWN0b3J5IDogZnVuY3Rpb24oZGlyZWN0b3J5TmFtZSwgY3VycmVudERpcmVjdG9yeSkge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLmNyZWF0ZU5ld0RpcmVjdG9yeShkaXJlY3RvcnlOYW1lLCBjdXJyZW50RGlyZWN0b3J5LFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbihlcnIsIGRpcmVjdG9yeURhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gaGFuZGxlIGVycm9yIGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ29uTmV3RGlyZWN0b3J5Q3JlYXRlZCcsIFtkaXJlY3RvcnlEYXRhXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbmFtZXMgYSBjYXRlZ29yeS5cbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkTmFtZVxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZVxuICAgICAgICAgKi9cbiAgICAgICAgcmVuYW1lQ2F0ZWdvcnkgOiBmdW5jdGlvbiAocHJvamVjdElkLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIucmVuYW1lQ2F0ZWdvcnkocHJvamVjdElkLCBvbGROYW1lLCBuZXdOYW1lLFxuICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbiAoZXJyLCBvbGROYW1lLCBuZXdOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdyZW5hbWVDYXRlZ29yeScsIFtvbGROYW1lLCBuZXdOYW1lXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlbW92ZXMgYSBjYXRlZ29yeSB3aXRoIGFsbCBpdCdzIGNoaWxkIGtleXMuXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNhdE5hbWVcbiAgICAgICAgICovXG4gICAgICAgIHJlbW92ZUNhdGVnb3J5IDogZnVuY3Rpb24gKHByb2plY3RJZCwgY2F0TmFtZSkge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLnJlbW92ZUNhdGVnb3J5KHByb2plY3RJZCwgY2F0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgY2F0TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcigncmVtb3ZlQ2F0ZWdvcnknLCBbY2F0TmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW5hbWVzIGEga2V5IGZvciBhbGwgbGFuZ3VhZ2VzXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9qZWN0SWRcbiAgICAgICAgICogQHBhcmFtIHt7bmV3S2V5OiBzdHJpbmcsIG9sZEtleTogc3RyaW5nfX0gb2JqXG4gICAgICAgICAqL1xuICAgICAgICByZW5hbWVLZXkgOiBmdW5jdGlvbiAocHJvamVjdElkLCBvYmopIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKVxuICAgICAgICAgICAgICAgIHNlcnZlci5yZW5hbWVLZXkocHJvamVjdElkLCB7XG4gICAgICAgICAgICAgICAgICAgIG5ld0tleSA6IG9iai5uZXdLZXksXG4gICAgICAgICAgICAgICAgICAgIG9sZEtleSA6IG9iai5vbGRLZXlcbiAgICAgICAgICAgICAgICB9LCBmdW5jdGlvbiAoZXJyLCBvbGRLZXksIG5ld0tleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ3JlbmFtZUtleScsIFtvbGRLZXksIG5ld0tleV0pXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcigncmVuYW1lS2V5JywgW2ZhbHNlXSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmVzIGEga2V5IGZvciBhbGwgbGFuZ3VhZ2VzLlxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXlOYW1lXG4gICAgICAgICAqIEBwYXJhbSB7ZnVuY3Rpb259IGNiXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVLZXkgOiBmdW5jdGlvbiAocHJvamVjdElkLCBrZXlOYW1lLCBjYikge1xuICAgICAgICAgICAgaWYgKGlzQ29ubmVjdGVkKCkpXG4gICAgICAgICAgICAgICAgc2VydmVyLnJlbW92ZUtleShwcm9qZWN0SWQsIGtleU5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIGtleU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Ioa2V5TmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcigncmVtb3ZlS2V5JywgW2tleU5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHByb2plY3RJZFxuICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gY2F0ZWdvcnlOYW1lXG4gICAgICAgICAqL1xuICAgICAgICByZW1vdmVJbWFnZSA6IGZ1bmN0aW9uKHByb2plY3RJZCwgY2F0ZWdvcnlOYW1lKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIucmVtb3ZlSW1hZ2UocHJvamVjdElkLCBjYXRlZ29yeU5hbWUsIGZ1bmN0aW9uIChlcnIsIGNhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ2ltYWdlUmVtb3ZlZCcsIFtjYXRlZ29yeU5hbWVdKVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9hc3Quc2hvd01lc3NhZ2UoZXJyLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogR2V0IHRoZSBjb250ZW50cyBvZiB0aGUgZGlyZWN0b3J5LlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gZGlyIHRoZSBzZWxlY3RlZCBkaXJlY3RvcnkuXG4gICAgICAgICAqIEBwYXJhbSBjYiB7cHJvamVjdHM6W1N0cmluZ106ZGlyczpbU3RyaW5nXX1cbiAgICAgICAgICovXG4gICAgICAgIGdldERpcmVjdG9yeSA6IGZ1bmN0aW9uIChkaXIsIGNiKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuZ2V0RGlyZWN0b3J5KGRpcixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgYXJncykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvYXN0LnNob3dNZXNzYWdlKCdJbnRlcm5hbCBzZXJ2ZXIgZXJyb3IhIFBsZWFzZSByZXBvcnQgdGhpcyBtZXNzYWdlIHRvIGEgZGV2ZWxvcGVyOiAnICsgZXJyLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9ubHkgY2FsbCB0aGUgY29udHJvbGxlciBpZiBub3QgZmFsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIGNiICYmIGNiKGFyZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXJncyAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsQ29udHJvbGxlcignZ2V0RGlyZWN0b3J5JywgW2FyZ3NdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogc2F2ZSB0aGUgcHJvamVjdCBkZXNjcmlwdGlvblxuICAgICAgICAgKiBAcGFyYW0gcHJvamVjdElkXG4gICAgICAgICAqIEBwYXJhbSBpZFxuICAgICAgICAgKiBAcGFyYW0gZGVzY3JpcHRpb25cbiAgICAgICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICAgICAqL1xuICAgICAgICBzYXZlUHJvamVjdERlc2NyaXB0aW9uIDogZnVuY3Rpb24ocHJvamVjdElkLCBpZCwgZGVzY3JpcHRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuc2F2ZVByb2plY3REZXNjcmlwdGlvbihwcm9qZWN0SWQsIGlkLCBkZXNjcmlwdGlvbixcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKHRydWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbENvbnRyb2xsZXIoJ3NhdmVkUHJvamVjdERlc2NyaXB0aW9uJywgW10pXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogVE9ETyBzdW1tYXJpemUgcHJvamVjdE5hbWUgKyBjdXJyZW50RGlySWQgdG8gb25lIHByb2plY3RJZFxuICAgICAgICAgKiBEZWxldGUgYSBwcm9qZWN0LlxuICAgICAgICAgKiBAcGFyYW0gcHJvamVjdE5hbWVcbiAgICAgICAgICogQHBhcmFtIGN1cnJlbnREaXJJZCAtIEBkZXByZWNhdGVkXG4gICAgICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAgICAgKi9cbiAgICAgICAgZGVsZXRlUHJvamVjdCA6IGZ1bmN0aW9uIChpZCwgY2IpIHtcbiAgICAgICAgICAgIGlmIChpc0Nvbm5lY3RlZCgpKSB7XG4gICAgICAgICAgICAgICAgc2VydmVyLmRlbGV0ZVByb2plY3QoaWQsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChlcnIsIHByb2plY3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBjaGFuZ2UgdG86IHByak5hbWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYihudWxsLCBwcm9qZWN0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdwcm9qZWN0RGVsZXRlZCcsIFtwcm9qZWN0XSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoZXJyKVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRGVsZXRlIGEgcHJvamVjdC5cbiAgICAgICAgICogQHBhcmFtIGRpck5hbWVcbiAgICAgICAgICogQHBhcmFtIGN1cnJlbnREaXJJZFxuICAgICAgICAgKiBAcGFyYW0gY2FsbGJhY2tcbiAgICAgICAgICovXG4gICAgICAgIGRlbGV0ZUZvbGRlciA6IGZ1bmN0aW9uIChkaXJOYW1lLCBjdXJyZW50RGlySWQsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAoaXNDb25uZWN0ZWQoKSlcbiAgICAgICAgICAgICAgICBzZXJ2ZXIuZGVsZXRlRm9sZGVyKGN1cnJlbnREaXJJZCwgZGlyTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVyciwgZGlyTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhudWxsLCBkaXJOYW1lKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxDb250cm9sbGVyKCdmb2xkZXJEZWxldGVkJywgW2Rpck5hbWVdKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayAmJiBjYWxsYmFjayhlcnIpXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIC8vIE5vdCByZWFsbHkgdGVzdGVkXG4gICAgICAgIHJlYWR5IDogZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICBpZiAoc2VydmVyKSB7XG4gICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2JzLnB1c2goY2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhZGU7IiwidmFyIHVpRXZlbnQgPSAoZnVuY3Rpb24gKCkge1xuICAgIHZhciBldmVudFF1ZXVlcyA9IHtcbiAgICAgICAgICAgIGFjdGl2YXRlTGFuZ3VhZ2UgOiBbXSxcbiAgICAgICAgICAgIGRlQWN0aXZhdGVMYW5ndWFnZSA6IFtdLFxuICAgICAgICAgICAgYWRkTGFuZ3VhZ2U6IFtdLFxuICAgICAgICAgICAgc2hvd0V4cG9ydERpYWxvZzogW10sXG4gICAgICAgICAgICBwcm9qZWN0U2VsZWN0ZWQ6IFtdLFxuICAgICAgICAgICAgc2hvd092ZXJ2aWV3UGFnZTogW10sXG4gICAgICAgICAgICB1cGRhdGVLZXk6IFtdLFxuICAgICAgICAgICAgYW5jaG9yRm9jdXM6IFtdLFxuICAgICAgICAgICAgZW5hYmxlRWRpdG9yTW9kZTogW10sXG4gICAgICAgICAgICB0b2dnbGVXb3JkQ291bnQ6IFtdLFxuICAgICAgICAgICAgc2hvd0ZpbGVVcGxvYWQ6IFtdLFxuICAgICAgICAgICAgc2hvd0pNQkZVcGxvYWRlcjogW10sXG4gICAgICAgICAgICBzaG93SlNPTkltcG9ydDogW10sXG4gICAgICAgICAgICBKTUJGRmlsZVVwbG9hZGVkOiBbXSxcbiAgICAgICAgICAgIGpzb25JbXBvcnRlZDogW10sXG4gICAgICAgICAgICBmaWxlVXBsb2FkZWQ6IFtdXG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRVaUV2ZW50TGlzdGVuZXIgOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhvYmopLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGlmIChldmVudFF1ZXVlcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50UXVldWVzW2tleV0ucHVzaChvYmpba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0sXG4gICAgICAgIGNhbGxVaWV2ZW50IDogZnVuY3Rpb24gKGV2ZW50TmFtZSwgYXJncykge1xuICAgICAgICAgICAgdmFyIGFyZ3NMaXN0ID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEsIGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICAgICAgaWYgKGV2ZW50UXVldWVzLmhhc093blByb3BlcnR5KGV2ZW50TmFtZSkpIHtcbiAgICAgICAgICAgICAgICBldmVudFF1ZXVlc1tldmVudE5hbWVdLmZvckVhY2goZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgZmMuYXBwbHkobnVsbCwgYXJnc0xpc3QpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1aUV2ZW50O1xuIiwiLyoqXG4gKiBzaG93cyB0aGUgdXBsb2FkZXIgZm9ybSB0byB1cGxvYWQgYSBpbWFnZSB0byB0aGUgc2VydmVyXG4gKi9cbnZhciBvblVwbG9hZCA9IGZ1bmN0aW9uICgpIHt9LFxuICAgIGJyYWluID0ge1xuICAgICAgICBmaWxlSW5wdXQgOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbmZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICBjb25zb2xlLmxvZygnYy11cGxvYWQ6dHJpZ2dlciB1cGxvYWQnKTtcbiAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbMF07XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgICAgLy8gc2VuZCBpdCBkaXJlY3QgYWZ0ZXIgZHJvcFxuICAgICAgICBbXS5zbGljZS5jYWxsKHRoaXMuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gaW5zdGVhZCBwYXNzICBkaXJlY3RseSBhIGFycmF5IG9mIGZpbGVzIC0gc28gd2Ugc2F2ZSBQT1NUIGNhbGxzXG4gICAgICAgICAgICBvblVwbG9hZChmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNsZWFudXAgdmFsdWUgb3RoZXJ3aXNlIGZpbGUgd2l0aCBzYW1lIG5hbWUgY2FuJ3QgdXBsb2FkZWQgYWdhaW5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7e2FkZDogRnVuY3Rpb24sIHJlYWR5OiBGdW5jdGlvbn19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uVXBsb2FkIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIG9uVXBsb2FkID0gZmM7XG4gICAgfSxcbiAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICBpZiAoYnJhaW4uaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgIGJyYWluW2F0dHJdLmluaXQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59OyIsIi8qKlxuICogc2hvd3MgdGhlIHVwbG9hZGVyIGZvcm0gdG8gdXBsb2FkIGEgaW1hZ2UgdG8gdGhlIHNlcnZlclxuICovXG52YXIgb25VcGxvYWQgPSBmdW5jdGlvbiAoKSB7fSxcbiAgICBicmFpbiA9IHtcbiAgICAgICAgZmlsZUlucHV0IDoge1xuICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIHVwbG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuXG5mdW5jdGlvbiB1cGxvYWQoKSB7XG4gICAgdmFyIGZpbGUgPSB0aGlzLmZpbGVzWzBdO1xuICAgIGlmIChmaWxlKSB7XG4gICAgICAgIC8vIHNlbmQgaXQgZGlyZWN0IGFmdGVyIGRyb3BcbiAgICAgICAgW10uc2xpY2UuY2FsbCh0aGlzLmZpbGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChmaWxlKSB7XG4gICAgICAgICAgICAvLyBUT0RPIGluc3RlYWQgcGFzcyAgZGlyZWN0bHkgYSBhcnJheSBvZiBmaWxlcyAtIHNvIHdlIHNhdmUgUE9TVCBjYWxsc1xuICAgICAgICAgICAgb25VcGxvYWQoZmlsZSk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBjbGVhbnVwIHZhbHVlIG90aGVyd2lzZSBmaWxlIHdpdGggc2FtZSBuYW1lIGNhbid0IHVwbG9hZGVkIGFnYWluXG4gICAgICAgIHRoaXMudmFsdWUgPSBudWxsO1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuLyoqXG4gKlxuICogQHJldHVybnMge3thZGQ6IEZ1bmN0aW9uLCByZWFkeTogRnVuY3Rpb259fVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBvblVwbG9hZCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICBvblVwbG9hZCA9IGZjO1xuICAgIH0sXG4gICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgaWYgKGJyYWluLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICBicmFpblthdHRyXS5pbml0KG5vZGUpO1xuICAgICAgICB9XG4gICAgfVxufTsiLCIvKipcbiAqIGFuY2hvck1lbnVcbiAqXG4gKiBUT0RPIHNob3cgdGhlIGFjdHVhbCBmcmFtZTpcbiAqICAqIGRldGVjdCB3aGljaCBkb21lIGNhdGVnb3JpZXMgaW4gZG9tIGFyZSBpbiB2aWV3IGFuZCBhZGQgYSBjbGFzc2VzIHRvIHRoZSBtZW51IHVsIGNhdGVnb3J5LlxuICogICAgICAqIHRoZSBleHBlY3RlZCBlZmZlY3Qgd2lsbCBiZSBsb29rIGxpa2UgYSBmcmFtZSB3aGljaCBjYXRlZ29yaWVzIGFyZSBpbiB2aWV3XG4gKiAgICAgICogZmlyc3QtY2hpbGQgYm9yZGVyLXRvcCBsYXN0LWNoaWxkIGJvcmRlciBib3R0b20gYW5kIHRoZSByZXN0IGJvcmRlciBsZWZ0IGFuZCByaWdodCB3aWxsIGdpdmUgYSBmcmFtZSBlZmZlY3RcbiAqXG4gKiAgZG8gaXQgZm9yIGFsbCBjLWFuY2hvck1lbnUtcGFyZW50IGVsZW1lbnQgd2hpY2ggY291bGQgYmUgZm91bmQgaW4gdmlld1xuICpcbiAqIFRoZSBhbmNob3IgbWVudSBzaG93cyBhbGwgZWxlbWVudHMgd2hpY2ggaGF2ZSB0aGUgY2xhc3MgYy1hbmNob3JNZW51LXBhcmVudCBhcyBwYXJlbnQgYW5kIHNlYXJjaGVzIGZvciBjaGlsZHJlblxuICogd2l0aCBjbGFzcyBjLWFuY2hvck1lbnUtY2hpbGQuIEl0IHJlbmRlcnMgYSB1bCBsaSBsaXN0IGFuZCByZWdpc3RlcmVkIGEgY2xpY2sgY2FsbCB0byB0aHJvdyBhIGNsaWNrIGV2ZW50IHdpdGggdGhlIGlkLlxuICpcbiAqIEB0eXBlIHtleHBvcnRzfVxuICovXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwvdXJsJyksXG4gICAgdHJhbnNsYXRpb25WaWV3Q29uZmlnID0gcmVxdWlyZSgnLi90cmFuc2xhdGlvblZpZXcnKS5jb25maWcsXG4gICAgcm9vdE5vZGUsXG4gICAgcGFyZW50Tm9kZUxpc3QgPSBbXSxcbiAgICBvblNlbGVjdCA9IGZ1bmN0aW9uICgpIHt9LFxuICAgIHNocmlua09mZnNldEZvclZpZXdEZXRlY3Rpb24gPSAxMDAsXG4gICAgaGlnaGxpZ2h0VG9wTW9zdEtleSA9IChmdW5jdGlvbigpIHtcblxuICAgICAgICB2YXIgaGlnaGxpZ2h0ZWRJdGVtO1xuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBjaGVjayBpZiBub2RlIGlzIGFsaWduZWQgdG9wIG1vc3QgaW4gdGhlIGJyb3dzZXIgdmlld1xuICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAqL1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgICAgIHZhciBmaXJzdE9wZW5DYXRlZ29yeSA9IHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJ2xpLmMtaW5WaWV3JyksXG4gICAgICAgICAgICAgICAgY3VycmVudE1haW5WaWV3Q2F0ZWdvcnlOb2RlLFxuICAgICAgICAgICAgICAgIGN1cnJlbnRNYWluVmlld0NhdGVnb3J5Q2hpbGROb2RlcyxcbiAgICAgICAgICAgICAgICBtYWluVmlld1RvcE1vc3RLZXlOb2RlO1xuXG4gICAgICAgICAgICBpZiAoIWZpcnN0T3BlbkNhdGVnb3J5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBSZXNldCBwcmV2aW91cyBoaWdobGlnaHRlZCBpdGVtXG4gICAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWRJdGVtLmNsYXNzTGlzdC5yZW1vdmUoJ2Mta2V5LWhpZ2hsaWdodCcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBIaWdobGlnaHQgdG9wbW9zdCBpdGVtXG4gICAgICAgICAgICBjdXJyZW50TWFpblZpZXdDYXRlZ29yeU5vZGUgPSBkb2N1bWVudC5ib2R5LnF1ZXJ5U2VsZWN0b3IoJyMnICsgdHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCArIGZpcnN0T3BlbkNhdGVnb3J5LmF0dHJpYnV0ZXMuZGF0YS5ub2RlVmFsdWUucmVwbGFjZSgnYW5jaG9yXycsICcnKSk7XG4gICAgICAgICAgICBpZiAoY3VycmVudE1haW5WaWV3Q2F0ZWdvcnlOb2RlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudE1haW5WaWV3Q2F0ZWdvcnlDaGlsZE5vZGVzID0gY3VycmVudE1haW5WaWV3Q2F0ZWdvcnlOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jLWFuY2hvck1lbnUtY2hpbGQnKTtcbiAgICAgICAgICAgICAgICBtYWluVmlld1RvcE1vc3RLZXlOb2RlID0gZ2V0Rmlyc3RFbGVtZW50SW5WaWV3cG9ydChjdXJyZW50TWFpblZpZXdDYXRlZ29yeUNoaWxkTm9kZXMpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhbmNob3JNZW51OkNhblxcJ3QgZmluZCB0aGUgY2F0ZWdvcnkgbm9kZSB3aXRoIGlkJywgdHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCArIGZpcnN0T3BlbkNhdGVnb3J5LmF0dHJpYnV0ZXMuZGF0YS5ub2RlVmFsdWUucmVwbGFjZSgnYW5jaG9yXycsICcnKSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChtYWluVmlld1RvcE1vc3RLZXlOb2RlKSB7XG4gICAgICAgICAgICAgICAgaGlnaGxpZ2h0ZWRJdGVtID0gcm9vdE5vZGUucXVlcnlTZWxlY3RvcignW2RhdGE9YW5jaG9yXycgKyBtYWluVmlld1RvcE1vc3RLZXlOb2RlLmlkLnJlcGxhY2UodHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCwgJycpICsgJ10nKTtcbiAgICAgICAgICAgICAgICBpZiAoaGlnaGxpZ2h0ZWRJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgIGhpZ2hsaWdodGVkSXRlbS5jbGFzc0xpc3QuYWRkKCdjLWtleS1oaWdobGlnaHQnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9KSgpO1xuXG5mdW5jdGlvbiBmb2N1c0VsZW1lbnQoaWQsIGVsZW0pIHtcbiAgICB2YXIgZG9tO1xuICAgIC8vIGhhbmRsZSB0aGUgYWN0aXZlIGNsYXNzIGZyb20gbWVudVxuICAgIFtdLnNsaWNlLmNhbGwocm9vdE5vZGUucXVlcnlTZWxlY3RvckFsbCgnLmMtYWN0aXZlJykpLmZvckVhY2goZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgbi5jbGFzc0xpc3QucmVtb3ZlKCdjLWFjdGl2ZScpO1xuICAgIH0pO1xuICAgIGVsZW0uY2xhc3NMaXN0LmFkZCgnYy1hY3RpdmUnKTtcbiAgICBlbGVtLnBhcmVudE5vZGUucGFyZW50Tm9kZS5jbGFzc0xpc3QuYWRkKCdjLWFjdGl2ZScpO1xuICAgIC8vIGhhbmRsZSB0aGUgY29tbW9uIGRvbSBhY3RpdmUgY2xhc3NcbiAgICBbXS5zbGljZS5jYWxsKGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jLWFuY2hvck1lbnUtZm9jdXMnKSkuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICBuLmNsYXNzTGlzdC5yZW1vdmUoJ2MtYW5jaG9yTWVudS1mb2N1cycpO1xuICAgIH0pO1xuICAgIGRvbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRyYW5zbGF0aW9uVmlld0NvbmZpZy5yb3dQcmVmaXggKyBpZCk7XG4gICAgaWYgKGRvbSkge1xuICAgICAgICBkb20uY2xhc3NMaXN0LmFkZCgnYy1hbmNob3JNZW51LWZvY3VzJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coJ2FuY2hvck1lbnU6Zm9jdXNFbGVtZW50IGNhblxcJ3QgZmluZCBlbGVtZW50IGZvciBhIGFuY2hvcicsIGlkKTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gaXRlbXMgW3tpZCA6IHN0cmluZywgY2hpbGRyZW4gOiBbc3RyaW5nXX1dXG4gKi9cbmZ1bmN0aW9uIGFkZEl0ZW1zKHJvb3QsIGl0ZW1zKSB7XG4gICAgdmFyIHVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndWwnKSxcbiAgICAgICAgYW5jaG9yID0gdXRpbC5nZXRBbmNob3IoKTtcbiAgICByb290LmFwcGVuZENoaWxkKHVsKTtcbiAgICBpdGVtcy5mb3JFYWNoKGZ1bmN0aW9uIChjYXRPYmopIHtcbiAgICAgICAgdmFyIGxpID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnbGknKSxcbiAgICAgICAgICAgIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgIC8vIFRPRE8gY2hlY2sgd2l0aCBsb2dcbiAgICAgICAgaWYgKHR5cGVvZiBjYXRPYmogIT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKCdhbmNob3JNZW51OmNhdGVnb3J5IG5lZWRzIHRvIGJlIGFuIG9iamVjdCcsIGNhdE9iaik7XG4gICAgICAgIH1cbiAgICAgICAgc3Bhbi5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjYXRPYmouaWQpKTtcbiAgICAgICAgbGkuYXBwZW5kQ2hpbGQoc3Bhbik7XG4gICAgICAgIGxpLnNldEF0dHJpYnV0ZSgnZGF0YScsICdhbmNob3JfJyArIGNhdE9iai5pZCk7XG4gICAgICAgIHNwYW4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBvblNlbGVjdChjYXRPYmouaWQpO1xuICAgICAgICAgICAgZm9jdXNFbGVtZW50KGNhdE9iai5pZCwgbGkpO1xuICAgICAgICB9KTtcblxuICAgICAgICBpZiAoY2F0T2JqLmNoaWxkcmVuKSB7XG4gICAgICAgICAgICBhZGRJdGVtcyhsaSwgY2F0T2JqLmNoaWxkcmVuKVxuICAgICAgICB9XG4gICAgICAgIHVsLmFwcGVuZENoaWxkKGxpKTtcbiAgICAgICAgaWYgKCcjJyArIGNhdE9iai5pZCA9PT0gYW5jaG9yKSB7XG4gICAgICAgICAgICBmb2N1c0VsZW1lbnQoY2F0T2JqLmlkLCBsaSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuLyoqXG4gKiBjaGVjayBpcyB0aGUgbm9kZSBpcyBpbiB0aGUgdmlld1xuICogQHBhcmFtIG5vZGVcbiAqL1xuZnVuY3Rpb24gaXNOb2RlSW5WaWV3KG5vZGUpIHtcbiAgICB2YXIgeU9mZnNldCA9IHdpbmRvdy5zY3JvbGxZIHx8IHdpbmRvdy5wYWdlWU9mZnNldCxcbiAgICAgICAgdyA9IHtcbiAgICAgICAgICAgIHRvcDogeU9mZnNldCxcbiAgICAgICAgICAgIGJvdHRvbSA6IHlPZmZzZXQgKyB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICAgICAgfSxcbiAgICAgICAgYm9keVJlY3QgPSBkb2N1bWVudC5ib2R5LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLFxuICAgICAgICBlbGVtUmVjdCA9IG5vZGUuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIG9mZnNldCA9IGVsZW1SZWN0LnRvcCAtIGJvZHlSZWN0LnRvcCArIHNocmlua09mZnNldEZvclZpZXdEZXRlY3Rpb24sXG4gICAgICAgIG5vZGVIZWlnaHQgPSBvZmZzZXQgKyBub2RlLm9mZnNldEhlaWdodCAtIChzaHJpbmtPZmZzZXRGb3JWaWV3RGV0ZWN0aW9uICogMik7XG4gICAgcmV0dXJuIG9mZnNldCA+IHcudG9wICYmIG9mZnNldCA8IHcuYm90dG9tIHx8ICAgIC8vIGlzIHRvcCBmcmFtZSBpbiB2aWV3XG4gICAgICAgIG5vZGVIZWlnaHQgPiB3LnRvcCAmJiBub2RlSGVpZ2h0IDwgdy5ib3R0b20gfHwgIC8vIGlzIGJvdHRvbSBmcmFtZSBpbiB2aWV3XG4gICAgICAgIG9mZnNldCA8IHcudG9wICYmIG5vZGVIZWlnaHQgPiB3LmJvdHRvbTsgICAgLy8gaXMgdG9wIGZyYW1lIGFib3ZlIHZpZXcgYW5kIGJvdHRvbSBmcmFtZSBiZWxvdyB2aWV3XG59XG5cbmZ1bmN0aW9uIGN1dENhdGVnb3JpZXModmFsKSB7XG4gICAgdmFyIHNwbGl0ID0gdmFsLnNwbGl0KCdfJyk7XG4gICAgaWYgKHNwbGl0Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgc3BsaXQuc3BsaWNlKDAsIDEpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBpZCA6IHZhbCxcbiAgICAgICAgdmFsdWUgOiBzcGxpdC5qb2luKCdfJylcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGV4cGFuZENhdGVnb3JpZXNJblZpZXcoKSAgICAge1xuICAgIHBhcmVudE5vZGVMaXN0LmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgbGkgPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCdbZGF0YT1hbmNob3JfJyArIG9iai5pZCArICddJyk7XG4gICAgICAgIGlmIChpc05vZGVJblZpZXcob2JqLm5vZGUpKSB7XG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKCdjLWluVmlldycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGkuY2xhc3NMaXN0LnJlbW92ZSgnYy1pblZpZXcnKTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBnZXRGaXJzdEVsZW1lbnRJblZpZXdwb3J0KG5vZGVzKSB7XG4gICAgdmFyIGtleU5vZGUsXG4gICAgICAgIHBhZ2VTY3JvbGxPZmZzZXQgPSBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcCB8fCAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3ApLFxuICAgICAgICBpID0gbm9kZXMubGVuZ3RoLFxuICAgICAgICBub2RlTWFyZ2luO1xuXG4gICAgd2hpbGUoaS0tKSB7XG4gICAgICAgIGtleU5vZGUgPSBub2Rlc1tpXTtcbiAgICAgICAgbm9kZU1hcmdpbiA9IHBhcnNlSW50KHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGtleU5vZGUsIG51bGwpLm1hcmdpbkJvdHRvbSwgMTApO1xuICAgICAgICBpZihnZXRQYWdlT2Zmc2V0Rm9yRWxlbWVudChrZXlOb2RlKSAtIG5vZGVNYXJnaW4gKiAyIDw9IHBhZ2VTY3JvbGxPZmZzZXQpIHtcbiAgICAgICAgICAgIHJldHVybiBrZXlOb2RlO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gUmV0dXJuIGZpcnN0IGtleSBub2RlIGZvciBjdXJyZW50IGFjdGl2ZSBjYXRlZ29yeVxuICAgIHJldHVybiBub2Rlc1swXTtcbn1cblxuZnVuY3Rpb24gZ2V0UGFnZU9mZnNldEZvckVsZW1lbnQoZWxlbSkge1xuICAgIHZhciBib2R5UmVjdCA9IGRvY3VtZW50LmJvZHkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICAgIGVsZW1SZWN0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICByZXR1cm4gZWxlbVJlY3QudG9wIC0gYm9keVJlY3QudG9wO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBmb2N1c0VsZW1lbnQgOiBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgdmFyIGxpID0gcm9vdE5vZGUucXVlcnlTZWxlY3RvcignW2RhdGE9YW5jaG9yXycgKyBpZCArICddJyk7XG4gICAgICAgIGlmIChsaSkge1xuICAgICAgICAgICAgZm9jdXNFbGVtZW50KGlkLGxpKTtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgb25TZWxlY3QgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25TZWxlY3QgPSBmYztcbiAgICB9LFxuICAgIHJlbmRlck1lbnUgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjYXRPYmogPSBbXTtcbiAgICAgICAgLy8gY2xlYXIgcGFyZW50IG5vZGUgbGlzdFxuICAgICAgICBwYXJlbnROb2RlTGlzdCA9IFtdO1xuXG4gICAgICAgIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgnLmMtYW5jaG9yTWVudS1wYXJlbnQnKSkuZm9yRWFjaChmdW5jdGlvbiAocGFyZW50KSB7XG4gICAgICAgICAgICB2YXIgaWQgPSBwYXJlbnQuZ2V0QXR0cmlidXRlKCdpZCcpLFxuICAgICAgICAgICAgICAgIGNoaWxkcmVuID0gW107XG4gICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICBpZCA9IGlkLnJlcGxhY2UodHJhbnNsYXRpb25WaWV3Q29uZmlnLnJvd1ByZWZpeCwgJycpO1xuICAgICAgICAgICAgICAgIC8vIGNvbGxlY3QgcGFyZW50c1xuICAgICAgICAgICAgICAgIHBhcmVudE5vZGVMaXN0LnB1c2goe25vZGUgOiBwYXJlbnQsIGlkIDogaWR9KTtcblxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwocGFyZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJy5jLWFuY2hvck1lbnUtY2hpbGQnKSkuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gY2hpbGQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkcmVuLnB1c2goY3V0Q2F0ZWdvcmllcyhpZC5yZXBsYWNlKHRyYW5zbGF0aW9uVmlld0NvbmZpZy5yb3dQcmVmaXgsICcnKSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2F0T2JqLnB1c2goe2lkIDogaWQsIGNoaWxkcmVuIDogY2hpbGRyZW59KTtcblxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgW10uc2xpY2UuY2FsbChyb290Tm9kZS5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIGNoaWxkLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICB9KTtcbiAgICAgICAgYWRkSXRlbXMocm9vdE5vZGUsIGNhdE9iaik7XG4gICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuWzBdLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIDEyNSArICdweCc7XG4gICAgICAgIFxuICAgICAgICAvLyB0aW1lIGRlbGF5ZWQgdHJpZ2dlciB0aGUgaW5pdCB2aWV3XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXhwYW5kQ2F0ZWdvcmllc0luVmlldygpO1xuICAgICAgICAgICAgaGlnaGxpZ2h0VG9wTW9zdEtleSgpO1xuICAgICAgICB9LCAxMDAwKVxuICAgIH0sXG4gICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgcm9vdE5vZGUgPSBub2RlO1xuICAgIH0sXG4gICAgcmVhZHkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgZXhwYW5kQ2F0ZWdvcmllc0luVmlldygpO1xuICAgICAgICAgICAgaGlnaGxpZ2h0VG9wTW9zdEtleSgpO1xuICAgICAgICB9KTtcbiAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGlmIChyb290Tm9kZS5jaGlsZHJlblswXSkge1xuICAgICAgICAgICAgICAgIHJvb3ROb2RlLmNoaWxkcmVuWzBdLnN0eWxlLmhlaWdodCA9IHdpbmRvdy5pbm5lckhlaWdodCAtIDEyNSArICdweCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBpbml0IHRoZSBtZW51IHdpdGggYSB0aW1lIGRlbGF5XG4gICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgZXhwYW5kQ2F0ZWdvcmllc0luVmlldygpO1xuICAgICAgICAgICAgaGlnaGxpZ2h0VG9wTW9zdEtleSgpO1xuICAgICAgICB9LCAxNTAwKVxuXG4gICAgfVxufTsiLCJ2YXIgb25Mb2dvdXQgPSBmdW5jdGlvbiAoKSB7Y29uc29sZS5sb2coJ2F1dGg6b25Mb2dvdXQgaXMgbm90IGhhbmRsZWQnKX0sXG4gICAgYnJhaW4gPSB7XG4gICAgICAgIGxvZ291dEJ1dHRvbiA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25Mb2dvdXQpO1xuICAgICAgICB9XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25Mb2dvdXQgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25Mb2dvdXQgPSBmYztcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgIGlmIChicmFpbi5oYXNPd25Qcm9wZXJ0eShhdHRyKSkge1xuICAgICAgICAgICAgYnJhaW5bYXR0cl0obm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59OyIsInZhciByZXBlYXRGY1BvaW50ZXIsXG4gICAgb25DbGljayA9IGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgIGNvbnNvbGUud2FybignYnJlYWRjcnVtYjpjbGljayBoYW5kbGVyIG5vdCByZWdpc3RlcmVkJywgaXRlbSk7XG4gICAgfTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25DbGljayA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICBvbkNsaWNrID0gZmM7XG4gICAgfSxcbiAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge30sXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcGFyZW50RGlyZWN0b3JpZXMgW1N0cmluZ11cbiAgICAgKi9cbiAgICB1cGRhdGVGb2xkZXJzIDogZnVuY3Rpb24gKHBhcmVudERpcmVjdG9yaWVzKSB7XG4gICAgICAgIHJlcGVhdEZjUG9pbnRlcihwYXJlbnREaXJlY3Rvcmllcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiB7bmFtZSA6IGl0ZW0ubmFtZSwgb25DbGljayA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBvbkNsaWNrKGl0ZW0uaWQpO1xuICAgICAgICAgICAgfX1cbiAgICAgICAgfSkpO1xuICAgIH0sXG4gICAgLyoqXG4gICAgICogZm9yIGNhbm55IHJlcGVhdCB0byBnZXRcbiAgICAgKi9cbiAgICByZWdpc3RlckNhbm55UmVwZWF0IDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIHJlcGVhdEZjUG9pbnRlciA9IGZjO1xuICAgIH1cbn1cbiIsIm1vZHVsZS5leHBvcnRzID0gXCI8ZGl2IGNsYXNzPVxcXCJjb25uZWN0aW9uTG9zdFxcXCI+XFxuICA8c2VjdGlvbj5cXG4gICAgPGkgY2xhc3M9XFxcIm9jdGljb24gb2N0aWNvbi1wbHVnXFxcIj48L2k+XFxuICAgIDxoMj57e2l0ZW0udGl0bGV9fTwvaDI+XFxuICAgIDxkaXYgY2xhc3M9XFxcImVycm9yQ29kZVxcXCI+PHA+RXJyb3IgY29kZTogPHN0cm9uZz57e2l0ZW0uZXJyb3JDb2RlfX08L3N0cm9uZz48c3BhbiBjbGFzcz1cXFwiZXJyb3JNZXNzYWdlXFxcIiB3ay1iaW5kPVxcXCJpdGVtLmVycm9yTWVzc2FnZVxcXCI+PC9zcGFuPjwvcD48L2Rpdj5cXG4gICAgPGRpdiBjbGFzcz1cXFwiYnV0dG9uLXNlY3Rpb25cXFwiPlxcbiAgICAgIDxidXR0b24gY2xhc3M9XFxcInJlY29ubmVjdFxcXCIgd2stYmluZD1cXFwiaXRlbS5yZWNvbm5lY3RcXFwiIHRpdGxlPVxcXCJUcnkgdG8gcmVjb25uZWN0IHlvdXIgY2hhbmdlcyB3aWxsIGJlIG92ZXJ3cml0dGVuXFxcIj5yZWNvbm5lY3Q8L2J1dHRvbj5cXG4gICAgICA8YnV0dG9uIGNsYXNzPVxcXCJjbG9zZVxcXCIgd2stYmluZD1cXFwiaXRlbS5jbG9zZVxcXCIgdGl0bGU9XFxcIllvdSBjYW4gY2xvc2UgdGhpcyB2aWV3IHRvIHJlc2N1cmUgeW91IGNoYW5nZXMgbWFudWFsbHlcXFwiPmNsb3NlPC9idXR0b24+XFxuICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwicmVsb2FkXFxcIiB3ay1iaW5kPVxcXCJpdGVtLnJlbG9hZFxcXCIgdGl0bGU9XFxcIklmIHlvdSBkbyBhIHBhZ2UgcmVsb2FkIGFsbCB5b3VyIHVuc2F2ZWQgY2hhbmdlcyB3aWxsIGJlIGxvc3RcXFwiPnJlbG9hZCBwYWdlPC9idXR0b24+XFxuICAgIDwvZGl2PlxcbiAgPC9zZWN0aW9uPlxcbiAgPGRpdiBjbGFzcz1cXFwicHJvZ3Jlc3NVaVxcXCI+PC9kaXY+XFxuPC9kaXY+XCI7XG4iLCJjb25zdCB3aGlza2VyID0gcmVxdWlyZSgnY2FubnkvbW9kL3doaXNrZXInKVxuY29uc3QgdGVtcGxhdGUgPSByZXF1aXJlKCcuL2luZGV4Lmh0bWwnKVxuY29uc3QgVEVYVFMgPSBmdW5jdGlvbiAoY29kZSkge1xuICAgIHN3aXRjaChjb2RlKSB7XG4gICAgICAgIGNhc2UgJ0VYQ0VQVElPTic6XG4gICAgICAgICAgICByZXR1cm4gJ3dvdy4uLiBub3QgZ29vZCAtIHBsZWFzZSByZXBvcnQgdGhpcyBwcm9ibGVtIHRvIGEgZGV2ZWxvcGVyJ1xuICAgICAgICBjYXNlICdGQVRBTCc6XG4gICAgICAgICAgICByZXR1cm4gJ2RhbW1lZC4uLiB0aGlzIHNob3VsZCBub3QgaGFwcGVuIC0gcGxlYXNlIGNvbnN1bHQgZGV2IG9mIHRydXN0J1xuICAgICAgICBjYXNlICdBVVRIJzpcbiAgICAgICAgICAgIHJldHVybiAnU2Vzc2lvbiB0aW1lb3V0IHBsZWFzZSBsb2dpbiBhZ2FpbidcbiAgICAgICAgY2FzZSAnUkVDT05ORUNUX0ZBSUwnOlxuICAgICAgICAgICAgcmV0dXJuICdjYW5cXCd0IGNyZWF0ZSBhIGNvbm5lY3Rpb24nXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICByZXR1cm4gJ3dob29vcHMuLi4gc2VydmVyIGNvbm5lY3Rpb24gbG9zdCdcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcGFyYW0gb25SZWxvYWRcbiAqIEBwYXJhbSBvblJlY29ubmVjdFxuICogQHJldHVybnMge3tyZW5kZXI6IChmdW5jdGlvbihzdHJpbmcpKSwgZGVzdHJveTogKGZ1bmN0aW9uKCkpfX1cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoe29uUmVsb2FkLCBvblJlY29ubmVjdCwgb25DbG9zZX0pIHtcbiAgICAvLyBzYXZlcyB0aGUgYWN0aXZlIG5vZGVcbiAgICBsZXQgdWk7XG5cbiAgICBmdW5jdGlvbiByZW5kZXIoe2Vycm9yQ29kZSwgZXJyb3JNZXNzYWdlfSkge1xuICAgICAgICBpZiAodWkpIHVpLnJlbW92ZSgpXG4gICAgICAgIGNvbnN0IGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgICAgICBkLmlubmVySFRNTCA9IHRlbXBsYXRlXG4gICAgICAgIHdoaXNrZXIuYWRkKGQuY2hpbGRyZW5bMF0sIHtcbiAgICAgICAgICAgIHJlY29ubmVjdCA6IG4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvckNvZGUgPT09ICdSRUNPTk5FQ1RfRkFJTCcgfHwgZXJyb3JDb2RlID09PSAnRkFUQUwnIHx8IGVycm9yQ29kZSA9PT0gJ0FVVEgnIHx8IGVycm9yQ29kZSA9PT0gJ1NFUlZFUl9ET1dOJyB8fCBlcnJvckNvZGUgPT09ICdFWENFUFRJT04nKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgICAgICBuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgb25SZWNvbm5lY3QpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UgOiBuID0+IG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBvbkNsb3NlKSxcbiAgICAgICAgICAgIHJlbG9hZCA6IG4gPT4gbi5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIG9uUmVsb2FkKSxcbiAgICAgICAgICAgIGVycm9yQ29kZSxcbiAgICAgICAgICAgIHRpdGxlIDogVEVYVFMoZXJyb3JDb2RlKSxcbiAgICAgICAgICAgIGVycm9yTWVzc2FnZSA6IG4gPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvck1lc3NhZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgbi5pbm5lckhUTUwgPSBgICR7ZXJyb3JNZXNzYWdlfWBcbiAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQodWkgPSBkLmNoaWxkcmVuWzBdKVxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBTaG93IHRoZSBtb2R1bGVcbiAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGVyciAtIGVycm9yIGNvZGUgdG8gcHJpbnQgb24gdGhlIHZpZXdcbiAgICAgICAgICovXG4gICAgICAgIHJlbmRlciA6IChlcnIsIG1zZykgPT4gcmVuZGVyKHtlcnJvckNvZGUgOiBlcnIsIGVycm9yTWVzc2FnZTogbXNnfSksXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBSZW1vdmUgdGhlIG1vZHVsZSBmcm9tIHVpXG4gICAgICAgICAqL1xuICAgICAgICBkZXN0cm95IDogKCkgPT4ge1xuICAgICAgICAgICAgdWkucmVtb3ZlKClcbiAgICAgICAgICAgIHVpID0gdW5kZWZpbmVkXG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBpbmRpY2F0ZXMgdGhhdCB0aGUgdmlldyBpcyBidXN5XG4gICAgICAgICAqL1xuICAgICAgICBzaG93UHJvZ3Jlc3MgOiAoKSA9PiB7XG4gICAgICAgICAgICB1aS5jbGFzc0xpc3QuYWRkKCdwcm9ncmVzcycpXG4gICAgICAgIH1cbiAgICB9XG59IiwidmFyIG9uQ3JlYXRlTmV3UHJvamVjdCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4oJ2NyZWF0ZU5ld1Byb2plY3Qub25DcmVhdGVOZXdQcm9qZWN0IG5vdCBzZXQnKX0sXG4gICAgb25DcmVhdGVOZXdEaXJlY3RvcnkgPSBmdW5jdGlvbigpIHsgY29uc29sZS53YXJuKCdjcmVhdGVOZXdQcm9qZWN0Lm9uQ3JlYXRlTmV3RGlyZWN0b3J5IG5vdCBzZXQnKX07XG5cbnZhciBwcm9qZWN0TmFtZUlucHV0Tm9kZSxcbiAgICBkaXJlY3RvcnlOYW1lSW5wdXROb2RlO1xuXG5mdW5jdGlvbiBpc1ZhbGlkUHJvamVjdE5hbWUocHJvamVjdE5hbWUpIHtcbiAgICByZXR1cm4gKHByb2plY3ROYW1lLmxlbmd0aCA+IDAgJiYgcHJvamVjdE5hbWUuc2VhcmNoKCdcXFxcLnwsfCAnKSA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBpc1ZhbGlkRGlyZWN0b3J5TmFtZShkaXJlY3RvcnlOYW1lKSB7XG4gICAgLy8gVEJEIG1vcmUgZm9yYmlkZGVuIGNoYXJhY3RlcnM/XG4gICAgcmV0dXJuIChkaXJlY3RvcnlOYW1lLmxlbmd0aCA+IDAgJiYgZGlyZWN0b3J5TmFtZS5zZWFyY2goJy8nKSA9PT0gLTEpID8gdHJ1ZSA6IGZhbHNlO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhZGQgOiBmdW5jdGlvbihub2RlLCBhdHRyaWJ1dGUpIHtcbiAgICAgICAgc3dpdGNoIChhdHRyaWJ1dGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZU5ld1Byb2plY3RJbnB1dFByb2plY3QnIDpcbiAgICAgICAgICAgICAgICBwcm9qZWN0TmFtZUlucHV0Tm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICduZXdEaXJlY3RvcnlOYW1lSW5wdXQnIDpcbiAgICAgICAgICAgICAgICBkaXJlY3RvcnlOYW1lSW5wdXROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZU5ld1Byb2plY3RTdWJtaXQnIDpcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0TmFtZSA9IHByb2plY3ROYW1lSW5wdXROb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZFByb2plY3ROYW1lKHByb2plY3ROYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgb25DcmVhdGVOZXdQcm9qZWN0KHByb2plY3ROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb2plY3ROYW1lSW5wdXROb2RlLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2NyZWF0ZU5ld0RpcmVjdG9yeVN1Ym1pdCcgOlxuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdG9yeU5hbWUgPSBkaXJlY3RvcnlOYW1lSW5wdXROb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNWYWxpZERpcmVjdG9yeU5hbWUoZGlyZWN0b3J5TmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ3JlYXRlTmV3RGlyZWN0b3J5KGRpcmVjdG9yeU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGlyZWN0b3J5TmFtZUlucHV0Tm9kZS5jbGFzc0xpc3QuYWRkKCdlcnJvcicpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdjYW5jZWwnOlxuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FubnkuZGlzcGxheU1hbmFnZXIuaGlkZSh0aGlzLmRhdGFzZXQudmlldylcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXNzIGluIGxpc3RlbmVyIGZvciBleGVjdXRpb24gb2YgY3JlYXRpbmcgbmV3IHByb2plY3QuXG4gICAgICogQHBhcmFtIGZ1bmNcbiAgICAgKi9cbiAgICBvbkNyZWF0ZU5ld1Byb2plY3QgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgIG9uQ3JlYXRlTmV3UHJvamVjdCA9IGZ1bmM7XG4gICAgfSxcbiAgICAvKipcbiAgICAgKiBQYXNzIGluIGxpc3RlbmVyIGZvciBleGVjdXRpb24gb2YgY3JlYXRpbmcgYSBuZXcgZGlyZWN0b3J5LlxuICAgICAqIEBwYXJhbSBmdW5jXG4gICAgICovXG4gICAgb25DcmVhdGVOZXdEaXJlY3RveSA6IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICAgICAgb25DcmVhdGVOZXdEaXJlY3RvcnkgPSBmdW5jO1xuICAgIH1cbn07XG4iLCJ2YXIgT3ZlcmxheSA9IHJlcXVpcmUoJy4vb3ZlcmxheScpLFxuXHRkaXNwbGF5TWFuYWdlciA9IGZ1bmN0aW9uKCkge1xuXG5cdFx0dmFyIG1haW5Db250cm9sbGVyID0gY2FubnkuZmxvd0NvbnRyb2wsXG5cdFx0XHRvdmVybGF5Q29udHJvbGxlciA9IGNhbm55LmZsb3dDb250cm9sLmNyZWF0ZU5ld0luc3RhbmNlKCdvdmVybGF5cycpLFxuXHRcdFx0Y2hpbGRyZW4gPSB7XG5cdFx0XHRcdG92ZXJsYXk6IHtcblx0XHRcdFx0XHRpZHM6IFtdLFxuXHRcdFx0XHRcdGNvbnRyb2xsZXI6IG92ZXJsYXlDb250cm9sbGVyLFxuXHRcdFx0XHRcdGFkZDogZnVuY3Rpb24obm9kZSwgaWQpIHtcblxuXHRcdFx0XHRcdFx0dmFyIG92ZXJsYXkgPSBuZXcgT3ZlcmxheShub2RlLCBpZCk7XG5cdFx0XHRcdFx0XHRvdmVybGF5Lm9uQ2xpY2soZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHNldERpc3BsYXlTdGF0ZUJ5SWQoaWQsIGZhbHNlKTtcblx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHR0aGlzLmNvbnRyb2xsZXIuYWRkKG92ZXJsYXkubm9kZSwge1xuXHRcdFx0XHRcdFx0XHQndmlldyc6IG92ZXJsYXkuaWRcblx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0dGhpcy5pZHMucHVzaChvdmVybGF5LmlkKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHZpZXc6IHtcblx0XHRcdFx0XHRpZHM6IFtdLFxuXHRcdFx0XHRcdGNvbnRyb2xsZXI6IG1haW5Db250cm9sbGVyLFxuXHRcdFx0XHRcdGFkZDogZnVuY3Rpb24obm9kZSwgaWQpIHtcblx0XHRcdFx0XHRcdHRoaXMuY29udHJvbGxlci5hZGQobm9kZSwge1xuXHRcdFx0XHRcdFx0XHQndmlldyc6IGlkXG5cdFx0XHRcdFx0XHR9KTtcblx0XHRcdFx0XHRcdHRoaXMuaWRzLnB1c2goaWQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdGZ1bmN0aW9uIHNldERpc3BsYXlTdGF0ZUJ5SWQoaWQsIHNob3cpIHtcblx0XHRcdE9iamVjdC5rZXlzKGNoaWxkcmVuKS5tYXAoZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHR2YXIgcG9vbCA9IGNoaWxkcmVuW3R5cGVdLFxuXHRcdFx0XHRcdGlkcyA9IHBvb2wuaWRzLFxuXHRcdFx0XHRcdGN1cnJlbnRJZDtcblxuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGlkcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRcdGN1cnJlbnRJZCA9IGlkc1tpXTtcblx0XHRcdFx0XHRpZiAoaWQgPT09IGN1cnJlbnRJZCkge1xuXHRcdFx0XHRcdFx0aWYgKHNob3cpIHtcblx0XHRcdFx0XHRcdFx0cG9vbC5jb250cm9sbGVyLnNob3coY3VycmVudElkKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGVsc2UgaWYgKHBvb2wuY29udHJvbGxlci5tb2RbaWRdKSB7XG5cdFx0XHRcdFx0XHRcdHBvb2wuY29udHJvbGxlci5tb2RbaWRdLmZvckVhY2goZnVuY3Rpb24ob2JqKSB7XG5cdFx0XHRcdFx0XHRcdFx0b2JqLmhpZGUoKTtcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKG5vZGUsIGRlc2NyaXB0b3IpIHtcblx0XHRcdFx0dmFyIGtleXMsIGtleTtcblx0XHRcdFx0aWYgKHR5cGVvZiBkZXNjcmlwdG9yID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHRcdGtleXMgPSBPYmplY3Qua2V5cyhkZXNjcmlwdG9yKTtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdFx0XHRcdGtleSA9IGtleXNbaV07XG5cdFx0XHRcdFx0XHRpZiAoY2hpbGRyZW4uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuXHRcdFx0XHRcdFx0XHRjaGlsZHJlbltrZXldLmFkZChub2RlLCBkZXNjcmlwdG9yW2tleV0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHRjb25zb2xlLndhcm4oJ1BhcmFtZXRlciB0byBhZGQgY2hpbGQgdG8gZGlzcGxheU1hbmFnZXIgaXMgbm90IHZhbGlkOiAnICsgZGVzY3JpcHRvcik7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRzaG93OiBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRzZXREaXNwbGF5U3RhdGVCeUlkKGlkLCB0cnVlKTtcblx0XHRcdH0sXG5cdFx0XHRoaWRlOiBmdW5jdGlvbihpZCkge1xuXHRcdFx0XHRzZXREaXNwbGF5U3RhdGVCeUlkKGlkLCBmYWxzZSk7XG5cdFx0XHR9XG5cblx0XHR9O1xuXHR9O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRpc3BsYXlNYW5hZ2VyOyIsIi8qKlxuICogaGFuZGxlcyBhbGwgdGV4dHNcbiAqL1xudmFyIGRvbU9wdHMgPSByZXF1aXJlKCdkb20tb3B0cycpLFxuICAgIGZsYWdNYXAgPSB7XG4gICAgICAgIGRhOiAnZGsnLFxuICAgICAgICBkZTogJ2RlJyxcbiAgICAgICAgZnI6ICdmcicsXG4gICAgICAgIG5sOiAnbmwnLFxuICAgICAgICBlbjogJ3VzJyxcbiAgICAgICAgZW5fR0I6ICdnYicsXG4gICAgICAgIHN2OiAnc2UnLFxuICAgICAgICBlczogJ2VzJ1xuICAgIH07XG5cbmZ1bmN0aW9uIGdldExhbmcobGFuZykge1xuICAgIHZhciBmbGFnTGFuZyA9IGxhbmc7XG4gICAgaWYgKGZsYWdNYXAuaGFzT3duUHJvcGVydHkobGFuZykpIHtcbiAgICAgICAgZmxhZ0xhbmcgPSBmbGFnTWFwW2xhbmddO1xuICAgIH1cbiAgICByZXR1cm4gZmxhZ0xhbmc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGdldEZsYWcgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICByZXR1cm4gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ2ZsYWctaWNvbiBmbGFnLWljb24tJyArIGdldExhbmcobGFuZykpO1xuICAgIH0sXG4gICAgZ2V0RmxhZ0NsYXNzZXMgOiBmdW5jdGlvbiAobGFuZykge1xuICAgICAgICByZXR1cm4gWydmbGFnLWljb24nLCAnZmxhZy1pY29uLScgKyBnZXRMYW5nKGxhbmcpXTtcbiAgICB9XG59OyIsIi8qZ2xvYmFsIGFjZSAqL1xuLypqc2xpbnQgYnJvd3NlcjogdHJ1ZSAqL1xudmFyIHRyYWRlID0gcmVxdWlyZSgnLi4vdHJhZGUuanMnKSxcbiAgICBldmVudHMgPSByZXF1aXJlKCcuLi9ldmVudHMuanMnKSxcbiAgICBDID0gcmVxdWlyZSgnLi4vQ09OU1QuanMnKTtcblxud2luZG93LmRvbU9wdHMgPSB3aW5kb3cuZG9tT3B0cyB8fCByZXF1aXJlKCdkb20tb3B0cycpO1xuXG52YXIgaW1hZ2VWaWV3ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIG5vZGVUb0FwcGVuZCxcbiAgICAgICAgaW5pdCA9IGZhbHNlLFxuICAgICAgICBjb25maWcgPSB7XG4gICAgICAgICAgICBpZFByZWZpeCA6ICdpbWFnZVZpZXdlcl8nXG4gICAgICAgIH0sXG4gICAgICAgIHNldHVwQ29udGFpbmVyQ1NTID0gZnVuY3Rpb24gKG5vZGUsIGNzcykge1xuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjc3MpIHtcbiAgICAgICAgICAgICAgICBub2RlLnN0eWxlW3Byb3BdID0gIGNzc1twcm9wXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2V0dGluZ3MgPSB7XG4gICAgICAgICAgICBtYXhXaWR0aCA6IDMwMCxcbiAgICAgICAgICAgIG1heEhlaWdodDogMzAwXG4gICAgICAgIH0sXG4gICAgICAgIGZjID0ge1xuICAgICAgICAgICAgaGlkZUltYWdlVmlld2VyIDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBwcmVzID0gbm9kZVRvQXBwZW5kLmRvbUNoaWxkVGFncygnaW1nJyk7XG5cbiAgICAgICAgICAgICAgICBpZiAocHJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSBvdGhlciBvcGVuIGltYWdlc1xuICAgICAgICAgICAgICAgICAgICBwcmVzLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGUuZG9tQWRkQ2xhc3MoJ2hpZGRlbicpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2hvd0ltYWdlIDogZnVuY3Rpb24gKG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBpbWcsIGlkID0gY29uZmlnLmlkUHJlZml4ICsgb2JqLmlkLFxuICAgICAgICAgICAgICAgICAgICBhY3R1YWxJbWcgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpZCk7XG5cbiAgICAgICAgICAgICAgICBpZiAoYWN0dWFsSW1nICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjdHVhbEltZy5kb21SZW1vdmVDbGFzcygnaGlkZGVuJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5vbmxvYWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygnRE9ORSBJTUFHRScpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBpbWcuc3JjID0gIFwiZGF0YTppbWFnZS9wbmc7YmFzZTY0LFwiICsgb2JqLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHNldHVwQ29udGFpbmVyQ1NTKGltZywge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4V2lkdGggOiAnMTAwJScsXG4gICAgICAgICAgICAgICAgICAgICAgICBtYXhIZWlnaHQgOiAnMTAwJSdcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGltZy5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpO1xuICAgICAgICAgICAgICAgICAgICBpbWcuZG9tQXBwZW5kVG8obm9kZVRvQXBwZW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG5cbiAgICAgICAgZXZlbnRzLmFkZFNlcnZlckxpc3RlbmVyKCdzZW5kRmlsZScsIGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgICAgIGlmIChpbml0KSB7XG4gICAgICAgICAgICAgICAgZmMuaGlkZUltYWdlVmlld2VyKCk7XG5cbiAgICAgICAgICAgICAgICBpZiAob2JqLmZpbGVUeXBlID09PSBDLkZJTEVfTUFOQUdFUi5GSUxFX1RZUEVTLklNQUdFKSB7XG4gICAgICAgICAgICAgICAgICAgIGZjLnNob3dJbWFnZShvYmopO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cblxuICAgIHJldHVybiB7XG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgICAgICBpbml0ID0gdHJ1ZTtcbiAgICAgICAgICAgIG5vZGVUb0FwcGVuZCA9IG5vZGU7XG4gICAgICAgICAgICBub2RlVG9BcHBlbmQuc2V0QXR0cmlidXRlKCdpZCcsICdpbWFnZVZpZXdlcicpO1xuXG4gICAgICAgICAgICBzZXR1cENvbnRhaW5lckNTUyhub2RlVG9BcHBlbmQsIHtcbiAgICAgICAgICAgICAgICB3aWR0aCA6IHNldHRpbmdzLm1heFdpZHRoICsgJ3B4JyxcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHNldHRpbmdzLm1heEhlaWdodCArICdweCdcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgICAgICBzZXR1cCA6IGZ1bmN0aW9uIChjb25maWcpIHtcbiAgICAgICAgICAgIHZhciBvYmo7XG4gICAgICAgICAgICBmb3IgKG9iaiBpbiBjb25maWcpIHtcbiAgICAgICAgICAgICAgICBzZXR0aW5nc1tvYmpdID0gY29uZmlnW29ial07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSBpbWFnZVZpZXdlcjsiLCJcbmZ1bmN0aW9uIGFkZEVkaXQobm9kZSwgZmMpIHtcbiAgIHZhciBkaXYgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyLWJ1dHRvbiBlZGl0IG9jdGljb24gb2N0aWNvbi1wZW5jaWwnKTtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdjLWVkaXQnKTtcbiAgICAgICAgZmMoZXZlbnQpO1xuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ2VkaXQnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XG59XG5mdW5jdGlvbiBhZGRDYW5jZWwobm9kZSwgZmMpIHtcbiAgICB2YXIgZGl2ID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnaW5wdXRFZGl0TWFuYWdlci1idXR0b24gY2FuY2VsIG9jdGljb24gb2N0aWNvbi14Jyk7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1lZGl0Jyk7XG4gICAgICAgIGZjKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCd0aXRsZScsICdjYW5jZWwnKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XG59XG5cbmZ1bmN0aW9uIGFkZFNhdmUobm9kZSwgZmMpIHtcbiAgICB2YXIgZGl2ID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnaW5wdXRFZGl0TWFuYWdlci1idXR0b24gc2F2ZSBvY3RpY29uIG9jdGljb24tY2hlY2snKTtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZmMoZXZlbnQpO1xuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ3NhdmUgY2hhbmdlcycpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQoZGl2KTtcbn1cblxuZnVuY3Rpb24gYWRkQ2xvbmUobm9kZSwgZmMpIHtcbiAgICB2YXIgZGl2ID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnaW5wdXRFZGl0TWFuYWdlci1idXR0b24gc2F2ZSBvY3RpY29uIG9jdGljb24tZmlsZS1zeW1saW5rLWZpbGUnKTtcbiAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgZmMoZXZlbnQpO1xuICAgIH0pO1xuICAgIGRpdi5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ21vdmUga2V5IGludG8gb3RoZXIgY2F0ZWdvcnknKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XG59XG5cbmZ1bmN0aW9uIGFkZERlbGV0ZShub2RlLCBmYykge1xuICAgIHZhciBkaXYgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyLWJ1dHRvbiBkZWxldGUgb2N0aWNvbiBvY3RpY29uLXRyYXNoY2FuJyk7XG4gICAgZGl2LmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKGV2ZW50KSB7XG4gICAgICAgIGZjKGV2ZW50KTtcbiAgICB9KTtcbiAgICBkaXYuc2V0QXR0cmlidXRlKCd0aXRsZScsICdyZW1vdmUgdGhpcyBrZXknKTtcbiAgICBub2RlLmFwcGVuZENoaWxkKGRpdik7XG59XG5cbmZ1bmN0aW9uIGNsb3NlRWRpdG9yVmlldyhrZXlJbnB1dE5vZGUpIHtcbiAgICB2YXIgZWRpdG9yUGFuZWxOb2RlID0ga2V5SW5wdXROb2RlLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLmlucHV0RWRpdE1hbmFnZXIud3JhcCcpO1xuICAgIGlmIChlZGl0b3JQYW5lbE5vZGUpIHtcbiAgICAgICAgZWRpdG9yUGFuZWxOb2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2MtZWRpdCcpO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgLyoqXG4gICAgICogZWFjaCBrZXkgaW5wdXQgbm9kZSBoYXN0XG4gICAgICogQHBhcmFtIGtleUlucHV0Tm9kZVxuICAgICAqL1xuICAgIGNsb3NlRWRpdFZpZXcgOiBmdW5jdGlvbiAoa2V5SW5wdXROb2RlKSB7XG4gICAgICAgIGlmIChrZXlJbnB1dE5vZGUpIHtcbiAgICAgICAgICAgIGNsb3NlRWRpdG9yVmlldyhrZXlJbnB1dE5vZGUpO1xuICAgICAgICB9XG4gICAgfSxcbiAgICBhZGRFZGl0b3JQYW5lbCA6IGZ1bmN0aW9uIChrZXlOb2RlLCBsaXN0ZW5lcnMpIHtcbiAgICAgICAgdmFyIGNvbnRhaW5lck5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdpbnB1dEVkaXRNYW5hZ2VyIHdyYXAnKTtcblxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvbkVkaXQnKSkge1xuICAgICAgICAgICAgYWRkRWRpdChjb250YWluZXJOb2RlLCBsaXN0ZW5lcnMub25FZGl0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvbkRlbGV0ZScpKSB7XG4gICAgICAgICAgICBhZGREZWxldGUoY29udGFpbmVyTm9kZSwgbGlzdGVuZXJzLm9uRGVsZXRlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvblNhdmUnKSkge1xuICAgICAgICAgICAgYWRkU2F2ZShjb250YWluZXJOb2RlLCBsaXN0ZW5lcnMub25TYXZlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvbkNsb25lJykpIHtcbiAgICAgICAgICAgIGFkZENsb25lKGNvbnRhaW5lck5vZGUsIGxpc3RlbmVycy5vbkNsb25lKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdGVuZXJzLmhhc093blByb3BlcnR5KCdvbkNhbmNlbCcpKSB7XG4gICAgICAgICAgICBhZGRDYW5jZWwoY29udGFpbmVyTm9kZSwgbGlzdGVuZXJzLm9uQ2FuY2VsKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnRhaW5lck5vZGUuZG9tQXBwZW5kVG8oa2V5Tm9kZSk7XG5cbiAgICAgICAgcmV0dXJuIGNvbnRhaW5lck5vZGU7XG4gICAgfSxcbiAgICByZW1vdmVQYW5lbCA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIG5vZGUucXVlcnlTZWxlY3RvcignLmlucHV0RWRpdE1hbmFnZXIud3JhcCcpLmRvbVJlbW92ZSgpO1xuICAgIH1cbn0iLCJcbnZhciByb290Tm9kZTtcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgc2hvdyA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LmFkZCgnYy1zaG93Jyk7XG4gICAgfSxcbiAgICBoaWRlIDogZnVuY3Rpb24gKCkge1xuICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLXNob3cnKTtcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgIGlmIChhdHRyID09PSAnYnV0dG9uJykge1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgIGlmIChyb290Tm9kZS5jbGFzc0xpc3QuY29udGFpbnMoJ2Mtc2hvdycpKSB7XG4gICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1zaG93Jyk7XG4gICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlLmNsYXNzTGlzdC5hZGQoJ2Mtc2hvdycpO1xuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByb290Tm9kZSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBPdmVybGF5KG5vZGUsIGlkKSB7XG5cblx0dmFyIGlkID0gaWQsXG5cdFx0bm9kZSA9IG5vZGUsXG5cdFx0Y2xpY2tIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRjb25zb2xlLndhcm4oJ0NsaWNrIGxpc3RlbmVyIG5vdCBhdHRhY2hlZCBmb3Igb3ZlcmxheSB3aXRoIGlkOiAnICsgaWQpO1xuXHRcdH07XG5cblx0bm9kZS5jbGFzc0xpc3QuYWRkKCdkaXNwbGF5TWFuYWdlci1vdmVybGF5Jyk7XG5cdG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoZSkge1xuXHRcdGlmIChub2RlID09PSBlLnRhcmdldCkge1xuXHRcdFx0Y2xpY2tIYW5kbGVyKCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdGlkOiBpZCxcblx0XHRub2RlOiBub2RlLFxuXHRcdG9uQ2xpY2s6IGZ1bmN0aW9uKGNiKSB7XG5cdFx0XHRjbGlja0hhbmRsZXIgPSBjYjtcblx0XHR9XG5cdH1cbn07IiwiLypnbG9iYWwgKi9cbi8qanNsaW50IGJyb3dzZXI6IHRydWUqL1xuXG52YXIgY2FubnkgPSByZXF1aXJlKCdjYW5ueScpLFxuICAgIGZsYWcgPSByZXF1aXJlKCcuL2ZsYWcnKSxcbiAgICB0ZXh0cyA9IHJlcXVpcmUoJy4vdGV4dHMnKTtcblxuLyoqXG4gKiBFLmcuOiBjYW5ueS1tb2Q9XCJmbG93Q29udHJvbFwiIGNhbm55LXZhcj1cInsndmlldycgOiAndmlld1RvU2hvdyd9XCJcbiAqXG4gKiB5b3UgY2FuIGFjdGl2YXRlIGEgaW5pdGlhbCB2aWV3IHdpdGggYSBhbmNob3IgaW4gdGhlIFVSTCBlLmcuOiB5b3VyZG9tYWluLmh0bWwjdmlld1RvU2hvd1xuICogT3IgcGFzcyBhIGNvbW1hIHNlcGFyYXRlZCBtb2R1bGUgbGlzdCBmb3IgYWN0aXZhdGUgbW9yZSBtb2R1bGUgI3ZpZXdUb1Nob3csb3RoZXJWaWV3XG4gKlxuICogVE9ETyBtYWRlIGl0IHBvc3NpYmxlIHRvIHN1bW1hcml6ZSB2aWV3cyB3aXRoIG9uZSBpZGVudGlmaWVyLlxuICogSW5zdGVhZCBvZiBjYWxsOiBnZG9tLmZsb3dDb250cm9sLnNob3coJ3ZpZXcxJywgJ3ZpZXcyJywgJ3ZpZXczJykgY2FsbCBnZG9tLmZsb3dDb250cm9sLnNob3coJ3ZpZXcnKS5cbiAqL1xudmFyIHByb2plY3RNYWluTmF2aWdhdGlvbiA9IChmdW5jdGlvbiAoKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG5cbiAgICB2YXIgbWFpbk5vZGUsXG4gICAgICAgIHNlbGVjdExhbmd1YWdlUXVldWUgPSBbXSxcbiAgICAgICAgb25TaG93SlNPTlF1ZXVlID0gW10sXG4gICAgICAgIG9uRW5hYmxlRWRpdG9yTW9kZVF1ZXVlID0gW10sXG4gICAgICAgIG9uVG9nZ2xlV29yZENvdW50UXVldWUgPSBbXSxcbiAgICAgICAgb25TaG93Sk1CRlF1ZXVlID0gW10sXG4gICAgICAgIG9uU2hvd0pNQkZVcGxvYWRlclF1ZXVlID0gW10sXG4gICAgICAgIG9uU2hvd0pTT05JbXBvcnRRdWV1ZSA9IFtdLFxuICAgICAgICBidW5kbGVOYW1lID0gd2luZG93LmRvbU9wdHMucGFyYW1zLmJ1bmRsZSxcbiAgICAgICAgbW9kVmlld3MgPSB7XG4gICAgICAgICAgICBtYWluIDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBtYWluTm9kZSA9IG5vZGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgbWVudVRvZ2dsZUJ1dHRvbiA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgbmV3IHN2Z0ljb24obm9kZSwge1xuICAgICAgICAgICAgICAgICAgICBoYW1idXJnZXJDcm9zcyA6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA6ICcvZGlzdC9hbmltYXRlZFNWRy9zdmcvaGFtYnVyZ2VyLnN2ZycsXG4gICAgICAgICAgICAgICAgICAgICAgICBhbmltYXRpb24gOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA6ICdwYXRoOm50aC1jaGlsZCgxKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wZXJ0aWVzIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA6IHsgdmFsIDogJ3tcInBhdGhcIiA6IFwibSA1LjA5MTY3ODksMjAuODE4OTk0IDUzLjgxNjY0MjEsMFwifScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIDogeyB2YWwgOiAne1wicGF0aFwiIDogXCJNIDEyLjk3Mjk0NCw1MC45MzYxNDcgNTEuMDI3MDU2LDEyLjg4MjAzNVwifScgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsIDogJ3BhdGg6bnRoLWNoaWxkKDIpJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYW5pbVByb3BlcnRpZXMgOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmcm9tIDogeyB2YWwgOiAne1widHJhbnNmb3JtXCIgOiBcInMxIDFcIiwgXCJvcGFjaXR5XCIgOiAxfScsIGJlZm9yZSA6ICd7XCJ0cmFuc2Zvcm1cIiA6IFwiczAgMFwifScgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRvIDogeyB2YWwgOiAne1wib3BhY2l0eVwiIDogMH0nIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA6ICdwYXRoOm50aC1jaGlsZCgzKScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFuaW1Qcm9wZXJ0aWVzIDoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJvbSA6IHsgdmFsIDogJ3tcInBhdGhcIiA6IFwibSA1LjA5MTY3ODgsNDIuOTU2OTggNTMuODE2NjQyMiwwXCJ9JyB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG8gOiB7IHZhbCA6ICd7XCJwYXRoXCIgOiBcIk0gMTIuOTcyOTQ0LDEyLjg4MjAzNSA1MS4wMjcwNTYsNTAuOTM2MTQ3XCJ9JyB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgICAgIGVhc2luZyA6IG1pbmEuZWxhc3RpYywgc3BlZWQ6IDEyMDAsIHNpemUgOiB7dyA6ICc0ZW0nLCBoIDogJzNlbSd9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1haW5Ob2RlLmNsYXNzTGlzdC5jb250YWlucygnYy1vcGVuJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5Ob2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2Mtb3BlbicpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWFpbk5vZGUuY2xhc3NMaXN0LmFkZCgnYy1vcGVuJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dSZXNvdXJjZUJ1bmRsZUVkaXRvciA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgLy8gcmVsb2FkIHRoZSBwYWdlIGJlY2F1c2UgdGhlIGZpbGVzIGFyZSBub3Qgc3luY2VkXG4gICAgICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCAnIycpO1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uLnJlbG9hZCgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dNZXNzYWdlQnVuZGxlRm9ybWF0IDogZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBvblNob3dKTUJGUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dKU09OQnVuZGxlIDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TaG93SlNPTlF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93Sk1CRlVwbG9hZGVyIDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TaG93Sk1CRlVwbG9hZGVyUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dKU09OSW1wb3J0IDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb25TaG93SlNPTkltcG9ydFF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmYygpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBlbmFibGVFZGl0b3JNb2RlIDogZnVuY3Rpb24obm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgb25FbmFibGVFZGl0b3JNb2RlUXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZVdvcmRDb3VudCA6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uVG9nZ2xlV29yZENvdW50UXVldWUuZm9yRWFjaChmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGZyb20gOiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZnJvbS5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICB0byA6IGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50by5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIC8qKlxuICAgICAqXG4gICAgICogQHBhcmFtIGxvY2FsZXMgW11cbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldExvY2FsZShsb2NhbGVzLCBub2RlKSB7XG4gICAgICAgIHZhciB1bCA9IG5vZGUucXVlcnlTZWxlY3RvcignLmxhbmd1YWdlcycpLCBsaSwgbGFuZ3VhZ2VOYW1lTm9kZSwgcHJvZ3Jlc3NOb2RlLCBmbGFnSUM7XG4gICAgICAgIGlmICh1bCkge1xuICAgICAgICAgICAgLy8gcmVtb3ZlIGFsbCBleGlzdGluZyBjaGlsZHJlbiBmaXJzdFxuICAgICAgICAgICAgW10uc2xpY2UuY2FsbCh1bC5xdWVyeVNlbGVjdG9yQWxsKCdsaScpKS5mb3JFYWNoKGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgICAgICAgICAgICAgdWwucmVtb3ZlQ2hpbGQoZWxlbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHVsID0gd2luZG93LmRvbU9wdHMuY3JlYXRlRWxlbWVudCgndWwnLCBudWxsLCAnbmF2aWdhdGlvbk1lbnUgbGFuZ3VhZ2VzJyk7XG4gICAgICAgIH1cbiAgICAgICAgbG9jYWxlcy5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBudW1PZlRyYW5zS2V5cyA9IHdpbmRvdy5kb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3NwYW4nLCBudWxsLCAnbnVtT2ZUcmFuc0tleXMnKSxcbiAgICAgICAgICAgICAgICBtYXhLZXlOb2RlID0gd2luZG93LmRvbU9wdHMuY3JlYXRlRWxlbWVudCgnc3BhbicsIG51bGwsICdtYXhLZXknKTtcbiAgICAgICAgICAgIGxpID0gd2luZG93LmRvbU9wdHMuY3JlYXRlRWxlbWVudCgnbGknKTtcbiAgICAgICAgICAgIGxhbmd1YWdlTmFtZU5vZGUgPSB3aW5kb3cuZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICBwcm9ncmVzc05vZGUgPSB3aW5kb3cuZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ3Byb2dyZXNzJyk7XG4gICAgICAgICAgICBudW1PZlRyYW5zS2V5cy5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgnLScpKTtcbiAgICAgICAgICAgIG51bU9mVHJhbnNLZXlzLmRvbUFwcGVuZFRvKHByb2dyZXNzTm9kZSk7XG4gICAgICAgICAgICBwcm9ncmVzc05vZGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJy8nKSk7XG4gICAgICAgICAgICBtYXhLZXlOb2RlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKCctJykpO1xuICAgICAgICAgICAgbWF4S2V5Tm9kZS5kb21BcHBlbmRUbyhwcm9ncmVzc05vZGUpO1xuXG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKCdsYW5nJyk7XG4gICAgICAgICAgICBsaS5jbGFzc0xpc3QuYWRkKGtleSk7XG5cbiAgICAgICAgICAgIGxpLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBpc0luYWN0aXZlID0gdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgaXNBY3RpdmUgPSB0aGlzLmNsYXNzTGlzdC5jb250YWlucygnYy1hY3RpdmUnKTtcblxuICAgICAgICAgICAgICAgIGlmIChpc0FjdGl2ZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsYXNzTGlzdC50b2dnbGUoJ2MtaW5hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgaXNJbmFjdGl2ZSA9IHRoaXMuY2xhc3NMaXN0LmNvbnRhaW5zKCdjLWluYWN0aXZlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaGFzIG5vIHN0YXRlXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgc2VsZWN0TGFuZ3VhZ2VRdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0FjdGl2ZSA6IGlzQWN0aXZlLFxuICAgICAgICAgICAgICAgICAgICAgICAgaXNJbmFjdGl2ZSA6IGlzSW5hY3RpdmUsXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm9qZWN0IDogYnVuZGxlTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmd1YWdlOiBrZXlcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgbGFuZ3VhZ2VOYW1lTm9kZS5pbm5lckhUTUwgPSB0ZXh0cy5nZXRMYW5ndWFnZU5hbWVzKGtleSk7XG4gICAgICAgICAgICBsYW5ndWFnZU5hbWVOb2RlLmNsYXNzTmFtZSA9ICdsYW5nTmFtZSc7XG4gICAgICAgICAgICBsYW5ndWFnZU5hbWVOb2RlLmRvbUFwcGVuZFRvKGxpKTtcbiAgICAgICAgICAgIHByb2dyZXNzTm9kZS5kb21BcHBlbmRUbyhsaSk7XG4gICAgICAgICAgICBmbGFnSUMgPSBmbGFnLmdldEZsYWcoa2V5KTtcbiAgICAgICAgICAgIGZsYWdJQy5jbGFzc0xpc3QuYWRkKCdpY29uJywgJ29jdGljb24nLCAnb2N0aWNvbi1wbHVzJyk7XG4gICAgICAgICAgICBmbGFnSUMuZG9tQXBwZW5kVG8obGkpO1xuICAgICAgICAgICAgbGkuZG9tQXBwZW5kVG8odWwpO1xuICAgICAgICB9KTtcbiAgICAgICAgdWwuZG9tQXBwZW5kVG8obm9kZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogdXBkYXRlIGFsbCBsYW5ndWFnZSBtYXgga2V5cyBmb3IgYWxsIGxhbmd1YWdlc1xuICAgICAqIEBwYXJhbSBrZXlzXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVNYXhLZXlzKGtleXMsIG5vZGUpIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5sYW5ndWFnZXMgLmxhbmcnKSkuZm9yRWFjaChmdW5jdGlvbihsYW5nTm9kZSkge1xuICAgICAgICAgICAgbGFuZ05vZGUucXVlcnlTZWxlY3RvcignLm1heEtleScpLmlubmVySFRNTCA9IGtleXM7XG4gICAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIHVwZGF0ZSBhIHNwZWNpZmljIGxhbmd1YWdlXG4gICAgICogQHBhcmFtIGtleVxuICAgICAqIEBwYXJhbSBsYW5nXG4gICAgICogQHBhcmFtIG5vZGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGVOdW1iZXJPZkxhbmdLZXlzKGtleSwgbGFuZywgbm9kZSkge1xuICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdE1haW5OYXZpZ2F0aW9uOnVwZGF0ZU51bWJlck9mTGFuZ0tleXMnLCBrZXksIGxhbmcpO1xuICAgICAgICBub2RlLnF1ZXJ5U2VsZWN0b3IoJy5sYW5ndWFnZXMgLmxhbmcuJyArIGxhbmcgKyAnIC5udW1PZlRyYW5zS2V5cycpLmlubmVySFRNTCA9IGtleTtcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgICBzZXROdW1iZXJPZlRyYW5zbGF0aW9uTWF4S2V5cyA6IGZ1bmN0aW9uIChtYXhLZXlzKSB7XG4gICAgICAgICAgICB1cGRhdGVNYXhLZXlzKG1heEtleXMsIG1vZFZpZXdzLmZyb20ubm9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHNldE51bWJlck9mVHJhbnNsYXRlZExhbmd1YWdlS2V5IDogZnVuY3Rpb24gKG51bWJlck9mS2V5cywgbGFuZykge1xuICAgICAgICAgICAgdXBkYXRlTnVtYmVyT2ZMYW5nS2V5cyhudW1iZXJPZktleXMsIGxhbmcsIG1vZFZpZXdzLmZyb20ubm9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uTGFuZ3VhZ2VTZWxlY3QgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgIHNlbGVjdExhbmd1YWdlUXVldWUucHVzaChmYyk7XG4gICAgICAgIH0sXG4gICAgICAgIG9uU2hvd0pTT04gOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgIG9uU2hvd0pTT05RdWV1ZS5wdXNoKGZjKTtcbiAgICAgICAgfSxcbiAgICAgICAgb25TaG93Sk1CRiA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25TaG93Sk1CRlF1ZXVlLnB1c2goZmMpO1xuICAgICAgICB9LFxuICAgICAgICBvblNob3dKTUJGVXBsb2FkZXIgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgIG9uU2hvd0pNQkZVcGxvYWRlclF1ZXVlLnB1c2goZmMpOyBcbiAgICAgICAgfSxcbiAgICAgICAgb25TaG93SlNPTkltcG9ydCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25TaG93SlNPTkltcG9ydFF1ZXVlLnB1c2goZmMpO1xuICAgICAgICB9LFxuICAgICAgICBvbkVuYWJsZUVkaXRvck1vZGUgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgIG9uRW5hYmxlRWRpdG9yTW9kZVF1ZXVlLnB1c2goZmMpO1xuICAgICAgICB9LFxuICAgICAgICBvblRvZ2dsZVdvcmRDb3VudCA6IGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgb25Ub2dnbGVXb3JkQ291bnRRdWV1ZS5wdXNoKGZjKTtcbiAgICAgICAgfSxcbiAgICAgICAgYWN0aXZhdGVMYW5nIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbWFpbk5vZGUucXVlcnlTZWxlY3RvcignbGkuJyArIGxhbmcpO1xuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLWluYWN0aXZlJyk7XG4gICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2MtYWN0aXZlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIGRlQWN0aXZhdGVMYW5nIDogZnVuY3Rpb24gKGxhbmcpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gbWFpbk5vZGUucXVlcnlTZWxlY3RvcignbGkuJyArIGxhbmcpO1xuICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdjLWluYWN0aXZlJyk7XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBBcHBseSB0aGUgY3VycmVudCBwcm9qZWN0J3MgbnVtYmVyIHRvIHRoZSBmbGFnczogYWN0aXZhdGUgZmxhZyB3aGVyZSB0cmFuc2xhdGlvbnMgZXhpc3QgYW5kIHNob3cgbnVtYmVyIG9mXG4gICAgICAgICAqIHRyYW5zbGF0ZWQga2V5cy5cbiAgICAgICAgICogQHBhcmFtIGtleXNUb3RhbCB0aGUgdG90YWwgbnVtYmVyIG9mIGtleXNcbiAgICAgICAgICogQHBhcmFtIHRyYW5zbGF0ZWRLZXlzUGVyTGFuZyB0aGUgbnVtYmVyIG9mIHRyYW5zbGF0ZWQga2V5cyBwZXIgbGFuZ3VhZ2VcbiAgICAgICAgICovXG4gICAgICAgIHNldEFjdGl2YXRlZFByb2plY3RMYW5ndWFnZXMgOiBmdW5jdGlvbiAoa2V5c1RvdGFsLCB0cmFuc2xhdGVkS2V5c1BlckxhbmcpIHtcbiAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobWFpbk5vZGUucXVlcnlTZWxlY3RvckFsbCgnbGknKSkuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBwcm9ncmVzc05vZGUgPSBub2RlLnF1ZXJ5U2VsZWN0b3IoJy5wcm9ncmVzcycpO1xuICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTm9kZS5jaGlsZHJlblswXS5pbm5lckhUTUwgPSBcIi1cIjtcbiAgICAgICAgICAgICAgICAgICAgcHJvZ3Jlc3NOb2RlLmNoaWxkcmVuWzFdLmlubmVySFRNTCA9IFwiLVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICBPYmplY3Qua2V5cyh0cmFuc2xhdGVkS2V5c1BlckxhbmcpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobWFpbk5vZGUucXVlcnlTZWxlY3RvckFsbCgnbGkuJyArIGtleSkpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHByb2dyZXNzTm9kZSA9IG5vZGUucXVlcnlTZWxlY3RvcignLnByb2dyZXNzJyk7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnYy1hY3RpdmUnKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzTm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc05vZGUuY2hpbGRyZW5bMF0uaW5uZXJIVE1MID0gdHJhbnNsYXRlZEtleXNQZXJMYW5nW2tleV07XG4gICAgICAgICAgICAgICAgICAgICAgIHByb2dyZXNzTm9kZS5jaGlsZHJlblsxXS5pbm5lckhUTUwgPSBrZXlzVG90YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHNldEF2YWlsYWJsZUxhbmd1YWdlcyA6IGZ1bmN0aW9uIChsYW5ndWFnZXMpIHtcbiAgICAgICAgICAgIHNldExvY2FsZShsYW5ndWFnZXMsIG1vZFZpZXdzLmZyb20ubm9kZSk7XG4gICAgICAgIH0sXG4gICAgICAgIHJlYWR5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgY29uc29sZS5sb2coJ25hdi1jb250cm9sbGVyIHJlYWR5IGV2ZW50Jyk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7ICAgIC8vIHBhcnQgb2YgYXBpXG4gICAgICAgICAgICBpZiAobW9kVmlld3MuaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgICAgICBtb2RWaWV3c1thdHRyXShub2RlKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0xJTksgTk9UIElNUExFTUVOVEVEJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSAgcHJvamVjdE1haW5OYXZpZ2F0aW9uOyIsInZhciBwcm9qZWN0T3ZlcnZpZXcgPSAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgdmFyIGNvbXBvbmVudFJvb3ROb2RlLFxuICAgICAgICByZW5kZXJQcm9qZWN0c0FuZERpcmVjdG9yaWVzTGlzdCxcbiAgICAgICAgb25DcmVhdGVQcm9qZWN0UHJlc3NlZCA9IGZ1bmN0aW9uKCkgeyBjb25zb2xlLndhcm4oJ3Byb2plY3RPdmVydmlldy5vbkNyZWF0ZVByb2plY3RQcmVzc2VkIG5vdCBzZXQnKX0sXG4gICAgICAgIG9uUGFyZW50RGlyZWN0b3J5U2VsZWN0ZWQgPSBmdW5jdGlvbigpIHtjb25zb2xlLndhcm4oJ3Byb2plY3RPdmVydmlldy5vblBhcmVudERpcmVjdG9yeVNlbGVjdGVkIG5vdCBzZXQnKX0sXG4gICAgICAgIG9uUHJvamVjdFNlbGVjdGVkID0gZnVuY3Rpb24oKSB7IGNvbnNvbGUud2FybigncHJvamVjdE92ZXJ2aWV3Lm9uUHJvamVjdFNlbGVjdGVkIG5vdCBzZXQnKX0sXG4gICAgICAgIG9uRGVsZXRlUHJvamVjdFByZXNzZWQgPSBmdW5jdGlvbigpIHsgY29uc29sZS53YXJuKCdwcm9qZWN0T3ZlcnZpZXcub25EZWxldGVQcm9qZWN0UHJlc3NlZCBub3Qgc2V0Jyl9LFxuICAgICAgICBvbkRlbGV0ZUZvbGRlclByZXNzZWQgPSBmdW5jdGlvbigpIHsgY29uc29sZS53YXJuKCdwcm9qZWN0T3ZlcnZpZXcub25EZWxldGVGb2xkZXJQcmVzc2VkIG5vdCBzZXQnKX0sXG4gICAgICAgIG9uRGlyZWN0b3J5U2VsZWN0ZWQgPSBmdW5jdGlvbigpIHsgY29uc29sZS53YXJuKCdwcm9qZWN0T3ZlcnZpZXcub25EaXJlY3RvcnlTZWxlY3RlZCBub3Qgc2V0Jyl9LFxuICAgICAgICBvbkNyZWF0ZURpcmVjdG9yeVByZXNzZWQgPSBmdW5jdGlvbigpIHsgY29uc29sZS53YXJuKCdwcm9qZWN0T3ZlcnZpZXcub25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkIG5vdCBzZXQnKX0sXG4gICAgICAgIGVkaXRNb2RlRW5hYmxlZCA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIENhbGxlZCBmcm9tIGNhbm55IHdoZW4gcmVnaXN0ZXJpbmcgY29tcG9uZW50cy4gVGhlIG9ubHkgY29tcG9uZW50IHdoaWNoIHdlIGV4cGVjdCB0byBiZSByZWdpc3RlcmVkIGlzXG4gICAgICAgICAqIFwicHJvamVjdE92ZXJ2aWV3Q29udGFpbmVyXCIgKHRoZSByb290IG5vZGUgb2YgdGhlIGNvbXBvbmVudCkuXG4gICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAqIEBwYXJhbSB2YXJzXG4gICAgICAgICAqL1xuICAgICAgICBhZGQ6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Um9vdE5vZGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGNvbXBvbmVudFJvb3ROb2RlID0gbm9kZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdwcm9qZWN0T3ZlcnZpZXc6YWRkIG11bHRpcGxlIHZpZXdzIGRldGVjdGVkIC0gaXQgc2hvdWxkIGJlIHJlZ2lzdGVyZWQgb25seSBvbmVzIGluIHRoZSBET00hJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBDYWxsZWQgZnJvbSBjYW5ueSBvbiBkb2N1bWVudFJlYWR5IGV2ZW50LlxuICAgICAgICAgKi9cbiAgICAgICAgcmVhZHk6IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICB2YXIgY3JlYXRlUHJvamVjdEJ1dHRvbk5vZGUgPSBjb21wb25lbnRSb290Tm9kZS5xdWVyeVNlbGVjdG9yKCcuanMtY3JlYXRlUHJvamVjdEJ1dHRvbicpO1xuICAgICAgICAgICAgaWYgKCFjcmVhdGVQcm9qZWN0QnV0dG9uTm9kZSkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ05vIGNoaWxkIG5vZGUgd2l0aCBjbGFzcyBcImNyZWF0ZVByb2plY3RCdXR0b24gZm91bmQgaW5zaWRlIFwicHJvamVjdE92ZXJ2aWV3Q29udGFpbmVyXCInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY3JlYXRlUHJvamVjdEJ1dHRvbk5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNyZWF0ZVByb2plY3RQcmVzc2VkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjcmVhdGVGb2xkZXJCdXR0b25Ob2RlID0gY29tcG9uZW50Um9vdE5vZGUucXVlcnlTZWxlY3RvcignLmpzLWNyZWF0ZUZvbGRlckJ1dHRvbicpO1xuICAgICAgICAgICAgaWYgKCFjcmVhdGVGb2xkZXJCdXR0b25Ob2RlKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignTm8gY2hpbGQgbm9kZSB3aXRoIGNsYXNzIFwiY3JlYXRlRm9sZGVyQnV0dG9uIGZvdW5kIGluc2lkZSBcInByb2plY3RPdmVydmlld0NvbnRhaW5lclwiJyk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGNyZWF0ZUZvbGRlckJ1dHRvbk5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvbkNyZWF0ZURpcmVjdG9yeVByZXNzZWQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIHRvZ2dsZUVkaXRNb2RlQnV0dG9uTm9kZSA9IGNvbXBvbmVudFJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy10b2dnbGVFZGl0TW9kZUJ1dHRvbicpO1xuICAgICAgICAgICAgaWYgKCF0b2dnbGVFZGl0TW9kZUJ1dHRvbk5vZGUpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBjaGlsZCBub2RlIHdpdGggY2xhc3MgXCJjcmVhdGVGb2xkZXJCdXR0b24gZm91bmQgaW5zaWRlIFwicHJvamVjdE92ZXJ2aWV3Q29udGFpbmVyXCInKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdG9nZ2xlRWRpdE1vZGVCdXR0b25Ob2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgZWRpdE1vZGVFbmFibGVkID0gIWVkaXRNb2RlRW5hYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50Um9vdE5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgnZWRpdE1vZGUtZW5hYmxlZCcsIGVkaXRNb2RlRW5hYmxlZCk7XG4gICAgICAgICAgICAgICAgICAgIHRvZ2dsZUVkaXRNb2RlQnV0dG9uTm9kZS5jbGFzc0xpc3QudG9nZ2xlKCdhY3RpdmUnLCBlZGl0TW9kZUVuYWJsZWQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB2YXIgc2VsZWN0UGFyZW50RGlyZWN0b3J5QnV0dG9uID0gY29tcG9uZW50Um9vdE5vZGUucXVlcnlTZWxlY3RvcignLmpzLXNlbGVjdFBhcmVudERpcmVjdG9yeUJ1dHRvbicpO1xuICAgICAgICAgICAgaWYgKCFzZWxlY3RQYXJlbnREaXJlY3RvcnlCdXR0b24pIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdObyBjaGlsZCBub2RlIHdpdGggY2xhc3MgXCJzZWxlY3RQYXJlbnREaXJlY3RvcnlCdXR0b25cIiBmb3VuZCBpbnNpZGUgXCJwcm9qZWN0T3ZlcnZpZXdDb250YWluZXJcIicpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxlY3RQYXJlbnREaXJlY3RvcnlCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICBvblBhcmVudERpcmVjdG9yeVNlbGVjdGVkKCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBJbmZvcm0gdGhlIHVpIG1vZHVsZSBhYm91dCB0aGUgbmV3IGN1cnJlbnQgc2V0IG9mIGRpcmVjdG9yaWVzIGFuZCBwcm9qZWN0cyB0byBsaXN0LiBUaGlzIHdpbGwgYWxzbyB0cmlnZ2VyXG4gICAgICAgICAqIGEgbmV3IHJlbmRlcmluZyBvZiB0aGUgcHJvamVjdHMgbGlzdCB3aXRoIHRoZSBuZXcgY29udGVudC5cbiAgICAgICAgICogQHBhcmFtIHByb2plY3ROYW1lc1xuICAgICAgICAgKiBAcGFyYW0gZGlyZWN0b3J5TmFtZXNcbiAgICAgICAgICovXG4gICAgICAgIHNldFByb2plY3RzQW5kRGlyZWN0b3JpZXM6IGZ1bmN0aW9uIChwcm9qZWN0TmFtZXMsIGRpcmVjdG9yeU5hbWVzKSB7XG4gICAgICAgICAgICB2YXIgcHJvamVjdHNBbmREaXJlY3RvcmllcyA9IFtdO1xuXG4gICAgICAgICAgICBpZiAoIXByb2plY3ROYW1lcyB8fCAhZGlyZWN0b3J5TmFtZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9IGVsc2UgaWYgKCFyZW5kZXJQcm9qZWN0c0FuZERpcmVjdG9yaWVzTGlzdCkge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlbmRlclByb2plY3RzQW5kRGlyZWN0b3JpZXNMaXN0IGZ1bmN0aW9uIGhhcyBub3QgYmVlbiBzZXQsIG5ldyBsaXN0IGNhbm5vdCBiZSBzaG93bicpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgY29uc29sZS5sb2coJ2dvdCBwcm9qZWN0cycsIHByb2plY3ROYW1lcyk7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygnZ290IGRpcmVjdG9yaWVzJywgZGlyZWN0b3J5TmFtZXMpO1xuXG4gICAgICAgICAgICBwcm9qZWN0TmFtZXMuZm9yRWFjaChmdW5jdGlvbihwcm9qZWN0TmFtZSkge1xuICAgICAgICAgICAgICAgIHByb2plY3RzQW5kRGlyZWN0b3JpZXMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgOiBwcm9qZWN0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlyIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIG9wZW5Qcm9qZWN0TGlzdEl0ZW0gOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygncHJvamVjdCBzZWxlY3RlZDonLCBwcm9qZWN0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob25Qcm9qZWN0U2VsZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblByb2plY3RTZWxlY3RlZChwcm9qZWN0TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZVByb2plY3RMaXN0SXRlbSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbGV0aW9uQ29uZmlybWVkID0gd2luZG93LmNvbmZpcm0oJ1JlYWxseSBkZWxldGUgcHJvamVjdCAnICsgcHJvamVjdE5hbWUgKyAnPycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGVsZXRlUHJvamVjdFByZXNzZWQgJiYgZGVsZXRpb25Db25maXJtZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZVByb2plY3RQcmVzc2VkKHByb2plY3ROYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBkaXJlY3RvcnlOYW1lcy5mb3JFYWNoKGZ1bmN0aW9uKGRpcmVjdG9yeU5hbWUpIHtcbiAgICAgICAgICAgICAgICBwcm9qZWN0c0FuZERpcmVjdG9yaWVzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBuYW1lIDogZGlyZWN0b3J5TmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlyIDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgb3BlblByb2plY3RMaXN0SXRlbSA6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2RpcmVjdG9yeSBzZWxlY3RlZDonLCBkaXJlY3RvcnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvbkRpcmVjdG9yeVNlbGVjdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EaXJlY3RvcnlTZWxlY3RlZChkaXJlY3RvcnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlUHJvamVjdExpc3RJdGVtIDogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgZGVsZXRpb25Db25maXJtZWQgPSB3aW5kb3cuY29uZmlybSgnUmVhbGx5IGRlbGV0ZSBmb2xkZXIgJyArIGRpcmVjdG9yeU5hbWUgKyAnPycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9uRGVsZXRlRm9sZGVyUHJlc3NlZCAmJiBkZWxldGlvbkNvbmZpcm1lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uRGVsZXRlRm9sZGVyUHJlc3NlZChkaXJlY3RvcnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHJlbmRlclByb2plY3RzQW5kRGlyZWN0b3JpZXNMaXN0KHByb2plY3RzQW5kRGlyZWN0b3JpZXMpO1xuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogRm9yIGNhbm55LXJlcGVhdCByZWdpc3RlcmVkIG9uIHRoZSBwcm9qZWN0cyBsaXN0LCBwcm92aWRlIHRoZSBmdW5jdGlvbiBmb3IgcmVuZGVyaW5nIHRoZSBsaXN0LlxuICAgICAgICAgKiBAcGFyYW0gZnVuYyBhIGZ1bmN0aW9uIHdoaWNoIHdpbGwgc2V0IHRoZSBsaXN0IG9mIHByb2plY3RzIGFuZCBkaXJlY3Rvcmllcy5cbiAgICAgICAgICovXG4gICAgICAgIHNldFJlbmRlclByb2plY3RzQW5kRGlyZWN0b3JpZXNMaXN0RnVuY3Rpb24gOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICByZW5kZXJQcm9qZWN0c0FuZERpcmVjdG9yaWVzTGlzdCA9IGZ1bmM7XG4gICAgICAgIH0sXG4gICAgICAgIGRlbGV0ZVByb2plY3RMaXN0Tm9kZSA6IGZ1bmN0aW9uKGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICB2YXIgbm9kZSA9IGNvbXBvbmVudFJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3IoJ3RyW2RhdGEtbGlzdEl0ZW09JyArIGl0ZW1OYW1lICsgJ10nKTtcbiAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUucGFyZW50Tm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChub2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgY2FsbGJhY2sgd2hpY2ggd2lsbCByZWFjdCB0byBcInRvIHBhcmVudCBkaXJlY3RvcnlcIiBldmVudC5cbiAgICAgICAgICogQHBhcmFtIGxpc3RlbmVyXG4gICAgICAgICAqL1xuICAgICAgICBvblBhcmVudERpcmVjdG9yeVNlbGVjdGVkIDogZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9uUGFyZW50RGlyZWN0b3J5U2VsZWN0ZWQgPSBsaXN0ZW5lcjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgY2FsbGJhY2sgd2hpY2ggd2lsbCByZWFjdCB0byBjbGlja3Mgb24gYSBwcm9qZWN0LiBUaGUgY2FsbGJhY2sgZnVuY3Rpb24gc2hvdWxkIGV4cGVjdFxuICAgICAgICAgKiBvbmUgcGFyYW1ldGVyIHdoaWNoIGlzIHRoZSBwcm9qZWN0IG5hbWUuXG4gICAgICAgICAqIEBwYXJhbSBsaXN0ZW5lclxuICAgICAgICAgKi9cbiAgICAgICAgb25Qcm9qZWN0U2VsZWN0ZWQgOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgb25Qcm9qZWN0U2VsZWN0ZWQgPSBsaXN0ZW5lcjtcbiAgICAgICAgfSxcbiAgICAgICAgLyoqXG4gICAgICAgICAqIFJlZ2lzdGVyIGEgbGlzdGVuZXIgY2FsbGJhY2sgd2hpY2ggd2lsbCByZWFjdCB0byBjbGlja3Mgb24gYSBkaXJlY3RvcnkuIFRoZSBjYWxsYmFjayBmdW5jdGlvbiBzaG91bGQgZXhwZWN0XG4gICAgICAgICAqIG9uZSBwYXJhbWV0ZXIgd2hpY2ggaXMgdGhlIGRpcmVjdG9yeSBuYW1lLlxuICAgICAgICAgKiBAcGFyYW0gbGlzdGVuZXJcbiAgICAgICAgICovXG4gICAgICAgIG9uRGlyZWN0b3J5U2VsZWN0ZWQgOiBmdW5jdGlvbihsaXN0ZW5lcikge1xuICAgICAgICAgICAgb25EaXJlY3RvcnlTZWxlY3RlZCA9IGxpc3RlbmVyO1xuICAgICAgICB9LFxuICAgICAgICBvbkNyZWF0ZVByb2plY3RQcmVzc2VkIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgb25DcmVhdGVQcm9qZWN0UHJlc3NlZCA9IGZ1bmM7XG4gICAgICAgIH0sXG4gICAgICAgIG9uRGVsZXRlUHJvamVjdFByZXNzZWQgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICBvbkRlbGV0ZVByb2plY3RQcmVzc2VkID0gZnVuYztcbiAgICAgICAgfSxcbiAgICAgICAgb25EZWxldGVGb2xkZXJQcmVzc2VkIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgb25EZWxldGVGb2xkZXJQcmVzc2VkID0gZnVuYztcbiAgICAgICAgfSxcbiAgICAgICAgb25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkIDogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgb25DcmVhdGVEaXJlY3RvcnlQcmVzc2VkID0gZnVuYztcbiAgICAgICAgfVxuICAgIH07XG59KSgpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2plY3RPdmVydmlldztcbiIsIi8qKlxuICogaGFuZGxlcyBhbGwgdGV4dHNcbiAqL1xudmFyIHRleHRzID0gKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIG5vZGUsXG4gICAgICAgIGxhbmd1YWdlTmFtZXMgPSB7XG4gICAgICAgICAgICBkYTogJ0Rhbm1hcmsnLFxuICAgICAgICAgICAgZGU6ICdEZXV0c2NobGFuZCcsXG4gICAgICAgICAgICBmcjogJ0ZyYW5jZScsXG4gICAgICAgICAgICBubDogJ05lZGVybGFuZCcsXG4gICAgICAgICAgICBlbjogJ1VuaXRlZCBTdGF0ZXMgKERlZmF1bHQpJyxcbiAgICAgICAgICAgIGVuX0dCOiAnVW5pdGVkIEtpbmdkb20nLFxuICAgICAgICAgICAgc3Y6ICdTdmVyaWdlJyxcbiAgICAgICAgICAgIGVzOiAnRXNwYW5vbCdcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dHMgPSB7XG4gICAgICAgICAgICBjaGFuZ2VUZXh0cyA6ICBmdW5jdGlvbiAoKSB7fSxcbiAgICAgICAgICAgIGRhdGEgOiB7XG4gICAgICAgICAgICAgICAgcHJvamVjdE5hbWU6ICcnLFxuICAgICAgICAgICAgICAgIHByb2plY3REZXNjcmlwdGlvbjogJydcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGdldExhbmd1YWdlTmFtZXMgOiBmdW5jdGlvbiAoa2V5KSB7cmV0dXJuIGxhbmd1YWdlTmFtZXNba2V5XX0sXG4gICAgICAgIHNldFRleHRzIDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICAgIHRleHRzLmNoYW5nZVRleHRzKCdtc2cnLCBkYXRhKTtcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGV4dHMgOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKCd0ZXh0czp5ZXMgdGV4dCBpcyB0cmlnZ2VyZWQnKTtcbiAgICAgICAgICAgIHRleHRzLmNoYW5nZVRleHRzID0gZmM7XG4gICAgICAgICAgICB0ZXh0cy5jaGFuZ2VUZXh0cygnbXNnJywgdGV4dHMuZGF0YSk7XG4gICAgICAgIH0sXG4gICAgICAgIGFkZCA6IGZ1bmN0aW9uIChlbGVtLCBhdHRyKSB7XG4gICAgICAgICAgICBub2RlID0gZWxlbTtcbiAgICAgICAgfSxcbiAgICAgICAgcmVhZHkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZygndGV4dHMgcmVhZHkhJyk7XG4gICAgICAgIH1cbiAgICB9O1xufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0ZXh0czsiLCJ2YXIgZmxhZyA9IHJlcXVpcmUoJy4vZmxhZy5qcycpLFxuICAgIGlucHV0RWRpdE1hbmFnZXIgPSByZXF1aXJlKCcuL2lucHV0RWRpdE1hbmFnZXIuanMnKSxcbiAgICB3b3JkQ291bnRlciA9IHJlcXVpcmUoJy4uL3V0aWwvd29yZENvdW50ZXInKSxcbiAgICBkaXNwbGF5TWFuYWdlciA9IHJlcXVpcmUoJ2Nhbm55JykuZGlzcGxheU1hbmFnZXIsXG4gICAgY29uZiA9IHtcbiAgICAgICAgcm93UHJlZml4OiBcInR2X1wiLFxuICAgICAgICBpbnB1dFByZWZpeDogXCJrZXlWYWx1ZV9cIixcbiAgICAgICAgaW5wdXRUcmFuc1ByZWZpeDogXCJ0cmFuc19cIlxuICAgIH0sXG4gICAgY2F0UHJlZml4ID0gJ3R2Xyc7XG4vKipcbiAqIFJlbmFtZSBhbGwgRE9NIGlkIGF0dHJpYnV0ZXMgZnJvbSBvbGQgdG8gbmV3IGtleVxuICogQHBhcmFtIG9sZEtleVxuICogQHBhcmFtIG5ld0tleVxuICovXG5mdW5jdGlvbiByZW5hbWVET01JZHMob2xkS2V5LCBuZXdLZXksIGF2YWlsYWJsZUxhbmd1YWdlcykge1xuICAgIE9iamVjdC5rZXlzKGNvbmYpLmZvckVhY2goZnVuY3Rpb24ocHJvcCkge1xuICAgICAgICB2YXIgbm9kZTtcbiAgICAgICAgaWYgKHByb3AgPT09ICdpbnB1dFRyYW5zUHJlZml4Jykge1xuICAgICAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VzLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChnZXRMYW5ndWFnZVRleHRJZChvbGRLZXksIGxhbmcpKTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaWQnLCBnZXRMYW5ndWFnZVRleHRJZChuZXdLZXksIGxhbmcpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2xhdGlvblZpZXc6cmVuYW1lSWRzIGNhbiBub3QgZmluZCBkb20gbm9kZSBmb3IgaWQnLCBnZXRMYW5ndWFnZVRleHRJZChuZXdLZXksIGxhbmcpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmZbcHJvcF0gKyBvbGRLZXkpO1xuICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICBub2RlLnNldEF0dHJpYnV0ZSgnaWQnLCBjb25mW3Byb3BdICsgbmV3S2V5KTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3OnJlbmFtZUlkcyBjYW4gbm90IGZpbmQgZG9tIG5vZGUgZm9yIGlkJywgY29uZltwcm9wXSArIG9sZEtleSwgJ3Byb3BlcnR5OicsIHByb3ApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHRleHRBcmVhS2V5UHJlc3NMaXN0ZW5lcihlKSB7XG4gICAgdmFyIGtleSA9IGUua2V5Q29kZSB8fCBlLndoaWNoO1xuICAgIC8vIFRPRE8gYWxsb3cgZW50ZXIgLSBpdCdzIHVzZWZ1bCBmb3IgZm9ybWF0dGluZyBhIHRleHQgLSBidXQgaXQncyBhIG1lc3MgZm9yIGFsbCBvdGhlclxuICAgIGlmIChrZXkgPT09IDEzKSB7XG4gICAgICAgIGUucmV0dXJuVmFsdWUgPSBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIGtleUtleVByZXNzTGlzdGVuZXIoZSkge1xuICAgIHZhciBrZXkgPSBlLmtleUNvZGUgfHwgZS53aGljaDtcbiAgICBpZiAoa2V5ID09PSAzMikge1xuICAgICAgICBlLnJldHVyblZhbHVlID0gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZU5ld0tleShzdHJpbmcpIHtcbiAgICByZXR1cm4gKHN0cmluZy5sZW5ndGggPiAwICYmIHN0cmluZy5zZWFyY2goJ1xcXFwufCx8ICcpID09PSAtMSkgPyB0cnVlIDogZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldExhbmd1YWdlVGV4dElkKGtleSwgbGFuZykge1xuICAgIHJldHVybiBjb25mLmlucHV0VHJhbnNQcmVmaXggKyBba2V5LCBsYW5nXS5qb2luKCdfJyk7XG59XG5cbmZ1bmN0aW9uIGdldFdvcmRDb3VudFRleHQoY291bnQpIHtcbiAgICByZXR1cm4gJ1dvcmRzOiAnICsgY291bnQ7XG59XG5cbi8qKlxuICogQ291bnQgb25seSBsZXR0ZXJzXG4gKiBAcGFyYW0gdmFsdWVcbiAqL1xuZnVuY3Rpb24gZ2V0Q2hhcmFjdGVyQ291bnQodmFsdWUpIHtcbiAgICB3aGlsZSAoL3suKj99Ly50ZXN0KHZhbHVlKSlcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC97Lio/fS8sICcnKVxuXG4gICAgcmV0dXJuIFsuLi52YWx1ZV0uZmlsdGVyKChjaGFyKSA9PiAvW2EtekEtel0vLnRlc3QoY2hhcikpLmxlbmd0aFxufVxuXG5mdW5jdGlvbiBnZXRXb3JkQ291bnRIZWFkbGluZShjYXRlZ29yeSkge1xuICAgIHJldHVybiAnT3ZlcmFsbCB3b3JkcyBpbiAnICsgY2F0ZWdvcnk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVdvcmRDb3VudEZvckxhbmd1YWdlKGxhbmcpIHtcbiAgICB2YXIgY291bnRXcmFwcGVyID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBudWxsLCAnZGF0YSBqc18nICsgbGFuZyksXG4gICAgICAgIGZsYWdDbGFzcyA9IGZsYWcuZ2V0RmxhZ0NsYXNzZXMobGFuZykucG9wKCksXG4gICAgICAgIHdvcmRDb3VudExhYmVsID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ3dvcmRDb3VudExhYmVsICcuY29uY2F0KGZsYWdDbGFzcykpO1xuICAgIHdvcmRDb3VudExhYmVsLmlubmVySFRNTCA9IGdldFdvcmRDb3VudFRleHQoMCk7XG4gICAgY291bnRXcmFwcGVyLmFwcGVuZENoaWxkKHdvcmRDb3VudExhYmVsKTtcbiAgICByZXR1cm4gY291bnRXcmFwcGVyO1xufVxuXG4vKipcbiAqIGhhbmRsZSB0aGUgdHJhbnNsYXRpb24gb3ZlcnZpZXdcbiAqIFRPRE8gcmVmYWN0b3IgYmFzZS5jb25uZWN0aW9uXG4gKi9cbnZhciB0cmFuc2xhdGlvblZpZXcgPSAoZnVuY3Rpb24oKSB7XG4gICAgJ3VzZSBzdHJpY3QnO1xuXG4gICAgLyoqXG4gICAgICogVE9ETyByZW1vdmUgcHJvamVjdCBuYW1lIC0gb25seSB0aGUgY29udHJvbGxlciBuZWVkcyB0byBrbm93IHRoaXNcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IC0gQGRlcHJlY2F0ZWRcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGFuZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0XG4gICAgICpcbiAgICAgKiBAY2xhc3NcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBTYXZlT25MZWF2ZShub2RlLCBrZXksIGxhbmcsIHRleHQpIHtcbiAgICAgICAgdmFyIHRleHRMaXN0ID0gW3RleHRdLFxuICAgICAgICAgICAgdGV4dElkeCA9IDA7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAgICAgICAgICogQHJldHVybnMge3N0cmluZ30gdGhlIGtleSBpZFxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZ2V0SWRGcm9tUm93KG5vZGUpIHtcbiAgICAgICAgICAgIHJldHVybiBub2RlLnBhcmVudE5vZGUucGFyZW50Tm9kZS5wYXJlbnROb2RlLmdldEF0dHJpYnV0ZSgnaWQnKS5yZXBsYWNlKGNvbmYucm93UHJlZml4LCAnJyk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiT2xkOiBcIiArIHRleHRMaXN0W3RleHRJZHhdKTtcbiAgICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IHRoaXMudmFsdWU7XG4gICAgICAgICAgICBpZiAodGV4dExpc3RbdGV4dElkeF0gIT09IG5ld1ZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdGV4dExpc3QucHVzaChuZXdWYWx1ZSk7XG4gICAgICAgICAgICAgICAgdGV4dElkeCsrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2codGV4dExpc3QpO1xuICAgICAgICAgICAgb25TYXZlS2V5ICYmIG9uU2F2ZUtleShnZXRJZEZyb21Sb3cobm9kZSksIGxhbmcsIG5ld1ZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2xlYW4gdXAgdGhlIGF0dGFjaGVkIGV2ZW50IGxpc3RlbmVycyBhbmQgcmVtb3ZlcyB0aGVtIGZyb20gdGhlIG5vZGUuXG4gICAgICogSXQgcmVtb3ZlcyB0aGUgJ2NoYW5nZScgYW5kICdrZXlwcmVzcycgZXZlbnQgZnJvbSBhbGwgdGV4dEFyZWEncyBhbmQgaW5wdXQgZmllbGRzIGFuZFxuICAgICAqIHNldCBpdCB0byBcInJlYWQgb25seVwiXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByb3dOb2RlXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnNGcm9tUm93KHJvd05vZGUpIHtcbiAgICAgICAgW10uc2xpY2UuY2FsbChyb3dOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ3RleHRhcmVhJykpLmZvckVhY2goZnVuY3Rpb24odGFyZWEpIHtcbiAgICAgICAgICAgIHRhcmVhLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIGZhbHNlKTtcbiAgICAgICAgICAgIHRhcmVhLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAndHJ1ZScpO1xuICAgICAgICB9KTtcblxuICAgICAgICBbXS5zbGljZS5jYWxsKHJvd05vZGUucXVlcnlTZWxlY3RvckFsbCgnaW5wdXQnKSkuZm9yRWFjaChmdW5jdGlvbihpbnB1dCkge1xuICAgICAgICAgICAgaW5wdXQucmVtb3ZlRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCBmYWxzZSk7XG4gICAgICAgICAgICBpbnB1dC5zZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JywgJ3RydWUnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBjYXROb2RlVG9JbnNlcnRcbiAgICAgKiBAcGFyYW0ge0FycmF5PEhUTUxFbGVtZW50Pn0gY2F0Tm9kZXNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRDYXRlZ29yeShjYXROb2RlVG9JbnNlcnQsIGNhdE5vZGVzKSB7XG4gICAgICAgIHZhciBjYXRUb0FwcGVuZElEID0gY2F0Tm9kZVRvSW5zZXJ0LmlkLnRvTG93ZXJDYXNlKCksXG4gICAgICAgICAgICBzaG93bkNhdE5vZGUsXG4gICAgICAgICAgICBzaG93bkNhdElEO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2F0Tm9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNob3duQ2F0Tm9kZSA9IGNhdE5vZGVzW2ldO1xuICAgICAgICAgICAgc2hvd25DYXRJRCA9IGNhdE5vZGVzW2ldLmlkLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBpZiAoY2F0VG9BcHBlbmRJRCA8IHNob3duQ2F0SUQpIHtcbiAgICAgICAgICAgICAgICByb290Tm9kZS5pbnNlcnRCZWZvcmUoY2F0Tm9kZVRvSW5zZXJ0LCBzaG93bkNhdE5vZGUpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNhdE5vZGVzLmxlbmd0aCA9PT0gMCB8fCBjYXRUb0FwcGVuZElEID4gc2hvd25DYXRJRCkge1xuICAgICAgICAgICAgcm9vdE5vZGUuYXBwZW5kQ2hpbGQoY2F0Tm9kZVRvSW5zZXJ0KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciByb290Tm9kZSwgLy8gbWFpbiBub2RlIGFsbCBjb250ZW50IGFyZSBhZGRlZCB0byBoZXJlXG4gICAgICAgIHJlbmRlclRleHRGYyxcbiAgICAgICAgc2VsZWN0b3JzID0ge1xuICAgICAgICAgICAgcm9vdDogXCJyZXNvdXJjZUJ1bmRsZVRhYmxlXCIsXG4gICAgICAgICAgICBkZWJ1ZzogXCJkZWJ1Z0luY29tbWluZ1wiLFxuICAgICAgICAgICAgdHBsOiB7XG4gICAgICAgICAgICAgICAgdGFibGVCb2R5OiAndGFibGVCb2R5J1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvLyBRVUVTVElPTjogYXJlIHRoZXNlIHJlYWwgcXVldWVzP1xuICAgICAgICBvblF1ZXVlcyA9IHtcbiAgICAgICAgICAgIGFkZE5ld0tleTogW10sXG4gICAgICAgICAgICBjcmVhdGVOZXdQcm9qZWN0OiBbXSxcbiAgICAgICAgICAgIHJlbW92ZUtleTogW10sXG4gICAgICAgICAgICByZW5hbWVLZXk6IFtdLFxuICAgICAgICAgICAgY2F0ZWdvcnlDbGlja2VkOiBbXSxcbiAgICAgICAgICAgIHJlbW92ZUNhdGVnb3J5OiBbXSxcbiAgICAgICAgICAgIHJlbmFtZUNhdGVnb3J5OiBbXVxuICAgICAgICB9LFxuICAgICAgICB1aSA9IHtcbiAgICAgICAgICAgIGNzczoge1xuICAgICAgICAgICAgICAgIHNlbmRTdWNjZXNzOiAnc2VuZFN1Y2Nlc3MnLFxuICAgICAgICAgICAgICAgIHVwZGF0ZUtleTogJ3VwZGF0ZUtleSdcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0ga2V5XG4gICAgICAgICAgICAgKiBAcGFyYW0gaW5wdXRQcmVmaXhcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc2VuZFN1Y2Nlc3M6IGZ1bmN0aW9uKGtleSwgaW5wdXRQcmVmaXgpIHtcbiAgICAgICAgICAgICAgICB2YXIgbm9kZTEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGtleSksXG4gICAgICAgICAgICAgICAgICAgIG5vZGUyID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaW5wdXRQcmVmaXggKyBrZXkpO1xuICAgICAgICAgICAgICAgIGlmIChub2RlMSkge1xuICAgICAgICAgICAgICAgICAgICB1aS5yZW1vdmVTdGF0ZUNsYXNzZXMobm9kZTEpLmNsYXNzTGlzdC5yZW1vdmUodWkuY3NzLnNlbmRTdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLnJlbW92ZVN0YXRlQ2xhc3Nlcyhub2RlMSkuY2xhc3NMaXN0LmFkZCh1aS5jc3Muc2VuZFN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlMikge1xuICAgICAgICAgICAgICAgICAgICB1aS5yZW1vdmVTdGF0ZUNsYXNzZXMobm9kZTIpLmNsYXNzTGlzdC5yZW1vdmUodWkuY3NzLnNlbmRTdWNjZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHVpLnJlbW92ZVN0YXRlQ2xhc3Nlcyhub2RlMikuY2xhc3NMaXN0LmFkZCh1aS5jc3Muc2VuZFN1Y2Nlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9LCAxMDApXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZUlucHV0RmllbGRzOiBmdW5jdGlvbihrZXksIGlucHV0UHJlZml4KSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3OnVwZGF0ZUlucHV0RmllbGRzJywgJ2lzIHRoaXMgc3RpbGwgaW4gdXNlPz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Pz8/Jyk7XG4gICAgICAgICAgICAgICAgZGVidWdnZXI7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChpbnB1dFByZWZpeCArIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdWkucmVtb3ZlU3RhdGVDbGFzc2VzKG5vZGUpLmRvbUFkZENsYXNzKHVpLmNzcy51cGRhdGVLZXkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICByZW1vdmVTdGF0ZUNsYXNzZXM6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgY3NzU3RhdGUsIGNsYXNzZXMgPSAnJztcbiAgICAgICAgICAgICAgICBpZiAoIW5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUT0RPIHJlZmFjdG9yIE9iamVjdC5rZXlzKClcbiAgICAgICAgICAgICAgICBmb3IgKGNzc1N0YXRlIGluIHVpLmNzcykge1xuICAgICAgICAgICAgICAgICAgICBjbGFzc2VzICs9IGNzc1N0YXRlICsgJyAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLmRvbVJlbW92ZUNsYXNzKGNsYXNzZXMpO1xuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICAvKipcbiAgICAgICAgICogQ2FsbGJhY2sgKHJlZ2lzdGVyZWQgZnJvbSBjb250cm9sbGVyKSB0byBiZSBjYWxsZWQgd2hlbiBjaGFuZ2VzIHRvIGEga2V5IG11c3QgYmUgc2F2ZWRcbiAgICAgICAgICovXG4gICAgICAgIG9uU2F2ZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXc6b25TYXZlS2V5IG5vdCBpbml0aWFsaXplZCcpO1xuICAgICAgICB9LFxuICAgICAgICBvbkNyZWF0ZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXc6b25DcmVhdGVLZXkgbm90IGluaXRpYWxpemVkJylcbiAgICAgICAgfSxcbiAgICAgICAgb25DbG9uZUtleSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXc6b25DbG9uZUtleSBub3QgaW5pdGlhbGl6ZWQnKVxuICAgICAgICB9LFxuICAgICAgICBicmFpbiA9IHtcbiAgICAgICAgICAgIGNsb25lS2V5T3ZlcmxheToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgcmVuZGVyVGV4dEZjKCdjbG9uZUtleU92ZXJsYXlUZXh0Jywge1xuICAgICAgICAgICAgICAgICAgICAgICAga2V5TmFtZTogZGF0YS5rZXlOYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlOYW1lOiBkYXRhLmNvbnRleHROYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZ2V0RGF0YTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmRhdGE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNsb25lS2V5SW5wdXRDYXRlZ29yeToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvbmVLZXlCdXR0b25TdWJtaXQ6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChicmFpbi5jbG9uZUtleUlucHV0Q2F0ZWdvcnkubm9kZS52YWx1ZS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFpbi5jbG9uZUtleUlucHV0Q2F0ZWdvcnkubm9kZS5jbGFzc0xpc3QuYWRkKCdlcnJvcicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0gYnJhaW4uY2xvbmVLZXlPdmVybGF5LmdldERhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvbmVLZXkoZGF0YS5rZXksIGRhdGEua2V5TmFtZSwgZGF0YS5jb250ZXh0TmFtZSwgYnJhaW4uY2xvbmVLZXlJbnB1dENhdGVnb3J5Lm5vZGUudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdElucHV0UHJvamVjdDoge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdFByb2plY3REZXNjcmlwdGlvbjoge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY3JlYXRlTmV3UHJvamVjdFN1Ym1pdDogKGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlO1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUgPSBlbGVtO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBwcm9qZWN0VmFsdWUgPSBicmFpbi5jcmVhdGVOZXdQcm9qZWN0SW5wdXRQcm9qZWN0Lm5vZGUudmFsdWU7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVOZXdLZXkocHJvamVjdFZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlYWQgZGVzY3JpcHRpb24gZmllbGRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZXMuY3JlYXRlTmV3UHJvamVjdC5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyhwcm9qZWN0VmFsdWUsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYnJhaW4uY3JlYXRlTmV3UHJvamVjdFByb2plY3REZXNjcmlwdGlvbi5ub2RlLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2hlY2sgaWYgY2xvc2VkIGlzIG5lZWRlZD9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGlzcGxheU1hbmFnZXIuaGlkZSgnY3JlYXRlTmV3UHJvamVjdFZpZXcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHJlcGxhY2Ugd2l0aCBjbGFzc2VzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWluLmNyZWF0ZU5ld1Byb2plY3RJbnB1dFByb2plY3Qubm9kZS5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSAnI2ZmNDQ0NCc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KCkpLFxuICAgICAgICAgICAgcHJvamVjdFNob3c6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3RyYW5zbGF0aW9uVmlld1Byb2plY3RDYXRlZ29yeUtleScpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcHJvamVjdElucHV0Q2F0ZWdvcnk6IHtcbiAgICAgICAgICAgICAgICBpbml0OiBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHByb2plY3RJbnB1dEtleToge1xuICAgICAgICAgICAgICAgIGluaXQ6IGZ1bmN0aW9uKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2FuY2VsIDogKCgpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICBpbml0IDogKG5vZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS5kaXNwbGF5TWFuYWdlci5oaWRlKHRoaXMuZGF0YXNldC52aWV3KVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pKCksXG4gICAgICAgICAgICBwcm9qZWN0U3VibWl0OiAoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5vZGU7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24oZWxlbSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGVsZW07XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5S2V5ID0gYnJhaW4ucHJvamVjdElucHV0Q2F0ZWdvcnkubm9kZS52YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gYnJhaW4ucHJvamVjdElucHV0S2V5Lm5vZGUudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld0tleTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZU5ld0tleShjYXRlZ29yeUtleSkgJiYgdmFsaWRhdGVOZXdLZXkoa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGRlZmF1bHQgbGFuZ3VhZ2VcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5ID0gY2F0ZWdvcnlLZXkgKyAnXycgKyBrZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uQ3JlYXRlS2V5KG5ld0tleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZXBsYWNlIHdpdGggY2xhc3Nlc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmFpbi5wcm9qZWN0SW5wdXRDYXRlZ29yeS5ub2RlLmNsYXNzTGlzdC5hZGQoJ2Vycm9yJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJhaW4ucHJvamVjdElucHV0S2V5Lm5vZGUuY2xhc3NMaXN0LmFkZCgnZXJyb3InKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSgpKVxuICAgICAgICB9LFxuICAgICAgICBmYyA9IHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEByZXR1cm5zIHt7cm93UHJlZml4OiBzdHJpbmcsIGlucHV0UHJlZml4OiBzdHJpbmcsIGlucHV0VHJhbnNQcmVmaXg6IHN0cmluZ319XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldCBjb25maWcgKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25mO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVuYWJsZUVkaXRvck1vZGU6IGZ1bmN0aW9uKGVuYWJsZSkge1xuICAgICAgICAgICAgICAgIGlmIChlbmFibGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LmFkZCgnYy1lbmFibGVFZGl0b3JNb2RlJyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1lbmFibGVFZGl0b3JNb2RlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvZ2dsZVdvcmRDb3VudDogZnVuY3Rpb24oZW5hYmxlKSB7XG4gICAgICAgICAgICAgICAgcm9vdE5vZGUuY2xhc3NMaXN0LnRvZ2dsZSgnYy13b3JkQ291bnRFbmFibGVkJywgZW5hYmxlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZW5kU3VjY2VzczogdWkuc2VuZFN1Y2Nlc3MsXG4gICAgICAgICAgICBhZGQ6IGZ1bmN0aW9uKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICAgICAgICBpZiAoYXR0ciA9PT0gJ21haW4nKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvb3ROb2RlID0gbm9kZTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGJyYWluLmhhc093blByb3BlcnR5KGF0dHIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGJyYWluW2F0dHJdLmluaXQobm9kZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFZpZXdLZXlPYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuICAgICAgICAgICAgICAgIHZhciBuZXdLZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHROYW1lID0gbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgZGVsaW1pdGVyID0gJ18nO1xuICAgICAgICAgICAgICAgIGlmICgvXFwuLy50ZXN0KG9iai5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGltaXRlciA9ICcuJztcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBuZXdLZXkgPSBvYmoua2V5LnNwbGl0KGRlbGltaXRlcik7XG5cbiAgICAgICAgICAgICAgICBpZiAobmV3S2V5Lmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gdXNlIHNsaWNlIGlmIHdlIG5lZWQgdGhlIGNvbXBsZXRlIGtleSBpbiB0aGUgdmlld1xuICAgICAgICAgICAgICAgICAgICBjb250ZXh0TmFtZSA9IG5ld0tleS5zcGxpY2UoMCwgMSlbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBvYmoua2V5LCAgLy8gZGVwcmVjYXRlZFxuICAgICAgICAgICAgICAgICAgICBrZXk6IG9iai5rZXksXG4gICAgICAgICAgICAgICAgICAgIGNvbnRleHROYW1lOiBjb250ZXh0TmFtZSxcbiAgICAgICAgICAgICAgICAgICAga2V5TmFtZTogbmV3S2V5LmpvaW4oZGVsaW1pdGVyKSxcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9iai52YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaXNCdW5kbGVFcXVhbDogZnVuY3Rpb24oYnVuZGxlMSwgYnVuZGxlMikge1xuICAgICAgICAgICAgICAgIGlmIChidW5kbGUxLmJ1bmRsZSA9PT0gYnVuZGxlMi5idW5kbGUgJiYgYnVuZGxlMS5sb2NhbGUgPT09IGJ1bmRsZTIubG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZUZyb206IGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgYnVuZGxlOiBkb21PcHRzLnBhcmFtcy5idW5kbGUgfHwgJ21lc3NhZ2VzJyxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiB0aGlzLmdldEZyb21QYXJhbSgpXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRGcm9tUGFyYW06IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBkb21PcHRzLnBhcmFtcy5mcm9tIHx8ICdkZSc7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZVRvOiBmdW5jdGlvbigpIHtcblxuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIGJ1bmRsZTogZG9tT3B0cy5wYXJhbXMuYnVuZGxlIHx8ICdtZXNzYWdlcycsXG4gICAgICAgICAgICAgICAgICAgIGxvY2FsZTogZG9tT3B0cy5wYXJhbXMudG8gfHwgbnVsbFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0QnVuZGxlTmFtZTogZnVuY3Rpb24obG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgdmFyIGJ1bmRsZSA9IGRvbU9wdHMucGFyYW1zLmJ1bmRsZSB8fCAnbWVzc2FnZXMnO1xuICAgICAgICAgICAgICAgIHJldHVybiBidW5kbGUgKyAnXycgKyBsb2NhbGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBSZW5kZXIgdGhlIGkxOG4gaW5wdXQgZmllbGQgZm9yIGtleXMgZnJvbSBhIHNpbmdsZSBsYW5ndWFnZS4gVGhlIHJvdyBoZWFkZXIgKGkuZS4gdGhlIGFjdHVhbCBrZXkgZmllbGQpIGlzXG4gICAgICAgICAgICAgKiByZW5kZXJlZCwgdG9vIGlmIGl0IGRvZXMgbm90IGV4aXN0IHlldC5cbiAgICAgICAgICAgICAqIEBwYXJhbSBidW5kbGVzIHtrZXk6IHN0cmluZywgZGF0YTogc3RyaW5nfVxuICAgICAgICAgICAgICogQHBhcmFtIGFjdHVhbExhbmd1YWdlXG4gICAgICAgICAgICAgKiBAcGFyYW0gYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlc1xuICAgICAgICAgICAgICogQHBhcmFtIHByb2plY3ROYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHByaW50QnVuZGxlVGVtcGxhdGU6IGZ1bmN0aW9uKGJ1bmRsZXMsIGFjdHVhbExhbmd1YWdlLCBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzLCBjYikge1xuICAgICAgICAgICAgICAgIHZhciBrZXlPYmosXG4gICAgICAgICAgICAgICAgICAgIHByb2plY3ROb2RlLFxuICAgICAgICAgICAgICAgICAgICBzaG93bkNhdGVnb3JpZXMgPSBbXS5zbGljZS5jYWxsKHJvb3ROb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jYXRlZ29yeU5vZGUnKSk7XG4gICAgICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAgICAgKiBTZXR1cCBoZWFkZXIgYW5kIGhhbmRsZSB0aGUgY2F0ZWdvcnlcbiAgICAgICAgICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGNvbnRleHROYW1lXG4gICAgICAgICAgICAgICAgICAgICAqIEByZXR1cm5zIHtIVE1MRWxlbWVudH1cbiAgICAgICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHByZXBhcmVDYXRlZ29yeU5vZGUoY29udGV4dE5hbWUsIGxhbmd1YWdlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsgY29udGV4dE5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjYXRlZ29yeU5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeU5vZGUgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcjdGVtcGxhdGVzIC5jYXRlZ29yeU5vZGUnKS5jbG9uZU5vZGUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnlOb2RlLmNsYXNzTGlzdC5hZGQoJ2MtYW5jaG9yTWVudS1wYXJlbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgY2F0ZWdvcnlOYW1lID0gY29udGV4dE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdGVnb3J5Tm9kZUlkID0gY2F0ZWdvcnlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGVnb3J5Tm9kZS5zZXRBdHRyaWJ1dGUoJ2lkJywgY29uZi5yb3dQcmVmaXggKyBjYXRlZ29yeU5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhdGVnb3J5TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgd3JhcHBlciA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCcuaGVhZGxpbmVXcmFwcGVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMiA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCdoMicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIG1ha2UgYSBzcGFuIGZvciBpdFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoMi5hcHBlbmRDaGlsZCgoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNhdGVnb3J5TmFtZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSAna2V5TmFtZSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3BhblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaDIuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25RdWV1ZXMuY2F0ZWdvcnlDbGlja2VkLmZvckVhY2goZnVuY3Rpb24oZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyhjYXRlZ29yeU5vZGVJZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGVkaXRQYW5lbCA9IGlucHV0RWRpdE1hbmFnZXIuYWRkRWRpdG9yUGFuZWwoY2F0ZWdvcnlOb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkVkaXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnJlbW92ZUF0dHJpYnV0ZSgnZGlzYWJsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZXh0TmFtZSA9IGtleUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNhbmNlbDogZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnZhbHVlID0gY29udGV4dE5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25TYXZlOiBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbmFtZUNhdGVnb3J5LmZvckVhY2goZnVuY3Rpb24oZmMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2xkTmFtZTogY29udGV4dE5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdOYW1lOiBrZXlJbnB1dE5vZGUudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb25EZWxldGU6IGZ1bmN0aW9uKGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllcyA9IHdpbmRvdy5jb25maXJtKCdEZWxldGUgdGhpcyBjYXRlZ29yeT9cXG5BbGwga2V5cyB3aXRoaW4gd2l0aCB3aWxsIGJlIGxvc3QuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHllcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblF1ZXVlcy5yZW1vdmVDYXRlZ29yeS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcnk6IGNhdGVnb3J5TmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdyYXBwZXIuYXBwZW5kQ2hpbGQoZWRpdFBhbmVsKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIga2V5SW5wdXROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIGNvbmYucm93UHJlZml4ICsgY2F0ZWdvcnlOYW1lICsgJ19pbnB1dCcsICdjYXRlZ29yeUZpZWxkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2tleXByZXNzJywga2V5S2V5UHJlc3NMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyLmFwcGVuZENoaWxkKGtleUlucHV0Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS52YWx1ZSA9IGNhdGVnb3J5TmFtZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgdGhlIGRlc2NyaXB0aW9uIGZ1bmN0aW9uYWxpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGNhdERlc2NOb2RlID0gY2F0ZWdvcnlOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5qcy1jYXQtZGVzY3JpcHRpb24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNwYW4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzcGFuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uY2xhc3NOYW1lID0gJ2pzLXRleHQnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXREZXNjTm9kZS5hcHBlbmRDaGlsZChzcGFuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhdERlc2NOb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS50ZXh0RWRpdG9yLmFkZChjYXREZXNjTm9kZSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBjYXRlZ29yeU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGxhY2Vob2xkZXI6ICdBZGQgaGVyZSB0aGUgY2F0ZWdvcnkgZGVzY3JpcHRpb24nXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55LnRyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkLmFkZChjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLmpzLWltYWdlVXBsb2FkLWVkaXRCdXR0b24nKSwgY2F0ZWdvcnlOYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBhZGQgYWRkIGtleSBpbnB1dCBmaWVsZCBhbmQgYnV0dG9uXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBrZXlOYW1lSW5wdXQgPSBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLmFkZE5ld0tleXJvdyBpbnB1dCcpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlOYW1lSW5wdXQuc2V0QXR0cmlidXRlKCdjYXRlZ29yeScsIGNhdGVnb3J5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleU5hbWVJbnB1dC5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGtleUtleVByZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignbGFiZWwnKS5pbm5lclRleHQgPSBjYXRlZ29yeU5hbWUgKyBcIl9cIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGJ1dHRvbiA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCdidXR0b24nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsaWRhdGVOZXdLZXkoa2V5TmFtZUlucHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBuZXdLZXkgPSBrZXlOYW1lSW5wdXQuZ2V0QXR0cmlidXRlKCdjYXRlZ29yeScpICsgJ18nICsga2V5TmFtZUlucHV0LnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVmYWN0b3IgdGhpcyAtIHNlcnZlciBzaG91bGQgYWRkIHRoZSBrZXkgZm9yIGFsbCBhdmFpbGFibGUgbGFuZ3VhZ2VzIC0gb3IgcGFzcyBkZWZhdWx0IGxhbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbkNyZWF0ZUtleShuZXdLZXksIGFjdHVhbExhbmd1YWdlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnV0dG9uLnN0eWxlLmNvbG9yID0gJyNmZjAwMDAnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleU5hbWVJbnB1dC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBcIiNmZjQ0NDRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIG92ZXJhbGwgd29yZCBjb3VudCBmb3IgZWFjaCBsYW5ndWFnZSBvZiBhIGNhdGVnb3J5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG92ZXJhbGxXb3Jkc1dyYXBwZXIgPSBjYXRlZ29yeU5vZGUucXVlcnlTZWxlY3RvcignLm92ZXJhbGxXb3JkQ291bnRXcmFwcGVyJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJhbGxIZWFkbGluZSA9IG92ZXJhbGxXb3Jkc1dyYXBwZXIucXVlcnlTZWxlY3RvcignLm92ZXJhbGxXb3Jkc0hlYWRsaW5lJyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50ZXJzV3JhcHBlciA9IG92ZXJhbGxXb3Jkc1dyYXBwZXIucXVlcnlTZWxlY3RvcignLnRyYW5zbGF0aW9uQ29udGFpbmVyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmFsbEhlYWRsaW5lLmlubmVySFRNTCA9IGdldFdvcmRDb3VudEhlYWRsaW5lKGNhdGVnb3J5TmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFuZ3VhZ2VzLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudGVyc1dyYXBwZXIuYXBwZW5kQ2hpbGQoY3JlYXRlV29yZENvdW50Rm9yTGFuZ3VhZ2UobGFuZykpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhdGVnb3J5Tm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIGJ1bmRsZXMuZm9yRWFjaChmdW5jdGlvbihkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIGtleU9iaiA9IGZjLmdldFZpZXdLZXlPYmplY3QoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gd2hpY2ggd2hvIGNhbGMgdGhlIGNhdGUuLi5cbiAgICAgICAgICAgICAgICAgICAgcHJvamVjdE5vZGUgPSBwcmVwYXJlQ2F0ZWdvcnlOb2RlKGtleU9iai5jb250ZXh0TmFtZSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIGluc2VydENhdGVnb3J5KHByb2plY3ROb2RlLCBzaG93bkNhdGVnb3JpZXMpO1xuICAgICAgICAgICAgICAgICAgICBmYy5hZGRSb3dXaXRoTGFuZ3VhZ2VzKHByb2plY3ROb2RlLCBrZXlPYmosIGFjdHVhbExhbmd1YWdlLCBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAgY2IocHJvamVjdE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpLnJlcGxhY2UoY29uZi5yb3dQcmVmaXgsICcnKSk7XG4gICAgICAgICAgICAgICAgICAgIGNiKGtleU9iai5rZXkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogVXBkYXRlIHRoZSB3b3JkIGNvdW50IGZvciBhIGdpdmVuIGNhdGVnb3J5XG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICB1cGRhdGVDYXRlZ29yeVdvcmRDb3VudDogZnVuY3Rpb24oZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciBsYWJlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJyMnICsgY29uZi5yb3dQcmVmaXggKyBkYXRhLmlkICsgJyAub3ZlcmFsbFdvcmRDb3VudFdyYXBwZXIgLmpzXycgKyBkYXRhLmxhbmd1YWdlICsgJyAud29yZENvdW50TGFiZWwnKTtcbiAgICAgICAgICAgICAgICBpZiAobGFiZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgbGFiZWwuaW5uZXJIVE1MID0gZ2V0V29yZENvdW50VGV4dChkYXRhLndvcmRzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjcmVhdGVzIGEga2V5IGZpZWxkXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGFkZEtleUZpZWxkOiBmdW5jdGlvbihub2RlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleUlucHV0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYuaW5wdXRQcmVmaXggKyBkYXRhLmtleSksXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGU7XG4gICAgICAgICAgICAgICAgaWYgKCFrZXlJbnB1dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdpbnB1dCcsIGNvbmYuaW5wdXRQcmVmaXggKyBkYXRhLmtleSwgJ2tleUZpZWxkJyk7XG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ2RpdicsIG51bGwsICdkYXRhIGtleSBvY3RpY29uIG9jdGljb24ta2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXRFZGl0TWFuYWdlci5hZGRFZGl0b3JQYW5lbChrZXlOb2RlLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkRlbGV0ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHllcyA9IHdpbmRvdy5jb25maXJtKCdEZWxldGUgdGhpcyBrZXk/XFxuVGhpcyBrZXkgd2l0aCBhbGwgdHJhbnNsYXRpb25zIHdpbGwgcmVtb3ZlZC4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoeWVzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbW92ZUtleS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5OiBkYXRhLmtleVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVkaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5yZW1vdmVBdHRyaWJ1dGUoJ2Rpc2FibGVkJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZSBhY3R1YWwga2V5IGZvciByZXN0b3JpbmcgaWYgY2FuY2VsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5rZXlOYW1lID0ga2V5SW5wdXROb2RlLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldCB0aGUga2V5OiB0YWtlIGlkIGF0dHJpYnV0ZSBhbmQgcmVtb3ZlIHRoZSB2YWx1ZSBmcm9tIGl0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YS5rZXkgPSBrZXlJbnB1dE5vZGUuZ2V0QXR0cmlidXRlKCdpZCcpLnJlcGxhY2UoY29uZi5pbnB1dFByZWZpeCwgJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEuY29udGV4dE5hbWUgPSBkYXRhLmtleS5zcGxpdCgnXycpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5mb2N1cygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2FuY2VsOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXlJbnB1dE5vZGUuc2V0QXR0cmlidXRlKCdkaXNhYmxlZCcsICd0cnVlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnZhbHVlID0gZGF0YS5rZXlOYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU2F2ZTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlldzphZGRLZXlGaWVsZCBzYXZlIG5ldyBrZXknKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsdWUgPSBkYXRhLmNvbnRleHROYW1lID8gZGF0YS5jb250ZXh0TmFtZSArICdfJyArIGtleUlucHV0Tm9kZS52YWx1ZSA6IGtleUlucHV0Tm9kZS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoa2V5SW5wdXROb2RlLnZhbHVlICE9ICcnICYmIHZhbHVlICE9IGRhdGEua2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbmFtZUtleS5mb3JFYWNoKGZ1bmN0aW9uKGZjKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3S2V5OiB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbGRLZXk6IGRhdGEua2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uQ2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyYWluLmNsb25lS2V5T3ZlcmxheS5zZXREYXRhKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXlNYW5hZ2VyLnNob3coJ3RyYW5zbGF0aW9uVmlld0Nsb25lS2V5Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAvLyByZWdpc3RlciB0aGUgaW5wdXQga2V5IGxpc3RlbmVyIHRvIGNhcHR1cmUgd3JvbmcgY2hhcmFjdGVyXG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXlwcmVzcycsIGtleUtleVByZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICBrZXlOb2RlLmFwcGVuZENoaWxkKChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwYW4uYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoZGF0YS5rZXlOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzcGFuLmNsYXNzTmFtZSA9ICdrZXlOYW1lJztcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzcGFuXG4gICAgICAgICAgICAgICAgICAgIH0oKSkpO1xuXG4gICAgICAgICAgICAgICAgICAgIGtleU5vZGUuYXBwZW5kQ2hpbGQoa2V5SW5wdXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5pbnNlcnRCZWZvcmUoa2V5Tm9kZSwgbm9kZS5jaGlsZHJlblswXSk7XG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS52YWx1ZSA9IGRhdGEua2V5TmFtZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDYWxsIHRoaXMgdG8gdXBkYXRlL2NyZWF0ZSBhIGxhbmd1YWdlIGZpZWxkXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlXG4gICAgICAgICAgICAgKiBAcGFyYW0gbGFuZ1xuICAgICAgICAgICAgICogQHBhcmFtIHdvcmRDb3VudFxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBhZGRMYW5ndWFnZUZpZWxkOiBmdW5jdGlvbihub2RlLCBrZXksIHZhbHVlLCBsYW5nLCB3b3JkQ291bnQpIHtcblxuICAgICAgICAgICAgICAgIHZhciB0ZXh0Tm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGdldExhbmd1YWdlVGV4dElkKGtleSwgbGFuZykpLFxuICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZSxcbiAgICAgICAgICAgICAgICAgICAgd29yZENvdW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50Tm9kZSxcbiAgICAgICAgICAgICAgICAgICAgdGV4dEluZm9ybWF0aW9uTm9kZTtcblxuICAgICAgICAgICAgICAgIGlmICghdGV4dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUgPSBkb21PcHRzLmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJywgZ2V0TGFuZ3VhZ2VUZXh0SWQoa2V5LCBsYW5nKSwgJ3RleHRGaWVsZCcpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZSA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ2RhdGEgdHBsIGpzXycgKyBsYW5nKTtcbiAgICAgICAgICAgICAgICAgICAgdGV4dEluZm9ybWF0aW9uTm9kZSA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ3RleHRJbmZvcm1hdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICB3b3JkQ291bnROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ3RleHRJbmZvcm1hdGlvbi13b3JkQ291bnRMYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICBjaGFyQ291bnROb2RlID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdzcGFuJywgbnVsbCwgJ3RleHRJbmZvcm1hdGlvbi1jaGFyQ291bnRMYWJlbCcpO1xuICAgICAgICAgICAgICAgICAgICB3b3JkQ291bnROb2RlLmlubmVySFRNTCA9IGdldFdvcmRDb3VudFRleHQoMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dEluZm9ybWF0aW9uTm9kZS5hcHBlbmRDaGlsZChmbGFnLmdldEZsYWcobGFuZykpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0SW5mb3JtYXRpb25Ob2RlLmFwcGVuZENoaWxkKHdvcmRDb3VudE5vZGUpXG4gICAgICAgICAgICAgICAgICAgIHRleHRJbmZvcm1hdGlvbk5vZGUuYXBwZW5kQ2hpbGQoY2hhckNvdW50Tm9kZSlcblxuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5hZGRFdmVudExpc3RlbmVyKCdrZXl1cCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYXJDb3VudE5vZGUuaW5uZXJIVE1MID0gZ2V0Q2hhcmFjdGVyQ291bnQodGhpcy52YWx1ZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHdvcmRDb3VudE5vZGUuaW5uZXJIVE1MID0gZ2V0V29yZENvdW50VGV4dCh3b3JkQ291bnRlci5jb3VudFdvcmRzSW5TdHJpbmcodGhpcy52YWx1ZSkpXG4gICAgICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICAgICAgdGV4dE5vZGUuYWRkRXZlbnRMaXN0ZW5lcigna2V5cHJlc3MnLCB0ZXh0QXJlYUtleVByZXNzTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0Tm9kZS5zZXRBdHRyaWJ1dGUoJ3R5cGUnLCAndGV4dCcpO1xuXG4gICAgICAgICAgICAgICAgICAgIG5ldyBTYXZlT25MZWF2ZSh0ZXh0Tm9kZSwga2V5LCBsYW5nLCB2YWx1ZSk7XG5cbiAgICAgICAgICAgICAgICAgICAgZGF0YU5vZGUuYXBwZW5kQ2hpbGQodGV4dE5vZGUpO1xuICAgICAgICAgICAgICAgICAgICBkYXRhTm9kZS5hcHBlbmRDaGlsZCh0ZXh0SW5mb3JtYXRpb25Ob2RlKTtcblxuICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGRhdGFOb2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB3b3JkQ291bnROb2RlID0gdGV4dE5vZGUucGFyZW50RWxlbWVudC5xdWVyeVNlbGVjdG9yKCcudGV4dEluZm9ybWF0aW9uLXdvcmRDb3VudExhYmVsJyk7XG4gICAgICAgICAgICAgICAgICAgIGNoYXJDb3VudE5vZGUgPSB0ZXh0Tm9kZS5wYXJlbnRFbGVtZW50LnF1ZXJ5U2VsZWN0b3IoJy50ZXh0SW5mb3JtYXRpb24tY2hhckNvdW50TGFiZWwnKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgfHwgdmFsdWUgPT09ICcnKSB7XG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlLnZhbHVlID0gdmFsdWUgPyB1bmljb2RlLmVuY29kZSh2YWx1ZSkgOiAnJ1xuICAgICAgICAgICAgICAgICAgICB3b3JkQ291bnROb2RlLmlubmVySFRNTCA9IGdldFdvcmRDb3VudFRleHQod29yZENvdW50ZXIuY291bnRXb3Jkc0luU3RyaW5nKHZhbHVlKSlcbiAgICAgICAgICAgICAgICAgICAgY2hhckNvdW50Tm9kZS5pbm5lckhUTUwgPSBnZXRDaGFyYWN0ZXJDb3VudCh2YWx1ZSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjcmVhdGVzIGEgcm93XG4gICAgICAgICAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7SFRNTEVsZW1lbnR9IHRoZSBleGlzdGluZyByb3cgb3IgaW4gY2FzZSBpZiBub3QgZXhpc3RzIGEgbmV3IGNyZWF0ZWQgcm93XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFJvdzogZnVuY3Rpb24obm9kZSwga2V5KSB7XG4gICAgICAgICAgICAgICAgLy8gdHJ5IHRvIGdldCB0aGUgcm93XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsga2V5KSxcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNsYXRpb25Db250YWluZXIgPSByb3cgIT09IG51bGwgPyByb3cucXVlcnlTZWxlY3RvcignLnRyYW5zbGF0aW9uQ29udGFpbmVyJykgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgICAgICAgICAgICAgIHRyYW5zbGF0aW9uQ29udGFpbmVyLmNsYXNzTmFtZSA9IFwidHJhbnNsYXRpb25Db250YWluZXJcIjtcblxuICAgICAgICAgICAgICAgIC8vIGlmIHRoZXJlIGlzIGEgcm93IGJ1dCBpdCBpcyBtYXJrZWQgYXMgcmVtb3ZlZCB0aGFuIHJlbW92ZWQgaXRcbiAgICAgICAgICAgICAgICBpZiAocm93ICYmIHJvdy5jbGFzc0xpc3QuY29udGFpbnMoJ2MtcmVtb3ZlZCcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5kb21SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBjcmVhdGUgYSByb3cgaWYgdGhlIHJvdyBpcyBub3QgZXhpc3RzXG4gICAgICAgICAgICAgICAgaWYgKCFyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93ID0gZG9tT3B0cy5jcmVhdGVFbGVtZW50KCdkaXYnLCBjb25mLnJvd1ByZWZpeCArIGtleSwgJ3JvdyBjLXJvdyBjLWFuY2hvck1lbnUtY2hpbGQnKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSBkZXNjcmlwdGlvbiBmdW5jdGlvbmFsaXR5XG4gICAgICAgICAgICAgICAgICAgIHZhciBjYXREZXNjTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NwYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgc3Bhbi5jbGFzc05hbWUgPSAnanMtdGV4dCc7XG4gICAgICAgICAgICAgICAgICAgIGNhdERlc2NOb2RlLmFwcGVuZENoaWxkKHNwYW4pO1xuICAgICAgICAgICAgICAgICAgICBjYXREZXNjTm9kZS5jbGFzc05hbWUgPSAnanMtcm93LWRlc2NyaXB0aW9uJztcbiAgICAgICAgICAgICAgICAgICAgcm93LmFwcGVuZENoaWxkKGNhdERlc2NOb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgY2FubnkudGV4dEVkaXRvci5hZGQoY2F0RGVzY05vZGUsIHtpZDoga2V5LCBwbGFjZWhvbGRlcjogJ0FkZCBoZXJlIHRoZSBrZXkgZGVzY3JpcHRpb24nfSk7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gYWRkIHRoZSB0cmFuc2xhdGlvbiBhcmVhIGZpZWxkIGNvbnRhaW5lclxuICAgICAgICAgICAgICAgICAgICByb3cuYXBwZW5kQ2hpbGQodHJhbnNsYXRpb25Db250YWluZXIpO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnF1ZXJ5U2VsZWN0b3IoJy5rZXlzV3JhcHBlcicpLmFwcGVuZENoaWxkKHJvdyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByb3c7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYWRkUm93V2l0aExhbmd1YWdlczogZnVuY3Rpb24obm9kZSwgZGF0YSwgYWN0dWFsTGFuZ3VhZ2UsIGFsbFByb2plY3RMYW5ndWFnZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcm93ID0gZmMuZ2V0Um93KG5vZGUsIGRhdGEua2V5KTtcblxuICAgICAgICAgICAgICAgIGZjLmFkZEtleUZpZWxkKHJvdywgZGF0YSk7XG5cbiAgICAgICAgICAgICAgICBhbGxQcm9qZWN0TGFuZ3VhZ2VzLmZvckVhY2goZnVuY3Rpb24obGFuZykge1xuICAgICAgICAgICAgICAgICAgICBmYy5hZGRMYW5ndWFnZUZpZWxkKHJvdy5xdWVyeVNlbGVjdG9yKCcudHJhbnNsYXRpb25Db250YWluZXInKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEua2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgYWN0dWFsTGFuZ3VhZ2UgPT09IGxhbmcgPyBkYXRhLnZhbHVlIDogbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhbmcpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGFkZExhbmd1YWdlOiBmdW5jdGlvbihrZXlzLCBsYW5nKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyxcbiAgICAgICAgICAgICAgICAgICAgY2F0ZWdvcmllcyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2F0ZWdvcnk7XG4gICAgICAgICAgICAgICAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgICAgICByb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjLmFkZExhbmd1YWdlRmllbGQocm93LnF1ZXJ5U2VsZWN0b3IoJy50cmFuc2xhdGlvbkNvbnRhaW5lcicpLCBrZXksIG51bGwsIGxhbmcsIDApO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBjdXJyZW50Q2F0ZWdvcnkgPSBrZXkuc3BsaXQoJ18nKVswXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXRlZ29yaWVzLmluZGV4T2YoY3VycmVudENhdGVnb3J5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXRlZ29yaWVzLnB1c2goY3VycmVudENhdGVnb3J5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3RyYW5zbGF0aW9uVmlldzphZGRMYW5ndWFnZSBmb3VuZCBrZXkgd2hpY2ggaXMgbm90IGF2YWlsYWJsZSBpbiB2aWV3OicsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGNhdGVnb3JpZXMuZm9yRWFjaChmdW5jdGlvbihjYXRlZ29yeSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBvdmVyYWxsV29yZENvdW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcignIycgKyBjb25mLnJvd1ByZWZpeCArIGNhdGVnb3J5ICsgJyAub3ZlcmFsbFdvcmRDb3VudFdyYXBwZXIgLnRyYW5zbGF0aW9uQ29udGFpbmVyJylcbiAgICAgICAgICAgICAgICAgICAgb3ZlcmFsbFdvcmRDb3VudC5hcHBlbmRDaGlsZChjcmVhdGVXb3JkQ291bnRGb3JMYW5ndWFnZShsYW5nKSlcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbGVhclZpZXc6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIC8vIGp1c3QgcmVzZXQgYWxsIGZvciBub3dcbiAgICAgICAgICAgICAgICAvLyBUT0RPIGRvIGl0IGJldHRlciA7KVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwocm9vdE5vZGUuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24oY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgcm9vdE5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNob3dMYW5nOiBmdW5jdGlvbihsYW5nKSB7XG4gICAgICAgICAgICAgICAgLy8gc2hvdyB0aGUgbGFuZyB0YWJcbiAgICAgICAgICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QucmVtb3ZlKCdjLWhpZGVfJyArIGxhbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVtb3ZlIGEgY2F0ZWdvcnlcbiAgICAgICAgICAgICAqIFRPRE8gaXQncyBub3QgY2FsbGVkIGlmIG93biB1c2VyIHJlbmFtZXMgYSBjYXRlZ29yeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW5hbWVDYXRlZ29yeTogZnVuY3Rpb24ob2xkTmFtZSwgbmV3TmFtZSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcykge1xuICAgICAgICAgICAgICAgIHZhciBjYXRlZ29yeU5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIG9sZE5hbWUpLFxuICAgICAgICAgICAgICAgICAgICByb3dzID0gY2F0ZWdvcnlOb2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJy5jLXJvdycpLFxuICAgICAgICAgICAgICAgICAgICBoZWFkbGluZSA9IGNhdGVnb3J5Tm9kZS5xdWVyeVNlbGVjdG9yKCdoMicpLFxuICAgICAgICAgICAgICAgICAgICBhZGRLZXlOb2RlID0gY2F0ZWdvcnlOb2RlLnF1ZXJ5U2VsZWN0b3IoJy5hZGROZXdLZXlyb3cnKTtcblxuICAgICAgICAgICAgICAgIGNhdGVnb3J5Tm9kZS5pZCA9IGNvbmYucm93UHJlZml4ICsgbmV3TmFtZTtcblxuICAgICAgICAgICAgICAgIGhlYWRsaW5lLnF1ZXJ5U2VsZWN0b3IoJy5rZXlOYW1lJykuY2hpbGROb2Rlc1swXS5ub2RlVmFsdWUgPSBuZXdOYW1lO1xuXG4gICAgICAgICAgICAgICAgYWRkS2V5Tm9kZS5xdWVyeVNlbGVjdG9yKCdsYWJlbCcpLmlubmVySFRNTCA9IG5ld05hbWUgKyAnXyc7XG4gICAgICAgICAgICAgICAgYWRkS2V5Tm9kZS5xdWVyeVNlbGVjdG9yKCdpbnB1dCcpLnNldEF0dHJpYnV0ZSgnY2F0ZWdvcnknLCBuZXdOYW1lKTtcblxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwocm93cykuZm9yRWFjaChmdW5jdGlvbihyb3cpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlkID0gcm93LmlkLnJlcGxhY2UoY29uZi5yb3dQcmVmaXgsICcnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHNwbGl0TmFtZSA9IGlkLnNwbGl0KCdfJyksXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdLZXlOYW1lO1xuXG4gICAgICAgICAgICAgICAgICAgIHNwbGl0TmFtZS5zaGlmdCgpO1xuICAgICAgICAgICAgICAgICAgICBuZXdLZXlOYW1lID0gbmV3TmFtZSArICdfJyArIHNwbGl0TmFtZS5qb2luKCdfJyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpZCAhPT0gJycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlbmFtZURPTUlkcyhpZCwgbmV3S2V5TmFtZSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCd0cmFuc2xhdGlvblZpZXc6cmVuYW1lQ2F0ZWdvcnkgc2hvdWxkIG5vdCBoYXYgYW4gZW1wdHkgaWQnLCByb3cpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaW5wdXRFZGl0TWFuYWdlci5jbG9zZUVkaXRWaWV3KGhlYWRsaW5lKTtcbiAgICAgICAgICAgICAgICBoZWFkbGluZS5xdWVyeVNlbGVjdG9yKCcuY2F0ZWdvcnlGaWVsZCcpLnNldEF0dHJpYnV0ZSgnZGlzYWJsZWQnLCAndHJ1ZScpO1xuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZW1vdmUgYSBjYXRlZ29yeVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVDYXRlZ29yeTogZnVuY3Rpb24oY2F0KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsgY2F0KTtcbiAgICAgICAgICAgICAgICBpZiAocm93KSB7XG4gICAgICAgICAgICAgICAgICAgIHJvdy5kb21SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBzaG93IGEga2V5IGFzIGRlbGV0ZWRcbiAgICAgICAgICAgICAqIEBwYXJhbSBrZXlcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgbWFya0tleUFzUmVtb3ZlZDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgdmFyIHJvdyA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGNvbmYucm93UHJlZml4ICsga2V5KSxcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSWM7XG4gICAgICAgICAgICAgICAgaWYgKHJvdyAmJiAhcm93LmNsYXNzTGlzdC5jb250YWlucygnYy1yZW1vdmVkJykpIHtcbiAgICAgICAgICAgICAgICAgICAgcm93LmNsYXNzTGlzdC5hZGQoJ2MtcmVtb3ZlZCcpO1xuICAgICAgICAgICAgICAgICAgICByZW1vdmVJYyA9IGRvbU9wdHMuY3JlYXRlRWxlbWVudCgnZGl2JywgbnVsbCwgJ3JlbW92ZS1idXR0b24gb2N0aWNvbiBvY3RpY29uLXgnKTtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlSWMuYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJvdy5kb21SZW1vdmUoKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUljLmRvbUFwcGVuZFRvKHJvdyk7XG4gICAgICAgICAgICAgICAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXJzRnJvbVJvdyhyb3cpO1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVkaXRNYW5hZ2VyLnJlbW92ZVBhbmVsKHJvdyk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcigndHJhbnNsYXRpb25WaWV3Om1hcmtrZXlBc1JlbW92ZWQgbm8gbm9kZSBmb3VuZCBmb3Iga2V5Jywga2V5LCByb3cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIHJlbW92ZSBhIGtleVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICByZW1vdmVLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgICAgICAgICAgIHZhciByb3cgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLnJvd1ByZWZpeCArIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHJvdykge1xuICAgICAgICAgICAgICAgICAgICByb3cuZG9tUmVtb3ZlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVuYW1lIGEga2V5XG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG9sZEtleVxuICAgICAgICAgICAgICogQHBhcmFtIG5ld0tleVxuICAgICAgICAgICAgICogQHBhcmFtIGF2YWlsYWJsZVByb2plY3RMYW5ndWFnZXMgW11cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgcmVuYW1lS2V5OiBmdW5jdGlvbihvbGRLZXksIG5ld0tleSwgYXZhaWxhYmxlUHJvamVjdExhbmd1YWdlcykge1xuICAgICAgICAgICAgICAgIHZhciBrZXlJbnB1dE5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjb25mLmlucHV0UHJlZml4ICsgb2xkS2V5KSxcbiAgICAgICAgICAgICAgICAgICAga2V5TmFtZTtcblxuICAgICAgICAgICAgICAgIGlmIChrZXlJbnB1dE5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAga2V5TmFtZSA9IGZjLmdldFZpZXdLZXlPYmplY3Qoe2tleTogbmV3S2V5fSkua2V5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgcmVuYW1lRE9NSWRzKG9sZEtleSwgbmV3S2V5LCBhdmFpbGFibGVQcm9qZWN0TGFuZ3VhZ2VzKTtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnZhbHVlID0ga2V5TmFtZTtcbiAgICAgICAgICAgICAgICAgICAgLy8gY2xvc2UgdGhlIGVkaXQgdmlld1xuICAgICAgICAgICAgICAgICAgICBpbnB1dEVkaXRNYW5hZ2VyLmNsb3NlRWRpdFZpZXcoa2V5SW5wdXROb2RlKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZGlzYWJsZWQgdGhlIGlucHV0IGZpZWxkXG4gICAgICAgICAgICAgICAgICAgIGtleUlucHV0Tm9kZS5zZXRBdHRyaWJ1dGUoJ2Rpc2FibGVkJywgJ3RydWUnKTtcbiAgICAgICAgICAgICAgICAgICAga2V5SW5wdXROb2RlLnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcignLmtleU5hbWUnKS5jaGlsZE5vZGVzWzBdLm5vZGVWYWx1ZSA9IGtleU5hbWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlbW92ZUltYWdlOiBmdW5jdGlvbihjYXRlZ29yeU5hbWUpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW1hZ2VCb3ggPSByb290Tm9kZS5xdWVyeVNlbGVjdG9yKCcjJyArIGNvbmYucm93UHJlZml4ICsgY2F0ZWdvcnlOYW1lICsgJyAuaW1hZ2VVcGxvYWQtaW1hZ2VCb3gnKTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoaW1hZ2VCb3guZmlyc3RDaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICBpbWFnZUJveC5yZW1vdmVDaGlsZChpbWFnZUJveC5maXJzdENoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaW1hZ2VCb3guY2xhc3NMaXN0LnJlbW92ZSgnYy1zaG93Jyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgaGlkZUxhbmc6IGZ1bmN0aW9uKGxhbmcpIHtcbiAgICAgICAgICAgICAgICByb290Tm9kZS5jbGFzc0xpc3QuYWRkKCdjLWhpZGVfJyArIGxhbmcpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ3JlYXRlTmV3UHJvamVjdDogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICBvblF1ZXVlcy5jcmVhdGVOZXdQcm9qZWN0LnB1c2goY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uQ2F0ZWdvcnlDbGlja2VkOiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgIG9uUXVldWVzLmNhdGVnb3J5Q2xpY2tlZC5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkFkZE5ld0tleTogZnVuY3Rpb24oY2IpIHtcbiAgICAgICAgICAgICAgICBvblF1ZXVlcy5hZGROZXdLZXkucHVzaChjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgb25SZW5hbWVLZXk6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgb25RdWV1ZXMucmVuYW1lS2V5LnB1c2goY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVtb3ZlS2V5OiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbW92ZUtleS5wdXNoKGNiKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvblJlbW92ZUNhdGVnb3J5OiBmdW5jdGlvbihjYikge1xuICAgICAgICAgICAgICAgIG9uUXVldWVzLnJlbW92ZUNhdGVnb3J5LnB1c2goY2IpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIG9uUmVuYW1lQ2F0ZWdvcnk6IGZ1bmN0aW9uKGNiKSB7XG4gICAgICAgICAgICAgICAgb25RdWV1ZXMucmVuYW1lQ2F0ZWdvcnkucHVzaChjYik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBTZXQgbG9naWMgZm9yIGhhbmRsaW5nIHNhdmluZyBjaGFuZ2VzIHRvIGEga2V5LlxuICAgICAgICAgICAgICogQHBhcmFtIGZ1bmNcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgb25TYXZlS2V5OiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgb25TYXZlS2V5ID0gZnVuYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFNldCBsb2dpYyBmb3IgaGFuZGxpbmcgc2F2aW5nIGNoYW5nZXMgdG8gYSBrZXkuXG4gICAgICAgICAgICAgKiBAcGFyYW0gZnVuY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBvbkNyZWF0ZUtleTogZnVuY3Rpb24oZnVuYykge1xuICAgICAgICAgICAgICAgIG9uQ3JlYXRlS2V5ID0gZnVuYztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBvbkNsb25lS2V5OiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICAgICAgICAgICAgb25DbG9uZUtleSA9IGZ1bmM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVnaXN0ZXJXaGlza2VyOiBmdW5jdGlvbihmYykge1xuICAgICAgICAgICAgICAgIHJlbmRlclRleHRGYyA9IGZjO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIHJldHVybiBmYztcbn0oKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gdHJhbnNsYXRpb25WaWV3O1xuIiwidmFyIG5vZGU7XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBhZGQgOiBmdW5jdGlvbiAoZWxlbSAsYXR0cikge1xuICAgICAgICBub2RlID0gZWxlbTtcbiAgICB9LFxuICAgIGFkZERlc2NyaXB0aW9ucyA6IGZ1bmN0aW9uIChrZXlEZXNjcmlwdGlvbnMpIHtcbiAgICAgICAgT2JqZWN0LmtleXMoa2V5RGVzY3JpcHRpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIHZhciBwYXJlbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChrZXkpLFxuICAgICAgICAgICAgICAgIGNoaWxkO1xuICAgICAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gcGFyZW50LnF1ZXJ5U2VsZWN0b3IoJy5qcy10ZXh0Jyk7XG4gICAgICAgICAgICAgICAgaWYgKGNoaWxkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkLmlubmVySFRNTCA9IGtleURlc2NyaXB0aW9uc1trZXldO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICB9XG59IiwiLyoqXG4gKiBpcyBmb3IgdGhlIHRyYW5zbGF0aW9uIHZpZXcgdG8gYWRkIHRoZSBpbWFnZSB1cGxvYWQgYnV0dG9uIGFuZCBzaG93IHRoZSBpbWFnZXNcbiAqL1xudmFyIHJvb3ROb2RlLFxuICAgIG9uVXBsb2FkQnV0dG9uID0gZnVuY3Rpb24gKCkgeyBjb25zb2xlLndhcm4oJ3RyYW5zbGF0aW9uVmlld0ltYWdlVXBsb2FkOjpvblVwbG9hZEJ1dHRvbigpIG5vdCBpbXBsZW1lbnRlZC4nKTsgfSxcbiAgICBvbkRlbGV0ZUJ1dHRvbiA9IGZ1bmN0aW9uICgpIHsgY29uc29sZS53YXJuKCd0cmFuc2xhdGlvblZpZXdJbWFnZVVwbG9hZDo6b25EZWxldGVCdXR0b24oKSBub3QgaW1wbGVtZW50ZWQuJyk7IH07XG5cbmZ1bmN0aW9uIHVwbG9hZEJ1dHRvbihpZCkge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgbm9kZS5jbGFzc05hbWUgPSAndXBsb2FkLWJ0biBvY3RpY29uIG9jdGljb24tY2xvdWQtdXBsb2FkJztcbiAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBvblVwbG9hZEJ1dHRvbihpZCk7XG4gICAgfSk7XG4gICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3RpdGxlJywgJ3VwbG9hZCBhIGltYWdlIGZpbGUnKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxuZnVuY3Rpb24gZWRpdFBhbmVsKGlkKSB7XG4gICAgdmFyIGRlbGV0ZUJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBlZGl0QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIGNhbmNlbEJ0biA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLFxuICAgICAgICBwYW5lbFdyYXAgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcblxuICAgIHBhbmVsV3JhcC5jbGFzc05hbWUgPSAnaW1hZ2VVcGxvYWQtaW1hZ2VCb3gtZWRpdFBhbmVsJztcbiAgICBlZGl0QnRuLmNsYXNzTmFtZSA9ICdlZGl0LWJ0biBvY3RpY29uIG9jdGljb24tcGVuY2lsJztcbiAgICBlZGl0QnRuLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICBwYW5lbFdyYXAuY2xhc3NMaXN0LmFkZCgnYy1lZGl0Jyk7XG4gICAgfSk7XG4gICAgY2FuY2VsQnRuLmNsYXNzTmFtZSA9ICdjYW5jZWwtYnRuIG9jdGljb24gb2N0aWNvbi14JztcbiAgICBjYW5jZWxCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHBhbmVsV3JhcC5jbGFzc0xpc3QucmVtb3ZlKCdjLWVkaXQnKTtcbiAgICB9KTtcbiAgICBkZWxldGVCdG4uY2xhc3NOYW1lID0gJ2RlbGV0ZS1idG4gb2N0aWNvbiBvY3RpY29uLXRyYXNoY2FuJztcbiAgICBkZWxldGVCdG4uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIG9uRGVsZXRlQnV0dG9uKGlkKTtcbiAgICB9KTtcbiAgICBcbiAgICBkZWxldGVCdG4uc2V0QXR0cmlidXRlKCd0aXRsZScsICdyZW1vdmUgaW1hZ2UnKTtcbiAgICBjYW5jZWxCdG4uc2V0QXR0cmlidXRlKCd0aXRsZScsICdjYW5jZWwnKTtcbiAgICBlZGl0QnRuLnNldEF0dHJpYnV0ZSgndGl0bGUnLCAnZWRpdCcpO1xuXG4gICAgcGFuZWxXcmFwLmFwcGVuZENoaWxkKGVkaXRCdG4pO1xuICAgIHBhbmVsV3JhcC5hcHBlbmRDaGlsZChjYW5jZWxCdG4pO1xuICAgIHBhbmVsV3JhcC5hcHBlbmRDaGlsZChkZWxldGVCdG4pO1xuICAgIHJldHVybiBwYW5lbFdyYXA7XG59XG5cbmZ1bmN0aW9uIGdldEltYWdlKGZpbGUpIHtcbiAgICB2YXIgaW1nID0gbmV3IEltYWdlKCk7XG4gICAgaW1nLnNyYyA9IGZpbGU7XG4gICAgaW1nLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgd2luID0gd2luZG93Lm9wZW4oZmlsZSwgJ19ibGFuaycpO1xuICAgICAgICB3aW4uZm9jdXMoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW1nO1xufVxuXG5mdW5jdGlvbiBhZGRJbWFnZUNvbnRlbnQoaWQsIGltZykge1xuICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JyksXG4gICAgICAgIHJlc2l6ZUFibGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICByZXNpemVBYmxlLmNsYXNzTmFtZSA9ICdpbWFnZVVwbG9hZC1pbWFnZUJveC1yZXNpemVhYmxlJzsgXG4gICAgbm9kZS5jbGFzc05hbWUgPSAnaW1hZ2VVcGxvYWQtaW1hZ2VCb3gtY29udGVudCc7XG4gICAgcmVzaXplQWJsZS5hcHBlbmRDaGlsZChpbWcpO1xuICAgIG5vZGUuYXBwZW5kQ2hpbGQocmVzaXplQWJsZSk7XG4gICAgbm9kZS5hcHBlbmRDaGlsZChlZGl0UGFuZWwoaWQpKTtcbiAgICByZXR1cm4gbm9kZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgb25VcGxvYWRCdXR0b24gOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25VcGxvYWRCdXR0b24gPSBmYztcbiAgICB9LFxuICAgIG9uRGVsZXRlQnV0dG9uOiBmdW5jdGlvbiAoZmMpIHtcbiAgICAgICAgb25EZWxldGVCdXR0b24gPSBmYztcbiAgICB9LFxuICAgIGFkZCA6IGZ1bmN0aW9uIChub2RlLCBhdHRyKSB7XG4gICAgICAgIG5vZGUuYXBwZW5kQ2hpbGQodXBsb2FkQnV0dG9uKGF0dHIpKVxuICAgIH0sXG4gICAgYXBwZW5kSW1hZ2UgOiBmdW5jdGlvbiAocHJvamVjdElkLCBpZCwgdXJsKSB7XG4gICAgICAgIHZhciBkb20gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgndHZfJyArIGlkKSxcbiAgICAgICAgICAgIGltZ0NvbnRhaW5lcjtcbiAgICAgICAgaWYgKGRvbSkge1xuICAgICAgICAgICAgaW1nQ29udGFpbmVyID0gZG9tLnF1ZXJ5U2VsZWN0b3IoJy5qcy1pbWFnZVVwbG9hZC1ib3gnKTtcbiAgICAgICAgICAgIGlmIChpbWdDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGltZ0NvbnRhaW5lci5jaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobikge1xuICAgICAgICAgICAgICAgICAgICBuLnJlbW92ZSgpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGltZ0NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKCdjLXNob3cnKTtcbiAgICAgICAgICAgICAgICBpbWdDb250YWluZXIuYXBwZW5kQ2hpbGQoYWRkSW1hZ2VDb250ZW50KGlkLCBnZXRJbWFnZSgnL2ltYWdlcycgKyB1cmwpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59IiwiLyoqXG4gKiBzaG93cyB0aGUgdXBsb2FkZXIgZm9ybSB0byB1cGxvYWQgYSBpbWFnZSB0byB0aGUgc2VydmVyXG4gKi9cbnZhciBvblVwbG9hZCA9IGZ1bmN0aW9uICgpIHt9LFxuICAgIGJyYWluID0ge1xuICAgICAgICBmaWxlSW5wdXQgOiB7XG4gICAgICAgICAgICBpbml0OiBmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIG5vZGUuYWRkRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgdXBsb2FkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG5cbmZ1bmN0aW9uIHVwbG9hZCgpIHtcbiAgICBjb25zb2xlLmxvZygnYy11cGxvYWQ6dHJpZ2dlciB1cGxvYWQnKTtcbiAgICB2YXIgZmlsZSA9IHRoaXMuZmlsZXNbMF07XG4gICAgaWYgKGZpbGUpIHtcbiAgICAgICAgLy8gc2VuZCBpdCBkaXJlY3QgYWZ0ZXIgZHJvcFxuICAgICAgICBbXS5zbGljZS5jYWxsKHRoaXMuZmlsZXMpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcbiAgICAgICAgICAgIC8vIFRPRE8gaW5zdGVhZCBwYXNzICBkaXJlY3RseSBhIGFycmF5IG9mIGZpbGVzIC0gc28gd2Ugc2F2ZSBQT1NUIGNhbGxzXG4gICAgICAgICAgICBvblVwbG9hZChmaWxlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIGNsZWFudXAgdmFsdWUgb3RoZXJ3aXNlIGZpbGUgd2l0aCBzYW1lIG5hbWUgY2FuJ3QgdXBsb2FkZWQgYWdhaW5cbiAgICAgICAgdGhpcy52YWx1ZSA9IG51bGw7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4vKipcbiAqXG4gKiBAcmV0dXJucyB7e2FkZDogRnVuY3Rpb24sIHJlYWR5OiBGdW5jdGlvbn19XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIG9uVXBsb2FkIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgIG9uVXBsb2FkID0gZmM7XG4gICAgfSxcbiAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICBpZiAoYnJhaW4uaGFzT3duUHJvcGVydHkoYXR0cikpIHtcbiAgICAgICAgICAgIGJyYWluW2F0dHJdLmluaXQobm9kZSk7XG4gICAgICAgIH1cbiAgICB9XG59OyIsIlxudmFyIHVuaWNvZGUgPSAoZnVuY3Rpb24oKXtcblxuICAgIFN0cmluZy5wcm90b3R5cGUuZ2V0RWFjaENoYXIgPSBmdW5jdGlvbihjYil7XG4gICAgICAgIHZhciBuZXdTdHJpbmcgPSB0aGlzO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5ld1N0cmluZy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbmV3U3RyaW5nW2ldID0gY2IobmV3U3RyaW5nW2ldKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3U3RyaW5nLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIHZhciByZWcgPSBuZXcgUmVnRXhwKCdcXFxcXFxcXHUoWzAtOWEtZkEtRl17NH0pJyxcImdcIik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgZW5jb2RlIDogZnVuY3Rpb24oc3RyaW5nKXtcbiAgICAgICAgICAgIGlmKCFzdHJpbmcpe3JldHVybiAnJzt9XG4gICAgICAgICAgICB2YXIgbmV3c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnLFxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIChtYXRjaCwgc3VibWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoc3VibWF0Y2gsIDE2KSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3c3RyaW5nO1xuICAgICAgICB9LFxuICAgICAgICBkZWNvZGUgOiBmdW5jdGlvbihzdHJpbmcpe1xuICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5nZXRFYWNoQ2hhcihmdW5jdGlvbihjKXtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRhYmxlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmKHRhYmxlW2ldID09IGMpe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2ZvdW5kOicrdGFibGVbaV0pXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGFibGVbaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGM7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgfVxufSgpKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bmljb2RlO1xuXG52YXIgdGFibGUgPSBbXG4gICAgJ1xcdTAwQzAnLFxuICAgICdcXHUwMEMxJyxcbiAgICAnXFx1MDBDMicsXG4gICAgJ1xcdTAwQzMnLFxuICAgICdcXHUwMEM0JyxcbiAgICAnXFx1MDBDNScsXG4gICAgJ1xcdTAwQzYnLFxuICAgICdcXHUwMEM3JyxcbiAgICAnXFx1MDBDOCcsXG4gICAgJ1xcdTAwQzknLFxuICAgICdcXHUwMENBJyxcbiAgICAnXFx1MDBDQicsXG4gICAgJ1xcdTAwQ0MnLFxuICAgICdcXHUwMENEJyxcbiAgICAnXFx1MDBDRScsXG4gICAgJ1xcdTAwQ0YnLFxuICAgICdcXHUwMEQwJyxcbiAgICAnXFx1MDBEMScsXG4gICAgJ1xcdTAwRDInLFxuICAgICdcXHUwMEQzJyxcbiAgICAnXFx1MDBENCcsXG4gICAgJ1xcdTAwRDUnLFxuICAgICdcXHUwMEQ2JyxcbiAgICAnXFx1MDBEOCcsXG4gICAgJ1xcdTAwRDknLFxuICAgICdcXHUwMERBJyxcbiAgICAnXFx1MDBEQicsXG4gICAgJ1xcdTAwREMnLFxuICAgICdcXHUwMEREJyxcbiAgICAnXFx1MDBERScsXG4gICAgJ1xcdTAwREYnLFxuICAgICdcXHUwMEUwJyxcbiAgICAnXFx1MDBFMScsXG4gICAgJ1xcdTAwRTInLFxuICAgICdcXHUwMEUzJyxcbiAgICAnXFx1MDBFNCcsXG4gICAgJ1xcdTAwRTUnLFxuICAgICdcXHUwMEU2JyxcbiAgICAnXFx1MDBFNycsXG4gICAgJ1xcdTAwRTgnLFxuICAgICdcXHUwMEU5JyxcbiAgICAnXFx1MDBFQScsXG4gICAgJ1xcdTAwRUInLFxuICAgICdcXHUwMEVDJyxcbiAgICAnXFx1MDBFRCcsXG4gICAgJ1xcdTAwRUUnLFxuICAgICdcXHUwMEVGJyxcbiAgICAnXFx1MDBGMCcsXG4gICAgJ1xcdTAwRjEnLFxuICAgICdcXHUwMEYyJyxcbiAgICAnXFx1MDBGMycsXG4gICAgJ1xcdTAwRjQnLFxuICAgICdcXHUwMEY1JyxcbiAgICAnXFx1MDBGNicsXG4gICAgJ1xcdTAwRjgnLFxuICAgICdcXHUwMEY5JyxcbiAgICAnXFx1MDBGQScsXG4gICAgJ1xcdTAwRkInLFxuICAgICdcXHUwMEZDJyxcbiAgICAnXFx1MDBGRCcsXG4gICAgJ1xcdTAwRkUnLFxuICAgICdcXHUwMEZGJ1xuXTsiLCJmdW5jdGlvbiBnZXRBbmNob3IoKSB7XG4gICAgdmFyIGhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuICAgIGlmICgvIy8udGVzdChocmVmKSkge1xuICAgICAgICByZXR1cm4gJyMnICsgbG9jYXRpb24uaHJlZi5yZXBsYWNlKC8uKiMvLCAnJyk7XG4gICAgfVxuICAgIHJldHVybiAnJztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gICAgZ2V0QW5jaG9yIDogZ2V0QW5jaG9yLFxuICAgIGhhc0FuY2hvciA6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGdldEFuY2hvcigpICE9PSAnJztcbiAgICB9XG59IiwiY29uc3QgcmVnRXhQdW5jID0gbmV3IFJlZ0V4cCgvW1xcLixcXHMhOz86XFxcIl0rL2dpKVxuXG4vKipcbiAqIENvdW50IGFtb3VudCBvZiB3b3JkcyBpbiBhIGdpdmVuIFN0cmluZ1xuICogQHBhcmFtIHN0clxuICogQHJldHVybnMgTnVtYmVyXG4gKi9cbm1vZHVsZS5leHBvcnRzLmNvdW50V29yZHNJblN0cmluZyA9IGZ1bmN0aW9uIGNvdW50V29yZHNJblN0cmluZyhzdHIpIHtcbiAgICBpZiAoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShyZWdFeFB1bmMsICcgJykudHJpbSgpLnNwbGl0KCcgJykubGVuZ3RoO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbn0iLCIndXNlIHN0cmljdCdcblxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuZXhwb3J0cy50b0J5dGVBcnJheSA9IHRvQnl0ZUFycmF5XG5leHBvcnRzLmZyb21CeXRlQXJyYXkgPSBmcm9tQnl0ZUFycmF5XG5cbnZhciBsb29rdXAgPSBbXVxudmFyIHJldkxvb2t1cCA9IFtdXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XG5cbnZhciBjb2RlID0gJ0FCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky8nXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICBsb29rdXBbaV0gPSBjb2RlW2ldXG4gIHJldkxvb2t1cFtjb2RlLmNoYXJDb2RlQXQoaSldID0gaVxufVxuXG5yZXZMb29rdXBbJy0nLmNoYXJDb2RlQXQoMCldID0gNjJcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xuXG5mdW5jdGlvbiBwbGFjZUhvbGRlcnNDb3VudCAoYjY0KSB7XG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXG4gIGlmIChsZW4gJSA0ID4gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBzdHJpbmcuIExlbmd0aCBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgNCcpXG4gIH1cblxuICAvLyB0aGUgbnVtYmVyIG9mIGVxdWFsIHNpZ25zIChwbGFjZSBob2xkZXJzKVxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XG4gIC8vIHJlcHJlc2VudCBvbmUgYnl0ZVxuICAvLyBpZiB0aGVyZSBpcyBvbmx5IG9uZSwgdGhlbiB0aGUgdGhyZWUgY2hhcmFjdGVycyBiZWZvcmUgaXQgcmVwcmVzZW50IDIgYnl0ZXNcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxuICByZXR1cm4gYjY0W2xlbiAtIDJdID09PSAnPScgPyAyIDogYjY0W2xlbiAtIDFdID09PSAnPScgPyAxIDogMFxufVxuXG5mdW5jdGlvbiBieXRlTGVuZ3RoIChiNjQpIHtcbiAgLy8gYmFzZTY0IGlzIDQvMyArIHVwIHRvIHR3byBjaGFyYWN0ZXJzIG9mIHRoZSBvcmlnaW5hbCBkYXRhXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcbn1cblxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xuICB2YXIgaSwgbCwgdG1wLCBwbGFjZUhvbGRlcnMsIGFyclxuICB2YXIgbGVuID0gYjY0Lmxlbmd0aFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXG5cbiAgYXJyID0gbmV3IEFycigobGVuICogMyAvIDQpIC0gcGxhY2VIb2xkZXJzKVxuXG4gIC8vIGlmIHRoZXJlIGFyZSBwbGFjZWhvbGRlcnMsIG9ubHkgZ2V0IHVwIHRvIHRoZSBsYXN0IGNvbXBsZXRlIDQgY2hhcnNcbiAgbCA9IHBsYWNlSG9sZGVycyA+IDAgPyBsZW4gLSA0IDogbGVuXG5cbiAgdmFyIEwgPSAwXG5cbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDE4KSB8IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDEpXSA8PCAxMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPDwgNikgfCByZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSArIDMpXVxuICAgIGFycltMKytdID0gKHRtcCA+PiAxNikgJiAweEZGXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgaWYgKHBsYWNlSG9sZGVycyA9PT0gMikge1xuICAgIHRtcCA9IChyZXZMb29rdXBbYjY0LmNoYXJDb2RlQXQoaSldIDw8IDIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldID4+IDQpXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXG4gIH0gZWxzZSBpZiAocGxhY2VIb2xkZXJzID09PSAxKSB7XG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMTApIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMSldIDw8IDQpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildID4+IDIpXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxuICAgIGFycltMKytdID0gdG1wICYgMHhGRlxuICB9XG5cbiAgcmV0dXJuIGFyclxufVxuXG5mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQgKG51bSkge1xuICByZXR1cm4gbG9va3VwW251bSA+PiAxOCAmIDB4M0ZdICsgbG9va3VwW251bSA+PiAxMiAmIDB4M0ZdICsgbG9va3VwW251bSA+PiA2ICYgMHgzRl0gKyBsb29rdXBbbnVtICYgMHgzRl1cbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2h1bmsgKHVpbnQ4LCBzdGFydCwgZW5kKSB7XG4gIHZhciB0bXBcbiAgdmFyIG91dHB1dCA9IFtdXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSArPSAzKSB7XG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxuICAgIG91dHB1dC5wdXNoKHRyaXBsZXRUb0Jhc2U2NCh0bXApKVxuICB9XG4gIHJldHVybiBvdXRwdXQuam9pbignJylcbn1cblxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcbiAgdmFyIHRtcFxuICB2YXIgbGVuID0gdWludDgubGVuZ3RoXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xuICB2YXIgb3V0cHV0ID0gJydcbiAgdmFyIHBhcnRzID0gW11cbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXG5cbiAgLy8gZ28gdGhyb3VnaCB0aGUgYXJyYXkgZXZlcnkgdGhyZWUgYnl0ZXMsIHdlJ2xsIGRlYWwgd2l0aCB0cmFpbGluZyBzdHVmZiBsYXRlclxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XG4gICAgcGFydHMucHVzaChlbmNvZGVDaHVuayh1aW50OCwgaSwgKGkgKyBtYXhDaHVua0xlbmd0aCkgPiBsZW4yID8gbGVuMiA6IChpICsgbWF4Q2h1bmtMZW5ndGgpKSlcbiAgfVxuXG4gIC8vIHBhZCB0aGUgZW5kIHdpdGggemVyb3MsIGJ1dCBtYWtlIHN1cmUgdG8gbm90IGZvcmdldCB0aGUgZXh0cmEgYnl0ZXNcbiAgaWYgKGV4dHJhQnl0ZXMgPT09IDEpIHtcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxuICAgIG91dHB1dCArPSBsb29rdXBbdG1wID4+IDJdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wIDw8IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gJz09J1xuICB9IGVsc2UgaWYgKGV4dHJhQnl0ZXMgPT09IDIpIHtcbiAgICB0bXAgPSAodWludDhbbGVuIC0gMl0gPDwgOCkgKyAodWludDhbbGVuIC0gMV0pXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXG4gICAgb3V0cHV0ICs9IGxvb2t1cFsodG1wID4+IDQpICYgMHgzRl1cbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgMikgJiAweDNGXVxuICAgIG91dHB1dCArPSAnPSdcbiAgfVxuXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxuXG4gIHJldHVybiBwYXJ0cy5qb2luKCcnKVxufVxuIiwiIiwiLyohXG4gKiBUaGUgYnVmZmVyIG1vZHVsZSBmcm9tIG5vZGUuanMsIGZvciB0aGUgYnJvd3Nlci5cbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuXG4ndXNlIHN0cmljdCdcblxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXG52YXIgaWVlZTc1NCA9IHJlcXVpcmUoJ2llZWU3NTQnKVxuXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxuZXhwb3J0cy5TbG93QnVmZmVyID0gU2xvd0J1ZmZlclxuZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFUyA9IDUwXG5cbnZhciBLX01BWF9MRU5HVEggPSAweDdmZmZmZmZmXG5leHBvcnRzLmtNYXhMZW5ndGggPSBLX01BWF9MRU5HVEhcblxuLyoqXG4gKiBJZiBgQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlRgOlxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcbiAqICAgPT09IGZhbHNlICAgUHJpbnQgd2FybmluZyBhbmQgcmVjb21tZW5kIHVzaW5nIGBidWZmZXJgIHY0Lnggd2hpY2ggaGFzIGFuIE9iamVjdFxuICogICAgICAgICAgICAgICBpbXBsZW1lbnRhdGlvbiAobW9zdCBjb21wYXRpYmxlLCBldmVuIElFNilcbiAqXG4gKiBCcm93c2VycyB0aGF0IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGFyZSBJRSAxMCssIEZpcmVmb3ggNCssIENocm9tZSA3KywgU2FmYXJpIDUuMSssXG4gKiBPcGVyYSAxMS42KywgaU9TIDQuMisuXG4gKlxuICogV2UgcmVwb3J0IHRoYXQgdGhlIGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0eXBlZCBhcnJheXMgaWYgdGhlIGFyZSBub3Qgc3ViY2xhc3NhYmxlXG4gKiB1c2luZyBfX3Byb3RvX18uIEZpcmVmb3ggNC0yOSBsYWNrcyBzdXBwb3J0IGZvciBhZGRpbmcgbmV3IHByb3BlcnRpZXMgdG8gYFVpbnQ4QXJyYXlgXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XG4gKiBmb3IgX19wcm90b19fIGFuZCBoYXMgYSBidWdneSB0eXBlZCBhcnJheSBpbXBsZW1lbnRhdGlvbi5cbiAqL1xuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXG5cbmlmICghQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgY29uc29sZS5lcnJvcihcbiAgICAnVGhpcyBicm93c2VyIGxhY2tzIHR5cGVkIGFycmF5IChVaW50OEFycmF5KSBzdXBwb3J0IHdoaWNoIGlzIHJlcXVpcmVkIGJ5ICcgK1xuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcbiAgKVxufVxuXG5mdW5jdGlvbiB0eXBlZEFycmF5U3VwcG9ydCAoKSB7XG4gIC8vIENhbiB0eXBlZCBhcnJheSBpbnN0YW5jZXMgY2FuIGJlIGF1Z21lbnRlZD9cbiAgdHJ5IHtcbiAgICB2YXIgYXJyID0gbmV3IFVpbnQ4QXJyYXkoMSlcbiAgICBhcnIuX19wcm90b19fID0ge19fcHJvdG9fXzogVWludDhBcnJheS5wcm90b3R5cGUsIGZvbzogZnVuY3Rpb24gKCkgeyByZXR1cm4gNDIgfX1cbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKGxlbmd0aCA+IEtfTUFYX0xFTkdUSCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbnZhbGlkIHR5cGVkIGFycmF5IGxlbmd0aCcpXG4gIH1cbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgdmFyIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGxlbmd0aClcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIGJ1ZlxufVxuXG4vKipcbiAqIFRoZSBCdWZmZXIgY29uc3RydWN0b3IgcmV0dXJucyBpbnN0YW5jZXMgb2YgYFVpbnQ4QXJyYXlgIHRoYXQgaGF2ZSB0aGVpclxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxuICogYFVpbnQ4QXJyYXlgLCBzbyB0aGUgcmV0dXJuZWQgaW5zdGFuY2VzIHdpbGwgaGF2ZSBhbGwgdGhlIG5vZGUgYEJ1ZmZlcmAgbWV0aG9kc1xuICogYW5kIHRoZSBgVWludDhBcnJheWAgbWV0aG9kcy4gU3F1YXJlIGJyYWNrZXQgbm90YXRpb24gd29ya3MgYXMgZXhwZWN0ZWQgLS0gaXRcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXG4gKlxuICogVGhlIGBVaW50OEFycmF5YCBwcm90b3R5cGUgcmVtYWlucyB1bm1vZGlmaWVkLlxuICovXG5cbmZ1bmN0aW9uIEJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgLy8gQ29tbW9uIGNhc2UuXG4gIGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJykge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmdPck9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ0lmIGVuY29kaW5nIGlzIHNwZWNpZmllZCB0aGVuIHRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgc3RyaW5nJ1xuICAgICAgKVxuICAgIH1cbiAgICByZXR1cm4gYWxsb2NVbnNhZmUoYXJnKVxuICB9XG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xuaWYgKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC5zcGVjaWVzICYmXG4gICAgQnVmZmVyW1N5bWJvbC5zcGVjaWVzXSA9PT0gQnVmZmVyKSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XG4gICAgdmFsdWU6IG51bGwsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICB9KVxufVxuXG5CdWZmZXIucG9vbFNpemUgPSA4MTkyIC8vIG5vdCB1c2VkIGJ5IHRoaXMgaW1wbGVtZW50YXRpb25cblxuZnVuY3Rpb24gZnJvbSAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1widmFsdWVcIiBhcmd1bWVudCBtdXN0IG5vdCBiZSBhIG51bWJlcicpXG4gIH1cblxuICBpZiAoaXNBcnJheUJ1ZmZlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gZnJvbUFycmF5QnVmZmVyKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxuICB9XG5cbiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpXG59XG5cbi8qKlxuICogRnVuY3Rpb25hbGx5IGVxdWl2YWxlbnQgdG8gQnVmZmVyKGFyZywgZW5jb2RpbmcpIGJ1dCB0aHJvd3MgYSBUeXBlRXJyb3JcbiAqIGlmIHZhbHVlIGlzIGEgbnVtYmVyLlxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxuICogQnVmZmVyLmZyb20oYXJyYXkpXG4gKiBCdWZmZXIuZnJvbShidWZmZXIpXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcbiAqKi9cbkJ1ZmZlci5mcm9tID0gZnVuY3Rpb24gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcbn1cblxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC8xNDhcbkJ1ZmZlci5wcm90b3R5cGUuX19wcm90b19fID0gVWludDhBcnJheS5wcm90b3R5cGVcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XG5cbmZ1bmN0aW9uIGFzc2VydFNpemUgKHNpemUpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wic2l6ZVwiIGFyZ3VtZW50IG11c3Qgbm90IGJlIG5lZ2F0aXZlJylcbiAgfVxufVxuXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgYXNzZXJ0U2l6ZShzaXplKVxuICBpZiAoc2l6ZSA8PSAwKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxuICB9XG4gIGlmIChmaWxsICE9PSB1bmRlZmluZWQpIHtcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xuICAgIC8vIHByZXZlbnRzIGFjY2lkZW50YWxseSBzZW5kaW5nIGluIGEgbnVtYmVyIHRoYXQgd291bGRcbiAgICAvLyBiZSBpbnRlcnByZXR0ZWQgYXMgYSBzdGFydCBvZmZzZXQuXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcbiAgICAgID8gY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbCwgZW5jb2RpbmcpXG4gICAgICA6IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwpXG4gIH1cbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxufVxuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcbiAqKi9cbkJ1ZmZlci5hbGxvYyA9IGZ1bmN0aW9uIChzaXplLCBmaWxsLCBlbmNvZGluZykge1xuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXG59XG5cbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XG4gIGFzc2VydFNpemUoc2l6ZSlcbiAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplIDwgMCA/IDAgOiBjaGVja2VkKHNpemUpIHwgMClcbn1cblxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxuICogKi9cbkJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuLyoqXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cbiAqL1xuQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxufVxuXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnIHx8IGVuY29kaW5nID09PSAnJykge1xuICAgIGVuY29kaW5nID0gJ3V0ZjgnXG4gIH1cblxuICBpZiAoIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZW5jb2RpbmdcIiBtdXN0IGJlIGEgdmFsaWQgc3RyaW5nIGVuY29kaW5nJylcbiAgfVxuXG4gIHZhciBsZW5ndGggPSBieXRlTGVuZ3RoKHN0cmluZywgZW5jb2RpbmcpIHwgMFxuICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbmd0aClcblxuICB2YXIgYWN0dWFsID0gYnVmLndyaXRlKHN0cmluZywgZW5jb2RpbmcpXG5cbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XG4gICAgLy8gV3JpdGluZyBhIGhleCBzdHJpbmcsIGZvciBleGFtcGxlLCB0aGF0IGNvbnRhaW5zIGludmFsaWQgY2hhcmFjdGVycyB3aWxsXG4gICAgLy8gY2F1c2UgZXZlcnl0aGluZyBhZnRlciB0aGUgZmlyc3QgaW52YWxpZCBjaGFyYWN0ZXIgdG8gYmUgaWdub3JlZC4gKGUuZy5cbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcbiAgICBidWYgPSBidWYuc2xpY2UoMCwgYWN0dWFsKVxuICB9XG5cbiAgcmV0dXJuIGJ1ZlxufVxuXG5mdW5jdGlvbiBmcm9tQXJyYXlMaWtlIChhcnJheSkge1xuICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoIDwgMCA/IDAgOiBjaGVja2VkKGFycmF5Lmxlbmd0aCkgfCAwXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSArPSAxKSB7XG4gICAgYnVmW2ldID0gYXJyYXlbaV0gJiAyNTVcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21BcnJheUJ1ZmZlciAoYXJyYXksIGJ5dGVPZmZzZXQsIGxlbmd0aCkge1xuICBpZiAoYnl0ZU9mZnNldCA8IDAgfHwgYXJyYXkuYnl0ZUxlbmd0aCA8IGJ5dGVPZmZzZXQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFwnb2Zmc2V0XFwnIGlzIG91dCBvZiBib3VuZHMnKVxuICB9XG5cbiAgaWYgKGFycmF5LmJ5dGVMZW5ndGggPCBieXRlT2Zmc2V0ICsgKGxlbmd0aCB8fCAwKSkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXCdsZW5ndGhcXCcgaXMgb3V0IG9mIGJvdW5kcycpXG4gIH1cblxuICB2YXIgYnVmXG4gIGlmIChieXRlT2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgbGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSlcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0KVxuICB9IGVsc2Uge1xuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXG4gIH1cblxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxuICBidWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxuICByZXR1cm4gYnVmXG59XG5cbmZ1bmN0aW9uIGZyb21PYmplY3QgKG9iaikge1xuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcbiAgICB2YXIgbGVuID0gY2hlY2tlZChvYmoubGVuZ3RoKSB8IDBcbiAgICB2YXIgYnVmID0gY3JlYXRlQnVmZmVyKGxlbilcblxuICAgIGlmIChidWYubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gYnVmXG4gICAgfVxuXG4gICAgb2JqLmNvcHkoYnVmLCAwLCAwLCBsZW4pXG4gICAgcmV0dXJuIGJ1ZlxuICB9XG5cbiAgaWYgKG9iaikge1xuICAgIGlmIChpc0FycmF5QnVmZmVyVmlldyhvYmopIHx8ICdsZW5ndGgnIGluIG9iaikge1xuICAgICAgaWYgKHR5cGVvZiBvYmoubGVuZ3RoICE9PSAnbnVtYmVyJyB8fCBudW1iZXJJc05hTihvYmoubGVuZ3RoKSkge1xuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXG4gICAgICB9XG4gICAgICByZXR1cm4gZnJvbUFycmF5TGlrZShvYmopXG4gICAgfVxuXG4gICAgaWYgKG9iai50eXBlID09PSAnQnVmZmVyJyAmJiBBcnJheS5pc0FycmF5KG9iai5kYXRhKSkge1xuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcignRmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIG9yIGFycmF5LWxpa2Ugb2JqZWN0LicpXG59XG5cbmZ1bmN0aW9uIGNoZWNrZWQgKGxlbmd0aCkge1xuICAvLyBOb3RlOiBjYW5ub3QgdXNlIGBsZW5ndGggPCBLX01BWF9MRU5HVEhgIGhlcmUgYmVjYXVzZSB0aGF0IGZhaWxzIHdoZW5cbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXG4gIGlmIChsZW5ndGggPj0gS19NQVhfTEVOR1RIKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcbiAgfVxuICByZXR1cm4gbGVuZ3RoIHwgMFxufVxuXG5mdW5jdGlvbiBTbG93QnVmZmVyIChsZW5ndGgpIHtcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXG4gICAgbGVuZ3RoID0gMFxuICB9XG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcbn1cblxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcbiAgcmV0dXJuIGIgIT0gbnVsbCAmJiBiLl9pc0J1ZmZlciA9PT0gdHJ1ZVxufVxuXG5CdWZmZXIuY29tcGFyZSA9IGZ1bmN0aW9uIGNvbXBhcmUgKGEsIGIpIHtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYSkgfHwgIUJ1ZmZlci5pc0J1ZmZlcihiKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxuICB9XG5cbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXG5cbiAgdmFyIHggPSBhLmxlbmd0aFxuICB2YXIgeSA9IGIubGVuZ3RoXG5cbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IE1hdGgubWluKHgsIHkpOyBpIDwgbGVuOyArK2kpIHtcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xuICAgICAgeCA9IGFbaV1cbiAgICAgIHkgPSBiW2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xuICBzd2l0Y2ggKFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6XG4gICAgY2FzZSAndXRmOCc6XG4gICAgY2FzZSAndXRmLTgnOlxuICAgIGNhc2UgJ2FzY2lpJzpcbiAgICBjYXNlICdsYXRpbjEnOlxuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgY2FzZSAnYmFzZTY0JzpcbiAgICBjYXNlICd1Y3MyJzpcbiAgICBjYXNlICd1Y3MtMic6XG4gICAgY2FzZSAndXRmMTZsZSc6XG4gICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgcmV0dXJuIHRydWVcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuQnVmZmVyLmNvbmNhdCA9IGZ1bmN0aW9uIGNvbmNhdCAobGlzdCwgbGVuZ3RoKSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShsaXN0KSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wibGlzdFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXG4gIH1cblxuICBpZiAobGlzdC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gQnVmZmVyLmFsbG9jKDApXG4gIH1cblxuICB2YXIgaVxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcbiAgICBsZW5ndGggPSAwXG4gICAgZm9yIChpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxuICAgIH1cbiAgfVxuXG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobGVuZ3RoKVxuICB2YXIgcG9zID0gMFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBidWYgPSBsaXN0W2ldXG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoYnVmKSkge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0XCIgYXJndW1lbnQgbXVzdCBiZSBhbiBBcnJheSBvZiBCdWZmZXJzJylcbiAgICB9XG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXG4gICAgcG9zICs9IGJ1Zi5sZW5ndGhcbiAgfVxuICByZXR1cm4gYnVmZmVyXG59XG5cbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcihzdHJpbmcpKSB7XG4gICAgcmV0dXJuIHN0cmluZy5sZW5ndGhcbiAgfVxuICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcoc3RyaW5nKSB8fCBpc0FycmF5QnVmZmVyKHN0cmluZykpIHtcbiAgICByZXR1cm4gc3RyaW5nLmJ5dGVMZW5ndGhcbiAgfVxuICBpZiAodHlwZW9mIHN0cmluZyAhPT0gJ3N0cmluZycpIHtcbiAgICBzdHJpbmcgPSAnJyArIHN0cmluZ1xuICB9XG5cbiAgdmFyIGxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcblxuICAvLyBVc2UgYSBmb3IgbG9vcCB0byBhdm9pZCByZWN1cnNpb25cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2FzY2lpJzpcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGVuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiBsZW4gKiAyXG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gbGVuID4+PiAxXG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgICByZXR1cm4gYmFzZTY0VG9CeXRlcyhzdHJpbmcpLmxlbmd0aFxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxuICAgICAgICBsb3dlcmVkQ2FzZSA9IHRydWVcbiAgICB9XG4gIH1cbn1cbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxuXG5mdW5jdGlvbiBzbG93VG9TdHJpbmcgKGVuY29kaW5nLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXG5cbiAgLy8gTm8gbmVlZCB0byB2ZXJpZnkgdGhhdCBcInRoaXMubGVuZ3RoIDw9IE1BWF9VSU5UMzJcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XG4gIC8vIHByb3BlcnR5IG9mIGEgdHlwZWQgYXJyYXkuXG5cbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXG4gIC8vIHRvIHRoZWlyIHVwcGVyL2xvd2VyIGJvdW5kcyBpZiB0aGUgdmFsdWUgcGFzc2VkIGlzIG91dCBvZiByYW5nZS5cbiAgLy8gdW5kZWZpbmVkIGlzIGhhbmRsZWQgc3BlY2lhbGx5IGFzIHBlciBFQ01BLTI2MiA2dGggRWRpdGlvbixcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkIHx8IHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIC8vIFJldHVybiBlYXJseSBpZiBzdGFydCA+IHRoaXMubGVuZ3RoLiBEb25lIGhlcmUgdG8gcHJldmVudCBwb3RlbnRpYWwgdWludDMyXG4gIC8vIGNvZXJjaW9uIGZhaWwgYmVsb3cuXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICBpZiAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gdGhpcy5sZW5ndGgpIHtcbiAgICBlbmQgPSB0aGlzLmxlbmd0aFxuICB9XG5cbiAgaWYgKGVuZCA8PSAwKSB7XG4gICAgcmV0dXJuICcnXG4gIH1cblxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxuICBlbmQgPj4+PSAwXG4gIHN0YXJ0ID4+Pj0gMFxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gJydcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgd2hpbGUgKHRydWUpIHtcbiAgICBzd2l0Y2ggKGVuY29kaW5nKSB7XG4gICAgICBjYXNlICdoZXgnOlxuICAgICAgICByZXR1cm4gaGV4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAndXRmOCc6XG4gICAgICBjYXNlICd1dGYtOCc6XG4gICAgICAgIHJldHVybiB1dGY4U2xpY2UodGhpcywgc3RhcnQsIGVuZClcblxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgICByZXR1cm4gYXNjaWlTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICdsYXRpbjEnOlxuICAgICAgY2FzZSAnYmluYXJ5JzpcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxuXG4gICAgICBjYXNlICd1Y3MyJzpcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxuICAgICAgY2FzZSAndXRmLTE2bGUnOlxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXG5cbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxuICAgICAgICBlbmNvZGluZyA9IChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxuICAgIH1cbiAgfVxufVxuXG4vLyBUaGlzIHByb3BlcnR5IGlzIHVzZWQgYnkgYEJ1ZmZlci5pc0J1ZmZlcmAgKGFuZCB0aGUgYGlzLWJ1ZmZlcmAgbnBtIHBhY2thZ2UpXG4vLyB0byBkZXRlY3QgYSBCdWZmZXIgaW5zdGFuY2UuIEl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBgaW5zdGFuY2VvZiBCdWZmZXJgXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxuLy8gY29waWVzIG9mIHRoZSAnYnVmZmVyJyBwYWNrYWdlIGluIHVzZS4gVGhpcyBtZXRob2Qgd29ya3MgZXZlbiBmb3IgQnVmZmVyXG4vLyBpbnN0YW5jZXMgdGhhdCB3ZXJlIGNyZWF0ZWQgZnJvbSBhbm90aGVyIGNvcHkgb2YgdGhlIGBidWZmZXJgIHBhY2thZ2UuXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcbkJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyID0gdHJ1ZVxuXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XG4gIHZhciBpID0gYltuXVxuICBiW25dID0gYlttXVxuICBiW21dID0gaVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxuICBpZiAobGVuICUgMiAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gMikge1xuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXG4gIH1cbiAgcmV0dXJuIHRoaXNcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5zd2FwMzIgPSBmdW5jdGlvbiBzd2FwMzIgKCkge1xuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbiAlIDQgIT09IDApIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHMnKVxuICB9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpICs9IDQpIHtcbiAgICBzd2FwKHRoaXMsIGksIGkgKyAzKVxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxuICB9XG4gIHJldHVybiB0aGlzXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuc3dhcDY0ID0gZnVuY3Rpb24gc3dhcDY0ICgpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIGlmIChsZW4gJSA4ICE9PSAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0J1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzJylcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA4KSB7XG4gICAgc3dhcCh0aGlzLCBpLCBpICsgNylcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcbiAgICBzd2FwKHRoaXMsIGkgKyAyLCBpICsgNSlcbiAgICBzd2FwKHRoaXMsIGkgKyAzLCBpICsgNClcbiAgfVxuICByZXR1cm4gdGhpc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKCkge1xuICB2YXIgbGVuZ3RoID0gdGhpcy5sZW5ndGhcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gdXRmOFNsaWNlKHRoaXMsIDAsIGxlbmd0aClcbiAgcmV0dXJuIHNsb3dUb1N0cmluZy5hcHBseSh0aGlzLCBhcmd1bWVudHMpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuZXF1YWxzID0gZnVuY3Rpb24gZXF1YWxzIChiKSB7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcbiAgaWYgKHRoaXMgPT09IGIpIHJldHVybiB0cnVlXG4gIHJldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLCBiKSA9PT0gMFxufVxuXG5CdWZmZXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0ICgpIHtcbiAgdmFyIHN0ciA9ICcnXG4gIHZhciBtYXggPSBleHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTXG4gIGlmICh0aGlzLmxlbmd0aCA+IDApIHtcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG1heCkgc3RyICs9ICcgLi4uICdcbiAgfVxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xufVxuXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih0YXJnZXQpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlcicpXG4gIH1cblxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCkge1xuICAgIHN0YXJ0ID0gMFxuICB9XG4gIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhpc1N0YXJ0ID0gMFxuICB9XG4gIGlmICh0aGlzRW5kID09PSB1bmRlZmluZWQpIHtcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcbiAgfVxuXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdvdXQgb2YgcmFuZ2UgaW5kZXgnKVxuICB9XG5cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kICYmIHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAwXG4gIH1cbiAgaWYgKHRoaXNTdGFydCA+PSB0aGlzRW5kKSB7XG4gICAgcmV0dXJuIC0xXG4gIH1cbiAgaWYgKHN0YXJ0ID49IGVuZCkge1xuICAgIHJldHVybiAxXG4gIH1cblxuICBzdGFydCA+Pj49IDBcbiAgZW5kID4+Pj0gMFxuICB0aGlzU3RhcnQgPj4+PSAwXG4gIHRoaXNFbmQgPj4+PSAwXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCkgcmV0dXJuIDBcblxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcbiAgdmFyIHkgPSBlbmQgLSBzdGFydFxuICB2YXIgbGVuID0gTWF0aC5taW4oeCwgeSlcblxuICB2YXIgdGhpc0NvcHkgPSB0aGlzLnNsaWNlKHRoaXNTdGFydCwgdGhpc0VuZClcbiAgdmFyIHRhcmdldENvcHkgPSB0YXJnZXQuc2xpY2Uoc3RhcnQsIGVuZClcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgaWYgKHRoaXNDb3B5W2ldICE9PSB0YXJnZXRDb3B5W2ldKSB7XG4gICAgICB4ID0gdGhpc0NvcHlbaV1cbiAgICAgIHkgPSB0YXJnZXRDb3B5W2ldXG4gICAgICBicmVha1xuICAgIH1cbiAgfVxuXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXG4gIGlmICh5IDwgeCkgcmV0dXJuIDFcbiAgcmV0dXJuIDBcbn1cblxuLy8gRmluZHMgZWl0aGVyIHRoZSBmaXJzdCBpbmRleCBvZiBgdmFsYCBpbiBgYnVmZmVyYCBhdCBvZmZzZXQgPj0gYGJ5dGVPZmZzZXRgLFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cbi8vXG4vLyBBcmd1bWVudHM6XG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxuLy8gLSB2YWwgLSBhIHN0cmluZywgQnVmZmVyLCBvciBudW1iZXJcbi8vIC0gYnl0ZU9mZnNldCAtIGFuIGluZGV4IGludG8gYGJ1ZmZlcmA7IHdpbGwgYmUgY2xhbXBlZCB0byBhbiBpbnQzMlxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcbi8vIC0gZGlyIC0gdHJ1ZSBmb3IgaW5kZXhPZiwgZmFsc2UgZm9yIGxhc3RJbmRleE9mXG5mdW5jdGlvbiBiaWRpcmVjdGlvbmFsSW5kZXhPZiAoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpIHtcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSByZXR1cm4gLTFcblxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxuICBpZiAodHlwZW9mIGJ5dGVPZmZzZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jb2RpbmcgPSBieXRlT2Zmc2V0XG4gICAgYnl0ZU9mZnNldCA9IDBcbiAgfSBlbHNlIGlmIChieXRlT2Zmc2V0ID4gMHg3ZmZmZmZmZikge1xuICAgIGJ5dGVPZmZzZXQgPSAweDdmZmZmZmZmXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XG4gICAgYnl0ZU9mZnNldCA9IC0weDgwMDAwMDAwXG4gIH1cbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxuICBpZiAobnVtYmVySXNOYU4oYnl0ZU9mZnNldCkpIHtcbiAgICAvLyBieXRlT2Zmc2V0OiBpdCBpdCdzIHVuZGVmaW5lZCwgbnVsbCwgTmFOLCBcImZvb1wiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcbiAgICBieXRlT2Zmc2V0ID0gZGlyID8gMCA6IChidWZmZXIubGVuZ3RoIC0gMSlcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBieXRlT2Zmc2V0OiBuZWdhdGl2ZSBvZmZzZXRzIHN0YXJ0IGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG4gIGlmIChieXRlT2Zmc2V0IDwgMCkgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggKyBieXRlT2Zmc2V0XG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICBpZiAoZGlyKSByZXR1cm4gLTFcbiAgICBlbHNlIGJ5dGVPZmZzZXQgPSBidWZmZXIubGVuZ3RoIC0gMVxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XG4gICAgaWYgKGRpcikgYnl0ZU9mZnNldCA9IDBcbiAgICBlbHNlIHJldHVybiAtMVxuICB9XG5cbiAgLy8gTm9ybWFsaXplIHZhbFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICB2YWwgPSBCdWZmZXIuZnJvbSh2YWwsIGVuY29kaW5nKVxuICB9XG5cbiAgLy8gRmluYWxseSwgc2VhcmNoIGVpdGhlciBpbmRleE9mIChpZiBkaXIgaXMgdHJ1ZSkgb3IgbGFzdEluZGV4T2ZcbiAgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB7XG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xuICAgIGlmICh2YWwubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gLTFcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcilcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxuICAgIGlmICh0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgaWYgKGRpcikge1xuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmxhc3RJbmRleE9mLmNhbGwoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQpXG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCBbIHZhbCBdLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKVxuICB9XG5cbiAgdGhyb3cgbmV3IFR5cGVFcnJvcigndmFsIG11c3QgYmUgc3RyaW5nLCBudW1iZXIgb3IgQnVmZmVyJylcbn1cblxuZnVuY3Rpb24gYXJyYXlJbmRleE9mIChhcnIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xuICB2YXIgaW5kZXhTaXplID0gMVxuICB2YXIgYXJyTGVuZ3RoID0gYXJyLmxlbmd0aFxuICB2YXIgdmFsTGVuZ3RoID0gdmFsLmxlbmd0aFxuXG4gIGlmIChlbmNvZGluZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSBTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxuICAgICAgICBlbmNvZGluZyA9PT0gJ3V0ZjE2bGUnIHx8IGVuY29kaW5nID09PSAndXRmLTE2bGUnKSB7XG4gICAgICBpZiAoYXJyLmxlbmd0aCA8IDIgfHwgdmFsLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIC0xXG4gICAgICB9XG4gICAgICBpbmRleFNpemUgPSAyXG4gICAgICBhcnJMZW5ndGggLz0gMlxuICAgICAgdmFsTGVuZ3RoIC89IDJcbiAgICAgIGJ5dGVPZmZzZXQgLz0gMlxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xuICAgIGlmIChpbmRleFNpemUgPT09IDEpIHtcbiAgICAgIHJldHVybiBidWZbaV1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGJ1Zi5yZWFkVUludDE2QkUoaSAqIGluZGV4U2l6ZSlcbiAgICB9XG4gIH1cblxuICB2YXIgaVxuICBpZiAoZGlyKSB7XG4gICAgdmFyIGZvdW5kSW5kZXggPSAtMVxuICAgIGZvciAoaSA9IGJ5dGVPZmZzZXQ7IGkgPCBhcnJMZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xuICAgICAgICBpZiAoZm91bmRJbmRleCA9PT0gLTEpIGZvdW5kSW5kZXggPSBpXG4gICAgICAgIGlmIChpIC0gZm91bmRJbmRleCArIDEgPT09IHZhbExlbmd0aCkgcmV0dXJuIGZvdW5kSW5kZXggKiBpbmRleFNpemVcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChmb3VuZEluZGV4ICE9PSAtMSkgaSAtPSBpIC0gZm91bmRJbmRleFxuICAgICAgICBmb3VuZEluZGV4ID0gLTFcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcbiAgICBmb3IgKGkgPSBieXRlT2Zmc2V0OyBpID49IDA7IGktLSkge1xuICAgICAgdmFyIGZvdW5kID0gdHJ1ZVxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xuICAgICAgICBpZiAocmVhZChhcnIsIGkgKyBqKSAhPT0gcmVhZCh2YWwsIGopKSB7XG4gICAgICAgICAgZm91bmQgPSBmYWxzZVxuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcbiAgICB9XG4gIH1cblxuICByZXR1cm4gLTFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcyA9IGZ1bmN0aW9uIGluY2x1ZGVzICh2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSB7XG4gIHJldHVybiB0aGlzLmluZGV4T2YodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykgIT09IC0xXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUuaW5kZXhPZiA9IGZ1bmN0aW9uIGluZGV4T2YgKHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcpIHtcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xuICByZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcywgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZmFsc2UpXG59XG5cbmZ1bmN0aW9uIGhleFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgb2Zmc2V0ID0gTnVtYmVyKG9mZnNldCkgfHwgMFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxuICBpZiAoIWxlbmd0aCkge1xuICAgIGxlbmd0aCA9IHJlbWFpbmluZ1xuICB9IGVsc2Uge1xuICAgIGxlbmd0aCA9IE51bWJlcihsZW5ndGgpXG4gICAgaWYgKGxlbmd0aCA+IHJlbWFpbmluZykge1xuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXG4gICAgfVxuICB9XG5cbiAgLy8gbXVzdCBiZSBhbiBldmVuIG51bWJlciBvZiBkaWdpdHNcbiAgdmFyIHN0ckxlbiA9IHN0cmluZy5sZW5ndGhcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXG5cbiAgaWYgKGxlbmd0aCA+IHN0ckxlbiAvIDIpIHtcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXG4gIH1cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXG4gICAgaWYgKG51bWJlcklzTmFOKHBhcnNlZCkpIHJldHVybiBpXG4gICAgYnVmW29mZnNldCArIGldID0gcGFyc2VkXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuZnVuY3Rpb24gdXRmOFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgcmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMoc3RyaW5nLCBidWYubGVuZ3RoIC0gb2Zmc2V0KSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYXNjaWlXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxufVxuXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBhc2NpaVdyaXRlKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcbn1cblxuZnVuY3Rpb24gYmFzZTY0V3JpdGUgKGJ1Ziwgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gYmxpdEJ1ZmZlcihiYXNlNjRUb0J5dGVzKHN0cmluZyksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbmZ1bmN0aW9uIHVjczJXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZylcbiAgaWYgKG9mZnNldCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZW5jb2RpbmcgPSAndXRmOCdcbiAgICBsZW5ndGggPSB0aGlzLmxlbmd0aFxuICAgIG9mZnNldCA9IDBcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXG4gIH0gZWxzZSBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9mZnNldCA9PT0gJ3N0cmluZycpIHtcbiAgICBlbmNvZGluZyA9IG9mZnNldFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXG4gICAgb2Zmc2V0ID0gMFxuICAvLyBCdWZmZXIjd3JpdGUoc3RyaW5nLCBvZmZzZXRbLCBsZW5ndGhdWywgZW5jb2RpbmddKVxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcbiAgICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgICBpZiAoaXNGaW5pdGUobGVuZ3RoKSkge1xuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXG4gICAgICBpZiAoZW5jb2RpbmcgPT09IHVuZGVmaW5lZCkgZW5jb2RpbmcgPSAndXRmOCdcbiAgICB9IGVsc2Uge1xuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcbiAgICAgIGxlbmd0aCA9IHVuZGVmaW5lZFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAnQnVmZmVyLndyaXRlKHN0cmluZywgZW5jb2RpbmcsIG9mZnNldFssIGxlbmd0aF0pIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQnXG4gICAgKVxuICB9XG5cbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XG4gIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCB8fCBsZW5ndGggPiByZW1haW5pbmcpIGxlbmd0aCA9IHJlbWFpbmluZ1xuXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0F0dGVtcHQgdG8gd3JpdGUgb3V0c2lkZSBidWZmZXIgYm91bmRzJylcbiAgfVxuXG4gIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gJ3V0ZjgnXG5cbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcbiAgZm9yICg7Oykge1xuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcbiAgICAgIGNhc2UgJ2hleCc6XG4gICAgICAgIHJldHVybiBoZXhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICd1dGY4JzpcbiAgICAgIGNhc2UgJ3V0Zi04JzpcbiAgICAgICAgcmV0dXJuIHV0ZjhXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxuXG4gICAgICBjYXNlICdhc2NpaSc6XG4gICAgICAgIHJldHVybiBhc2NpaVdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgY2FzZSAnYmFzZTY0JzpcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcbiAgICAgICAgcmV0dXJuIGJhc2U2NFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXG5cbiAgICAgIGNhc2UgJ3VjczInOlxuICAgICAgY2FzZSAndWNzLTInOlxuICAgICAgY2FzZSAndXRmMTZsZSc6XG4gICAgICBjYXNlICd1dGYtMTZsZSc6XG4gICAgICAgIHJldHVybiB1Y3MyV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcblxuICAgICAgZGVmYXVsdDpcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXG4gICAgfVxuICB9XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gdG9KU09OICgpIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAnQnVmZmVyJyxcbiAgICBkYXRhOiBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLl9hcnIgfHwgdGhpcywgMClcbiAgfVxufVxuXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIGlmIChzdGFydCA9PT0gMCAmJiBlbmQgPT09IGJ1Zi5sZW5ndGgpIHtcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYuc2xpY2Uoc3RhcnQsIGVuZCkpXG4gIH1cbn1cblxuZnVuY3Rpb24gdXRmOFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxuICB2YXIgcmVzID0gW11cblxuICB2YXIgaSA9IHN0YXJ0XG4gIHdoaWxlIChpIDwgZW5kKSB7XG4gICAgdmFyIGZpcnN0Qnl0ZSA9IGJ1ZltpXVxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXG4gICAgdmFyIGJ5dGVzUGVyU2VxdWVuY2UgPSAoZmlyc3RCeXRlID4gMHhFRikgPyA0XG4gICAgICA6IChmaXJzdEJ5dGUgPiAweERGKSA/IDNcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxuICAgICAgOiAxXG5cbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XG4gICAgICB2YXIgc2Vjb25kQnl0ZSwgdGhpcmRCeXRlLCBmb3VydGhCeXRlLCB0ZW1wQ29kZVBvaW50XG5cbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgaWYgKGZpcnN0Qnl0ZSA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4N0YpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XG4gICAgICAgICAgICB0ZW1wQ29kZVBvaW50ID0gKGZpcnN0Qnl0ZSAmIDB4RikgPDwgMHhDIHwgKHNlY29uZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAodGhpcmRCeXRlICYgMHgzRilcbiAgICAgICAgICAgIGlmICh0ZW1wQ29kZVBvaW50ID4gMHg3RkYgJiYgKHRlbXBDb2RlUG9pbnQgPCAweEQ4MDAgfHwgdGVtcENvZGVQb2ludCA+IDB4REZGRikpIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBicmVha1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgc2Vjb25kQnl0ZSA9IGJ1ZltpICsgMV1cbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXG4gICAgICAgICAgZm91cnRoQnl0ZSA9IGJ1ZltpICsgM11cbiAgICAgICAgICBpZiAoKHNlY29uZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAodGhpcmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKGZvdXJ0aEJ5dGUgJiAweEMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXG4gICAgICAgICAgICBpZiAodGVtcENvZGVQb2ludCA+IDB4RkZGRiAmJiB0ZW1wQ29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAoY29kZVBvaW50ID09PSBudWxsKSB7XG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXG4gICAgICAvLyByZXBsYWNlbWVudCBjaGFyIChVK0ZGRkQpIGFuZCBhZHZhbmNlIG9ubHkgMSBieXRlXG4gICAgICBjb2RlUG9pbnQgPSAweEZGRkRcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPiAweEZGRkYpIHtcbiAgICAgIC8vIGVuY29kZSB0byB1dGYxNiAoc3Vycm9nYXRlIHBhaXIgZGFuY2UpXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxuICAgICAgcmVzLnB1c2goY29kZVBvaW50ID4+PiAxMCAmIDB4M0ZGIHwgMHhEODAwKVxuICAgICAgY29kZVBvaW50ID0gMHhEQzAwIHwgY29kZVBvaW50ICYgMHgzRkZcbiAgICB9XG5cbiAgICByZXMucHVzaChjb2RlUG9pbnQpXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXG4gIH1cblxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcbn1cblxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXG4vLyB0aGUgbG93ZXN0IGxpbWl0IGlzIENocm9tZSwgd2l0aCAweDEwMDAwIGFyZ3MuXG4vLyBXZSBnbyAxIG1hZ25pdHVkZSBsZXNzLCBmb3Igc2FmZXR5XG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcblxuZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5IChjb2RlUG9pbnRzKSB7XG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxuICBpZiAobGVuIDw9IE1BWF9BUkdVTUVOVFNfTEVOR1RIKSB7XG4gICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoU3RyaW5nLCBjb2RlUG9pbnRzKSAvLyBhdm9pZCBleHRyYSBzbGljZSgpXG4gIH1cblxuICAvLyBEZWNvZGUgaW4gY2h1bmtzIHRvIGF2b2lkIFwiY2FsbCBzdGFjayBzaXplIGV4Y2VlZGVkXCIuXG4gIHZhciByZXMgPSAnJ1xuICB2YXIgaSA9IDBcbiAgd2hpbGUgKGkgPCBsZW4pIHtcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShcbiAgICAgIFN0cmluZyxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcbiAgICApXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcbiAgdmFyIHJldCA9ICcnXG4gIGVuZCA9IE1hdGgubWluKGJ1Zi5sZW5ndGgsIGVuZClcblxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgIHJldCArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ1ZltpXSAmIDB4N0YpXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBsYXRpbjFTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciByZXQgPSAnJ1xuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXG5cbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG5mdW5jdGlvbiBoZXhTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXG5cbiAgaWYgKCFzdGFydCB8fCBzdGFydCA8IDApIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXG5cbiAgdmFyIG91dCA9ICcnXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgb3V0ICs9IHRvSGV4KGJ1ZltpXSlcbiAgfVxuICByZXR1cm4gb3V0XG59XG5cbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XG4gIHZhciBieXRlcyA9IGJ1Zi5zbGljZShzdGFydCwgZW5kKVxuICB2YXIgcmVzID0gJydcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHJlcyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVzW2ldICsgKGJ5dGVzW2kgKyAxXSAqIDI1NikpXG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXG4gIHN0YXJ0ID0gfn5zdGFydFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXG5cbiAgaWYgKHN0YXJ0IDwgMCkge1xuICAgIHN0YXJ0ICs9IGxlblxuICAgIGlmIChzdGFydCA8IDApIHN0YXJ0ID0gMFxuICB9IGVsc2UgaWYgKHN0YXJ0ID4gbGVuKSB7XG4gICAgc3RhcnQgPSBsZW5cbiAgfVxuXG4gIGlmIChlbmQgPCAwKSB7XG4gICAgZW5kICs9IGxlblxuICAgIGlmIChlbmQgPCAwKSBlbmQgPSAwXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XG4gICAgZW5kID0gbGVuXG4gIH1cblxuICBpZiAoZW5kIDwgc3RhcnQpIGVuZCA9IHN0YXJ0XG5cbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcbiAgLy8gUmV0dXJuIGFuIGF1Z21lbnRlZCBgVWludDhBcnJheWAgaW5zdGFuY2VcbiAgbmV3QnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcbiAgcmV0dXJuIG5ld0J1ZlxufVxuXG4vKlxuICogTmVlZCB0byBtYWtlIHN1cmUgdGhhdCBidWZmZXIgaXNuJ3QgdHJ5aW5nIHRvIHdyaXRlIG91dCBvZiBib3VuZHMuXG4gKi9cbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XG4gIGlmICgob2Zmc2V0ICUgMSkgIT09IDAgfHwgb2Zmc2V0IDwgMCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ29mZnNldCBpcyBub3QgdWludCcpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBsZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludExFID0gZnVuY3Rpb24gcmVhZFVJbnRMRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIHZhbCArPSB0aGlzW29mZnNldCArIGldICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRCRSA9IGZ1bmN0aW9uIHJlYWRVSW50QkUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuICB9XG5cbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxuICB2YXIgbXVsID0gMVxuICB3aGlsZSAoYnl0ZUxlbmd0aCA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXG4gIH1cblxuICByZXR1cm4gdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDIsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKCh0aGlzW29mZnNldF0pIHxcbiAgICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xuICAgICAgKHRoaXNbb2Zmc2V0ICsgM10gKiAweDEwMDAwMDApXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQzMkJFID0gZnVuY3Rpb24gcmVhZFVJbnQzMkJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdICogMHgxMDAwMDAwKSArXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgIHRoaXNbb2Zmc2V0ICsgM10pXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludExFID0gZnVuY3Rpb24gcmVhZEludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxuXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF1cbiAgdmFyIG11bCA9IDFcbiAgdmFyIGkgPSAwXG4gIHdoaWxlICgrK2kgPCBieXRlTGVuZ3RoICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcbiAgfVxuICBtdWwgKj0gMHg4MFxuXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXG5cbiAgcmV0dXJuIHZhbFxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRSA9IGZ1bmN0aW9uIHJlYWRJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCBieXRlTGVuZ3RoLCB0aGlzLmxlbmd0aClcblxuICB2YXIgaSA9IGJ5dGVMZW5ndGhcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxuICB3aGlsZSAoaSA+IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWldICogbXVsXG4gIH1cbiAgbXVsICo9IDB4ODBcblxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxuXG4gIHJldHVybiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OCA9IGZ1bmN0aW9uIHJlYWRJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDEsIHRoaXMubGVuZ3RoKVxuICBpZiAoISh0aGlzW29mZnNldF0gJiAweDgwKSkgcmV0dXJuICh0aGlzW29mZnNldF0pXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxuICByZXR1cm4gKHZhbCAmIDB4ODAwMCkgPyB2YWwgfCAweEZGRkYwMDAwIDogdmFsXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkUgPSBmdW5jdGlvbiByZWFkSW50MTZCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgMV0gfCAodGhpc1tvZmZzZXRdIDw8IDgpXG4gIHJldHVybiAodmFsICYgMHg4MDAwKSA/IHZhbCB8IDB4RkZGRjAwMDAgOiB2YWxcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRJbnQzMkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcblxuICByZXR1cm4gKHRoaXNbb2Zmc2V0XSA8PCAyNCkgfFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxuICAgICh0aGlzW29mZnNldCArIDNdKVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFID0gZnVuY3Rpb24gcmVhZEZsb2F0TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCAyMywgNClcbn1cblxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRCRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdEJFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgZmFsc2UsIDIzLCA0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVMRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIHRydWUsIDUyLCA4KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRSA9IGZ1bmN0aW9uIHJlYWREb3VibGVCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCA1MiwgOClcbn1cblxuZnVuY3Rpb24gY2hlY2tJbnQgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgZXh0LCBtYXgsIG1pbikge1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImJ1ZmZlclwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxuICBpZiAodmFsdWUgPiBtYXggfHwgdmFsdWUgPCBtaW4pIHRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkge1xuICAgIHZhciBtYXhCeXRlcyA9IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKSAtIDFcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcbiAgfVxuXG4gIHZhciBtdWwgPSAxXG4gIHZhciBpID0gMFxuICB0aGlzW29mZnNldF0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50QkUgPSBmdW5jdGlvbiB3cml0ZVVJbnRCRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbWF4Qnl0ZXMsIDApXG4gIH1cblxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXG4gIHZhciBtdWwgPSAxXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcbiAgd2hpbGUgKC0taSA+PSAwICYmIChtdWwgKj0gMHgxMDApKSB7XG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludDggPSBmdW5jdGlvbiB3cml0ZVVJbnQ4ICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMSwgMHhmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MTZCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDIsIDB4ZmZmZiwgMClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDJcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkxFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDNdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFID0gZnVuY3Rpb24gd3JpdGVJbnRMRSAodmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcblxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIGxpbWl0IC0gMSwgLWxpbWl0KVxuICB9XG5cbiAgdmFyIGkgPSAwXG4gIHZhciBtdWwgPSAxXG4gIHZhciBzdWIgPSAwXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xuICAgIGlmICh2YWx1ZSA8IDAgJiYgc3ViID09PSAwICYmIHRoaXNbb2Zmc2V0ICsgaSAtIDFdICE9PSAwKSB7XG4gICAgICBzdWIgPSAxXG4gICAgfVxuICAgIHRoaXNbb2Zmc2V0ICsgaV0gPSAoKHZhbHVlIC8gbXVsKSA+PiAwKSAtIHN1YiAmIDB4RkZcbiAgfVxuXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnRCRSA9IGZ1bmN0aW9uIHdyaXRlSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgdmFyIGxpbWl0ID0gTWF0aC5wb3coMiwgKDggKiBieXRlTGVuZ3RoKSAtIDEpXG5cbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBsaW1pdCAtIDEsIC1saW1pdClcbiAgfVxuXG4gIHZhciBpID0gYnl0ZUxlbmd0aCAtIDFcbiAgdmFyIG11bCA9IDFcbiAgdmFyIHN1YiA9IDBcbiAgdGhpc1tvZmZzZXQgKyBpXSA9IHZhbHVlICYgMHhGRlxuICB3aGlsZSAoLS1pID49IDAgJiYgKG11bCAqPSAweDEwMCkpIHtcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xuICAgICAgc3ViID0gMVxuICAgIH1cbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXG4gIH1cblxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxuICBpZiAodmFsdWUgPCAwKSB2YWx1ZSA9IDB4ZmYgKyB2YWx1ZSArIDFcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcbiAgcmV0dXJuIG9mZnNldCArIDFcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXG4gIHRoaXNbb2Zmc2V0XSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXG4gIHJldHVybiBvZmZzZXQgKyAyXG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgJiAweGZmKVxuICByZXR1cm4gb2Zmc2V0ICsgMlxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiA4KVxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVJbnQzMkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICB2YWx1ZSA9ICt2YWx1ZVxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgNCwgMHg3ZmZmZmZmZiwgLTB4ODAwMDAwMDApXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlID4+PiAxNilcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXG4gIHJldHVybiBvZmZzZXQgKyA0XG59XG5cbmZ1bmN0aW9uIGNoZWNrSUVFRTc1NCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBleHQsIG1heCwgbWluKSB7XG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcbiAgaWYgKG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdJbmRleCBvdXQgb2YgcmFuZ2UnKVxufVxuXG5mdW5jdGlvbiB3cml0ZUZsb2F0IChidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgbm9Bc3NlcnQpIHtcbiAgdmFsdWUgPSArdmFsdWVcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXG4gIGlmICghbm9Bc3NlcnQpIHtcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA0LCAzLjQwMjgyMzQ2NjM4NTI4ODZlKzM4LCAtMy40MDI4MjM0NjYzODUyODg2ZSszOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCAyMywgNClcbiAgcmV0dXJuIG9mZnNldCArIDRcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEUgPSBmdW5jdGlvbiB3cml0ZUZsb2F0TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRmxvYXQodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG5mdW5jdGlvbiB3cml0ZURvdWJsZSAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XG4gIHZhbHVlID0gK3ZhbHVlXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxuICBpZiAoIW5vQXNzZXJ0KSB7XG4gICAgY2hlY2tJRUVFNzU0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgOCwgMS43OTc2OTMxMzQ4NjIzMTU3RSszMDgsIC0xLjc5NzY5MzEzNDg2MjMxNTdFKzMwOClcbiAgfVxuICBpZWVlNzU0LndyaXRlKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCA1MiwgOClcbiAgcmV0dXJuIG9mZnNldCArIDhcbn1cblxuQnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUxFID0gZnVuY3Rpb24gd3JpdGVEb3VibGVMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxufVxuXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xuICByZXR1cm4gd3JpdGVEb3VibGUodGhpcywgdmFsdWUsIG9mZnNldCwgZmFsc2UsIG5vQXNzZXJ0KVxufVxuXG4vLyBjb3B5KHRhcmdldEJ1ZmZlciwgdGFyZ2V0U3RhcnQ9MCwgc291cmNlU3RhcnQ9MCwgc291cmNlRW5kPWJ1ZmZlci5sZW5ndGgpXG5CdWZmZXIucHJvdG90eXBlLmNvcHkgPSBmdW5jdGlvbiBjb3B5ICh0YXJnZXQsIHRhcmdldFN0YXJ0LCBzdGFydCwgZW5kKSB7XG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxuICBpZiAoIWVuZCAmJiBlbmQgIT09IDApIGVuZCA9IHRoaXMubGVuZ3RoXG4gIGlmICh0YXJnZXRTdGFydCA+PSB0YXJnZXQubGVuZ3RoKSB0YXJnZXRTdGFydCA9IHRhcmdldC5sZW5ndGhcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXG4gIGlmIChlbmQgPiAwICYmIGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxuXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxuICBpZiAoZW5kID09PSBzdGFydCkgcmV0dXJuIDBcbiAgaWYgKHRhcmdldC5sZW5ndGggPT09IDAgfHwgdGhpcy5sZW5ndGggPT09IDApIHJldHVybiAwXG5cbiAgLy8gRmF0YWwgZXJyb3IgY29uZGl0aW9uc1xuICBpZiAodGFyZ2V0U3RhcnQgPCAwKSB7XG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxuICB9XG4gIGlmIChzdGFydCA8IDAgfHwgc3RhcnQgPj0gdGhpcy5sZW5ndGgpIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VTdGFydCBvdXQgb2YgYm91bmRzJylcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXG5cbiAgLy8gQXJlIHdlIG9vYj9cbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxuICBpZiAodGFyZ2V0Lmxlbmd0aCAtIHRhcmdldFN0YXJ0IDwgZW5kIC0gc3RhcnQpIHtcbiAgICBlbmQgPSB0YXJnZXQubGVuZ3RoIC0gdGFyZ2V0U3RhcnQgKyBzdGFydFxuICB9XG5cbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0XG4gIHZhciBpXG5cbiAgaWYgKHRoaXMgPT09IHRhcmdldCAmJiBzdGFydCA8IHRhcmdldFN0YXJ0ICYmIHRhcmdldFN0YXJ0IDwgZW5kKSB7XG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXG4gICAgZm9yIChpID0gbGVuIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgIHRhcmdldFtpICsgdGFyZ2V0U3RhcnRdID0gdGhpc1tpICsgc3RhcnRdXG4gICAgfVxuICB9IGVsc2UgaWYgKGxlbiA8IDEwMDApIHtcbiAgICAvLyBhc2NlbmRpbmcgY29weSBmcm9tIHN0YXJ0XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XG4gICAgICB0YXJnZXRbaSArIHRhcmdldFN0YXJ0XSA9IHRoaXNbaSArIHN0YXJ0XVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBVaW50OEFycmF5LnByb3RvdHlwZS5zZXQuY2FsbChcbiAgICAgIHRhcmdldCxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcbiAgICAgIHRhcmdldFN0YXJ0XG4gICAgKVxuICB9XG5cbiAgcmV0dXJuIGxlblxufVxuXG4vLyBVc2FnZTpcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxuLy8gICAgYnVmZmVyLmZpbGwoYnVmZmVyWywgb2Zmc2V0WywgZW5kXV0pXG4vLyAgICBidWZmZXIuZmlsbChzdHJpbmdbLCBvZmZzZXRbLCBlbmRdXVssIGVuY29kaW5nXSlcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcbiAgLy8gSGFuZGxlIHN0cmluZyBjYXNlczpcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGVuY29kaW5nID0gc3RhcnRcbiAgICAgIHN0YXJ0ID0gMFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBlbmQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuZFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcbiAgICB9XG4gICAgaWYgKHZhbC5sZW5ndGggPT09IDEpIHtcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcbiAgICAgIGlmIChjb2RlIDwgMjU2KSB7XG4gICAgICAgIHZhbCA9IGNvZGVcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGVuY29kaW5nICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXG4gICAgfVxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnICYmICFCdWZmZXIuaXNFbmNvZGluZyhlbmNvZGluZykpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcbiAgICB9XG4gIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICB2YWwgPSB2YWwgJiAyNTVcbiAgfVxuXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxuICBpZiAoc3RhcnQgPCAwIHx8IHRoaXMubGVuZ3RoIDwgc3RhcnQgfHwgdGhpcy5sZW5ndGggPCBlbmQpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignT3V0IG9mIHJhbmdlIGluZGV4JylcbiAgfVxuXG4gIGlmIChlbmQgPD0gc3RhcnQpIHtcbiAgICByZXR1cm4gdGhpc1xuICB9XG5cbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IHRoaXMubGVuZ3RoIDogZW5kID4+PiAwXG5cbiAgaWYgKCF2YWwpIHZhbCA9IDBcblxuICB2YXIgaVxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICBmb3IgKGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XG4gICAgICB0aGlzW2ldID0gdmFsXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBieXRlcyA9IEJ1ZmZlci5pc0J1ZmZlcih2YWwpXG4gICAgICA/IHZhbFxuICAgICAgOiBuZXcgQnVmZmVyKHZhbCwgZW5jb2RpbmcpXG4gICAgdmFyIGxlbiA9IGJ5dGVzLmxlbmd0aFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XG4gICAgICB0aGlzW2kgKyBzdGFydF0gPSBieXRlc1tpICUgbGVuXVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzXG59XG5cbi8vIEhFTFBFUiBGVU5DVElPTlNcbi8vID09PT09PT09PT09PT09PT1cblxudmFyIElOVkFMSURfQkFTRTY0X1JFID0gL1teKy8wLTlBLVphLXotX10vZ1xuXG5mdW5jdGlvbiBiYXNlNjRjbGVhbiAoc3RyKSB7XG4gIC8vIE5vZGUgc3RyaXBzIG91dCBpbnZhbGlkIGNoYXJhY3RlcnMgbGlrZSBcXG4gYW5kIFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxuICBzdHIgPSBzdHIudHJpbSgpLnJlcGxhY2UoSU5WQUxJRF9CQVNFNjRfUkUsICcnKVxuICAvLyBOb2RlIGNvbnZlcnRzIHN0cmluZ3Mgd2l0aCBsZW5ndGggPCAyIHRvICcnXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXG4gIC8vIE5vZGUgYWxsb3dzIGZvciBub24tcGFkZGVkIGJhc2U2NCBzdHJpbmdzIChtaXNzaW5nIHRyYWlsaW5nID09PSksIGJhc2U2NC1qcyBkb2VzIG5vdFxuICB3aGlsZSAoc3RyLmxlbmd0aCAlIDQgIT09IDApIHtcbiAgICBzdHIgPSBzdHIgKyAnPSdcbiAgfVxuICByZXR1cm4gc3RyXG59XG5cbmZ1bmN0aW9uIHRvSGV4IChuKSB7XG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxuICByZXR1cm4gbi50b1N0cmluZygxNilcbn1cblxuZnVuY3Rpb24gdXRmOFRvQnl0ZXMgKHN0cmluZywgdW5pdHMpIHtcbiAgdW5pdHMgPSB1bml0cyB8fCBJbmZpbml0eVxuICB2YXIgY29kZVBvaW50XG4gIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoXG4gIHZhciBsZWFkU3Vycm9nYXRlID0gbnVsbFxuICB2YXIgYnl0ZXMgPSBbXVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxuXG4gICAgLy8gaXMgc3Vycm9nYXRlIGNvbXBvbmVudFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XG4gICAgICAvLyBsYXN0IGNoYXIgd2FzIGEgbGVhZFxuICAgICAgaWYgKCFsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPiAweERCRkYpIHtcbiAgICAgICAgICAvLyB1bmV4cGVjdGVkIHRyYWlsXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfSBlbHNlIGlmIChpICsgMSA9PT0gbGVuZ3RoKSB7XG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxuICAgICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH1cblxuICAgICAgICAvLyB2YWxpZCBsZWFkXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcblxuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuXG4gICAgICAvLyAyIGxlYWRzIGluIGEgcm93XG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XG4gICAgICAgIGlmICgodW5pdHMgLT0gMykgPiAtMSkgYnl0ZXMucHVzaCgweEVGLCAweEJGLCAweEJEKVxuICAgICAgICBsZWFkU3Vycm9nYXRlID0gY29kZVBvaW50XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXG4gICAgICBjb2RlUG9pbnQgPSAobGVhZFN1cnJvZ2F0ZSAtIDB4RDgwMCA8PCAxMCB8IGNvZGVQb2ludCAtIDB4REMwMCkgKyAweDEwMDAwXG4gICAgfSBlbHNlIGlmIChsZWFkU3Vycm9nYXRlKSB7XG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXG4gICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcbiAgICB9XG5cbiAgICBsZWFkU3Vycm9nYXRlID0gbnVsbFxuXG4gICAgLy8gZW5jb2RlIHV0ZjhcbiAgICBpZiAoY29kZVBvaW50IDwgMHg4MCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAxKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4ODAwKSB7XG4gICAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcbiAgICAgIGJ5dGVzLnB1c2goXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgfCAweEMwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgaWYgKCh1bml0cyAtPSAzKSA8IDApIGJyZWFrXG4gICAgICBieXRlcy5wdXNoKFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDIHwgMHhFMCxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4NiAmIDB4M0YgfCAweDgwLFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxuICAgICAgKVxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50IDwgMHgxMTAwMDApIHtcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xuICAgICAgYnl0ZXMucHVzaChcbiAgICAgICAgY29kZVBvaW50ID4+IDB4MTIgfCAweEYwLFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXG4gICAgICAgIGNvZGVQb2ludCA+PiAweDYgJiAweDNGIHwgMHg4MCxcbiAgICAgICAgY29kZVBvaW50ICYgMHgzRiB8IDB4ODBcbiAgICAgIClcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGNvZGUgcG9pbnQnKVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBieXRlc1xufVxuXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xuICB2YXIgYnl0ZUFycmF5ID0gW11cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cbiAgICBieXRlQXJyYXkucHVzaChzdHIuY2hhckNvZGVBdChpKSAmIDB4RkYpXG4gIH1cbiAgcmV0dXJuIGJ5dGVBcnJheVxufVxuXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xuICB2YXIgYywgaGksIGxvXG4gIHZhciBieXRlQXJyYXkgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xuICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xuXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXG4gICAgaGkgPSBjID4+IDhcbiAgICBsbyA9IGMgJSAyNTZcbiAgICBieXRlQXJyYXkucHVzaChsbylcbiAgICBieXRlQXJyYXkucHVzaChoaSlcbiAgfVxuXG4gIHJldHVybiBieXRlQXJyYXlcbn1cblxuZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyAoc3RyKSB7XG4gIHJldHVybiBiYXNlNjQudG9CeXRlQXJyYXkoYmFzZTY0Y2xlYW4oc3RyKSlcbn1cblxuZnVuY3Rpb24gYmxpdEJ1ZmZlciAoc3JjLCBkc3QsIG9mZnNldCwgbGVuZ3RoKSB7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoKGkgKyBvZmZzZXQgPj0gZHN0Lmxlbmd0aCkgfHwgKGkgPj0gc3JjLmxlbmd0aCkpIGJyZWFrXG4gICAgZHN0W2kgKyBvZmZzZXRdID0gc3JjW2ldXG4gIH1cbiAgcmV0dXJuIGlcbn1cblxuLy8gQXJyYXlCdWZmZXJzIGZyb20gYW5vdGhlciBjb250ZXh0IChpLmUuIGFuIGlmcmFtZSkgZG8gbm90IHBhc3MgdGhlIGBpbnN0YW5jZW9mYCBjaGVja1xuLy8gYnV0IHRoZXkgc2hvdWxkIGJlIHRyZWF0ZWQgYXMgdmFsaWQuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvaXNzdWVzLzE2NlxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7XG4gIHJldHVybiBvYmogaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fFxuICAgIChvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IgIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3IubmFtZSA9PT0gJ0FycmF5QnVmZmVyJyAmJlxuICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJylcbn1cblxuLy8gTm9kZSAwLjEwIHN1cHBvcnRzIGBBcnJheUJ1ZmZlcmAgYnV0IGxhY2tzIGBBcnJheUJ1ZmZlci5pc1ZpZXdgXG5mdW5jdGlvbiBpc0FycmF5QnVmZmVyVmlldyAob2JqKSB7XG4gIHJldHVybiAodHlwZW9mIEFycmF5QnVmZmVyLmlzVmlldyA9PT0gJ2Z1bmN0aW9uJykgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KG9iailcbn1cblxuZnVuY3Rpb24gbnVtYmVySXNOYU4gKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcbn1cbiIsIi8qZ2xvYmFsIGJhc2UuY29va2llSGFuZGxlciwgY2FubnkgKi9cblxuKGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgREVGQVVMVF9MSUZFVElNRV9BU19EQVlTID0gMzY1ICogNSxcbiAgICAgICAgREVGQVVMVF9QQVRIID0gJy8nO1xuXG4gICAgdmFyIGNvb2tpZU1hbmFnZXIgPSB7fTtcblxuICAgIC8qKlxuICAgICAqIEEgY29va2llIG1hbmFnZXIgZm9yIGhhbmRsaW5nIGNvb2tpZXMgd2hlcmUgdGhlIGNvb2tpZSB2YWx1ZSBpcyBhIEpTT04tc3RyaW5naWZpZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogRm9yIGNyZWF0aW5nIGEgc2Vzc2lvbiBjb29raWUgKGkuZS4gZGVsZXRlZCB3aGVuIGJyb3dzZXIgY2xvc2VzKSwgYWRkIGEgbnVsbC12YWx1ZWQgZG9tYWluIHByb3BlcnR5IHRvXG4gICAgICogY29va2llQXR0cmlidXRlcy5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjb29raWVOYW1lXG4gICAgICogQHBhcmFtIGNvb2tpZUF0dHJpYnV0ZXM6IGFuIG9wdGlvbmFsIG9iamVjdCB3aGVyZSB0aGUgcHJvcGVydGllcyBhcmUgYXR0cmlidXRlcyBvZiB0aGUgY29va2llIC0gZXhwaXJlRGF5cyxcbiAgICAgKiBkb21haW4sIHBhdGggKGlmIGFueSBvZiB0aG9zZSBpcyBsZWZ0IG91dCBkZWZhdWx0cyB3aWxsIGJlIHVzZWQpLlxuICAgICAqIEByZXR1cm5zIHt7Y29va2llTmFtZSwgc3RvcmU6IHN0b3JlLCBzdG9yZUFsbDogc3RvcmVBbGwsIGdldFZhbHVlOiBnZXRWYWx1ZSwgZ2V0VmFsdWVzOiBnZXRWYWx1ZXN9fVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqL1xuICAgIHZhciBDb29raWVNYW5hZ2VyID0gZnVuY3Rpb24oY29va2llTmFtZSwgY29va2llQXR0cmlidXRlcykge1xuXG4gICAgICAgIHZhciBsaWZldGltZUFzRGF5cyA9IChmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChjb29raWVBdHRyaWJ1dGVzICYmIGNvb2tpZUF0dHJpYnV0ZXMuZXhwaXJlRGF5cykge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb29raWVBdHRyaWJ1dGVzLmV4cGlyZURheXM7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGNvb2tpZUF0dHJpYnV0ZXMgJiYgY29va2llQXR0cmlidXRlcy5leHBpcmVEYXlzID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBERUZBVUxUX0xJRkVUSU1FX0FTX0RBWVM7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKCk7XG4gICAgICAgIHZhciBkb21haW4gPSBjb29raWVBdHRyaWJ1dGVzICYmIGNvb2tpZUF0dHJpYnV0ZXMuZG9tYWluID9cbiAgICAgICAgICAgIGNvb2tpZUF0dHJpYnV0ZXMuZG9tYWluIDogY29va2llTWFuYWdlci5jb21wdXRlQ29va2llRG9tYWluKGRvY3VtZW50LmxvY2F0aW9uLmhvc3RuYW1lLCBmYWxzZSk7XG4gICAgICAgIHZhciBwYXRoID0gY29va2llQXR0cmlidXRlcyAmJiBjb29raWVBdHRyaWJ1dGVzLnBhdGggP1xuICAgICAgICAgICAgY29va2llQXR0cmlidXRlcy5wYXRoIDogREVGQVVMVF9QQVRIO1xuXG4gICAgICAgIGZ1bmN0aW9uIGdldENvb2tpZVZhbHVlcyhjb29raWVOYW1lKSB7XG4gICAgICAgICAgICB2YXIgaSwgY3VycmVudE5hbWUsIGN1cnJlbnRWYWx1ZSwgZGVjb2RlZFZhbHVlLFxuICAgICAgICAgICAgICAgIGFsbENvb2tpZXMgPSB3aW5kb3cuZG9jdW1lbnQuY29va2llLnNwbGl0KFwiO1wiKSxcbiAgICAgICAgICAgICAgICBjb29raWVWYWx1ZSA9IHt9O1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGFsbENvb2tpZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50TmFtZSA9IGFsbENvb2tpZXNbaV0uc3Vic3RyKDAsIGFsbENvb2tpZXNbaV0uaW5kZXhPZihcIj1cIikpO1xuICAgICAgICAgICAgICAgIGN1cnJlbnROYW1lID0gY3VycmVudE5hbWUucmVwbGFjZSgvXlxccyt8XFxzKyQvZywgXCJcIik7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnROYW1lID09PSBjb29raWVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRWYWx1ZSA9IGFsbENvb2tpZXNbaV0uc3Vic3RyKGFsbENvb2tpZXNbaV0uaW5kZXhPZihcIj1cIikgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICBjb29raWVWYWx1ZSA9IEpTT04ucGFyc2UoZGVjb2RlVVJJQ29tcG9uZW50KGN1cnJlbnRWYWx1ZSkpO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICBjb29raWVWYWx1ZSA9IGRlY29kZVVSSUNvbXBvbmVudChjdXJyZW50VmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gY29va2llVmFsdWU7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBjb21wdXRlTmV3RXhwaXJ5RGF0ZVN0cmluZygpIHtcbiAgICAgICAgICAgIHZhciBleHBpcnlEYXRlID0gbmV3IERhdGUoKTtcbiAgICAgICAgICAgIGV4cGlyeURhdGUuc2V0RGF0ZShleHBpcnlEYXRlLmdldERhdGUoKSArIGxpZmV0aW1lQXNEYXlzKTtcbiAgICAgICAgICAgIHJldHVybiBleHBpcnlEYXRlLnRvVVRDU3RyaW5nKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogVXBkYXRlIHRoZSAqZnVsbCogdmFsdWUgb2YgdGhlIGNvb2tpZSwgaW5jbC4gd3JpdGluZyBhbGwgb3RoZXIgY29va2llIGF0dHJpYnV0ZXMgYWNjb3JkaW5nIHRvXG4gICAgICAgICAqIGNvbmZpZ3VyYXRpb24gb2YgY29va2llIG1hbmFnZXIuXG4gICAgICAgICAqIEBwYXJhbSBjb29raWVWYWx1ZSBhbiBvYmplY3Qgd2hlcmUgZWFjaCBvd24gcHJvcGVydHkgaXMgYW4gZW50cnkgaW4gdGhlIGNvb2tpZSB2YWx1ZS5cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZUNvb2tpZShjb29raWVWYWx1ZSkge1xuICAgICAgICAgICAgdmFyIGNvb2tpZVBhcnRzID0gW1xuICAgICAgICAgICAgICAgIGNvb2tpZU5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoY29va2llVmFsdWUpKSxcbiAgICAgICAgICAgICAgICAncGF0aD0nICsgcGF0aCxcbiAgICAgICAgICAgICAgICAnZG9tYWluPScgKyBkb21haW5cbiAgICAgICAgICAgIF07XG4gICAgICAgICAgICBpZiAobGlmZXRpbWVBc0RheXMpIHtcbiAgICAgICAgICAgICAgICBjb29raWVQYXJ0cy5wdXNoKCdleHBpcmVzPScgKyBjb21wdXRlTmV3RXhwaXJ5RGF0ZVN0cmluZygpKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgd2luZG93LmRvY3VtZW50LmNvb2tpZSA9IGNvb2tpZVBhcnRzLmpvaW4oJzsnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBNZXJnZSBuZXcgdmFsdWVzIGludG8gZXhpc3Rpbmcvb2xkIHZhbHVlcy5cbiAgICAgICAgICogQHBhcmFtIG5ld0Nvb2tpZVZhbHVlcyBhbiBvYmplY3QgaG9sZGluZyBhbGwgbmV3IGNvb2tpZSB2YWx1ZSBlbnRyaWVzIChlbnRyaWVzIG1heSBhbHJlYWR5IGV4aXN0XG4gICAgICAgICAqIGluIGV4aXN0aW5nQ29va2llVmFsdWVzKVxuICAgICAgICAgKiBAcGFyYW0gZXhpc3RpbmdDb29raWVWYWx1ZXMgYW4gb2JqZWN0IGhvbGRpbmcgYWxsIGV4aXN0aW5nIGNvb2tpZSB2YWx1ZSBlbnRyaWVzLlxuICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIG1lcmdlTmV3SW50b09sZFZhbHVlcyhuZXdDb29raWVWYWx1ZXMsIGV4aXN0aW5nQ29va2llVmFsdWVzKSB7XG4gICAgICAgICAgICBPYmplY3Qua2V5cyhuZXdDb29raWVWYWx1ZXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nQ29va2llVmFsdWVzW2tleV0gPSBuZXdDb29raWVWYWx1ZXNba2V5XTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGV4aXN0aW5nQ29va2llVmFsdWVzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gdXBkYXRlQ29va2llVmFsdWVzKGNvb2tpZVZhbHVlcykge1xuICAgICAgICAgICAgdmFyIG9sZENvb2tpZVZhbHVlID0gZ2V0Q29va2llVmFsdWVzKGNvb2tpZU5hbWUpO1xuICAgICAgICAgICAgaWYgKE9iamVjdC5rZXlzKG9sZENvb2tpZVZhbHVlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB1cGRhdGVDb29raWUoY29va2llVmFsdWVzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlQ29va2llKG1lcmdlTmV3SW50b09sZFZhbHVlcyhjb29raWVWYWx1ZXMsIG9sZENvb2tpZVZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBpc1ZhbGlkQ29va2llVmFsdWVFbnRyaWVzKGVudHJpZXMpIHtcbiAgICAgICAgICAgIHJldHVybiB0eXBlb2YgZW50cmllcyA9PT0gJ29iamVjdCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKCBlbnRyaWVzICkgIT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgZ2V0IGNvb2tpZU5hbWUoKSB7IHJldHVybiBjb29raWVOYW1lOyB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIGtleSBhIGtleSAoU3RyaW5nKVxuICAgICAgICAgICAgICogQHBhcmFtIHZhbHVlIGEgdmFsdWUsIGNhbiBiZSBhbnkgdHlwZSBvZiBvYmplY3QgKGluY2wuIG5lc3RlZCkuIHZhbHVlIGNhbiBiZSBhIEpTT04gc3RyaW5nIGJ1dCB3aWxsXG4gICAgICAgICAgICAgKiAgICAgKm5vdCogIGJlIHBhcnNlZC5cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgc3RvcmUgOiBmdW5jdGlvbihrZXksIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG5ld1ZhbHVlID0ge307XG4gICAgICAgICAgICAgICAgbmV3VmFsdWVba2V5XSA9IHZhbHVlO1xuICAgICAgICAgICAgICAgIHVwZGF0ZUNvb2tpZVZhbHVlcyhuZXdWYWx1ZSk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIGVudHJpZXMgYW4gb2JqZWN0IHdoZXJlIGFsbCBvd24gcHJvcGVydGllcyB3aWxsIGJlIGFkZGVkIHRvIHRoZSBjb29raWUgdmFsdWUgKHJ1bGVzIGZvciB2YWx1ZXNcbiAgICAgICAgICAgICAqIGZyb20gc3RvcmUgZnVuY3Rpb24gYXBwbHkgaGVyZSBhcyB3ZWxsKS4gRXhpc3RpbmcgZW50cmllcyB3aWxsIGJlIG92ZXJ3cml0dGVuLiBObyBvYmplY3QgZW5jb2RlZCBhc1xuICAgICAgICAgICAgICogSnNvbiBzdHJpbmcgYWNjZXB0ZWQsIG5vIEFycmF5cyBlaXRoZXIuXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIHN0b3JlQWxsIDogZnVuY3Rpb24oZW50cmllcykge1xuICAgICAgICAgICAgICAgIGlmICghaXNWYWxpZENvb2tpZVZhbHVlRW50cmllcyhlbnRyaWVzKSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb29raWVNYW5hZ2VyLnN0b3JlQWxsIGFjY2VwdHMgb25seSBvYmplY3RzIChpbmNsLiBubyBhcnJheXMpLCBwYXJhbWV0ZXIgd2FzIFwiJ1xuICAgICAgICAgICAgICAgICAgICAgICAgKyBlbnRyaWVzICsgJ1wiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVwZGF0ZUNvb2tpZVZhbHVlcyhlbnRyaWVzKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIEdldCB0aGUgdmFsdWUgb2YgYSBzaW5nbGUgZW50cnkgZnJvbSB0aGUgY29va2llLlxuICAgICAgICAgICAgICogQHBhcmFtIGtleVxuICAgICAgICAgICAgICogQHJldHVybnMgeyp9XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGdldFZhbHVlIDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldENvb2tpZVZhbHVlcyhjb29raWVOYW1lKVtrZXldO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogR2V0IGFsbCBlbnRyaWVzIChhcyBhbiBvYmplY3QpIGZyb20gdGhlIGNvb2tpZS5cbiAgICAgICAgICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBnZXRWYWx1ZXMgOiBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0Q29va2llVmFsdWVzKGNvb2tpZU5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gaWYgbmVlZGVkLCBhZGQgcmVtb3ZlKGtleSkgYW5kIHJlbW92ZUFsbChrZXlzKSBmdW5jdGlvbnMgdG8gdGhlIGFwaVxuICAgICAgICB9O1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBGYWN0b3J5IGZ1bmN0aW9uIHdoaWNoIHByb2R1Y2VzIGEgY29va2llIG1hbmFnZXIgZm9yIHRoZSBnaXZlbiBjb29raWUgbmFtZSBhbmQgY29uZmlnLlxuICAgICAqIEBwYXJhbSBjb29raWVOYW1lXG4gICAgICogQHBhcmFtIGNvb2tpZUF0dHJpYnV0ZXM6IHNlZSBjb25zdHJ1Y3RvciBkb2N1bWVudGF0aW9uXG4gICAgICogQHJldHVybnMge0Nvb2tpZU1hbmFnZXJ9XG4gICAgICovXG4gICAgY29va2llTWFuYWdlci5mb3JDb29raWUgPSBmdW5jdGlvbihjb29raWVOYW1lLCBjb29raWVBdHRyaWJ1dGVzKSB7XG4gICAgICAgIHJldHVybiBuZXcgQ29va2llTWFuYWdlcihjb29raWVOYW1lLCBjb29raWVBdHRyaWJ1dGVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY29va2llTmFtZSB0aGUgbmFtZSBvZiB0aGUgY29va2llXG4gICAgICogQHBhcmFtIGNvb2tpZUF0dHJpYnV0ZXMgYXR0cmlidXRlcyBvZiB0aGUgY29va2llIChidXQgbm90ZSB0aGF0IGV4cGlyZXMgYXR0cmlidXRlcyBjYW5ub3QgYmUgb3ZlcndyaXR0ZW4sIGl0IHdpbGxcbiAgICAgKiBiZSBhZGRlZCB0byB0aGF0IG9iamVjdClcbiAgICAgKiBAcmV0dXJucyB7Q29va2llTWFuYWdlcn1cbiAgICAgKi9cbiAgICBjb29raWVNYW5hZ2VyLmZvclNlc3Npb25Db29raWUgPSBmdW5jdGlvbihjb29raWVOYW1lLCBjb29raWVBdHRyaWJ1dGVzKSB7XG4gICAgICAgIGNvb2tpZUF0dHJpYnV0ZXMgPSBjb29raWVBdHRyaWJ1dGVzIHx8IHt9O1xuICAgICAgICBjb29raWVBdHRyaWJ1dGVzWydleHBpcmVEYXlzJ10gPSBudWxsO1xuICAgICAgICByZXR1cm4gbmV3IENvb2tpZU1hbmFnZXIoY29va2llTmFtZSwgY29va2llQXR0cmlidXRlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlbmllbmNlIGZhY3RvcnkgZnVuY3Rpb24gd2hpY2ggcHJvZHVjZXMgYSBjb29raWUgbWFuYWdlciBmb3IgdGhlIHN0YW5kYXJkIEdEIGNvb2tpZS5cbiAgICAgKiBAcGFyYW0gY29va2llQXR0cmlidXRlczogc2VlIGNvbnN0cnVjdG9yIGRvY3VtZW50YXRpb25cbiAgICAgKiBAcmV0dXJucyB7Q29va2llTWFuYWdlcn1cbiAgICAgKi9cbiAgICBjb29raWVNYW5hZ2VyLmZvckdEU3RhbmRhcmRDb29raWUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIFRPRE8gd2hhdCBpcyB0aGUgbmFtZSBvZiB0aGUgc3RhbmRhcmQgY29va2llP1xuICAgICAgICByZXR1cm4gbmV3IENvb2tpZU1hbmFnZXIoJ0dEJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSBjb29raWUgZG9tYWluIGZyb20gdGhlIGdpdmVuIGhvc3RuYW1lLlxuICAgICAqIEBwYXJhbSBob3N0bmFtZVxuICAgICAqIEBwYXJhbSBpbmNsdWRlU3ViRG9tYWlucyBpZiB0cnVlIGFsbCBzdWJkb21haW5zIHdpbGwgYmUgb21pdHRlZFxuICAgICAqL1xuICAgIGNvb2tpZU1hbmFnZXIuY29tcHV0ZUNvb2tpZURvbWFpbiA9IGZ1bmN0aW9uKGhvc3RuYW1lLCBpbmNsdWRlU3ViRG9tYWlucykge1xuICAgICAgICBpZiAoaG9zdG5hbWUuaW5kZXhPZignZ2FtZWR1ZWxsJykgIT09IC0xICYmICFpbmNsdWRlU3ViRG9tYWlucykge1xuICAgICAgICAgICAgdmFyIGhvc3RuYW1lUGFydHMgPSBob3N0bmFtZS5zcGxpdCgnLicpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBob3N0bmFtZVBhcnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKGhvc3RuYW1lUGFydHNbaV0gPT09IFwiZ2FtZWR1ZWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gc29tZSBpbmZvcyBhYm91dCB0aGUgbGVhZGluZyBkb3Q6XG4gICAgICAgICAgICAgICAgICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvOTYxODIxNy93aGF0LWRvZXMtdGhlLWRvdC1wcmVmaXgtaW4tdGhlLWNvb2tpZS1kb21haW4tbWVhblxuICAgICAgICAgICAgICAgICAgICAvLyB0bDtkcjogYW4gb2Jzb2xldGUgUkZDIGRlZmluZWQgdGhhdCBhIGRvbWFpbiB3aXRoIGEgbGVhZGluZyBkb3Qgd291bGQgbWVhbiBcImFsbG93IGZvclxuICAgICAgICAgICAgICAgICAgICAvLyBzdWJkb21haW5zLCB0b29cIiBJRTgvOSBhcmUgc3RpbGwgYWZmZWN0ZWQuIE90aGVycyBzaG91bGQganVzdCBkaXNyZWdhcmQgdGhlIGRvdCAoYXMgcGVyIG5ld2VyXG4gICAgICAgICAgICAgICAgICAgIC8vIFJGQylcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcuJyArIGhvc3RuYW1lUGFydHMuc3BsaWNlKGkpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaG9zdG5hbWU7XG4gICAgfTtcblxuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSBjb29raWVNYW5hZ2VyO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbm55LmFkZCgnY29va2llTWFuYWdlcicsIGNvb2tpZU1hbmFnZXIpO1xuICAgIH1cblxufSgpKTtcbiIsIi8qZ2xvYmFsICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlKi9cbi8qKlxuICpcbiAqIEUuZy46XG4gKiAgY2FubnktbW9kPVwibW9kdWxlT2JqXCIgY2FubnktdmFyPVwieydwcm9wZXJ0eUtleSc6J3ZhbHVlJ31cIlxuICogIGNhbm55LW1vZD1cIm1vZHVsZVN0cmluZ1wiIGNhbm55LXZhcj1cImJ1dHRvblwiXG4gKlxuICogSW5zdGVhZCBvZiBjYW5ueS12YXIgeW91IGNhbiB1c2UgdGhlIG1vZHVsZSBuYW1lIHRvIGF2b2lkIGNvbmZsaWN0cyBsaWtlOlxuICogRS5nLjogY2FubnktbW9kPVwibW9kMSBtb2QyXCIgY2FubnktbW9kMT17J2Zvbyc6JzEyMzQ1NicsICdiYXInOic2NTQzMjEnfSBjYW5ueS1tb2QyPVwibW9kMlByb3BlcnR5XCJcbiAqXG4gKiAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIGVpZ2h0eWZvdXJcbiAqL1xuKGZ1bmN0aW9uIChnbG9iYWwpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgY2FubnkgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVhZHlRdWV1ZSA9IFtdLFxuICAgICAgICAgICAgcmVhZHlRdWV1ZUluaXQgPSBmYWxzZSxcbiAgICAgICAgICAgIG1vZHVsZVF1ZXVlID0gW107IC8vIHNhdmUgbW9kdWxlcyB0byBjYWxsIHRoZSByZWFkeSBtZXRob2Qgb25jZVxuXG4gICAgICAgIC8qKlxuICAgICAgICAgKiBGaW5kIHRoZSBzaW5nbGUgcXVvdGVzIGFuZCByZXBsYWNlIHRoZW0gd2l0aCBkb3VibGUgcXVvdGVzIGV4Y2VwdCBzdHJpbmcgd2hpY2hcbiAgICAgICAgICogYXJlIHBhcnQgb2YgdGhlIHByb3BlcnR5IHN0cmluZy5cbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHN0cmluZ1xuICAgICAgICAgKiBAcmV0dXJucyB7c3RyaW5nfVxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gZXNjYXBlU3RyaW5nRm9ySlNPTihzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBzID0gc3RyaW5nXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xce1xccypcXCcvZywne1wiJykucmVwbGFjZSgvXFwnXFxzKlxcfS9nLCdcIn0nKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC86XFxzKlxcJy9nLCc6XCInKS5yZXBsYWNlKC9cXCdcXHMqOi9nLCdcIjonKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8sXFxzKlxcJy9nLCcsXCInKS5yZXBsYWNlKC9cXCdcXHMqLC9nLCdcIiwnKVxuICAgICAgICAgICAgICAgIC5yZXBsYWNlKC9cXFtcXHMqXFwnL2csJ1tcIicpLnJlcGxhY2UoL1xcJ1xccypcXF0vZywnXCJdJyk7XG4gICAgICAgICAgICByZXR1cm4gcztcbiAgICAgICAgfVxuXG4gICAgICAgIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0ZvckpTT05BcnJheShzdHJpbmcpIHtcbiAgICAgICAgICAgIHZhciBzID0gc3RyaW5nXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoLyxcXHMqXFwnL2csJyxcIicpLnJlcGxhY2UoL1xcJ1xccyosL2csJ1wiLCcpXG4gICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcW1xccypcXCcvZywnW1wiJykucmVwbGFjZSgvXFwnXFxzKlxcXS9nLCdcIl0nKTtcbiAgICAgICAgICAgIHJldHVybiBzO1xuICAgICAgICB9XG5cbiAgICAgICAgZnVuY3Rpb24gY2FsbE1ldGhvZFF1ZXVlKHF1ZXVlKSB7XG4gICAgICAgICAgICAoZnVuY3Rpb24gcmVkdWNlKCkge1xuICAgICAgICAgICAgICAgIHZhciBmYyA9IHF1ZXVlLnBvcCgpO1xuICAgICAgICAgICAgICAgIGlmIChmYykge1xuICAgICAgICAgICAgICAgICAgICBmYygpO1xuICAgICAgICAgICAgICAgICAgICByZWR1Y2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0oKSk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZU5vZGUobm9kZSwgbmFtZSwgY2IpIHtcbiAgICAgICAgICAgIHZhciB0aGF0ID0gdGhpcywgZ2RNb2R1bGVDaGlsZHJlbiA9IFtdLnNsaWNlLmNhbGwobm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdbJyArIG5hbWUgKyAnLW1vZF0nKSksIHByZXBhcmVSZWFkeVF1ZXVlID0ge307XG5cbiAgICAgICAgICAgIGdkTW9kdWxlQ2hpbGRyZW4uZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGUgPSBub2RlLmdldEF0dHJpYnV0ZShuYW1lICsgJy1tb2QnKSwgYXR0ciwgdmlld1BhcnQsIGF0dHJpYnV0ZXMsIGNhbm55VmFyO1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcyA9IGF0dHJpYnV0ZS5zcGxpdCgnICcpO1xuXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGF0W21vZHVsZU5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSArICctbW9kJykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5nZXRBdHRyaWJ1dGUobmFtZSArICctJyArIG1vZHVsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55VmFyID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSArICctJyArIG1vZHVsZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55VmFyID0gbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSArICctdmFyJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5ueVZhcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBzaW1wbGUgSlNPTiB0ZXN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvXFx7XFxzKlxcJ3xcXFwiLio6LipcXH0vLnRlc3QoY2FubnlWYXIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyID0gZXNjYXBlU3RyaW5nRm9ySlNPTihjYW5ueVZhcik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBhIEpTT05cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1BhcnQgPSBKU09OLnBhcnNlKGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiY2FubnkgY2FuJ3QgcGFyc2UgcGFzc2VkIEpTT04gZm9yIG1vZHVsZTogXCIgKyBtb2R1bGVOYW1lLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICgvXFxbXFxzKlxcJ3xcXFwiLipcXCd8XFxcIlxcXS8udGVzdChjYW5ueVZhcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBlc2NhcGVTdHJpbmdGb3JKU09OQXJyYXkoY2FubnlWYXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2aWV3UGFydCA9IEpTT04ucGFyc2UoYXR0cik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJjYW5ueSBjYW4ndCBwYXJzZSBwYXNzZWQgSlNPTiBmb3IgbW9kdWxlOiBcIiArIG1vZHVsZU5hbWUsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmlld1BhcnQgPSBjYW5ueVZhcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhhcyBtb2R1bGUgYSByZWFkeSBmdW5jdGlvbiB0aGFuIHNhdmUgaXQgZm9yIGNhbGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0W21vZHVsZU5hbWVdLmhhc093blByb3BlcnR5KCdyZWFkeScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBvciBjYWxsIGl0IGltbWVkaWF0ZWx5P1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByZXBhcmVSZWFkeVF1ZXVlW21vZHVsZU5hbWVdID0gdGhhdFttb2R1bGVOYW1lXS5yZWFkeTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGF0Lmhhc093blByb3BlcnR5KG1vZHVsZU5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdFttb2R1bGVOYW1lXS5hZGQobm9kZSwgdmlld1BhcnQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjYW5ueSBwYXJzZTogbW9kdWxlIHdpdGggbmFtZSDCtCcgKyBtb2R1bGVOYW1lICsgJ8K0IGlzIG5vdCByZWdpc3RlcmVkJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gYWRkIHJlYWR5IGNhbGxiYWNrIHRvIG1vZHVsZVF1ZXVlXG4gICAgICAgICAgICBPYmplY3Qua2V5cyhwcmVwYXJlUmVhZHlRdWV1ZSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICAgICAgICAgIG1vZHVsZVF1ZXVlLnB1c2gocHJlcGFyZVJlYWR5UXVldWVbbmFtZV0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignRE9NQ29udGVudExvYWRlZCcsIGZ1bmN0aW9uIGNhbm55RG9tTG9hZCgpIHtcbiAgICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ0RPTUNvbnRlbnRMb2FkZWQnLCBjYW5ueURvbUxvYWQpO1xuXG4gICAgICAgICAgICBwYXJzZU5vZGUuYXBwbHkoY2FubnksIFtkb2N1bWVudCwgJ2Nhbm55J10pO1xuXG4gICAgICAgICAgICBjYWxsTWV0aG9kUXVldWUobW9kdWxlUXVldWUpO1xuICAgICAgICAgICAgLy8gY2FsbCByZWdpc3RlcmVkIHJlYWR5IGZ1bmN0aW9uc1xuICAgICAgICAgICAgcmVhZHlRdWV1ZUluaXQgPSB0cnVlO1xuICAgICAgICAgICAgY2FsbE1ldGhvZFF1ZXVlKHJlYWR5UXVldWUpO1xuICAgICAgICB9LCBmYWxzZSk7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGFkZCA6IGZ1bmN0aW9uIChuYW1lLCBtb2R1bGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgbW9kdWxlQXBpID0gbW9kdWxlO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbW9kdWxlQXBpID0gbW9kdWxlKHRoaXMpOyAvLyBpbml0aWFsaXplIHRoZSBtb2R1bGUgd2l0aCB0aGUgYWN0dWFsIGNhbm55IGluc3RhbmNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpc1tuYW1lXSA9IG1vZHVsZUFwaTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdjYW5ueTogVHJ5IHRvIHJlZ2lzdGVyIG1vZHVsZSB3aXRoIG5hbWUgJyArIG5hbWUgKyAnIHR3aWNlJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJlYWR5IDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFyZWFkeVF1ZXVlSW5pdCkge1xuICAgICAgICAgICAgICAgICAgICByZWFkeVF1ZXVlLnB1c2goZmMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZjKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNhbm55UGFyc2UgOiBmdW5jdGlvbiAobm9kZSwgbmFtZSwgY2IpIHtcbiAgICAgICAgICAgICAgICAvLyBUT0RPIG5lZWRzIGEgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2IgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICBuYW1lID0gXCJjYW5ueVwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBwYXJzZU5vZGUuYXBwbHkodGhpcyB8fCBjYW5ueSwgW25vZGUsIG5hbWUgfHwgJ2Nhbm55JywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsTWV0aG9kUXVldWUobW9kdWxlUXVldWUpO1xuICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xuICAgICAgICAgICAgICAgIH1dKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9KCkpO1xuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHsgbW9kdWxlLmV4cG9ydHMgPSBjYW5ueTsgfSBlbHNlIHtnbG9iYWwuY2FubnkgPSBjYW5ueTsgfVxufSh0aGlzKSk7IiwiLypnbG9iYWwgY2FubnkgKi9cbi8qanNsaW50IGJyb3dzZXI6IHRydWUqL1xuXG4vKipcbiAqIFJlcXVpcmVkOiAnY2FubnknIGluIGdsb2JhbCBzY29wZVxuICpcbiAqIEUuZy46XG4gKiBjYW5ueS5hc3luYy5sb2FkKFVSTCwgZnVuY3Rpb24gKHNyYykge1xuICogICAgIG5vZGUuaW5uZXJIVE1MID0gc3JjO1xuICogICAgIC8vIHRyaWdnZXIgY2FubnkgcGFyc2UgdG8gcmVnaXN0ZXIgY2Fubnkgb24gb3VyIG5ldyBtb2R1bGVzXG4gKiAgICAgY2FubnkuY2FubnlQYXJzZShub2RlLCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgICAgIGNvbnNvbGUubG9nKCdDQU5OWSBQQVJTRSBET05FJyk7XG4gKiAgICAgfSk7XG4gKiB9KTtcbiAqXG4gKiBBbHRlcm5hdGl2ZSB5b3UgY2FuIGp1c3QgdXNlIGxvYWRIVE1MIChzY3JpcHRzIHdpbGwgYXV0b21hdGljYWxseSBhZGRlZCBhbmQgcGFyc2VkIGJ5IGNhbm55KTpcbiAqIGNhbm55LmFzeW5jLmxvYWRIVE1MKG5vZGUsIHt1cmwgOiBVUkx9LCBmdW5jdGlvbiAoKSB7XG4gKiAgICAgY29uc29sZS5sb2coJ2tvZG9zX2xvYWQgUkVBRFknKTtcbiAqIH0pO1xuICpcbiAqIE9yIGRpcmVjdGx5IGFzIGNhbm55IG1vZHVsZTpcbiAqIDxkaXYgY2FubnktbW9kPVwiYXN5bmNcIiBjYW5ueS12YXI9XCJ7J3VybCc6Jy95b3UvSFRNTC9maWxlLmh0bWwnfVwiPjwvZGl2PlxuICpcbiAqIFRPRE8gc29sdmUgZGVwZW5kZW5jeSBwcm9ibGVtIHRvIGNhbm55LlxuICpcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG4gICAgdmFyIGFzeW5jID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGZpbGVzVG9Mb2FkID0gW10sXG4gICAgICAgICAgICBwdXNoTG9hZENCcyA9IFtdLFxuICAgICAgICAgICAgcmVhZHkgPSBmYWxzZTtcblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNjcmlwdFxuICAgICAgICAgKiBAcGFyYW0gbWVkaWFVUkxcbiAgICAgICAgICogQHBhcmFtIGNiXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBhcHBlbmRTY3JpcHQoc2NyaXB0LCBtZWRpYVVSTCwgY2IpIHtcbiAgICAgICAgICAgIHZhciBub2RlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JyksXG4gICAgICAgICAgICAgICAgc3JjID0gc2NyaXB0LmdldEF0dHJpYnV0ZSgnc3JjJyk7XG4gICAgICAgICAgICAvLyBoYW5kbGUgbWVkaWFVUkwgYW5kIGFsbCByZWxhdGl2ZSBzY3JpcHQgYXJlIGxvYWRlZCBmcm9tIHRoZSBtZWRpYSBVUkwgc3RyaW5nXG4gICAgICAgICAgICBpZiAobWVkaWFVUkwgJiYgc3JjWzBdICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICBpZiAobWVkaWFVUkxbbWVkaWFVUkwubGVuZ3RoIC0gMV0gIT09ICcvJykge1xuICAgICAgICAgICAgICAgICAgICBtZWRpYVVSTCArPSAnLyc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNyYyA9IG1lZGlhVVJMICsgc3JjO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbm9kZS50eXBlID0gXCJ0ZXh0L2phdmFzY3JpcHRcIjtcbiAgICAgICAgICAgIG5vZGUuYXN5bmMgPSB0cnVlO1xuICAgICAgICAgICAgbm9kZS5zZXRBdHRyaWJ1dGUoJ3NyYycsIHNyYyk7XG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2xvYWQnLCBjYiwgZmFsc2UpO1xuICAgICAgICAgICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKCdlcnJvcicsIGNiLCB0cnVlKTtcbiAgICAgICAgICAgIGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQobm9kZSk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIHNjcmlwdHNcbiAgICAgICAgICogQHBhcmFtIG1lZGlhVVJMXG4gICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gYXBwZW5kU2NyaXB0c1RvSGVhZChzY3JpcHRzLCBtZWRpYVVSTCwgY2IpIHtcbiAgICAgICAgICAgIHZhciBzY3JpcHQsIGksIGluY2x1ZGVzU2NyaXB0cyA9IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNjcmlwdENvdW50ZXIgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY291bnQgPSAwO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdXAgOiBmdW5jdGlvbiAoKSB7Y291bnQrKzsgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvdW50IDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSgpKTtcblxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IHNjcmlwdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBzY3JpcHRzW2ldO1xuICAgICAgICAgICAgICAgIGlmIChzY3JpcHQuZ2V0QXR0cmlidXRlKCdzcmMnKSkge1xuICAgICAgICAgICAgICAgICAgICBpbmNsdWRlc1NjcmlwdHMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBzY3JpcHRDb3VudGVyLnVwKCk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFNjcmlwdChzY3JpcHQsIG1lZGlhVVJMLCBzY3JpcHRDb3VudGVyLnJlYWR5KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ2FzeW5jOiBmb3VuZCBpbmxpbmUgc2NyaXB0IHRhZyEhIScpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHNjcmlwdHMubGVuZ3RoID09PSAwIHx8IGluY2x1ZGVzU2NyaXB0cyA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICBjYigpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogUGFyc2UgdGhlIGNvbXBsZXRlIGdpdmVuIERPTSBhbmQgcHJlZml4IGFsbCByZWxhdGl2ZSBocmVmIFVSTCdzIHdpdGggdGhlIGdpdmVuIFVSTFxuICAgICAgICAgKiBBbGwgVVJMJ3MgYXJlIGhhbmRsZWQgYXMgcmVsYXRpdmUgaWYgdGhlcmUgc3RhcnRzIG5vdCB3aXRoIGEgLyBvciBodHRwOi8vIG9yIGh0dHBzOi8vXG4gICAgICAgICAqIFRPRE8gYWRkIHN1cHBvcnQgZm9yIFVSTCdzIHdpdGggYSAuLyBvciAuLi8gYW5kIHNvIG9uXG4gICAgICAgICAqXG4gICAgICAgICAqIEBwYXJhbSBub2RlIHBhcmVudCBlbGVtZW50XG4gICAgICAgICAqIEBwYXJhbSBtZWRpYVVSTCBtZWRpYVBhdGggdG8gYW5vdGhlciBzZXJ2ZXJcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIGhhbmRsZUxpbmtzKG5vZGUsIG1lZGlhVVJMKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ2xpbmsnKSkuZm9yRWFjaChmdW5jdGlvbiAobGluaykge1xuICAgICAgICAgICAgICAgIHZhciBocmVmID0gbGluay5nZXRBdHRyaWJ1dGUoJ2hyZWYnKTtcbiAgICAgICAgICAgICAgICBpZiAobGluay5nZXRBdHRyaWJ1dGUoJ3R5cGUnKSA9PT0gJ3RleHQvY3NzJyAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWYgIT09IHVuZGVmaW5lZCAmJiBcbiAgICAgICAgICAgICAgICAgICAgICAgIGhyZWZbMF0gIT09ICcvJyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIS9eaHR0cDpcXC9cXC8uKi8udGVzdChocmVmKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIS9eaHR0cHM6XFwvXFwvLiovLnRlc3QoaHJlZikpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lZGlhVVJMW21lZGlhVVJMLmxlbmd0aCAtIDFdICE9PSAnLycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lZGlhVVJMICs9ICcvJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBocmVmID0gbWVkaWFVUkwgKyBocmVmO1xuICAgICAgICAgICAgICAgICAgICBsaW5rLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICpcbiAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICogQHBhcmFtIGF0dHIge3t1cmw6c3RyaW5nLCBtZWRpYVVSTDogc3RyaW5nfX1cbiAgICAgICAgICogQHBhcmFtIGNiXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBsb2FkSFRNTChub2RlLCBhdHRyLCBjYikge1xuICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgndGVtcGxhdGUnKSxcbiAgICAgICAgICAgICAgICBkaXYgPSAoJ2NvbnRlbnQnIGluIHRlbXBsYXRlID8gdGVtcGxhdGUgOiBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoJ21haW4nKS5ib2R5KSxcbiAgICAgICAgICAgICAgICBib2R5LFxuICAgICAgICAgICAgICAgIHNjcmlwdHMsXG4gICAgICAgICAgICAgICAgLy8gb25seSBwYXJzZSBpZiBodG1sIGFuZCBzY3JpcHRzIGFyZSBsb2FkZWQgKHNjcmlwdHMgaGFzIGNhbGxiYWNrcyBiZWNhdXNlIHRoZXJlIGFyZSBuZWVkcyB0byBsb2FkZWQgYXN5bmNocm9ub3VzKVxuICAgICAgICAgICAgICAgIGhhbmRsZUNhbm55UGFyc2UgPSAoZnVuY3Rpb24gKGNiKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciB3YWl0Rm9yU2NyaXB0cyA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0Rm9ySFRNTCA9IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXdhaXRGb3JTY3JpcHRzICYmICF3YWl0Rm9ySFRNTCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS5jYW5ueVBhcnNlKG5vZGUsIGNiKTsgLy8gaW5pdCBvbmx5IGNhbm55IG93biBtb2R1bGVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNjcmlwdFJlYWR5IDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdhaXRGb3JTY3JpcHRzID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJpZ2dnZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICBodG1sUmVhZHkgOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FpdEZvckhUTUwgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2dlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH0oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBjYihhdHRyKTtcbiAgICAgICAgICAgICAgICB9KSk7XG5cbiAgICAgICAgICAgIGxvYWQoYXR0ci51cmwsIGZ1bmN0aW9uIChzcmMpIHtcbiAgICAgICAgICAgICAgICB2YXIgY2hpbGRzO1xuICAgICAgICAgICAgICAgIGlmIChzcmMpIHtcbiAgICAgICAgICAgICAgICAgICAgZGl2LmlubmVySFRNTCA9IHNyYztcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgaXQgaXMgYSB0ZW1wbGF0ZSB3ZSBuZWVkIHRoZSBjb250ZW50XG4gICAgICAgICAgICAgICAgICAgIGJvZHkgPSAnY29udGVudCcgaW4gZGl2ID8gZGl2LmNvbnRlbnQgOiBkaXY7XG4gICAgICAgICAgICAgICAgICAgIHNjcmlwdHMgPSBib2R5LnF1ZXJ5U2VsZWN0b3JBbGwoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgICAgICAgICBjaGlsZHMgPSBbXS5zbGljZS5jYWxsKGJvZHkuY2hpbGROb2Rlcyk7XG4gICAgICAgICAgICAgICAgICAgIGFwcGVuZFNjcmlwdHNUb0hlYWQoc2NyaXB0cywgYXR0ci5tZWRpYVVSTCwgaGFuZGxlQ2FubnlQYXJzZS5zY3JpcHRSZWFkeSk7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIubWVkaWFVUkwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUxpbmtzKGJvZHksIGF0dHIubWVkaWFVUkwpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNoaWxkcy5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoY2hpbGQudGFnTmFtZSA9PT0gJ1NDUklQVCcgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKCdzcmMnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFwcGVuZENoaWxkKGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGhhbmRsZUNhbm55UGFyc2UuaHRtbFJlYWR5KCk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhc3luYzogTG9hZGluZyBhc3luYyBIVE1MIGZhaWxlZCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBzaW1wbGUgd3JhcHBlciB0byBsb2FkIEhUTUwgZmlsZXMgd2l0aCBHRVRcbiAgICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAgICogQHBhcmFtIGNiXG4gICAgICAgICAqL1xuICAgICAgICBmdW5jdGlvbiBsb2FkKHBhdGgsIGNiKSB7XG4gICAgICAgICAgICBkb0FqYXgoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBvblN1Y2Nlc3M6IGZ1bmN0aW9uIChyZXNwb25zZSkge1xuICAgICAgICAgICAgICAgICAgICBjYihyZXNwb25zZS5yZXNwb25zZVRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKlxuICAgICAgICAgKiBAcGFyYW0gcGFyYW1zIHt7XG4gICAgICAgICAqICAgbm9DYWNoZTpib29sZWFuLFxuICAgICAgICAgKiAgIG1ldGhvZDpzdHJpbmd8UE9TVChkZWZhdWx0KSxcbiAgICAgICAgICogICBkYXRhOm9iamVjdHxzdHJpbmcsXG4gICAgICAgICAqICAgcGF0aDpzdHJpbmcsXG4gICAgICAgICAqICAgYXN5bmM6Ym9vbGVhbnx0cnVlKGRlZmF1bHQpLFxuICAgICAgICAgKiAgIG9uUmVxdWVzdDpmdW5jdGlvbiAod2lsbCBiZSBjYWxsZWQgd2l0aCB0aGUgeG1sSFRUUFJlcXVlc3Qgb2JqZWN0IHF1aXRlIGNsb3NlIGJlZm9yZSB0aGUgc2VuZCBtZXRob2QgaXMgY2FsbGVkKSxcbiAgICAgICAgICogICBvbkZhaWx1cmU6ZnVuY3Rpb24sXG4gICAgICAgICAqICAgb25TdWNjZXNzOmZ1bmN0aW9uLFxuICAgICAgICAgKiAgIGNvbnRlbnRUeXBlOnN0cmluZ3xDb250ZW50LVR5cGUoZGVmYXVsdCksXG4gICAgICAgICAqICAgbWltZVR5cGU6c3RyaW5nfHRleHQgcGxhaW4oZGVmYXVsdClcbiAgICAgICAgICogfX1cbiAgICAgICAgICovXG4gICAgICAgICBmdW5jdGlvbiBkb0FqYXgocGFyYW1zKSB7XG4gICAgICAgICAgICB2YXIgY2FsbCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xuICAgICAgICAgICAgdmFyIHVybCA9IHBhcmFtcy5wYXRoO1xuICAgICAgICAgICAgaWYgKHBhcmFtcy5tZXRob2QgPT09ICdHRVQnICYmIHR5cGVvZiBwYXJhbXMuZGF0YSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBhdHRyIGluIHBhcmFtcy5kYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgIHVybCA9IHVybCArICgoL1xcPy8pLnRlc3QodXJsKSA/IFwiJlwiIDogXCI/XCIpICsgYXR0ciArIFwiPVwiICsgcGFyYW1zLmRhdGFbYXR0cl07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHBhcmFtcy5ub0NhY2hlKSB7XG4gICAgICAgICAgICAgICAgdXJsID0gdXJsICsgKCgvXFw/LykudGVzdCh1cmwpID8gXCImXCIgOiBcIj9cIikgKyBcInRzPVwiICsgKG5ldyBEYXRlKCkpLmdldFRpbWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHBhcmFtcy5tZXRob2QgPSBwYXJhbXMubWV0aG9kIHx8ICdQT1NUJztcbiAgICAgICAgICAgIGNhbGwub3BlbihwYXJhbXMubWV0aG9kLCB1cmwsIHBhcmFtcy5hc3luYyAhPT0gZmFsc2UpO1xuXG4gICAgICAgICAgICBpZiAocGFyYW1zLm9uU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIGNhbGwuYWRkRXZlbnRMaXN0ZW5lcihcImxvYWRcIiwgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm9uU3VjY2VzcyhzLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChwYXJhbXMub25GYWlsdXJlKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgZnVuY3Rpb24gKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLm9uRmFpbHVyZShzLnRhcmdldCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGNhbGwuc2V0UmVxdWVzdEhlYWRlcihwYXJhbXMuY29udGVudFR5cGUgfHwgXCJDb250ZW50LVR5cGVcIiwgcGFyYW1zLm1pbWVUeXBlIHx8IFwidGV4dC9wbGFpblwiKTtcblxuICAgICAgICAgICAgLy8gYWxsb3cgdGhlIGNhbGxlciB0byBkbyBzb21lIGV4dHJhIHN0dWZmIG9uIHRoZSByZXF1ZXN0IG9iamVjdFxuICAgICAgICAgICAgaWYgKHBhcmFtcy5vblJlcXVlc3QgJiYgdHlwZW9mIHBhcmFtcy5vblJlcXVlc3QgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMub25SZXF1ZXN0KGNhbGwpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAocGFyYW1zLm1ldGhvZCA9PT0gJ1BPU1QnKSB7XG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kKHBhcmFtcy5kYXRhKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbC5zZW5kKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogYWRkIGEgY2FsbGJhY2suIFNvIHlvdSB3aWxsIGJlIG5vdGlmaWVkIHdoZW4gZmlsZXMgYXJlIGxvYWRlZCBhc3luY2hyb25vdXMuXG4gICAgICAgICAgICAgKiBZb3Ugd2lsbCBiZSBjYWxsZWQgb25seSBvbmNlIGV4Y2VwdCB5b3VyIHJldHVybiB0cnVlIHRoZW4gYXN5bmMgd2lsbCBrZWVwXG4gICAgICAgICAgICAgKiB5b3VyIGNhbGxiYWNrIGluIHRoZSBub3RpZmllciBsaXN0IGFuZCB5b3Ugd2lsbCBiZSBpbmZvcm1lZCBmb3IgZWFjaCBhc3luYyByZXF1ZXN0LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIFRoZSBhc3luYyBtb2R1bGUgd2lsbCBjYWxsIGVhY2ggY2FsbGJhY2sgd2l0aCB0aGUgYWN0dWFsIGF0dHIuIFNvIHlvdSBoYXZlIHRoZSBjb250cm9sXG4gICAgICAgICAgICAgKiBob3cgb2Z0ZW4geW91IHdpbGwgYmUgbm90aWZpZWQuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogTWlnaHQgYmUgY2hhbmdlZCBpbiB0aGUgZnV0dXJlIHZlcnNpb24gb2YgYXN5bmM6XG4gICAgICAgICAgICAgKiBDdXJyZW50bHkgdGhpcyBpcyBvbmx5IGV4ZWN1dGVkIGZvciBjYW5ueSBtb2R1bGVzIHdoaWNoIGFyZSBsb2FkZWQgZnJvbSB0aGUgRE9NIGRpcmVjdGx5LlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBmY1xuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBwdXNoTG9hZENCIDogZnVuY3Rpb24gKGZjKSB7XG4gICAgICAgICAgICAgICAgcHVzaExvYWRDQnMucHVzaChmYyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEbyBhIHNpbXBsZSBhamF4IGNhbGwuXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIHBhcmFtcyB7e1xuICAgICAgICAgICAgICogICBub0NhY2hlOmJvb2xlYW4sXG4gICAgICAgICAgICAgKiAgIG1ldGhvZDpzdHJpbmd8UE9TVChkZWZhdWx0KSxcbiAgICAgICAgICAgICAqICAgZGF0YTpvYmplY3Qsc3RyaW5nLFxuICAgICAgICAgICAgICogICBhc3luYzpib29sZWFufHRydWUoZGVmYXVsdCksXG4gICAgICAgICAgICAgKiAgIHBhdGg6c3RyaW5nLFxuICAgICAgICAgICAgICogICBvblJlcXVlc3Q6ZnVuY3Rpb24gKHdpbGwgYmUgY2FsbGVkIHdpdGggdGhlIHhtbEhUVFBSZXF1ZXN0IG9iamVjdCBxdWl0ZSBjbG9zZSBiZWZvcmUgdGhlIHNlbmQgbWV0aG9kIGlzIGNhbGxlZCksXG4gICAgICAgICAgICAgKiAgIG9uRmFpbHVyZTpmdW5jdGlvbixcbiAgICAgICAgICAgICAqICAgb25TdWNjZXNzOmZ1bmN0aW9uLFxuICAgICAgICAgICAgICogICBjb250ZW50VHlwZTpzdHJpbmd8Q29udGVudC1UeXBlKGRlZmF1bHQpLFxuICAgICAgICAgICAgICogICBtaW1lVHlwZTpzdHJpbmd8dGV4dCBwbGFpbihkZWZhdWx0KVxuICAgICAgICAgICAgICogfX1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZG9BamF4OiBkb0FqYXgsXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGF0dHIge3tcbiAgICAgICAgICAgICAqICB1cmw6c3RyaW5nLFxuICAgICAgICAgICAgICogIG1lZGlhVVJMOnN0cmluZ1xuICAgICAgICAgICAgICogfX1cbiAgICAgICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsb2FkSFRNTCA6IGxvYWRIVE1MLFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBEZXByZWNhdGVkOiB1c2UgbG9hZEhUTUwgaW5zdGVhZFxuICAgICAgICAgICAgICogQHBhcmFtIHBhdGhcbiAgICAgICAgICAgICAqIEBwYXJhbSBjYlxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBsb2FkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdhc3luYzpsb2FkIGZ1bmN0aW9uIGxvYWQgaXMgZGVwcmVjYXRlZC4gVXNlIGxvYWRIVE1MIGluc3RlYWQnKTtcbiAgICAgICAgICAgICAgICBsb2FkLmFwcGx5KG51bGwsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBjYW5ueSdzIGFkZCBtZXRob2RcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGF0dHJcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgYWRkOiBmdW5jdGlvbiAobm9kZSwgYXR0cikgeyAgICAvLyBwYXJ0IG9mIGFwaVxuICAgICAgICAgICAgICAgIC8vIFRPRE8gaW1wbGVtZW50IGxvZ2ljIGZvciBsb2FkaW5nIGl0IGRpcmVjdGx5IGZyb20gaHRtbFxuICAgICAgICAgICAgICAgIGlmIChhdHRyLmhhc093blByb3BlcnR5KCd1cmwnKSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlYWR5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlc1RvTG9hZC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHI6IGF0dHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEhUTUwobm9kZSwgYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVhZHk6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgb2JqLCBjYkNvdW50ID0gZmlsZXNUb0xvYWQubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHdoaWxlIChmaWxlc1RvTG9hZC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGZpbGVzVG9Mb2FkLnNwbGljZSgwLCAxKVswXTtcbiAgICAgICAgICAgICAgICAgICAgbG9hZEhUTUwob2JqLm5vZGUsIG9iai5hdHRyLCBmdW5jdGlvbiAoYXR0cikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGtlZXBQdXNoQ0IgPSBbXSwgdG1wQ2I7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYkNvdW50LS07XG4gICAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAocHVzaExvYWRDQnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcENiID0gcHVzaExvYWRDQnMuc3BsaWNlKDAsIDEpWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBDYihhdHRyKSA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZWVwUHVzaENCLnB1c2godG1wQ2IpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hMb2FkQ0JzID0ga2VlcFB1c2hDQjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH0oKSk7XG4gICAgLy8gZXhwb3J0IGFzIG1vZHVsZSBvciBiaW5kIHRvIGdsb2JhbFxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoJ2V4cG9ydHMnKSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFzeW5jO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNhbm55LmFkZCgnYXN5bmMnLCBhc3luYyk7XG4gICAgfVxuXG59KCkpOyIsIi8qZ2xvYmFsIGNhbm55ICovXHJcbi8qanNsaW50IGJyb3dzZXI6IHRydWUqL1xyXG5cclxuLyoqXHJcbiAqIEUuZy46IGNhbm55LW1vZD1cImZsb3dDb250cm9sXCIgY2FubnktdmFyPVwieyd2aWV3JyA6ICd2aWV3TmFtZSd9XCJcclxuICpcclxuICogeW91IGNhbiBhY3RpdmF0ZSBhIGluaXRpYWwgdmlldyB3aXRoIGEgYW5jaG9yIGluIHRoZSBVUkwgZS5nLjogeW91cmRvbWFpbi5odG1sI3ZpZXdUb1Nob3dcclxuICogT3IgcGFzcyBhIGNvbW1hIHNlcGFyYXRlZCBtb2R1bGUgbGlzdCBmb3IgYWN0aXZhdGUgbW9yZSBtb2R1bGUgI3ZpZXdUb1Nob3csb3RoZXJWaWV3LlxyXG4gKlxyXG4gKiBUT0RPIG1hZGUgaXQgcG9zc2libGUgdG8gc3VtbWFyaXplIHZpZXdzIHdpdGggb25lIGlkZW50aWZpZXIuXHJcbiAqIEluc3RlYWQgb2YgY2FsbDogY2FubnkuZmxvd0NvbnRyb2wuc2hvdygndmlldzEnLCAndmlldzInLCAndmlldzMnKSBjYWxsIGNhbm55LmZsb3dDb250cm9sLnNob3coJ3ZpZXcnKS5cclxuICpcclxuICogVE9ETyBhZGQgYSBoaWRlIG1ldGhvZCB0aGF0IGp1c3QgaGlkZSB0aGUgc3BlY2lmaWMgZWxlbWVudC5cclxuICpcclxuICogVE9ETyBoYW5kbGUgdGhlIGZhZGUgaW4gYW5kIG91dCB2aWEgQ1NTIGNsYXNzZXMgLSBhbmQgdXNlIHRyYW5zaXRpb25zIGZvciBpdFxyXG4gKi9cclxuKGZ1bmN0aW9uICgpIHtcclxuICAgIFwidXNlIHN0cmljdFwiO1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogd3JhcHMgdHJhbnNpdGlvbmVuZCBldmVudCB2ZW5kb3IgaW1wbGVtZW50YXRpb25cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gb25UcmFuc2l0aW9uRW5kT25jZShub2RlLCBjYikge1xyXG4gICAgICAgIHZhciBldmVudCA9IChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdHlsZS53ZWJraXRUcmFuc2l0aW9uICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gJ3dlYmtpdFRyYW5zaXRpb25FbmQnO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlLnN0eWxlLnRyYW5zaXRpb24gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAndHJhbnNpdGlvbmVuZCc7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0oKSksXHJcbiAgICAgICAgICAgIGxpc3RlbmVyID0gZnVuY3Rpb24oZSkge1xyXG4gICAgICAgICAgICAgICAgZS50YXJnZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihlLnR5cGUsIGxpc3RlbmVyKTtcclxuICAgICAgICAgICAgICAgIGNiKGUpO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgY2IoKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgdmFyIGZsb3dDb250cm9sSW5zdGFuY2UgPSBmdW5jdGlvbiAoZmNJbnN0YW5jZU5hbWUpIHtcclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlTmFtZSA9IGZjSW5zdGFuY2VOYW1lLFxyXG4gICAgICAgICAgICAgICAgLy8gZmxhZyB0byBzYXZlIGlmIHRoZSBpbml0aWFsIHF1ZXVlIGlzIGFscmVhZHkgaW5pdGlhbGl6ZWQgb3Igbm90XHJcbiAgICAgICAgICAgICAgICBzaG93SW5pdGlhbFZpZXdDb21wbGV0ZSA9IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgb25TaG93SW5pdGlhbFZpZXdDb21wbGV0ZSA9IFtdLFxyXG4gICAgICAgICAgICAgICAgbW9kVmlld3MgPSB7fSwgLy8gc2F2ZXMgbW9kdWxlIHZpZXdzXHJcbiAgICAgICAgICAgICAgICBnZXRWaWV3QW5jaG9yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBoYXNoID0gbG9jYXRpb24uaGFzaCB8fCBudWxsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICByeCA9IG5ldyBSZWdFeHAoJ1teYS16QS1aLV8sXScsICdnJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hTdWI7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChoYXNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc2hTdWIgPSBoYXNoLnN1YnN0cigxKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc2hTdWIuc2VhcmNoKHJ4KSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYXNoU3ViID0gaGFzaFN1Yi5zdWJzdHJpbmcoMCwgaGFzaFN1Yi5zZWFyY2gocngpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gaGFzaFN1Yi5zcGxpdCgnLCcpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGhhc2g7XHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgZ2V0QWxsTW9kdWxlQ2hpbGRyZW5zID0gZnVuY3Rpb24gKGNOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0ZXN0IHNlbGVjdG9yIGlmIHdlIGhhdmUgbW9yZSB0aGFuIG9uZSBtb2R1bGUgaW4gY2FubnktbW9kXHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoaWxkcmVuID0gY05vZGUucXVlcnlTZWxlY3RvckFsbCgnW2Nhbm55LW1vZCo9JyArIGluc3RhbmNlTmFtZSArICddJyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGZjX2NoaWxkTm9kZXMgPSB7fTtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNOb2RlLmhhc0NoaWxkTm9kZXMoKSkge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChjTm9kZS5jaGlsZHJlbikuZm9yRWFjaChmaW5kQ2hpbGRyZW4pO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobW9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBhdHRyVmFsdWUsIHZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVhZCBhdHRyaWJ1dGVzIHNob3VsZCBiZSBhIHBhcnQgb2YgY2FubnkgZnVuY3Rpb25hbGl0eVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBhdHRyVmFsdWUgPSBtb2QuZ2V0QXR0cmlidXRlKCdjYW5ueS12YXInKS5zcGxpdChcIlxcJ1wiKS5qb2luKCdcXFwiJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgvOi8udGVzdChhdHRyVmFsdWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjb3VsZCBiZSBhIEpTT05cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcgPSBKU09OLnBhcnNlKGF0dHJWYWx1ZSkudmlldztcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZpZXcgPSBhdHRyVmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZmNfY2hpbGROb2Rlc1t2aWV3XSA9IG1vZDtcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmNfY2hpbGROb2RlcztcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAqIEVhY2ggZmxvd0NvbnRyb2wgbm9kZSB3aWxsIGVuZCB1cCBpbiBhIGZsb3dDb250cm9sTW9kdWxlLlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXHJcbiAgICAgICAgICAgICAgICAgKiBAcGFyYW0gYXR0clxyXG4gICAgICAgICAgICAgICAgICogQHJldHVybnMge3toYXNDaGlsZHJlbldpdGhOYW1lOiBoYXNDaGlsZHJlbldpdGhOYW1lLCBnZXRWaWV3TmFtZTogZ2V0Vmlld05hbWUsIHNob3c6IHNob3csIGhpZGU6IGhpZGUsIGZhZGVPdXQ6IGZhZGVPdXQsIGdldE5vZGU6IGdldE5vZGUsIGZhZGVJbjogZmFkZUlufX1cclxuICAgICAgICAgICAgICAgICAqL1xyXG4gICAgICAgICAgICAgICAgZmxvd0NvbnRyb2xNb2R1bGUgPSBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBmbG93Q29udHJvbENoaWxkTm9kZXMgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgPSBmYWxzZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyZW50Vmlld3MgPSBmYy5nZXRQYXJlbnROb2RlKGF0dHIudmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gc2F2ZXMgYWxsIGNoaWxkcmVuIGluIGEgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICAgICAgZmxvd0NvbnRyb2xDaGlsZE5vZGVzID0gZ2V0QWxsTW9kdWxlQ2hpbGRyZW5zKG5vZGUpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ2Zsb3dDb250cm9sQ2hpbGROb2RlczonLCBmbG93Q29udHJvbENoaWxkTm9kZXMpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhc0NoaWxkcmVuV2l0aE5hbWUgOiBmdW5jdGlvbiAodmlld05hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmbG93Q29udHJvbENoaWxkTm9kZXMuaGFzT3duUHJvcGVydHkodmlld05hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRWaWV3TmFtZSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhdHRyLnZpZXc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpc3BsYXkgOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBjYWxsIHBhcmVudHNcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGZhZGUgaW5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3R5bGUuZGlzcGxheSA9ICcnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93IDogZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyZW50Vmlld3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJlbnRWaWV3cy5mb3JFYWNoKGZ1bmN0aW9uIChmY19tb2R1bGUpIHtcclxuLy8gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCdwYXJlbnRWaWV3cycsIGZjX21vZHVsZS5nZXRWaWV3TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmNfbW9kdWxlLmRpc3BsYXkoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYXN5bmMgJiYgYXR0ci5oYXNPd25Qcm9wZXJ0eSgnYXN5bmMnKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbm55LmFzeW5jLmxvYWRIVE1MKG5vZGUsIHt1cmwgOiBhdHRyLmFzeW5jfSwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci53aGlza2VyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2Fubnkud2hpc2tlciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2Fubnkud2hpc2tlci5hZGQobm9kZSwgYXR0ci53aGlza2VyKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcImZsb3dDb250cm9sOnRyeSBleGVjdXRlIHdoaXNrZXIgYnV0IG5vIHdoaXNrZXIgbW9kdWxlIGlzIHJlZ2lzdGVyZWQgb24gY2FubnkuXCIpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNiKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLmRpc3BsYXkgPSAnJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYiAmJiBjYigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBoaWRlIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlT3V0IDogZnVuY3Rpb24gKGNiKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYy5mYWRlT3V0KG5vZGUsIGNiIHx8IGZ1bmN0aW9uICgpIHt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0Tm9kZSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBmYWRlSW4gOiBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRWaWV3cykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudFZpZXdzLmZvckVhY2goZnVuY3Rpb24gKGZjX21vZHVsZSkge1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3BhcmVudFZpZXdzJywgZmNfbW9kdWxlLmdldFZpZXdOYW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmY19tb2R1bGUuZGlzcGxheSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhc3luYyAmJiBhdHRyLmhhc093blByb3BlcnR5KCdhc3luYycpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FubnkuYXN5bmMubG9hZEhUTUwobm9kZSwge3VybCA6IGF0dHIuYXN5bmN9LCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChhdHRyLndoaXNrZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5ueS53aGlza2VyICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5ueS53aGlza2VyLmFkZChub2RlLCBhdHRyLndoaXNrZXIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiZmxvd0NvbnRyb2w6dHJ5IGV4ZWN1dGUgd2hpc2tlciBidXQgbm8gd2hpc2tlciBtb2R1bGUgaXMgcmVnaXN0ZXJlZCBvbiBjYW5ueS5cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMuZmFkZUluKG5vZGUsICBjYiB8fCBmdW5jdGlvbiAoKSB7fSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXN5bmMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYy5mYWRlSW4obm9kZSwgIGNiIHx8IGZ1bmN0aW9uICgpIHt9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIHNob3dJbml0aWFsVmlldyA9IGdldFZpZXdBbmNob3IoKSxcclxuICAgICAgICAgICAgICAgIGZjID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIGdldCBhbGwgcGFyZW50IG1vZHVsZXMgZnJvbSB0aGUgZ2l2ZW4gdmlld05hbWVcclxuICAgICAgICAgICAgICAgICAgICBnZXRQYXJlbnROb2RlIDogZnVuY3Rpb24gKHZpZXdOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciBxdWV1ZSA9IE9iamVjdC5rZXlzKG1vZFZpZXdzKSwgbCwgaSwgcGFyZW50cyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gcXVldWUubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlld05hbWUgIT09IHF1ZXVlW2ldICYmIG1vZFZpZXdzW3F1ZXVlW2ldXVswXS5oYXNDaGlsZHJlbldpdGhOYW1lKHZpZXdOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmVudHMucHVzaChtb2RWaWV3c1txdWV1ZVtpXV1bMF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBwYXJlbnRzLmxlbmd0aCA9PT0gMCA/IG51bGwgOiBwYXJlbnRzO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gcGFzc2VzIGEgdmlldyBsaXN0IGFuZCBjb21wbGV0ZSB0aGUgbGlzdCB3aXRoIGFsbCBwYXJlbnQgbm9kZSBuYW1lc1xyXG4gICAgICAgICAgICAgICAgICAgIGFkZFBhcmVudHMgOiBmdW5jdGlvbiAodmlld3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV4dFZpZXdzID0gdmlld3MsIGksIGwsIHBOb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaEV4dFZpZXdzID0gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXh0Vmlld3MuaW5kZXhPZihuYW1lKSA9PT0gLTEpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0Vmlld3MucHVzaChuYW1lKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRkUGFyZW50VmlldyA9IGZ1bmN0aW9uICh2aWV3TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gY2FsbCBlbmRzIGFsd2F5cyB3aXRoIG51bGwgLSB2aWV3TmFtZSBpcyB0b3AgcGFyZW50XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBWaWV3TmFtZSA9IGZjLmdldFBhcmVudE5vZGUodmlld05hbWUpO1xyXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZygndmlld05hbWU6ICcgKyB2aWV3TmFtZSwgJ3BWaWV3TmFtZSAnICsgcFZpZXdOYW1lICk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBWaWV3TmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwVmlld05hbWUuZm9yRWFjaChmdW5jdGlvbiAoZmNfbW9kdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHdoaWxlIGhhcyBwYXJlbnQgYWRkIGl0IHRvIHRoZSBleHRWaWV3c1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcHVzaEV4dFZpZXdzKGZjX21vZHVsZS5nZXRWaWV3TmFtZSgpKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhcmVudFZpZXcoZmNfbW9kdWxlLmdldFZpZXdOYW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBsID0gdmlld3MubGVuZ3RoO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwTm9kZSA9IGZjLmdldFBhcmVudE5vZGUodmlld3NbaV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcE5vZGUuZm9yRWFjaChmdW5jdGlvbiAoZmNfbW9kdWxlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHB1c2hFeHRWaWV3cyhmY19tb2R1bGUuZ2V0Vmlld05hbWUoKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIGZhciB3ZSBoYXZlIHBhcmVudHMgZG8gaXQgcmVjdXJzaXZlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gbm90IG5lZWRlZCBlYWNoIHBhcmVudCB3aWxsIGRvIGl0IGJ5IG93biAtXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFkZFBhcmVudFZpZXcoZmNfbW9kdWxlLmdldFZpZXdOYW1lKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRWaWV3cztcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZhZGVPdXQgOiBmdW5jdGlvbiAobm9kZSwgY2IpIHtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmKG5vZGUuc3R5bGUuZGlzcGxheSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jbGFzc0xpc3QuYWRkKCdjLWZsb3dDb250cm9sJyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2ZhZGUtb3V0Jyk7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnYy1mbG93Q29udHJvbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnZmFkZS1vdXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgMzAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIGZhZGVJbiA6IGZ1bmN0aW9uIChub2RlLCBjYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBmYWRlIGluIGRvZXMgbm90IHdvcmsgcHJvcGVybHlcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdHlsZS5kaXNwbGF5ID0gJyc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LmFkZCgnYy1mbG93Q29udHJvbCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5hZGQoJ2ZhZGUtaW4nKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmNsYXNzTGlzdC5yZW1vdmUoJ2MtZmxvd0NvbnRyb2wnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuY2xhc3NMaXN0LnJlbW92ZSgnZmFkZS1pbicpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IoKTtcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cmlnZ2VyIHJlZmxvdyB0byBmaXggdGhlIGJsYWNrIGJveGVzIGlzc3VlIEZUVFdPLTEyNDlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IGNoZWNrIGlmIHRoaXMgY2FuIGJlIGF2b2lkZWQgb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBib3ggPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcudC1jZW50ZXJCb3gtY29udGVudCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGJveCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJveC5zdHlsZS5vcGFjaXR5ID0gMC45OTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBib3guc3R5bGUub3BhY2l0eSA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgNTApO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICB9LCAzMDApO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBleHQgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBpbm5lck5vZGVcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcmV0dXJucyB7e3JlbW92ZTogcmVtb3ZlfX1cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBwcm9ncmVzcyA6IGZ1bmN0aW9uIChub2RlLCBpbm5lck5vZGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5ld05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKSwgY2VudGVyTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpLCB0eHROb2RlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnN0eWxlLnBvc2l0aW9uID0gJ3JlbGF0aXZlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zdHlsZS5vcGFjaXR5ID0gJzAuNic7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gJyM2NjYnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgbmV3Tm9kZS5zdHlsZS50b3AgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLmxlZnQgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLndpZHRoID0gbm9kZS5vZmZzZXRXaWR0aCArICdweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ld05vZGUuc3R5bGUuaGVpZ2h0ID0gbm9kZS5vZmZzZXRIZWlnaHQgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBuZXdOb2RlLnN0eWxlLmJvcmRlclJhZGl1cyA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKG5vZGUsIG51bGwpLmJvcmRlclJhZGl1cztcclxuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck5vZGUuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJOb2RlLnN0eWxlLnRvcCA9IChub2RlLm9mZnNldEhlaWdodCAvIDIpIC0gMzAgKyAncHgnO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJOb2RlLnN0eWxlLndpZHRoID0gbm9kZS5vZmZzZXRXaWR0aCArICdweCc7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNlbnRlck5vZGUuc3R5bGUudGV4dEFsaWduID0gJ2NlbnRlcic7XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5uZXJOb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjZW50ZXJOb2RlLmFwcGVuZENoaWxkKGlubmVyTm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChuZXdOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChjZW50ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSA6IGZ1bmN0aW9uIChkZWxheSwgY2IpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChuZXdOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVDaGlsZChjZW50ZXJOb2RlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LCBkZWxheSB8fCAwKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYWRlT3V0IDogZnVuY3Rpb24gKGRlbGF5LCBjYikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYy5mYWRlT3V0KG5ld05vZGUsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQobmV3Tm9kZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnJlbW92ZUNoaWxkKGNlbnRlck5vZGUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IgJiYgY2IoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSwgZGVsYXkgfHwgMCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAqIEB0eXBlIHt7bW9kOiB7fSwgY3JlYXRlTmV3SW5zdGFuY2U6IGNyZWF0ZU5ld0luc3RhbmNlLCByZWFkeTogcmVhZHksIGFkZDogYWRkLCBzaG93OiBzaG93LCBmYWRlSW46IGZhZGVJbiwgc2hvd0ltbWVkaWF0ZWx5OiBzaG93SW1tZWRpYXRlbHksIG92ZXJsYXk6IG92ZXJsYXl9fVxyXG4gICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICBhcGkgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbW9kIDogbW9kVmlld3MsIC8vIHBhcnQgb2YgYXBpXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogdGhpcyBtZXRob2QgY291bGQgYmUgdXNlZCB0byBjcmVhdGUgbmV3IGluc3RhbmNlcyBvZiBmbG93Q29udHJvbCAob25seSBuZWVkZWQgaWYgeW91XHJcbiAgICAgICAgICAgICAgICAgICAgICogbG9hZCB0aGlzIHNjcmlwdCBkaXJlY3RseSB3aXRob3V0IHJlcXVpcmUpXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG5hbWUgKHVuaXF1ZSBtb2R1bGUgbmFtZSlcclxuICAgICAgICAgICAgICAgICAgICAgKiovXHJcbiAgICAgICAgICAgICAgICAgICAgY3JlYXRlTmV3SW5zdGFuY2UgOiBmdW5jdGlvbiAobmFtZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmxvd0NvbnRyb2wobmFtZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICByZWFkeSA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG1vZE5hbWVzID0gT2JqZWN0LmtleXMobW9kVmlld3MpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEluaXRpYWxWaWV3Q29tcGxldGVRdWV1ZSA9IHRydWUsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsID0gbW9kTmFtZXMubGVuZ3RoLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3dJbml0aWFsVmlldyAmJiBsID4gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gY2hlY2sgaWYgc2hvd0luaXRpYWxWaWV3IGNvbnRhaW5zIGEgcmVnaXN0ZXJlZCBtb2R1bGVcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBmb3IgZXhpc3RpbmcgbmFtZSBpbiBzaG93SW5pdGlhbFZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoc2hvd0luaXRpYWxWaWV3LmluZGV4T2YobW9kTmFtZXNbaV0pICE9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SW5pdGlhbFZpZXcucHVzaChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNob3dJbml0aWFsVmlld0NvbXBsZXRlLmZvckVhY2goZnVuY3Rpb24oZmMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93SW5pdGlhbFZpZXdDb21wbGV0ZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbEluaXRpYWxWaWV3Q29tcGxldGVRdWV1ZSA9IGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcGkuc2hvd0ltbWVkaWF0ZWx5LmFwcGx5KG51bGwsIHNob3dJbml0aWFsVmlldyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxJbml0aWFsVmlld0NvbXBsZXRlUXVldWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uU2hvd0luaXRpYWxWaWV3Q29tcGxldGUuZm9yRWFjaChmdW5jdGlvbihmYykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dJbml0aWFsVmlld0NvbXBsZXRlID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmYygpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgICAgIC8qKlxyXG4gICAgICAgICAgICAgICAgICAgICAqIENhbGxzIHRoZSBnaXZlbiBmdW5jdGlvbiBhZnRlciBsb2FkaW5nIGFsbCBpbml0aWFsIHZpZXdzLlxyXG4gICAgICAgICAgICAgICAgICAgICAqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIGZjXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgb25TaG93SW5pdGlhbFZpZXdDb21wbGV0ZSA6IGZ1bmN0aW9uKGZjKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBwYXNzZWQgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWxzbyBhZnRlciBpbml0aWFsaXNhdGlvblxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXNob3dJbml0aWFsVmlld0NvbXBsZXRlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvblNob3dJbml0aWFsVmlld0NvbXBsZXRlLnB1c2goZmMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZmMoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICpcclxuICAgICAgICAgICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxyXG4gICAgICAgICAgICAgICAgICAgICAqIEBwYXJhbSBhdHRyIHt7dmlldzooaWRlbnRpZmllciksfX1cclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikgeyAgICAvLyBwYXJ0IG9mIGFwaVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1vZFZpZXdzW2F0dHIudmlld10pIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZFZpZXdzW2F0dHIudmlld10gPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RWaWV3c1thdHRyLnZpZXddLnB1c2goZmxvd0NvbnRyb2xNb2R1bGUobm9kZSwgYXR0cikpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQGRlcHJlY2F0ZWQgd2lsbCBoYW5kbGUgc2hvd0ltbWVkaWF0ZWx5IGluIG5lYXIgZnV0dXJlXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgc2hvdyA6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYXBpLmZhZGVJbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG4gICAgICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgLyoqXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG5hbWUgKGFyZ3VtZW50cyBsaXN0IG9mIHZpZXdzIHRvIHNob3cpXHJcbiAgICAgICAgICAgICAgICAgICAgICovXHJcbiAgICAgICAgICAgICAgICAgICAgZmFkZUluIDogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHNob3dNb2RzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcXVldWUgPSBPYmplY3Qua2V5cyhtb2RWaWV3cyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNvdW50ID0gMCwvLyA9IHF1ZXVlLmxlbmd0aCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZhZGVJbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93TW9kcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2R1bGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZFZpZXdzLmhhc093blByb3BlcnR5KG1vZHVsZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZFZpZXdzW21vZHVsZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLmZhZGVJbihmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlXHJcbi8vICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ0ZBREUgSU4gRE9ORScpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGNvdW50IGNhbGxiYWNrcyBhbmQgaGFuZGxlIGl0ID9cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaWYgbGFzdCBwYXJhbSBpcyBmdW5jdGlvbiB0aGFuIGhhbmRsZSBpdCBhcyBjYWxsYmFja1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygc2hvd01vZHNbc2hvd01vZHMubGVuZ3RoIC0gMV0gPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd01vZHNbc2hvd01vZHMubGVuZ3RoIC0gMV0oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93TW9kcyA9IGZjLmFkZFBhcmVudHMoc2hvd01vZHMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2aWV3KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNvdW50ICs9IG1vZFZpZXdzW3ZpZXddLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgcmVnaXN0ZXJlZCBtb2R1bGVzXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0ZXJhdGUgb3ZlciBhbGwgaW5zdGFuY2VzIG9mIHRoZSBzYW1lIHZpZXdcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZFZpZXdzW3ZpZXddLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhpZGUgYWxsIChleGNlcHQgaW5jb21pbmcgYW5kIHBhcmVudHMpIFRPRE8gYnV0IG9ubHkgdGhlIHBhcmVudHMgb2YgdGhlIG1vZHVsZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG93TW9kcy5pbmRleE9mKHZpZXcpID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvYmouZmFkZU91dChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZUNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocXVldWVDb3VudCA8PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFkZUluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlQ291bnQtLTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHF1ZXVlQ291bnQgPD0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmFkZUluKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAvKipcclxuICAgICAgICAgICAgICAgICAgICAgKiBAZGVwcmVjYXRlZCB1c2Ugc2hvdyBpbnN0ZWFkXHJcbiAgICAgICAgICAgICAgICAgICAgICogQHBhcmFtIG5hbWVcclxuICAgICAgICAgICAgICAgICAgICAgKi9cclxuICAgICAgICAgICAgICAgICAgICBzaG93SW1tZWRpYXRlbHkgOiBmdW5jdGlvbiAoKSB7ICAgIC8vIG1vZHVsZSBzcGVjaWZpY1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2hvd01vZHMgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cyksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBxdWV1ZSA9IE9iamVjdC5rZXlzKG1vZFZpZXdzKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvdW50Q2IgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBjYiwgbGVuZ3RoID0gMDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiBsYXN0IHBhcmFtIGlzIGZ1bmN0aW9uIHRoYW4gaGFuZGxlIGl0IGFzIGNhbGxiYWNrXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzaG93TW9kc1tzaG93TW9kcy5sZW5ndGggLSAxXSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYiA9IHNob3dNb2RzW3Nob3dNb2RzLmxlbmd0aCAtIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb3VudFVwIDogZnVuY3Rpb24gKG51bSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoICs9IG51bTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkdWNlIDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGVuZ3RoLS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2IgJiYgbGVuZ3RoIDw9IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYigpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSksXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaG93ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNb2RzLmZvckVhY2goZnVuY3Rpb24gKG1vZHVsZSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobW9kVmlld3MuaGFzT3duUHJvcGVydHkobW9kdWxlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY291bnRDYi5jb3VudFVwKG1vZFZpZXdzW21vZHVsZV0ubGVuZ3RoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZFZpZXdzW21vZHVsZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2JqLnNob3coY291bnRDYi5yZWR1Y2UpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNob3dNb2RzID0gZmMuYWRkUGFyZW50cyhzaG93TW9kcyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGhpZGUgYWxsIChleGNlcHQgaW5jb21pbmcpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXVlLmZvckVhY2goZnVuY3Rpb24gKHZpZXcpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1vZFZpZXdzW3ZpZXddLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzaG93TW9kcy5pbmRleE9mKG9iaikgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9iai5oaWRlKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBzaG93KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgICAgICBvdmVybGF5IDogZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIG5vZGU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGl0J3Mgb3duIG1vZHVsZT9cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG1vZFZpZXdzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlID0gbW9kVmlld3NbbmFtZV0uZ2V0Tm9kZSgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5hbWUpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnkgOiBmdW5jdGlvbiAobmFtZSwgdGV4dCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBleHRbbmFtZV0obm9kZSwgdGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIGFwaTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZsb3dDb250cm9sID0gKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGluc3RhbmNlcyA9IHt9O1xyXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG5hbWUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBpbnN0YW5jZSxcclxuICAgICAgICAgICAgICAgICAgICBkZWYgPSBuYW1lIHx8ICdmbG93Q29udHJvbCc7XHJcbiAgICAgICAgICAgICAgICBpZiAoaW5zdGFuY2VzLmhhc093blByb3BlcnR5KGRlZikpIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tkZWZdO1xyXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZXNbZGVmXSA9IGZsb3dDb250cm9sSW5zdGFuY2UoZGVmKTtcclxuICAgICAgICAgICAgICAgICAgICBpbnN0YW5jZSA9IGluc3RhbmNlc1tkZWZdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0oKSk7XHJcbiAgICAvLyBleHBvcnQgYXMgbW9kdWxlIG9yIGJpbmQgdG8gZ2xvYmFsXHJcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHsgbW9kdWxlLmV4cG9ydHMgPSBmbG93Q29udHJvbDsgfSBlbHNlIHtjYW5ueS5hZGQoJ2Zsb3dDb250cm9sJywgZmxvd0NvbnRyb2woJ2Zsb3dDb250cm9sJykpOyB9XHJcblxyXG59KCkpOyIsIi8qZ2xvYmFsIGNhbm55ICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlKi9cblxuLyoqXG4gKiByZXBlYXRcbiAqXG4gKiBFLmcuXG4gKiAgPGRpdiBjYW5ueS1tb2Q9XCJyZXBlYXRcIiBjYW5ueS12YXI9XCJ7J2Zvcic6J2l0ZW0nLCAnaW4nOidwYXRoLnRvLmxpc3QnfVwiPlxuICogICAgIDxwPkRBVEE6IHt7aXRlbX19KTwvcD5cbiAqICA8L2Rpdj5cbiAqICBvcjpcbiAqICA8ZGl2IGNhbm55LW1vZD1cInJlcGVhdFwiIGNhbm55LXZhcj1cInsnZm9yJzonb2JqZWN0SXRlbScsICdpbic6J3BhdGgudG8ub2JqZWN0J31cIj5cbiAqICAgICA8cD5EQVRBIEZPTzoge3tvYmplY3RJdGVtLmZvb319KTwvcD5cbiAqICAgICA8cD5EQVRBIEJBUjoge3tvYmplY3RJdGVtLmJhcn19KTwvcD5cbiAqICA8L2Rpdj5cbiAqXG4gKiBmb3I6XG4gKiBpcyB0aGUgbmFtZSBvZiB0aGUgaXRlcmF0aW5nIGl0ZW0gdG8gaGF2ZSBhY2Nlc3MgZnJvbSB0aGUgRE9NLlxuICpcbiAqIGluOlxuICogaXMgdGhlIHNvdXJjZSB3aGVyZSByZXBlYXQgY2FuIGZpbmQgdGhlIGFycmF5LlxuICogSXQgYWNjZXB0cyBmdW5jdGlvbnMsIGFycmF5LCBhbmQgb2JqZWN0cyBwb2ludGVyXG4gKiAtIG9iamVjdDoga2VlcCBpbiBtaW5kIHRoYXQgb2JqZWN0IGhhcyBubyBzcGVjaWZpYyBzb3J0aW5nXG4gKiAtIGFycmF5OlxuICogLSBmdW5jdGlvbjogcmVwZWF0IHdpbGwgY2FsbCBpdCB3aXRoIHRoZSBmb2xsb3dpbmcgcGFyYW1ldGVyOlxuICogICogZnVuY3Rpb24gd2hpY2ggbmVlZHMgdG8gYmUgY2FsbGVkIHdpdGggdGhlIG9iamVjdCBvciBsaXN0XG4gKiAgKiAuLi5cbiAqXG4gKiAgVE9ETzogYWRkIGV4YW1wbGUgdG8gZ2V0IGRhdGEgZGlyZWN0IGZyb21cbiAqICAgKiBhIGxpc3Qgb2YgZnVuY3Rpb25cbiAqICAgKiBhIG9iamVjdCB3aGljaCBjb250YWluIGZ1bmN0aW9uc1xuICpcbiAqL1xuKGZ1bmN0aW9uICgpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgb3BlbkNoYXIgPSAneycsXG4gICAgICAgIGVuZENoYXIgID0gJ30nLFxuICAgICAgICBFU0NBUEVfUkUgPSAvWy0uKis/XiR7fSgpfFtcXF1cXC9cXFxcXS9nLFxuICAgICAgICByZXBlYXQgPSAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIEJJTkRJTkdfUkUgPSBnZXRSZWdleCgpO1xuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICBQYXJzZSBhIHBpZWNlIG9mIHRleHQsIHJldHVybiBhbiBhcnJheSBvZiB0b2tlbnNcbiAgICAgICAgICAgICAqICBUT0RPIHJlZmFjdG9yIG1ldGhvZFxuICAgICAgICAgICAgICogIEBwYXJhbSB0ZXh0XG4gICAgICAgICAgICAgKiAgQHJldHVybiBbe2tleTpTdHJpbmcsIGh0bWw6Ym9vbGVhbn1dXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUJJTkRJTkdfUkUudGVzdCh0ZXh0KSkge3JldHVybiBudWxsOyB9XG4gICAgICAgICAgICAgICAgdmFyIG0sIGksIHRva2VuLCBtYXRjaCwgdG9rZW5zID0gW10sIG9yaWcgPSB7dGV4dDogdGV4dCwgaWR4IDogMH0sIHRleHRPYmplY3Q7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IGJvc3M6IHRydWUgKi9cbiAgICAgICAgICAgICAgICB3aGlsZSAobSA9IHRleHQubWF0Y2goQklORElOR19SRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0ge2NvbmNhdCA6IHRydWV9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnLmlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdCA6IG9yaWcudGV4dFtvcmlnLmlkeCAtIDFdICE9PSAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogdGV4dC5zbGljZSgwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWcuaWR4ICs9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWcuaWR4ICs9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0IDogb3JpZy50ZXh0W29yaWcuaWR4IC0gMV0gIT09ICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiB0ZXh0LnNsaWNlKDAsIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0IDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0ZXh0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5rZXkgPSBtWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtWzBdO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5odG1sID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmNoYXJBdCgyKSA9PT0gb3BlbkNoYXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmNoYXJBdChtYXRjaC5sZW5ndGggLSAzKSA9PT0gZW5kQ2hhcjtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShpICsgbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3ZhbHVlIDogdGV4dCwgdGV4dCA6IHRydWUsIGNvbmNhdDogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhT2JqXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbU5hbWVcbiAgICAgICAgICAgICAqIEByZXR1cm4gdG9rZW5zIFt7a2V5OlN0cmluZywgbm9kZTpET00gbm9kZSwgaHRtbDogYm9vbGVhbn1dXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBkYXRhT2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBwYXJzZShub2RlLm5vZGVWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGRhdGFPYmosXG4gICAgICAgICAgICAgICAgICAgIGVsLCB0b2tlbiwgaSwgbCwgdG1wLCB0b2tlbk9iamVjdFByb3BlcnR5LCB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbnMgfHwgb2JqID09PSB1bmRlZmluZWQpIHtyZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRva2VuID09PSAnb2JqZWN0JyAmJiB0b2tlbi5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRtcCA9IHRva2VuLmtleS5zcGxpdCgnLicpO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wLmxlbmd0aCA+IDAgJiYgdG1wWzBdID09PSBpdGVtTmFtZSkge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRtcFswXSAhPT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyBpbXBsZW1lbnQgZXJyb3IgaGFuZGxpbmcgaWYga2V5IGRvZXNuJ3QgbWF0Y2ggd2l0aCBpdGVtTmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBlYXQ6Y29tcGlsZVRleHROb2RlIGh1cHMgc29tZXRoaW5nIGlzIHdyb25nIHdoaWNoIG5lZWRzIHRvIGJlIGZpeGVkISEhIFRva2VuIHdpdGggbmFtZScsIHRva2VuLmtleSwgJ2RvZXNuXFwndCBtYXRjaCB3aXRoIHNjb3BlIG5hbWU6ICcsIGl0ZW1OYW1lICwgJyBSZXBlYXQgd2lsbCBjb250aW51ZSBidXQgYmUgY2FyZWZ1bGx5IHRoaXMgXCJidWdcIiB3aWxsIGJlIHJlbW92ZWQgaW4gbmV4dCB2ZXJzaW9uIG9mIHJlcGVhdCEhIScpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuT2JqZWN0UHJvcGVydHkgPSB0bXAuc2xpY2UoMSkuam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBnZXRHbG9iYWxDYWxsKHRva2VuT2JqZWN0UHJvcGVydHksIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8ganVzdCBhIHN0cmluZz9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHZhbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWwobm9kZS5wYXJlbnROb2RlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcFswXSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBpcyBub3QgZXhpc3RzIGJ1dCBpdCBpcyB0aGUgc2FtZSBzY29wZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSB0b2tlbi4uLiBsb29rcyBsaWtlIGlzIG5vdCBtaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgne3snICsgdG9rZW4ua2V5ICsgJ319Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5ub2RlID0gZWw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3Qgbm9ybWFsIHN0cmluZyBwdXQgYmFjayB0byB2aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YU9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVFbGVtZW50IChub2RlLCBkYXRhT2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGNvbXBpbGUgY2hpbGROb2Rlc1xuICAgICAgICAgICAgICAgIGlmIChub2RlLmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKG5vZGUuY2hpbGROb2RlcykuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbXBpbGUoY2hpbGQsIGRhdGFPYmosIGl0ZW1OYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDb21waWxlIGEgRE9NIG5vZGUgKHJlY3Vyc2l2ZSlcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YU9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGlsZShub2RlLCBkYXRhT2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlVHlwZSA9IG5vZGUubm9kZVR5cGU7XG4gICAgICAgICAgICAgICAgaWYgKG5vZGVUeXBlID09PSAxICYmIG5vZGUudGFnTmFtZSAhPT0gJ1NDUklQVCcpIHsgLy8gYSBub3JtYWwgbm9kZVxuICAgICAgICAgICAgICAgICAgICBjb21waWxlRWxlbWVudChub2RlLCBkYXRhT2JqLCBpdGVtTmFtZSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICBjb21waWxlVGV4dE5vZGUobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHJldHVybiBub2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiB0byBkbyB0aGUgcmVhZCB2YXJpYWJsZSBmcm9tIHN0cmluZyBtYWdpYy5cbiAgICAgICAgICAgICAqIFRoZSBjYiB3aWxsIGNhbGxlZCB3aXRoIHRoZSBwcm9wZXJ0eSB2YWx1ZSAtIGluIGNhc2Ugb2YgdW5kZWZpbmVkIHRoZSB2YXJpYWJsZSBkb2VzIG5vdCBleGlzdHNcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gYXR0cmlidXRlTmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIGNiXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUobm9kZSwgb2JqLCBpdGVtTmFtZSwgYXR0cmlidXRlTmFtZSwgY2IpIHtcbiAgICAgICAgICAgICAgICB2YXIgdG1wID0gbm9kZS5nZXRBdHRyaWJ1dGUoYXR0cmlidXRlTmFtZSkuc3BsaXQoJy4nKSwgdG9rZW5PYmplY3RQcm9wZXJ0eTtcbiAgICAgICAgICAgICAgICBpZiAodG1wLmxlbmd0aCA+IDAgJiYgdG1wWzBdID09PSBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbk9iamVjdFByb3BlcnR5ID0gdG1wLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgY2IoZ2V0R2xvYmFsQ2FsbCh0b2tlbk9iamVjdFByb3BlcnR5LCBvYmopKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIGhhbmRsZSB0aGlzIGNvcnJlY3RseVxuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKCdyZXBlYXQ6Z2V0TG9vcFZhbHVlRnJvbUF0dHJpYnV0ZSBoYXMgcHJvYmxlbXMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVnaXN0ZXIgY2xpY2sgZXZlbnRzXG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBycC1iaW5kIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2xvbmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbU5hbWVcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlRXZlbnRzKGNsb25lLCBvYmosIGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIG9uQ2xpY2sgPSAnb24tY2xpY2snO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNoaWxkcmVuIG9mIGNsb25lXG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChjbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCdbJyArIG9uQ2xpY2sgKyAnXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUobm9kZSwgb2JqLCBpdGVtTmFtZSwgb25DbGljaywgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coJ3JlcGVhdDpjYW4gbm90IHJlZ2lzdGVyIGNsaWNrIGxpc3RlbmVyIHdpdGhvdXQgYSBmdW5jdGlvbicsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiByZWdpc3RlciBycC1iaW5kIGhhbmRsZXJcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogV2l0aCBoZWxwIG9mIHRoaXMgdGhlIGlmIGFuZCBpZi1ub3QgYW5kIG9uQ2xpY2sgYXR0cmlidXRlIGlzIGRlcHJlY2F0ZWQgLSB5b3UgY2FuIGp1c3QgcGFzcyBhIGZ1bmN0aW9uIFxuICAgICAgICAgICAgICogcG9pbnRlciB0byBycC1iaW5kIGFuZCBkbyBhbGwgdGhlIHJlcXVpcmVkIGxvZ2ljIGJ5IHlvdXIgb3duLlxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBJZiB5b3UgcmV0dXJuIGZhbHNlIHRoZW4gdGhlIG5vZGUgd2lsbCBiZSByZW1vdmVkIGZyb20gdGhlIERPTVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBjbG9uZVxuICAgICAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZVJQQmluZEF0dHJpYnV0ZShjbG9uZSwgb2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyTmFtZSA9ICdycC1iaW5kJztcbiAgICAgICAgICAgICAgICAvLyBjaGVjayBjaGlsZHJlbiBvZiBjbG9uZVxuICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwoY2xvbmUucXVlcnlTZWxlY3RvckFsbCgnWycgKyBhdHRyTmFtZSArICddJykpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0TG9vcFZhbHVlRnJvbUF0dHJpYnV0ZShub2RlLCBvYmosIGl0ZW1OYW1lLCBhdHRyTmFtZSwgZnVuY3Rpb24gKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsKG5vZGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbm9kZSBpZiBmdW5jdGlvbiByZXR1cm5zIGZhbHNlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpOyBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlcGVhdDpjYW4gbm90IHJlZ2lzdGVyIGNvbnRyb2wgZnVuY3Rpb24gd2l0aG91dCBhIGZ1bmN0aW9uIHBvaW50ZXInLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogUmVwbGFjZXMgZXhwcmVzc2lvbnMgZm9yIGFsbCB0YWcgYXR0cmlidXRlc1xuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBjbG9uZVxuICAgICAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lIChjdXJyZW50bHkgbm90IGluIHVzZWQgYnV0IG5lZWRzIHRvIGJlIGNoZWNrZWQpXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGhhbmRsZUF0dHJpYnV0ZXMoY29udGFpbmVyTm9kZSwgb2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciByZXR1cm5Ub2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICAoZnVuY3Rpb24gc2VhcmNoRm9yRXhwcmVzc2lvbnMoY2hpbGRyZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChjaGlsZHJlbikuZm9yRWFjaChmdW5jdGlvbiAobm9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGksIGF0dHIsIHJUb2tlbnM7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5jaGlsZHJlbi5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gZG8gaXQgcmVjdXJzaXZlIGZvciBhbGwgY2hpbGRyZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hGb3JFeHByZXNzaW9ucyhub2RlLmNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGxvb3AgdGhyb3VnaCBlYWNoIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IG5vZGUuYXR0cmlidXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIgPSBub2RlLmF0dHJpYnV0ZXNbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKC9cXHtcXHsvLnRlc3QoYXR0ci50ZXh0Q29udGVudCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGF0dHIubmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgclRva2VucyA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRva2VuID0gcGFyc2UoYXR0ci50ZXh0Q29udGVudCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGEgPSBbXSwgdG1wVG9rZW4sIGosIHRtcFRva2VuU3BsaXQsIHZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0b2tlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUb2tlbiA9IHRva2VuW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0b2tlbiBub3QgaXRlbU5hbWUgc2tpcHAgYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBUb2tlbi5rZXkgIT09IHVuZGVmaW5lZCAmJiB0bXBUb2tlbi5rZXkuc3BsaXQoJy4nKVswXSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4uYXR0ciA9IGF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcLi8udGVzdCh0bXBUb2tlbi5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW5TcGxpdCA9IHRtcFRva2VuLmtleS5zcGxpdCgnLicpLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW5TcGxpdCA9IHRtcFRva2VuLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFRva2VuLnZhbHVlID0gZ2V0R2xvYmFsQ2FsbCh0bXBUb2tlblNwbGl0LCBvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG1wVG9rZW4udmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0bXBUb2tlbi52YWx1ZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG1wVG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBvYmoobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0bXBUb2tlbi5oYXNPd25Qcm9wZXJ0eSgna2V5JykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgdGhlIGV4cHJlc3Npb24gLSBtaWdodCBiZSBhbm90aGVyIHdoaXNrZXIgaW5zdGFuY2Ugd2lsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gbmVlZHMgdGhpc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSAne3snICsgdG1wVG9rZW4ua2V5ICsgJ319JztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdG1wVG9rZW4udmFsdWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0YS5wdXNoKHt2YWx1ZSA6IHZhbHVlLCBjb25jYXQgOiB0bXBUb2tlbi5jb25jYXR9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ci50ZXh0Q29udGVudCA9IGVuZERhdGEubWFwKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBkLmNvbmNhdCA/IGQudmFsdWUgOiAnICcgKyBkLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pLmpvaW4oJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm5Ub2tlbnMgPSByZXR1cm5Ub2tlbnMuY29uY2F0KHJUb2tlbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KGNvbnRhaW5lck5vZGUuY2hpbGRyZW4pKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmV0dXJuVG9rZW5zO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGhhbmRsZSB0aGUgaWYgY29uZGl0aW9ucyBpZiBhbmQgaWYtbm90XG4gICAgICAgICAgICAgKiBcbiAgICAgICAgICAgICAqIEBkZXByZWNhdGVkIHVzZSBycC1iaW5kIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBAcGFyYW0gY2xvbmVcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVJZkNvbmRpdGlvbihjbG9uZSwgb2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBhdHRyaWJ1dGVOYW1lX2lmID0gJ2lmJyxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlTmFtZV9pZl9ub3QgPSAnaWYtbm90JztcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIGNoZWNrSWYodmFsLCBub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghdmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gY2hlY2tJZk5vdCh2YWwsIG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHZhbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNoaWxkcmVuIG9mIGNsb25lXG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChjbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCdbJyArYXR0cmlidXRlTmFtZV9pZiArICddJykpLmZvckVhY2goZnVuY3Rpb24gKG5vZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0TG9vcFZhbHVlRnJvbUF0dHJpYnV0ZShub2RlLCBvYmosIGl0ZW1OYW1lLCBhdHRyaWJ1dGVOYW1lX2lmLCBmdW5jdGlvbiAodmFsKSB7Y2hlY2tJZih2YWwsIG5vZGUpO30pO1xuICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChjbG9uZS5xdWVyeVNlbGVjdG9yQWxsKCdbJyArYXR0cmlidXRlTmFtZV9pZl9ub3QgKyAnXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIGdldExvb3BWYWx1ZUZyb21BdHRyaWJ1dGUobm9kZSwgb2JqLCBpdGVtTmFtZSwgYXR0cmlidXRlTmFtZV9pZl9ub3QsIGZ1bmN0aW9uICh2YWwpIHtjaGVja0lmTm90KHZhbCwgbm9kZSk7fSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogTG9vcGVkIHRocm91Z2ggdGhlIGNvbGxlY3Rpb24gYW5kIGRvIHRoZSBsb2dpYyBmb3IgZWFjaCBjbG9uZSBpbnN0YW5jZS5cbiAgICAgICAgICAgICAqIEFjdHVhbGx5IGl0IHN1cHBvcnRzIG9ubHkgY29sbGVjdGlvbiAtIG5vIG9iamVjdHMuXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gY29sbGVjdGlvblxuICAgICAgICAgICAgICogQHBhcmFtIHRlbXBsYXRlXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlZ2lzdGVyVGVtcGxhdGUobm9kZSwgaXRlbU5hbWUsIGNvbGxlY3Rpb24sIHRlbXBsYXRlKSB7XG4gICAgICAgICAgICAgICAgdmFyIG1haW5GcmFnO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgY29sbGVjdGlvbiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChjb2xsZWN0aW9uKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXQgaXMgYW4gYXJyYXlcbiAgICAgICAgICAgICAgICAgICAgICAgIG1haW5GcmFnID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGlvbi5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBjb3VsZCBiZSBhbiBvYmplY3Qgb3IganVzdCBhIHByb3BlcnR5IGxpa2UgYVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHN0cmluZyAoaW4gY2FzZSBvZiBpdCBpcyBkaXJlY3QgYSBsaXN0IG9mIHN0cmluZ3MpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGVtcGxhdGUuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGRUcGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB3b3JrcyBhbHNvIHdpdGggZnJhZ21lbnQgYnV0IHRoZW4gdGhlIHF1bml0IHRlc3QgZmFpbHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gLSB0aGVyZSBpcyBhIHByb2JsZW0gd2l0aCB0aGUgcGhhbnRvbWpzXG4vLyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZnJhZ21lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnJhZ21lbnQuYXBwZW5kQ2hpbGQoY2hpbGRUcGwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUlmQ29uZGl0aW9uKGZyYWdtZW50LCBpdGVtLCBpdGVtTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGlmIGNvbmRpdGlvbnMgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIGNsb25lIC0gaXQncyBpbXBvcnRhbnQgdGhhdCB0aGlzIGlzIGV4ZWN1dGVkIGZpcnN0XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZHJlbiAmJiBmcmFnbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZVJQQmluZEF0dHJpYnV0ZShmcmFnbWVudCwgaXRlbSwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJwLWJpbmQgYXR0cmlidXRlIGNhbiBhbHNvIHJlbW92ZSBlbGVtZW50cyBzbyBuZWVkIHRvIGNoZWNrIGFnYWluIGlmIG5vZGUgZXhpc3RzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmcmFnbWVudC5jaGlsZHJlbiAmJiBmcmFnbWVudC5jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZUV2ZW50cyhmcmFnbWVudCwgaXRlbSwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlQXR0cmlidXRlcyhmcmFnbWVudCwgaXRlbSwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVwbGFjZSB0ZXh0czpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW5GcmFnLmFwcGVuZENoaWxkKGNvbXBpbGUoZnJhZ21lbnQuY2hpbGRyZW5bMF0sIGl0ZW0sIGl0ZW1OYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGNvbnNvbGUubG9nKCdyZXBlYXQ6ZWxlbWVudCBoYXMgYmVlbiByZW1vdmVkIGZyb20gRE9NJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5hcHBlbmRDaGlsZChtYWluRnJhZyk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBpdCBpcyBhbiBvYmplY3RcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlcGVhdCBkZXRlY3Qgb2JqZWN0IGJ1dCBvYmplY3QgY3VycmVudGx5IG5vdCBzdXBwb3J0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoYXQgcmVuZGVyPyAtIHByb3BlcnR5IG5hbWUgb3IgdmFsdWU/IC0gQm90aD9cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3JlcGVhdDpyZWdpc3RlclRlbXBsYXRlIGRldGVjdCBub25lIGFjY2VwdGFibGUgZGF0YSBhcmd1bWVudCcsIGNvbGxlY3Rpb24pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBDcmVhdGUgYSBuZXcgcmVwZWF0IGluc3RhbmNlIGFuZCBkbyB0aGUgXCJtYWdpY1wiLlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBzY29wZU5hbWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhIHtbXSwgZnVuY3Rpb259XG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4ZWNSZXBlYXQobm9kZSwgc2NvcGVOYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRlbXBsYXRlID0gW107XG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChub2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB0ZW1wbGF0ZS5wdXNoKG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBkYXRhKGZ1bmN0aW9uIChuYW1lLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjb3BlTmFtZSA9IG5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBuYW1lO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmV0dGVyIHdvdWxkIGJlIGEgdXBkYXRlIGNoaWxkcmVuIGJ1dCB0aGlzIGlzIG11Y2ggZWZmb3J0IHRvIGRldGVjdFxuICAgICAgICAgICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChub2RlLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWdpc3RlclRlbXBsYXRlKG5vZGUsIHNjb3BlTmFtZSwgZGF0YSwgdGVtcGxhdGUpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlclRlbXBsYXRlKG5vZGUsIHNjb3BlTmFtZSwgZGF0YSwgdGVtcGxhdGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICAgICAqIHRoZSBhdHRyaWJ1dGUgcmVxdWlyZXM6XG4gICAgICAgICAgICAgICAgICogIGZvcjogbmFtZSBvZiB0aGUgaXRlcmF0b3JcbiAgICAgICAgICAgICAgICAgKiAgaW46IHBvaW50ZXIgdG86IGZ1bmN0aW9uLCBhcnJheSBvciBvYmplY3RcbiAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgICAgICogQHBhcmFtIGF0dHIge3tmb3I6c3RyaW5nLGluOnN0cmluZ319XG4gICAgICAgICAgICAgICAgICovXG4gICAgICAgICAgICAgICAgYWRkIDogZnVuY3Rpb24gKG5vZGUsIGF0dHIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGluUG9pbnRlcjtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhdHRyID09PSAnb2JqZWN0JyAmJiBhdHRyLmluICYmIGF0dHIuZm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF0dHIuaW4gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyByZXBsYWNlIHdpbmRvdyB3aXRoIHRoaXMgYW5kIGFsc28gb3RoZXIgaW5zdGFuY2VzIGNvdWxkIHVzZSB0aGUgbWFnaWMgYXMgY2xvc3VyZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUG9pbnRlciA9IGdldEdsb2JhbENhbGwoYXR0ci5pbiwgd2luZG93KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Qb2ludGVyID0gYXR0ci5pbjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXBlYXQobm9kZSwgYXR0ci5mb3IgfHwgJ2l0ZW0nLCBpblBvaW50ZXIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhdHRyKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhlY1JlcGVhdChub2RlLCAnaXRlbScsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjUmVwZWF0KG5vZGUsICdpdGVtJywgYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGF0dHIgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpblBvaW50ZXIgPSBnZXRHbG9iYWxDYWxsKGF0dHIsIHdpbmRvdyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBleGVjUmVwZWF0KG5vZGUsICdpdGVtJywgaW5Qb2ludGVyKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybigncmVwZWF0OmFkZCBub25lIGFjY2VwdGFibGUgYXR0cmlidXRlcycsIGF0dHIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSgpKTtcblxuICAgIGZ1bmN0aW9uIGVzY2FwZVJlZ2V4KHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoRVNDQVBFX1JFLCAnXFxcXCQmJyk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZ2V0UmVnZXgoKSB7XG4gICAgICAgIHZhciBvcGVuID0gZXNjYXBlUmVnZXgob3BlbkNoYXIpLFxuICAgICAgICAgICAgZW5kICA9IGVzY2FwZVJlZ2V4KGVuZENoYXIpO1xuICAgICAgICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgb3BlbiArIG9wZW4gKyAnPyguKz8pJyArIGVuZCArICc/JyArIGVuZCArIGVuZCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVhZCBhIHByb3BlcnR5IGZyb20gYSBnaXZlbiBzdHJpbmcgYW5kIG9iamVjdC5cbiAgICAgKiBSZXR1cm5zIHRoZSBmb3VuZGVkIHByb3BlcnR5IHBvaW50ZXIgb3IgdW5kZWZpbmVkLlxuICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAqIEBwYXJhbSBvYmpcbiAgICAgKiBAcmV0dXJucyB7Kn0gb3IgdW5kZWZpbmVkXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0R2xvYmFsQ2FsbCAodmFsdWUsIG9iaikge1xuICAgICAgICB2YXIgc3BsaXQgPSB2YWx1ZS5zcGxpdCgnLicpLFxuICAgICAgICAgICAgcmVjID0gZnVuY3Rpb24gKGN1cikge1xuICAgICAgICAgICAgICAgIGlmIChvYmpbY3VyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IG9ialtjdXJdO1xuICAgICAgICAgICAgICAgICAgICByZWMoc3BsaXQuc2hpZnQoKSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjdXIgPT09IHZhbHVlICkge1xuICAgICAgICAgICAgICAgICAgICBvYmogPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgcmVjKHNwbGl0LnNoaWZ0KCkpO1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH1cblxuICAgIC8vIGV4cG9ydCBhcyBtb2R1bGUgb3IgYmluZCB0byBnbG9iYWxcbiAgICBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmhhc093blByb3BlcnR5KCdleHBvcnRzJykpIHtcbiAgICAgICAgbW9kdWxlLmV4cG9ydHMgPSByZXBlYXQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FubnkuYWRkKCdyZXBlYXQnLCByZXBlYXQpO1xuICAgIH1cblxufSgpKTtcbiIsIi8qZ2xvYmFsIGNhbm55ICovXG4vKmpzbGludCBicm93c2VyOiB0cnVlKi9cbi8qKlxuICpcbiAqIEUuZy4ge3t3aGlza2VyfX06XG4gKiAgPGRpdiBjYW5ueS1tb2Q9XCJ3aGlza2VyXCIgY2FubnktdmFyPVwieydiaW5kJzonc2NvcGUnLCd0byc6eydtZXNzYWdlJzonTXkgdGV4dCd9fVwiPlxuICogICAgIDxwPkRBVEE6IHt7c2NvcGUubWVzc2FnZX19KTwvcD5cbiAqICA8L2Rpdj5cbiAqICBPciBqdXN0IHBhc3MgdGhlIGZ1bmN0aW9uIHBvaW50ZXIgdGhlIGRlZmF1bHQgc2NvcGUgaXMgJ3Njb3BlJy5cbiAqICA8ZGl2IGNhbm55LW1vZD1cIndoaXNrZXJcIiBjYW5ueS12YXI9XCJteW1vZHVsZS5mdW5jdGlvblBvaW50ZXJcIj5cbiAqICAgICA8cD5EQVRBOiB7e3Njb3BlLm1lc3NhZ2V9fSk8L3A+XG4gKiAgPC9kaXY+XG4gKlxuICovXG4oZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgdmFyIG9wZW5DaGFyID0gJ3snLFxuICAgICAgICBlbmRDaGFyICA9ICd9JyxcbiAgICAgICAgRVNDQVBFX1JFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZyxcbiAgICAgICAgd2hpc2tlciA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgQklORElOR19SRSA9IGdldFJlZ2V4KCk7XG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICBQYXJzZSBhIHBpZWNlIG9mIHRleHQsIHJldHVybiBhbiBhcnJheSBvZiB0b2tlbnNcbiAgICAgICAgICAgICAqICBUT0RPIHJlZmFjdG9yIG1ldGhvZFxuICAgICAgICAgICAgICogIEBwYXJhbSB0ZXh0XG4gICAgICAgICAgICAgKiAgQHJldHVybiBbe2tleTpTdHJpbmcsIGh0bWw6Ym9vbGVhbn1dXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlKHRleHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoIUJJTkRJTkdfUkUudGVzdCh0ZXh0KSkge3JldHVybiBudWxsOyB9XG4gICAgICAgICAgICAgICAgdmFyIG0sIGksIHRva2VuLCBtYXRjaCwgdG9rZW5zID0gW10sIG9yaWcgPSB7dGV4dDogdGV4dCwgaWR4IDogMH0sIHRleHRPYmplY3Q7XG4gICAgICAgICAgICAgICAgLyoganNoaW50IGJvc3M6IHRydWUgKi9cbiAgICAgICAgICAgICAgICB3aGlsZSAobSA9IHRleHQubWF0Y2goQklORElOR19SRSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaSA9IG0uaW5kZXg7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0ge2NvbmNhdCA6IHRydWV9O1xuICAgICAgICAgICAgICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcmlnLmlkeCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRleHRPYmplY3QgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmNhdCA6IG9yaWcudGV4dFtvcmlnLmlkeCAtIDFdICE9PSAnICcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlIDogdGV4dC5zbGljZSgwLCBpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dCA6IHRydWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWcuaWR4ICs9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9yaWcuaWR4ICs9IGk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dE9iamVjdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uY2F0IDogb3JpZy50ZXh0W29yaWcuaWR4IC0gMV0gIT09ICcgJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgOiB0ZXh0LnNsaWNlKDAsIGkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0IDogdHJ1ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMucHVzaCh0ZXh0T2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBvcmlnLmlkeCArPSBpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5rZXkgPSBtWzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgbWF0Y2ggPSBtWzBdO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5odG1sID1cbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmNoYXJBdCgyKSA9PT0gb3BlbkNoYXIgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoLmNoYXJBdChtYXRjaC5sZW5ndGggLSAzKSA9PT0gZW5kQ2hhcjtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB0ZXh0ID0gdGV4dC5zbGljZShpICsgbVswXS5sZW5ndGgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGV4dC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2goe3ZhbHVlIDogdGV4dCwgdGV4dCA6IHRydWUsIGNvbmNhdDogdHJ1ZX0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhT2JqXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbU5hbWVcbiAgICAgICAgICAgICAqIEByZXR1cm4gdG9rZW5zIFt7a2V5OlN0cmluZywgbm9kZTpET00gbm9kZSwgaHRtbDogYm9vbGVhbn1dXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVUZXh0Tm9kZShub2RlLCBkYXRhT2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBwYXJzZShub2RlLm5vZGVWYWx1ZSksXG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IGRhdGFPYmosXG4gICAgICAgICAgICAgICAgICAgIGVsLCB0b2tlbiwgaSwgbCwgdG1wLCB0b2tlbk9iamVjdFByb3BlcnR5LCB2YWwsIHZhbFVua25vd247XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbnMgfHwgb2JqID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtyZXR1cm47IH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDAsIGwgPSB0b2tlbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdG9rZW5zW2ldO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gPT09ICdvYmplY3QnICYmIHRva2VuLmhhc093blByb3BlcnR5KCdrZXknKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG1wID0gdG9rZW4ua2V5LnNwbGl0KCcuJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG1wLmxlbmd0aCA+IDAgJiYgdG1wWzBdID09PSBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuT2JqZWN0UHJvcGVydHkgPSB0bXAuc2xpY2UoMSkuam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWxVbmtub3duID0gZ2V0R2xvYmFsQ2FsbCh0b2tlbk9iamVjdFByb3BlcnR5LCBvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFVua25vd24gPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBqdXN0IGEgc3RyaW5nP1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbFVua25vd24gPSBvYmo7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsVW5rbm93biA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbFVua25vd24obm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbCA9IHZhbFVua25vd247XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUodmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIHZhbCA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh2YWwudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHZhbCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSB2YWw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRtcFswXSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBwcm9wZXJ0eSBpcyBub3QgZXhpc3RzIGJ1dCBpdCBpcyB0aGUgc2FtZSBzY29wZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZWwsIG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSB0b2tlbi4uLiBsb29rcyBsaWtlIGlzIG5vdCBtaW5lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWwgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSgne3snICsgdG9rZW4ua2V5ICsgJ319Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5wYXJlbnROb2RlLmluc2VydEJlZm9yZShlbCwgbm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5ub2RlID0gZWw7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbCA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKHRva2VuLnZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGp1c3Qgbm9ybWFsIHN0cmluZyBwdXQgYmFjayB0byB2aWV3XG4gICAgICAgICAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsLCBub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQobm9kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2VucztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YU9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGNvbXBpbGVFbGVtZW50IChub2RlLCBkYXRhT2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBbXSxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW47XG4gICAgICAgICAgICAgICAgLy8gcmVjdXJzaXZlbHkgY29tcGlsZSBjaGlsZE5vZGVzXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuaGFzQ2hpbGROb2RlcygpKSB7XG4gICAgICAgICAgICAgICAgICAgIFtdLnNsaWNlLmNhbGwobm9kZS5jaGlsZE5vZGVzKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSBjb21waWxlKGNoaWxkLCBkYXRhT2JqLCBpdGVtTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KHRva2VuKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbnMubGVuZ3RoID4gMCA/IHRva2VucyA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cblxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIGhlbHBlciBmdW5jdGlvbiB0byBkbyB0aGUgcmVhZCB2YXJpYWJsZSBmcm9tIHN0cmluZyBtYWdpYy5cbiAgICAgICAgICAgICAqIFRoZSBjYiB3aWxsIGNhbGxlZCB3aXRoIHRoZSBwcm9wZXJ0eSB2YWx1ZSAtIGluIGNhc2Ugb2YgdW5kZWZpbmVkIHRoZSB2YXJpYWJsZSBkb2VzIG5vdCBleGlzdHNcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBvYmpcbiAgICAgICAgICAgICAqIEBwYXJhbSBpdGVtTmFtZVxuICAgICAgICAgICAgICogQHBhcmFtIGF0dHJpYnV0ZU5hbWVcbiAgICAgICAgICAgICAqIFxuICAgICAgICAgICAgICogQHJldHVybiB7ZnVuY3Rpb259IHwgZmFsc2UgaWYgaXQgaXMgbm90IGEgZnVuY3Rpb24gb3Igbm90IGF2YWlsYWJsZSBcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0V2tCaW5kVmFsdWUobm9kZSwgb2JqLCBpdGVtTmFtZSwgYXR0cmlidXRlTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciB0bXAgPSBub2RlLmdldEF0dHJpYnV0ZShhdHRyaWJ1dGVOYW1lKS5zcGxpdCgnLicpLCB0b2tlbk9iamVjdFByb3BlcnR5O1xuICAgICAgICAgICAgICAgIGlmICh0bXAubGVuZ3RoID4gMCAmJiB0bXBbMF0gPT09IGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuT2JqZWN0UHJvcGVydHkgPSB0bXAuc2xpY2UoMSkuam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0R2xvYmFsQ2FsbCh0b2tlbk9iamVjdFByb3BlcnR5LCBvYmopIHx8IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogcmVnaXN0ZXIgcnAtYmluZCBoYW5kbGVyXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogV2l0aCBoZWxwIG9mIHRoaXMgdGhlIGlmIGFuZCBpZi1ub3QgYW5kIG9uQ2xpY2sgYXR0cmlidXRlIGlzIGRlcHJlY2F0ZWQgLSB5b3UgY2FuIGp1c3QgcGFzcyBhIGZ1bmN0aW9uIHBvaW50ZXIgdG8gcnAtYmluZCBhbmRcbiAgICAgICAgICAgICAqIGRvIGFsbCB0aGUgcmVxdWlyZWQgbG9naWMgYnkgeW91ciBvd24uXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogSWYgeW91IHJldHVybiBmYWxzZSB0aGVuIHRoZSBub2RlIHdpbGwgYmUgcmVtb3ZlZCBmcm9tIHRoZSBET01cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAgICAgICAgICogQHBhcmFtIG9ialxuICAgICAgICAgICAgICogQHBhcmFtIHNjb3BlTmFtZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiBoYW5kbGVXS0JpbmRBdHRyaWJ1dGUobm9kZSwgb2JqLCBzY29wZU5hbWUpIHtcblxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIHBhcnNlQ2hpbGRBdHRyaWJ1dGUoY2hpbGQsIGRhdGEsIHNjb3BlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAnd2stYmluZCcsXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBjaGlsZC5nZXRBdHRyaWJ1dGUoJ3drLWJpbmQnKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmMgPSBnZXRXa0JpbmRWYWx1ZShjaGlsZCwgZGF0YSwgc2NvcGVOYW1lLCBhdHRyTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgKGZ1bmN0aW9uIChmYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciBzaGFkb3csXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZmMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hhZG93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoYWRvdy5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmMoY2hpbGQpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGUgaWYgZnVuY3Rpb24gcmV0dXJucyBmYWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZChzaGFkb3csIGNoaWxkKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhpZGRlbiA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoaWRkZW4gOiBoaWRkZW4sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlIDogY2hpbGQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaGFkb3dOb2RlIDogc2hhZG93LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaXNXa0JpbmRUb2tlbiA6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBjaGVjayBpZiBrZXkgaXMgbmVlZGVkIGJlY2F1c2UgaXQgaGFzIHRoZSB3a0JpbmQgZnVuY3Rpb24gcG9pbnRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5IDogY2hpbGQuZ2V0QXR0cmlidXRlKCd3ay1iaW5kJylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcignd2hpc2tlcjpjYW4gbm90IHJlZ2lzdGVyIGNvbnRyb2wgZnVuY3Rpb24gd2l0aG91dCBhIGZ1bmN0aW9uIHBvaW50ZXInLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfShmYykpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdmFsaWQgaW4gY2FzZSBvZiB0aGVyZSBpcyBhIGRpZmZlcmVudCBzY29wZSB2YXJpYWJsZSBvclxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB2YXIgYXR0ck5hbWUgPSAnd2stYmluZCcsXG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgIC8vIGNoZWNrIGNoaWxkcmVuIG9mIGNsb25lXG4gICAgICAgICAgICAgICAgW10uc2xpY2UuY2FsbChub2RlLnF1ZXJ5U2VsZWN0b3JBbGwoJ1snICsgYXR0ck5hbWUgKyAnXScpKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdG1wVG9rZW4gPSBwYXJzZUNoaWxkQXR0cmlidXRlKGNoaWxkLCBvYmosIHNjb3BlTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0bXBUb2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zLnB1c2godG1wVG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vuc1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqICBDb21waWxlIGEgRE9NIG5vZGUgKHJlY3Vyc2l2ZSlcbiAgICAgICAgICAgICAqIEBwYXJhbSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gZGF0YU9ialxuICAgICAgICAgICAgICogQHBhcmFtIGl0ZW1OYW1lXG4gICAgICAgICAgICAgKiBAcmV0dXJucyB7Kn1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gY29tcGlsZShub2RlLCBkYXRhT2JqLCBpdGVtTmFtZSkge1xuICAgICAgICAgICAgICAgIHZhciBub2RlVHlwZSA9IG5vZGUubm9kZVR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IFtdLFxuICAgICAgICAgICAgICAgICAgICB0b2tlbjtcbiAgICAgICAgICAgICAgICBpZiAobm9kZVR5cGUgPT09IDEgJiYgbm9kZS50YWdOYW1lICE9PSAnU0NSSVBUJykgeyAvLyBhIG5vcm1hbCBub2RlXG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gY29tcGlsZUVsZW1lbnQobm9kZSwgZGF0YU9iaiwgaXRlbU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQodG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChub2RlVHlwZSA9PT0gMykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbiA9IGNvbXBpbGVUZXh0Tm9kZShub2RlLCBkYXRhT2JqLCBpdGVtTmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW5zID0gdG9rZW5zLmNvbmNhdCh0b2tlbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRva2Vucy5sZW5ndGggPiAwID8gdG9rZW5zIDogdW5kZWZpbmVkO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFJlcGxhY2VzIGV4cHJlc3Npb25zIGZvciBhbGwgdGFnIGF0dHJpYnV0ZXNcbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBsb29wIHRob3VnaCBhbGwgY2hpbGRyZW4gYW5kIGNoZWNrIGlmIGEgYXR0cmlidXRlIGhhcyBhIGV4cHJlc3Npb25zIGluc2lkZVxuICAgICAgICAgICAgICpcbiAgICAgICAgICAgICAqIEBwYXJhbSBjb250YWluZXJOb2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAgICAgKiBAcGFyYW0gaXRlbU5hbWVcbiAgICAgICAgICAgICAqIEByZXR1cm4gcmV0dXJuVG9rZW5zIFt7a2V5OlN0cmluZywgYXR0cjogbm9kZSBhdHRyaWJ1dGUgcmVmZXJlbmNlLCBodG1sOiBib29sZWFufV1cbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlcyhjb250YWluZXJOb2RlLCBvYmosIGl0ZW1OYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIHJldHVyblRva2VucyA9IFtdO1xuICAgICAgICAgICAgICAgIChmdW5jdGlvbiBzZWFyY2hGb3JFeHByZXNzaW9ucyhjaGlsZHJlbikge1xuICAgICAgICAgICAgICAgICAgICBbXS5zbGljZS5jYWxsKGNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgaSwgYXR0ciwgclRva2VucztcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBkbyBpdCByZWN1cnNpdmUgZm9yIGFsbCBjaGlsZHJlblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaEZvckV4cHJlc3Npb25zKG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gbG9vcCB0aHJvdWdoIGVhY2ggYXR0cmlidXRlXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbm9kZS5hdHRyaWJ1dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xce1xcey8udGVzdChhdHRyLnRleHRDb250ZW50KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci5uYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByVG9rZW5zID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG9rZW4gPSBwYXJzZShhdHRyLnRleHRDb250ZW50KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZW5kRGF0YSA9IFtdLCB0bXBUb2tlbiwgaiwgdG1wVG9rZW5TcGxpdCwgdmFsdWUsIHRtcFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCB0b2tlbi5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bXBUb2tlbiA9IHRva2VuW2pdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBpZiB0b2tlbiBub3QgaXRlbU5hbWUgc2tpcHAgYWxsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXBUb2tlbi5rZXkgIT09IHVuZGVmaW5lZCAmJiB0bXBUb2tlbi5rZXkuc3BsaXQoJy4nKVswXSA9PT0gaXRlbU5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNhdmUgdGhlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4uYXR0ciA9IGF0dHI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoL1xcLi8udGVzdCh0bXBUb2tlbi5rZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW5TcGxpdCA9IHRtcFRva2VuLmtleS5zcGxpdCgnLicpLnNsaWNlKDEpLmpvaW4oJy4nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW5TcGxpdCA9IHRtcFRva2VuLmtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRtcFZhbHVlID0gZ2V0R2xvYmFsQ2FsbCh0bXBUb2tlblNwbGl0LCBvYmopO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG1wVmFsdWUgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4udmFsdWUgPSB0bXBWYWx1ZShub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4ubm9kZSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG1wVG9rZW4udmFsdWUgPSB0bXBWYWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSB0bXBUb2tlbi52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IG9iajtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9iaiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gb2JqKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodG1wVG9rZW4uaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN0b3JlIHRoZSBleHByZXNzaW9uIC0gbWlnaHQgYmUgYW5vdGhlciB3aGlza2VyIGluc3RhbmNlIHdpbGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG5lZWRzIHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlID0gJ3t7JyArIHRtcFRva2VuLmtleSArICd9fSc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IHRtcFRva2VuLnZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVuZERhdGEucHVzaCh7dmFsdWUgOiB2YWx1ZSwgY29uY2F0IDogdG1wVG9rZW4uY29uY2F0fSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHIudGV4dENvbnRlbnQgPSBlbmREYXRhLm1hcChmdW5jdGlvbiAoZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZC5jb25jYXQgPyBkLnZhbHVlIDogJyAnICsgZC52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KS5qb2luKCcnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuVG9rZW5zID0gcmV0dXJuVG9rZW5zLmNvbmNhdChyVG9rZW5zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfShjb250YWluZXJOb2RlLmNoaWxkcmVuKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJldHVyblRva2VucztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBkbyB0aGUgbWFnaWMgZm9yIGF0dHJpYnV0ZXMgb3IgdGV4dCBub2Rlc1xuICAgICAgICAgICAgICogXG4gICAgICAgICAgICAgKiBUT0RPOiBidWcgaWYgcHJvcGVydHkgZG9lc24ndCBleGlzdHMgaW4gZmlyc3QgZXhlY3V0aW9uIGl0IHdhbnQgd29yayBhbnltb3JlIGZvciBhdHRyaWJ1dGVzIGFuZCB3ay1iaW5kXG4gICAgICAgICAgICAgKiAgU2VlOiB3aGlza2VyU3BlY3MuanMgPiBkeW5hbWljYWxseUNoYW5nZURhdGFXaXRoSW5pdGlhbE1pc3NpbmdQcm9wZXJ0aWVzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBzY29wZU5hbWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGZpbGxEYXRhKG5vZGUsIHNjb3BlTmFtZSwgZGF0YSkge1xuICAgICAgICAgICAgICAgIHZhciB0b2tlbnMgPSBbXTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGhhbmRsZUV2ZW50cyhub2RlLCBkYXRhLCBzY29wZU5hbWUpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KGhhbmRsZUF0dHJpYnV0ZXMobm9kZSwgZGF0YSwgc2NvcGVOYW1lKSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB0aGF0IHRoZSBjb21waWxlciBhbHNvIHVwZGF0ZXMgdGhlIGhpZGRlbiBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgIHRva2VucyA9IHRva2Vucy5jb25jYXQoY29tcGlsZShub2RlLCBkYXRhLCBzY29wZU5hbWUpKTtcblxuICAgICAgICAgICAgICAgICAgICB0b2tlbnMgPSB0b2tlbnMuY29uY2F0KGhhbmRsZVdLQmluZEF0dHJpYnV0ZShub2RlLCBkYXRhLCBzY29wZU5hbWUpKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyByZXBsYWNlIHRleHRzOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW5zO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ3doaXNrZXI6aGFuZGxlQXR0cmlidXRlcyBkZXRlY3Qgbm9uZSBhY2NlcHRhYmxlIGRhdGEgYXJndW1lbnQnLCBkYXRhKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uIGZvciB1cGRhdGVEYXRhIHRvIHVwZGF0ZSB0aGUgRE9NIEVsZW1lbnRzXG4gICAgICAgICAgICAgKiBAcGFyYW0gdG9rZW5cbiAgICAgICAgICAgICAqIEBwYXJhbSBkb21FbGVtZW50IERPTUVsZW1lbnRcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlRE9NRWxlbWVudCh0b2tlbiwgZG9tRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIHRva2VuLm5vZGUucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoZG9tRWxlbWVudCwgdG9rZW4ubm9kZSk7XG4gICAgICAgICAgICAgICAgdG9rZW4ubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRva2VuLm5vZGUpO1xuICAgICAgICAgICAgICAgIHRva2VuLm5vZGUgPSBkb21FbGVtZW50O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKiBoZWxwZXIgZnVuY3Rpb24gZm9yIHVwZGF0ZURhdGEgdG8gdXBkYXRlIHRoZSB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgKiBAcGFyYW0gdG9rZW5cbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWxcbiAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgZnVuY3Rpb24gdXBkYXRlVGV4dCh0b2tlbiwgdmFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRleHROb2RlO1xuICAgICAgICAgICAgICAgIGlmICh0b2tlbi5ub2RlIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gY29udmVydCBiYWNrIHRvIHRleHROb2RlXG4gICAgICAgICAgICAgICAgICAgIHRleHROb2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoJycpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5ub2RlLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKHRleHROb2RlLCB0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHRva2VuLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5ub2RlID0gdGV4dE5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyB8fCB0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgICAgICAgICB0b2tlbi5ub2RlLm5vZGVWYWx1ZSA9IHZhbDtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdib29sZWFuJykge1xuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPIHRlc3RcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZS5ub2RlVmFsdWUgPSB2YWwudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8qKlxuICAgICAgICAgICAgICogaGVscGVyIGZ1bmN0aW9uIGZvciB1cGRhdGVEYXRhIHRvIHVwZGF0ZSB0aGUgYXR0cmlidXRlcyBmb3IgYSBub2RlXG4gICAgICAgICAgICAgKiBAcGFyYW0gdG9rZW5cbiAgICAgICAgICAgICAqIEBwYXJhbSB2YWx1ZVxuICAgICAgICAgICAgICovXG4gICAgICAgICAgICBmdW5jdGlvbiB1cGRhdGVBdHRyaWJ1dGVzKHRva2VuLCB2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHZhciB2YWw7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZSh0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB2YWwgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXBsYWNlVGV4dCA9IHRva2VuLmF0dHIudGV4dENvbnRlbnQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlVGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uYXR0ci50ZXh0Q29udGVudCA9IHJlcGxhY2VUZXh0LnJlcGxhY2UodG9rZW4udmFsdWUsIHZhbCk7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b2tlbi5hdHRyLnRleHRDb250ZW50ID0gcmVwbGFjZVRleHQgKyB2YWw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdG9rZW4udmFsdWUgPSB2YWw7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVE9ETyB0ZXN0IChtYWtlcyBubyBzZW5zZSBmb3IgYW4gYXR0cmlidXRlIGJ1dCBuZWVkcyB0byBiZSBoYW5kbGVkIGNvcnJlY3RseSAodGhpbmsgYWJvdXQgd2hhdCB0byBkbyBpbiB0aGlzIGNhc2UpXG4gICAgICAgICAgICAgICAgICAgIHRva2VuLm5vZGUubm9kZVZhbHVlID0gdmFsLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyoqXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogQ2FsbCB0aGlzIHRvIHVwZGF0ZSB0aGUgZXhpc3RpbmcgZGF0YSdzXG4gICAgICAgICAgICAgKlxuICAgICAgICAgICAgICogVE9ETyB0ZXN0IGFsc28gYm9vbGVhbiBhbmQgZnVuY3Rpb25cbiAgICAgICAgICAgICAqXG4gICAgICAgICAgICAgKiBAcGFyYW0gdG9rZW5PYmpMaXN0IFt7a2V5IDogXCJzY29wZU5hbWUucHJvcGVydHlcIiwgbm9kZX1dXG4gICAgICAgICAgICAgKiBAcGFyYW0gc2NvcGVOYW1lXG4gICAgICAgICAgICAgKiBAcGFyYW0gb2JqXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIHVwZGF0ZURhdGEodG9rZW5PYmpMaXN0LCBzY29wZU5hbWUsIG9iaikge1xuICAgICAgICAgICAgICAgIHRva2VuT2JqTGlzdC5mb3JFYWNoKGZ1bmN0aW9uICh0b2tlbikge1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gJiYgdG9rZW4uaGFzT3duUHJvcGVydHkoJ2tleScpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgdG1wID0gdG9rZW4ua2V5LnNwbGl0KCcuJyksIHRva2VuT2JqZWN0UHJvcGVydHksIHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0bXAubGVuZ3RoID4gMCAmJiB0bXBbMF0gPT09IHNjb3BlTmFtZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuT2JqZWN0UHJvcGVydHkgPSB0bXAuc2xpY2UoMSkuam9pbignLicpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2JqID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWwgPSBnZXRHbG9iYWxDYWxsKHRva2VuT2JqZWN0UHJvcGVydHksIG9iaik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4uaGFzT3duUHJvcGVydHkoJ2F0dHInKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gaGFuZGxlIGF0dHJpYnV0ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlQXR0cmlidXRlcyh0b2tlbiwgdmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0b2tlbi5pc1drQmluZFRva2VuKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciByZW1vdmVNZUlmSW1GYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZU1lSWZJbUZhbHNlID0gdmFsKHRva2VuLm5vZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVtb3ZlTWVJZkltRmFsc2UgPT09IGZhbHNlICYmIHRva2VuLmhpZGRlbiA9PT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gcmVtb3ZlIG5vZGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uaGlkZGVuID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4ubm9kZS5wYXJlbnROb2RlLnJlcGxhY2VDaGlsZCh0b2tlbi5zaGFkb3dOb2RlLCB0b2tlbi5ub2RlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHJlbW92ZU1lSWZJbUZhbHNlICE9PSBmYWxzZSAmJiB0b2tlbi5oaWRkZW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG9rZW4uaGlkZGVuID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRva2VuLnNoYWRvd05vZGUucGFyZW50Tm9kZS5yZXBsYWNlQ2hpbGQodG9rZW4ubm9kZSwgdG9rZW4uc2hhZG93Tm9kZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlc3RvcmUgbm9kZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0oKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGEgcmV0dXJuIHJlc3VsdCBjb3VsZCBhbHNvIGJlIGEgSFRNTEVsZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHZhbCh0b2tlbi5ub2RlKSA6IHZhbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdXBkYXRlRE9NRWxlbWVudCh0b2tlbiwgcmVzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVUZXh0KHRva2VuLCByZXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0odmFsKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvKipcbiAgICAgICAgICAgICAqIFRPRE8gZGVzY3JpcHRpb25cbiAgICAgICAgICAgICAqIENyZWF0ZSBhIG5ldyB3aGlza2VyIGluc3RhbmNlIGFuZCBkbyB0aGUgXCJtYWdpY1wiLlxuICAgICAgICAgICAgICogQHBhcmFtIG5vZGVcbiAgICAgICAgICAgICAqIEBwYXJhbSBzY29wZU5hbWVcbiAgICAgICAgICAgICAqIEBwYXJhbSBkYXRhXG4gICAgICAgICAgICAgKi9cbiAgICAgICAgICAgIGZ1bmN0aW9uIGV4ZWMobm9kZSwgZGF0YSwgc2NvcGVOYW1lKSB7XG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnRTY29wZSA9IHNjb3BlTmFtZSB8fCAnaXRlbScsXG4gICAgICAgICAgICAgICAgICAgIGtleVZhbHVlaG9sZGVyID0ge307XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEoZnVuY3Rpb24gKHNjb3BlLCBkYXRhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVuZGVyU2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyU2NvcGUgPSBjdXJyZW50U2NvcGUgPSBzY29wZSB8fCBjdXJyZW50U2NvcGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBzY29wZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgdXNlIHRoZSBzY29wZSBmcm9tIHRoZSBpbml0aWFsaXNhdGlvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlbmRlclNjb3BlID0gY3VycmVudFNjb3BlO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGtleVZhbHVlaG9sZGVyLmhhc093blByb3BlcnR5KHJlbmRlclNjb3BlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZURhdGEoa2V5VmFsdWVob2xkZXJbcmVuZGVyU2NvcGVdLCByZW5kZXJTY29wZSwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleVZhbHVlaG9sZGVyW3JlbmRlclNjb3BlXSA9IGZpbGxEYXRhKG5vZGUsIHJlbmRlclNjb3BlLCBkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZmlsbERhdGEobm9kZSwgY3VycmVudFNjb3BlLCBkYXRhKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBhZGQgOiBmdW5jdGlvbiAobm9kZSwgYXR0cikge1xuICAgICAgICAgICAgICAgICAgICB2YXIgaW5Qb2ludGVyO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF0dHIgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ci50byAmJiBhdHRyLmJpbmQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGF0dHIudG8gPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVwbGFjZSB3aW5kb3cgd2l0aCB0aGlzIGFuZCBhbHNvIG90aGVyIGluc3RhbmNlcyBjb3VsZCB1c2UgdGhlIG1hZ2ljIGFzIGNsb3N1cmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5Qb2ludGVyID0gZ2V0R2xvYmFsQ2FsbChhdHRyLnRvLCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluUG9pbnRlciA9IGF0dHIudG87XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpblBvaW50ZXIgPSBhdHRyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZXhlYyhub2RlLCBpblBvaW50ZXIsIGF0dHIuYmluZCB8fCAnaXRlbScpO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhdHRyID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5Qb2ludGVyID0gZ2V0R2xvYmFsQ2FsbChhdHRyLCB3aW5kb3cpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBpblBvaW50ZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGVjKG5vZGUsIGluUG9pbnRlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignd2hpc2tlcjphZGQgbm9uZSBhY2NlcHRhYmxlIGF0dHJpYnV0ZXMnLCBhdHRyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWMobm9kZSwgYXR0cik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9KCkpO1xuXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG4gICAgICAgIHJldHVybiBzdHIucmVwbGFjZShFU0NBUEVfUkUsICdcXFxcJCYnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRSZWdleCgpIHtcbiAgICAgICAgdmFyIG9wZW4gPSBlc2NhcGVSZWdleChvcGVuQ2hhciksXG4gICAgICAgICAgICBlbmQgID0gZXNjYXBlUmVnZXgoZW5kQ2hhcik7XG4gICAgICAgIHJldHVybiBuZXcgUmVnRXhwKG9wZW4gKyBvcGVuICsgb3BlbiArICc/KC4rPyknICsgZW5kICsgJz8nICsgZW5kICsgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWFkIGEgcHJvcGVydHkgZnJvbSBhIGdpdmVuIHN0cmluZyBhbmQgb2JqZWN0LlxuICAgICAqIFJldHVybnMgdGhlIGZvdW5kZWQgcHJvcGVydHkgcG9pbnRlciBvciB1bmRlZmluZWQuXG4gICAgICogQHBhcmFtIHZhbHVlXG4gICAgICogQHBhcmFtIG9ialxuICAgICAqIEByZXR1cm5zIHsqfSBvciB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRHbG9iYWxDYWxsICh2YWx1ZSwgb2JqKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IHZhbHVlLnNwbGl0KCcuJyksXG4gICAgICAgICAgICByZWMgPSBmdW5jdGlvbiAoY3VyKSB7XG4gICAgICAgICAgICAgICAgaWYgKG9ialtjdXJdICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgb2JqID0gb2JqW2N1cl07XG4gICAgICAgICAgICAgICAgICAgIHJlYyhzcGxpdC5zaGlmdCgpKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGN1ciA9PT0gdmFsdWUgKSB7XG4gICAgICAgICAgICAgICAgICAgIG9iaiA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICByZWMoc3BsaXQuc2hpZnQoKSk7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuXG4gICAgLy8gZXhwb3J0IGFzIG1vZHVsZSBvciBiaW5kIHRvIGdsb2JhbFxuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuaGFzT3duUHJvcGVydHkoJ2V4cG9ydHMnKSkge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IHdoaXNrZXI7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY2FubnkuYWRkKCd3aGlza2VyJywgd2hpc2tlcik7XG4gICAgfVxuXG59KCkpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxuLy8gYmVjYXVzZSBpdCBpcyBmcmFnaWxlIGFuZCBjYW4gYmUgZWFzaWx5IGZha2VkIHdpdGggYE9iamVjdC5jcmVhdGUoKWAuXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYXJnKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KSB7XG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcbiAgfVxuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cbmV4cG9ydHMuaXNBcnJheSA9IGlzQXJyYXk7XG5cbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdib29sZWFuJztcbn1cbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xuXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IG51bGw7XG59XG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcblxuZnVuY3Rpb24gaXNOdWxsT3JVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT0gbnVsbDtcbn1cbmV4cG9ydHMuaXNOdWxsT3JVbmRlZmluZWQgPSBpc051bGxPclVuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnbnVtYmVyJztcbn1cbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcblxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcbn1cbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcblxuZnVuY3Rpb24gaXNTeW1ib2woYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcbn1cbmV4cG9ydHMuaXNTeW1ib2wgPSBpc1N5bWJvbDtcblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcblxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XG59XG5leHBvcnRzLmlzUmVnRXhwID0gaXNSZWdFeHA7XG5cbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ29iamVjdCcgJiYgYXJnICE9PSBudWxsO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xuICByZXR1cm4gb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xuXG5mdW5jdGlvbiBpc0Vycm9yKGUpIHtcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xufVxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcblxuZnVuY3Rpb24gaXNGdW5jdGlvbihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XG59XG5leHBvcnRzLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcbiAgcmV0dXJuIGFyZyA9PT0gbnVsbCB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycgfHxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcbn1cbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcblxuZXhwb3J0cy5pc0J1ZmZlciA9IEJ1ZmZlci5pc0J1ZmZlcjtcblxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG8pO1xufVxuIiwidmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBzY3J1YmJlciA9IHJlcXVpcmUoJy4vbGliL3NjcnViJyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4vbGliL2tleXMnKTtcbnZhciBmb3JFYWNoID0gcmVxdWlyZSgnLi9saWIvZm9yZWFjaCcpO1xudmFyIGlzRW51bWVyYWJsZSA9IHJlcXVpcmUoJy4vbGliL2lzX2VudW0nKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ucywgb3B0cykge1xuICAgIHJldHVybiBuZXcgUHJvdG8oY29ucywgb3B0cyk7XG59O1xuXG4oZnVuY3Rpb24gKCkgeyAvLyBicm93c2VycyBibGVoXG4gICAgZm9yICh2YXIga2V5IGluIEV2ZW50RW1pdHRlci5wcm90b3R5cGUpIHtcbiAgICAgICAgUHJvdG8ucHJvdG90eXBlW2tleV0gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlW2tleV07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gUHJvdG8gKGNvbnMsIG9wdHMpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgRXZlbnRFbWl0dGVyLmNhbGwoc2VsZik7XG4gICAgaWYgKCFvcHRzKSBvcHRzID0ge307XG4gICAgXG4gICAgc2VsZi5yZW1vdGUgPSB7fTtcbiAgICBzZWxmLmNhbGxiYWNrcyA9IHsgbG9jYWwgOiBbXSwgcmVtb3RlIDogW10gfTtcbiAgICBzZWxmLndyYXAgPSBvcHRzLndyYXA7XG4gICAgc2VsZi51bndyYXAgPSBvcHRzLnVud3JhcDtcbiAgICBcbiAgICBzZWxmLnNjcnViYmVyID0gc2NydWJiZXIoc2VsZi5jYWxsYmFja3MubG9jYWwpO1xuICAgIFxuICAgIGlmICh0eXBlb2YgY29ucyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBzZWxmLmluc3RhbmNlID0gbmV3IGNvbnMoc2VsZi5yZW1vdGUsIHNlbGYpO1xuICAgIH1cbiAgICBlbHNlIHNlbGYuaW5zdGFuY2UgPSBjb25zIHx8IHt9O1xufVxuXG5Qcm90by5wcm90b3R5cGUuc3RhcnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5yZXF1ZXN0KCdtZXRob2RzJywgWyB0aGlzLmluc3RhbmNlIF0pO1xufTtcblxuUHJvdG8ucHJvdG90eXBlLmN1bGwgPSBmdW5jdGlvbiAoaWQpIHtcbiAgICBkZWxldGUgdGhpcy5jYWxsYmFja3MucmVtb3RlW2lkXTtcbiAgICB0aGlzLmVtaXQoJ3JlcXVlc3QnLCB7XG4gICAgICAgIG1ldGhvZCA6ICdjdWxsJyxcbiAgICAgICAgYXJndW1lbnRzIDogWyBpZCBdXG4gICAgfSk7XG59O1xuXG5Qcm90by5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIGFyZ3MpIHtcbiAgICB2YXIgc2NydWIgPSB0aGlzLnNjcnViYmVyLnNjcnViKGFyZ3MpO1xuICAgIFxuICAgIHRoaXMuZW1pdCgncmVxdWVzdCcsIHtcbiAgICAgICAgbWV0aG9kIDogbWV0aG9kLFxuICAgICAgICBhcmd1bWVudHMgOiBzY3J1Yi5hcmd1bWVudHMsXG4gICAgICAgIGNhbGxiYWNrcyA6IHNjcnViLmNhbGxiYWNrcyxcbiAgICAgICAgbGlua3MgOiBzY3J1Yi5saW5rc1xuICAgIH0pO1xufTtcblxuUHJvdG8ucHJvdG90eXBlLmhhbmRsZSA9IGZ1bmN0aW9uIChyZXEpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIGFyZ3MgPSBzZWxmLnNjcnViYmVyLnVuc2NydWIocmVxLCBmdW5jdGlvbiAoaWQpIHtcbiAgICAgICAgaWYgKHNlbGYuY2FsbGJhY2tzLnJlbW90ZVtpZF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgLy8gY3JlYXRlIGEgbmV3IGZ1bmN0aW9uIG9ubHkgaWYgb25lIGhhc24ndCBhbHJlYWR5IGJlZW4gY3JlYXRlZFxuICAgICAgICAgICAgLy8gZm9yIGEgcGFydGljdWxhciBpZFxuICAgICAgICAgICAgdmFyIGNiID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHNlbGYucmVxdWVzdChpZCwgW10uc2xpY2UuYXBwbHkoYXJndW1lbnRzKSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgc2VsZi5jYWxsYmFja3MucmVtb3RlW2lkXSA9IHNlbGYud3JhcCA/IHNlbGYud3JhcChjYiwgaWQpIDogY2I7XG4gICAgICAgICAgICByZXR1cm4gY2I7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlbGYudW53cmFwXG4gICAgICAgICAgICA/IHNlbGYudW53cmFwKHNlbGYuY2FsbGJhY2tzLnJlbW90ZVtpZF0sIGlkKVxuICAgICAgICAgICAgOiBzZWxmLmNhbGxiYWNrcy5yZW1vdGVbaWRdXG4gICAgICAgIDtcbiAgICB9KTtcbiAgICBcbiAgICBpZiAocmVxLm1ldGhvZCA9PT0gJ21ldGhvZHMnKSB7XG4gICAgICAgIHNlbGYuaGFuZGxlTWV0aG9kcyhhcmdzWzBdKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVxLm1ldGhvZCA9PT0gJ2N1bGwnKSB7XG4gICAgICAgIGZvckVhY2goYXJncywgZnVuY3Rpb24gKGlkKSB7XG4gICAgICAgICAgICBkZWxldGUgc2VsZi5jYWxsYmFja3MubG9jYWxbaWRdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIHJlcS5tZXRob2QgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGlmIChpc0VudW1lcmFibGUoc2VsZi5pbnN0YW5jZSwgcmVxLm1ldGhvZCkpIHtcbiAgICAgICAgICAgIHNlbGYuYXBwbHkoc2VsZi5pbnN0YW5jZVtyZXEubWV0aG9kXSwgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2ZhaWwnLCBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgICAgJ3JlcXVlc3QgZm9yIG5vbi1lbnVtZXJhYmxlIG1ldGhvZDogJyArIHJlcS5tZXRob2RcbiAgICAgICAgICAgICkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiByZXEubWV0aG9kID09ICdudW1iZXInKSB7XG4gICAgICAgIHZhciBmbiA9IHNlbGYuY2FsbGJhY2tzLmxvY2FsW3JlcS5tZXRob2RdO1xuICAgICAgICBpZiAoIWZuKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2ZhaWwnLCBuZXcgRXJyb3IoJ25vIHN1Y2ggbWV0aG9kJykpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Ugc2VsZi5hcHBseShmbiwgYXJncyk7XG4gICAgfVxufTtcblxuUHJvdG8ucHJvdG90eXBlLmhhbmRsZU1ldGhvZHMgPSBmdW5jdGlvbiAobWV0aG9kcykge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBpZiAodHlwZW9mIG1ldGhvZHMgIT0gJ29iamVjdCcpIHtcbiAgICAgICAgbWV0aG9kcyA9IHt9O1xuICAgIH1cbiAgICBcbiAgICAvLyBjb3B5IHNpbmNlIGFzc2lnbm1lbnQgZGlzY2FyZHMgdGhlIHByZXZpb3VzIHJlZnNcbiAgICBmb3JFYWNoKG9iamVjdEtleXMoc2VsZi5yZW1vdGUpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgIGRlbGV0ZSBzZWxmLnJlbW90ZVtrZXldO1xuICAgIH0pO1xuICAgIFxuICAgIGZvckVhY2gob2JqZWN0S2V5cyhtZXRob2RzKSwgZnVuY3Rpb24gKGtleSkge1xuICAgICAgICBzZWxmLnJlbW90ZVtrZXldID0gbWV0aG9kc1trZXldO1xuICAgIH0pO1xuICAgIFxuICAgIHNlbGYuZW1pdCgncmVtb3RlJywgc2VsZi5yZW1vdGUpO1xuICAgIHNlbGYuZW1pdCgncmVhZHknKTtcbn07XG5cblByb3RvLnByb3RvdHlwZS5hcHBseSA9IGZ1bmN0aW9uIChmLCBhcmdzKSB7XG4gICAgdHJ5IHsgZi5hcHBseSh1bmRlZmluZWQsIGFyZ3MpIH1cbiAgICBjYXRjaCAoZXJyKSB7IHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpIH1cbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGZvckVhY2ggKHhzLCBmKSB7XG4gICAgaWYgKHhzLmZvckVhY2gpIHJldHVybiB4cy5mb3JFYWNoKGYpXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmLmNhbGwoeHMsIHhzW2ldLCBpKTtcbiAgICB9XG59XG4iLCJ2YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmosIGtleSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlKSB7XG4gICAgICAgIHJldHVybiBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBrZXkpO1xuICAgIH1cbiAgICB2YXIga2V5cyA9IG9iamVjdEtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGtleSA9PT0ga2V5c1tpXSkgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbn07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIHJldHVybiBrZXlzO1xufTtcbiIsInZhciB0cmF2ZXJzZSA9IHJlcXVpcmUoJ3RyYXZlcnNlJyk7XG52YXIgb2JqZWN0S2V5cyA9IHJlcXVpcmUoJy4va2V5cycpO1xudmFyIGZvckVhY2ggPSByZXF1aXJlKCcuL2ZvcmVhY2gnKTtcblxuZnVuY3Rpb24gaW5kZXhPZiAoeHMsIHgpIHtcbiAgICBpZiAoeHMuaW5kZXhPZikgcmV0dXJuIHhzLmluZGV4T2YoeCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB4cy5sZW5ndGg7IGkrKykgaWYgKHhzW2ldID09PSB4KSByZXR1cm4gaTtcbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIHNjcnViIGNhbGxiYWNrcyBvdXQgb2YgcmVxdWVzdHMgaW4gb3JkZXIgdG8gY2FsbCB0aGVtIGFnYWluIGxhdGVyXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjYWxsYmFja3MpIHtcbiAgICByZXR1cm4gbmV3IFNjcnViYmVyKGNhbGxiYWNrcyk7XG59O1xuXG5mdW5jdGlvbiBTY3J1YmJlciAoY2FsbGJhY2tzKSB7XG4gICAgdGhpcy5jYWxsYmFja3MgPSBjYWxsYmFja3M7XG59XG5cbi8vIFRha2UgdGhlIGZ1bmN0aW9ucyBvdXQgYW5kIG5vdGUgdGhlbSBmb3IgZnV0dXJlIHVzZVxuU2NydWJiZXIucHJvdG90eXBlLnNjcnViID0gZnVuY3Rpb24gKG9iaikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgcGF0aHMgPSB7fTtcbiAgICB2YXIgbGlua3MgPSBbXTtcbiAgICBcbiAgICB2YXIgYXJncyA9IHRyYXZlcnNlKG9iaikubWFwKGZ1bmN0aW9uIChub2RlKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdmFyIGkgPSBpbmRleE9mKHNlbGYuY2FsbGJhY2tzLCBub2RlKTtcbiAgICAgICAgICAgIGlmIChpID49IDAgJiYgIShpIGluIHBhdGhzKSkge1xuICAgICAgICAgICAgICAgIC8vIEtlZXAgcHJldmlvdXMgZnVuY3Rpb24gSURzIG9ubHkgZm9yIHRoZSBmaXJzdCBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIGZvdW5kLiBUaGlzIGlzIHNvbWV3aGF0IHN1Ym9wdGltYWwgYnV0IHRoZSBhbHRlcm5hdGl2ZXNcbiAgICAgICAgICAgICAgICAvLyBhcmUgd29yc2UuXG4gICAgICAgICAgICAgICAgcGF0aHNbaV0gPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBzZWxmLmNhbGxiYWNrcy5sZW5ndGg7XG4gICAgICAgICAgICAgICAgc2VsZi5jYWxsYmFja3MucHVzaChub2RlKTtcbiAgICAgICAgICAgICAgICBwYXRoc1tpZF0gPSB0aGlzLnBhdGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIHRoaXMudXBkYXRlKCdbRnVuY3Rpb25dJyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5jaXJjdWxhcikge1xuICAgICAgICAgICAgbGlua3MucHVzaCh7IGZyb20gOiB0aGlzLmNpcmN1bGFyLnBhdGgsIHRvIDogdGhpcy5wYXRoIH0pO1xuICAgICAgICAgICAgdGhpcy51cGRhdGUoJ1tDaXJjdWxhcl0nKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIFxuICAgIHJldHVybiB7XG4gICAgICAgIGFyZ3VtZW50cyA6IGFyZ3MsXG4gICAgICAgIGNhbGxiYWNrcyA6IHBhdGhzLFxuICAgICAgICBsaW5rcyA6IGxpbmtzXG4gICAgfTtcbn07XG4gXG4vLyBSZXBsYWNlIGNhbGxiYWNrcy4gVGhlIHN1cHBsaWVkIGZ1bmN0aW9uIHNob3VsZCB0YWtlIGEgY2FsbGJhY2sgaWQgYW5kXG4vLyByZXR1cm4gYSBjYWxsYmFjayBvZiBpdHMgb3duLlxuU2NydWJiZXIucHJvdG90eXBlLnVuc2NydWIgPSBmdW5jdGlvbiAobXNnLCBmKSB7XG4gICAgdmFyIGFyZ3MgPSBtc2cuYXJndW1lbnRzIHx8IFtdO1xuICAgIGZvckVhY2gob2JqZWN0S2V5cyhtc2cuY2FsbGJhY2tzIHx8IHt9KSwgZnVuY3Rpb24gKHNpZCkge1xuICAgICAgICB2YXIgaWQgPSBwYXJzZUludChzaWQsIDEwKTtcbiAgICAgICAgdmFyIHBhdGggPSBtc2cuY2FsbGJhY2tzW2lkXTtcbiAgICAgICAgdHJhdmVyc2Uuc2V0KGFyZ3MsIHBhdGgsIGYoaWQpKTtcbiAgICB9KTtcbiAgICBcbiAgICBmb3JFYWNoKG1zZy5saW5rcyB8fCBbXSwgZnVuY3Rpb24gKGxpbmspIHtcbiAgICAgICAgdmFyIHZhbHVlID0gdHJhdmVyc2UuZ2V0KGFyZ3MsIGxpbmsuZnJvbSk7XG4gICAgICAgIHRyYXZlcnNlLnNldChhcmdzLCBsaW5rLnRvLCB2YWx1ZSk7XG4gICAgfSk7XG4gICAgXG4gICAgcmV0dXJuIGFyZ3M7XG59O1xuIiwidmFyIGRub2RlID0gcmVxdWlyZSgnLi9saWIvZG5vZGUnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY29ucywgb3B0cykge1xuICAgIHJldHVybiBuZXcgZG5vZGUoY29ucywgb3B0cyk7XG59O1xuIiwidmFyIHByb3RvY29sID0gcmVxdWlyZSgnZG5vZGUtcHJvdG9jb2wnKTtcbnZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBqc29uID0gdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHJlcXVpcmUoJ2pzb25pZnknKTtcblxubW9kdWxlLmV4cG9ydHMgPSBkbm9kZTtcbmRub2RlLnByb3RvdHlwZSA9IHt9O1xuKGZ1bmN0aW9uICgpIHsgLy8gYnJvd3NlcnMgZXRjXG4gICAgZm9yICh2YXIga2V5IGluIFN0cmVhbS5wcm90b3R5cGUpIHtcbiAgICAgICAgZG5vZGUucHJvdG90eXBlW2tleV0gPSBTdHJlYW0ucHJvdG90eXBlW2tleV07XG4gICAgfVxufSkoKTtcblxuZnVuY3Rpb24gZG5vZGUgKGNvbnMsIG9wdHMpIHtcbiAgICBTdHJlYW0uY2FsbCh0aGlzKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgXG4gICAgc2VsZi5vcHRzID0gb3B0cyB8fCB7fTtcbiAgICBcbiAgICBzZWxmLmNvbnMgPSB0eXBlb2YgY29ucyA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNvbnNcbiAgICAgICAgOiBmdW5jdGlvbiAoKSB7IHJldHVybiBjb25zIHx8IHt9IH1cbiAgICA7XG4gICAgXG4gICAgc2VsZi5yZWFkYWJsZSA9IHRydWU7XG4gICAgc2VsZi53cml0YWJsZSA9IHRydWU7XG4gICAgXG4gICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChzZWxmLl9lbmRlZCkgcmV0dXJuO1xuICAgICAgICBzZWxmLnByb3RvID0gc2VsZi5fY3JlYXRlUHJvdG8oKTtcbiAgICAgICAgc2VsZi5wcm90by5zdGFydCgpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFzZWxmLl9oYW5kbGVRdWV1ZSkgcmV0dXJuO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYuX2hhbmRsZVF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBzZWxmLmhhbmRsZShzZWxmLl9oYW5kbGVRdWV1ZVtpXSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cblxuZG5vZGUucHJvdG90eXBlLl9jcmVhdGVQcm90byA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdmFyIHByb3RvID0gcHJvdG9jb2woZnVuY3Rpb24gKHJlbW90ZSkge1xuICAgICAgICBpZiAoc2VsZi5fZW5kZWQpIHJldHVybjtcbiAgICAgICAgXG4gICAgICAgIHZhciByZWYgPSBzZWxmLmNvbnMuY2FsbCh0aGlzLCByZW1vdGUsIHNlbGYpO1xuICAgICAgICBpZiAodHlwZW9mIHJlZiAhPT0gJ29iamVjdCcpIHJlZiA9IHRoaXM7XG4gICAgICAgIFxuICAgICAgICBzZWxmLmVtaXQoJ2xvY2FsJywgcmVmLCBzZWxmKTtcbiAgICAgICAgXG4gICAgICAgIHJldHVybiByZWY7XG4gICAgfSwgc2VsZi5vcHRzLnByb3RvKTtcbiAgICBcbiAgICBwcm90by5vbigncmVtb3RlJywgZnVuY3Rpb24gKHJlbW90ZSkge1xuICAgICAgICBzZWxmLmVtaXQoJ3JlbW90ZScsIHJlbW90ZSwgc2VsZik7XG4gICAgICAgIHNlbGYuZW1pdCgncmVhZHknKTsgLy8gYmFja3dhcmRzIGNvbXBhdGFiaWxpdHksIGRlcHJlY2F0ZWRcbiAgICB9KTtcbiAgICBcbiAgICBwcm90by5vbigncmVxdWVzdCcsIGZ1bmN0aW9uIChyZXEpIHtcbiAgICAgICAgaWYgKCFzZWxmLnJlYWRhYmxlKSByZXR1cm47XG4gICAgICAgIFxuICAgICAgICBpZiAoc2VsZi5vcHRzLmVtaXQgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICBzZWxmLmVtaXQoJ2RhdGEnLCByZXEpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Ugc2VsZi5lbWl0KCdkYXRhJywganNvbi5zdHJpbmdpZnkocmVxKSArICdcXG4nKTtcbiAgICB9KTtcbiAgICBcbiAgICBwcm90by5vbignZmFpbCcsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gZXJyb3JzIHRoYXQgdGhlIHJlbW90ZSBlbmQgd2FzIHJlc3BvbnNpYmxlIGZvclxuICAgICAgICBzZWxmLmVtaXQoJ2ZhaWwnLCBlcnIpO1xuICAgIH0pO1xuICAgIFxuICAgIHByb3RvLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgLy8gZXJyb3JzIHRoYXQgdGhlIGxvY2FsIGNvZGUgd2FzIHJlc3BvbnNpYmxlIGZvclxuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcbiAgICB9KTtcbiAgICBcbiAgICByZXR1cm4gcHJvdG87XG59O1xuXG5kbm9kZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XG4gICAgaWYgKHRoaXMuX2VuZGVkKSByZXR1cm47XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciByb3c7XG4gICAgXG4gICAgaWYgKGJ1ZiAmJiB0eXBlb2YgYnVmID09PSAnb2JqZWN0J1xuICAgICYmIGJ1Zi5jb25zdHJ1Y3RvciAmJiBidWYuY29uc3RydWN0b3IubmFtZSA9PT0gJ0J1ZmZlcidcbiAgICAmJiBidWYubGVuZ3RoXG4gICAgJiYgdHlwZW9mIGJ1Zi5zbGljZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyB0cmVhdCBsaWtlIGEgYnVmZmVyXG4gICAgICAgIGlmICghc2VsZi5fYnVmcykgc2VsZi5fYnVmcyA9IFtdO1xuICAgICAgICBcbiAgICAgICAgLy8gdHJlYXQgbGlrZSBhIGJ1ZmZlclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgaiA9IDA7IGkgPCBidWYubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChidWZbaV0gPT09IDB4MGEpIHtcbiAgICAgICAgICAgICAgICBzZWxmLl9idWZzLnB1c2goYnVmLnNsaWNlKGosIGkpKTtcbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9ICcnO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgc2VsZi5fYnVmcy5sZW5ndGg7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICBsaW5lICs9IFN0cmluZyhzZWxmLl9idWZzW2tdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgdHJ5IHsgcm93ID0ganNvbi5wYXJzZShsaW5lKSB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikgeyByZXR1cm4gc2VsZi5lbmQoKSB9XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaiA9IGkgKyAxO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHNlbGYuaGFuZGxlKHJvdyk7XG4gICAgICAgICAgICAgICAgc2VsZi5fYnVmcyA9IFtdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAoaiA8IGJ1Zi5sZW5ndGgpIHNlbGYuX2J1ZnMucHVzaChidWYuc2xpY2UoaiwgYnVmLmxlbmd0aCkpO1xuICAgIH1cbiAgICBlbHNlIGlmIChidWYgJiYgdHlwZW9mIGJ1ZiA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgLy8gLmlzQnVmZmVyKCkgd2l0aG91dCB0aGUgQnVmZmVyXG4gICAgICAgIC8vIFVzZSBzZWxmIHRvIHBpcGUgSlNPTlN0cmVhbS5wYXJzZSgpIHN0cmVhbXMuXG4gICAgICAgIHNlbGYuaGFuZGxlKGJ1Zik7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAodHlwZW9mIGJ1ZiAhPT0gJ3N0cmluZycpIGJ1ZiA9IFN0cmluZyhidWYpO1xuICAgICAgICBpZiAoIXNlbGYuX2xpbmUpIHNlbGYuX2xpbmUgPSAnJztcbiAgICAgICAgXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnVmLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoYnVmLmNoYXJDb2RlQXQoaSkgPT09IDB4MGEpIHtcbiAgICAgICAgICAgICAgICB0cnkgeyByb3cgPSBqc29uLnBhcnNlKHNlbGYuX2xpbmUpIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7IHJldHVybiBzZWxmLmVuZCgpIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICBzZWxmLl9saW5lID0gJyc7XG4gICAgICAgICAgICAgICAgc2VsZi5oYW5kbGUocm93KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Ugc2VsZi5fbGluZSArPSBidWYuY2hhckF0KGkpXG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5kbm9kZS5wcm90b3R5cGUuaGFuZGxlID0gZnVuY3Rpb24gKHJvdykge1xuICAgIGlmICghdGhpcy5wcm90bykge1xuICAgICAgICBpZiAoIXRoaXMuX2hhbmRsZVF1ZXVlKSB0aGlzLl9oYW5kbGVRdWV1ZSA9IFtdO1xuICAgICAgICB0aGlzLl9oYW5kbGVRdWV1ZS5wdXNoKHJvdyk7XG4gICAgfVxuICAgIGVsc2UgdGhpcy5wcm90by5oYW5kbGUocm93KTtcbn07XG5cbmRub2RlLnByb3RvdHlwZS5lbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX2VuZGVkKSByZXR1cm47XG4gICAgdGhpcy5fZW5kZWQgPSB0cnVlO1xuICAgIHRoaXMud3JpdGFibGUgPSBmYWxzZTtcbiAgICB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XG4gICAgdGhpcy5lbWl0KCdlbmQnKTtcbn07XG5cbmRub2RlLnByb3RvdHlwZS5kZXN0cm95ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZW5kKCk7XG59O1xuIiwiLypnbG9iYWwgSFRNTEVsZW1lbnQgKi9cbi8qanNsaW50IGJyb3dzZXI6IHRydWUgKi9cblxudmFyIGRvbU9wdHMgPSB7fTtcblxuZG9tT3B0cy5wYXJhbXMgPSAoZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBwYXJhbXMgPSB7fSwgaSwgbnYsIHBhcnRzO1xuICAgIGlmIChsb2NhdGlvbi5zZWFyY2gpIHtcbiAgICAgICAgcGFydHMgPSBsb2NhdGlvbi5zZWFyY2guc3Vic3RyaW5nKDEpLnNwbGl0KCcmJyk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBwYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbnYgPSBwYXJ0c1tpXS5zcGxpdCgnPScpO1xuICAgICAgICAgICAgaWYgKG52WzBdKSB7XG4gICAgICAgICAgICAgICAgcGFyYW1zW252WzBdXSA9IG52WzFdIHx8IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtcztcbn0oKSk7XG5cbmRvbU9wdHMuY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uICh0YWcsIGlkLCBjbGFzc2VzKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG5ld05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHRhZyk7XG4gICAgaWYgKGlkKSB7bmV3Tm9kZS5zZXRBdHRyaWJ1dGUoJ2lkJywgaWQpOyB9XG4gICAgaWYgKGNsYXNzZXMpIHtuZXdOb2RlLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjbGFzc2VzKTsgfVxuICAgIHJldHVybiBuZXdOb2RlO1xufTtcbm1vZHVsZS5leHBvcnRzID0gIGRvbU9wdHM7XG5cbi8vIGRvbSBvcGVyYXRpb25zOlxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRvbUFkZENsYXNzID0gZnVuY3Rpb24gKGFkZENsYXNzZXMpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgYXR0ckNsYXNzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyksXG4gICAgICAgIGFkZENsYXNzZXNMaXN0ID0gYWRkQ2xhc3Nlcy5zcGxpdCgnICcpLCBuZXdDbGFzc2VzID0gW10sIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IGFkZENsYXNzZXNMaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmICghdGhpcy5kb21IYXNDbGFzcyhhZGRDbGFzc2VzTGlzdFtpXSkpIHtcbiAgICAgICAgICAgIG5ld0NsYXNzZXMucHVzaChhZGRDbGFzc2VzTGlzdFtpXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5zZXRBdHRyaWJ1dGUoJ2NsYXNzJywgYXR0ckNsYXNzICE9PSBudWxsID8gYXR0ckNsYXNzICsgJyAnICsgbmV3Q2xhc3Nlcy5qb2luKCcgJykgOiBuZXdDbGFzc2VzLmpvaW4oJyAnKSk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuLy8gVE9ETyByZW1vdmUgYWxsIGNsYXNzZXMgd2l0aCBzYW1lIG5hbWVcbkhUTUxFbGVtZW50LnByb3RvdHlwZS5kb21SZW1vdmVDbGFzcyA9IGZ1bmN0aW9uIChyZW1vdmVhYmxlQ2xhc3Nlcykge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciByZW1vdmVDbGFzc2VzID0gKHJlbW92ZWFibGVDbGFzc2VzICYmIHJlbW92ZWFibGVDbGFzc2VzLnNwbGl0KCcgJykpIHx8IHRoaXMuZ2V0QXR0cmlidXRlKCdjbGFzcycpLnNwbGl0KCcgJyksXG4gICAgICAgIGF0dHJDbGFzcyA9IHRoaXMuZ2V0QXR0cmlidXRlKCdjbGFzcycpLFxuICAgICAgICBjdXJyZW50Q2xhc3NlcyxcbiAgICAgICAgaSxcbiAgICAgICAgaWR4O1xuICAgIGlmIChhdHRyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgY3VycmVudENsYXNzZXMgPSBhdHRyQ2xhc3Muc3BsaXQoJyAnKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHJlbW92ZUNsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlkeCA9IGN1cnJlbnRDbGFzc2VzLmluZGV4T2YocmVtb3ZlQ2xhc3Nlc1tpXSk7XG4gICAgICAgICAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50Q2xhc3NlcyA9IGN1cnJlbnRDbGFzc2VzLnNsaWNlKDAsIGlkeCkuY29uY2F0KGN1cnJlbnRDbGFzc2VzLnNsaWNlKGlkeCArIDEsIGN1cnJlbnRDbGFzc2VzLmxlbmd0aCAtIDEpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCBjdXJyZW50Q2xhc3Nlcy5qb2luKCcgJykpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGRvbSBvcGVyYXRpb25zOlxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRvbUhhc0NsYXNzID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBjbGFzc2VzID0gdGhpcy5nZXRBdHRyaWJ1dGUoJ2NsYXNzJyksIGN1cnJlbnRDbGFzc2VzLCBpO1xuICAgIGlmIChjbGFzc2VzICE9PSBudWxsKSB7XG4gICAgICAgIGN1cnJlbnRDbGFzc2VzID0gY2xhc3Nlcy5zcGxpdCgnICcpO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY3VycmVudENsYXNzZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50Q2xhc3Nlc1tpXSA9PT0gY2xhc3NOYW1lKSB7cmV0dXJuIHRydWU7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZG9tUmVtb3ZlID0gZnVuY3Rpb24gKCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHRoaXMucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzKTtcbn07XG4vKipcbiAqIHJlbW92ZSBhbGwgY2hpbGQgZWxlbWVudHMgZnJvbSBub2RlXG4gKi9cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5kb21FbXB0eSA9IGZ1bmN0aW9uICgpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbCh0aGlzLmNoaWxkcmVuKS5mb3JFYWNoKGZ1bmN0aW9uIChjaGlsZCkge1xuICAgICAgICBjaGlsZC5kb21SZW1vdmUodGhpcyk7XG4gICAgfSk7XG59O1xuXG5IVE1MRWxlbWVudC5wcm90b3R5cGUuZG9tQXBwZW5kVG8gPSBmdW5jdGlvbiAoZWxlbSkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuICAgIHZhciBub2RlID0gZWxlbTtcbiAgICBpZiAodHlwZW9mIG5vZGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChub2RlKTtcbiAgICB9XG4gICAgbm9kZS5hcHBlbmRDaGlsZCh0aGlzKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbkhUTUxFbGVtZW50LnByb3RvdHlwZS5kb21BcHBlbmRDaGlsZCA9IGZ1bmN0aW9uIChlbGVtKSB7XG4gICAgXCJ1c2Ugc3RyaWN0XCI7XG4gICAgdmFyIG5vZGUgPSBlbGVtO1xuICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKG5vZGUpO1xuICAgIH1cbiAgICB0aGlzLmFwcGVuZENoaWxkKG5vZGUpO1xuICAgIHJldHVybiB0aGlzO1xufTtcblxuSFRNTEVsZW1lbnQucHJvdG90eXBlLmRvbUNoaWxkVGFncyA9IGZ1bmN0aW9uICh0YWcpIHtcbiAgICBcInVzZSBzdHJpY3RcIjtcbiAgICB2YXIgdGFncyA9IFtdO1xuICAgIEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuY2hpbGRyZW4pLmZvckVhY2goZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgaWYgKGUudGFnTmFtZS50b0xvd2VyQ2FzZSgpID09PSB0YWcudG9Mb3dlckNhc2UoKSkge1xuICAgICAgICAgICAgdGFncy5wdXNoKGUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRhZ3M7XG59OyIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG5mdW5jdGlvbiBFdmVudEVtaXR0ZXIoKSB7XG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gdGhpcy5fbWF4TGlzdGVuZXJzIHx8IHVuZGVmaW5lZDtcbn1cbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xuXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjEwLnhcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX2V2ZW50cyA9IHVuZGVmaW5lZDtcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcblxuLy8gQnkgZGVmYXVsdCBFdmVudEVtaXR0ZXJzIHdpbGwgcHJpbnQgYSB3YXJuaW5nIGlmIG1vcmUgdGhhbiAxMCBsaXN0ZW5lcnMgYXJlXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxuRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnMgPSAxMDtcblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24obikge1xuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxuICAgIHRocm93IFR5cGVFcnJvcignbiBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgbGlzdGVuZXJzO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzKVxuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKHR5cGUgPT09ICdlcnJvcicpIHtcbiAgICBpZiAoIXRoaXMuX2V2ZW50cy5lcnJvciB8fFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcbiAgICAgIGVyID0gYXJndW1lbnRzWzFdO1xuICAgICAgaWYgKGVyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBBdCBsZWFzdCBnaXZlIHNvbWUga2luZCBvZiBjb250ZXh0IHRvIHRoZSB1c2VyXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgICBlcnIuY29udGV4dCA9IGVyO1xuICAgICAgICB0aHJvdyBlcnI7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaGFuZGxlciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcblxuICBpZiAoaXNVbmRlZmluZWQoaGFuZGxlcikpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGhhbmRsZXIpKSB7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgICBjYXNlIDE6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGhhbmRsZXIuY2FsbCh0aGlzLCBhcmd1bWVudHNbMV0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMzpcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICAvLyBzbG93ZXJcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgICAgICBoYW5kbGVyLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xuICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIGxpc3RlbmVycyA9IGhhbmRsZXIuc2xpY2UoKTtcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xuICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKylcbiAgICAgIGxpc3RlbmVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuXG4gIHJldHVybiB0cnVlO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBtO1xuXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcblxuICAvLyBUbyBhdm9pZCByZWN1cnNpb24gaW4gdGhlIGNhc2UgdGhhdCB0eXBlID09PSBcIm5ld0xpc3RlbmVyXCIhIEJlZm9yZVxuICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXG4gICAgdGhpcy5lbWl0KCduZXdMaXN0ZW5lcicsIHR5cGUsXG4gICAgICAgICAgICAgIGlzRnVuY3Rpb24obGlzdGVuZXIubGlzdGVuZXIpID9cbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XG5cbiAgaWYgKCF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgdGhpcy5fZXZlbnRzW3R5cGVdID0gbGlzdGVuZXI7XG4gIGVsc2UgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkpXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5wdXNoKGxpc3RlbmVyKTtcbiAgZWxzZVxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IFt0aGlzLl9ldmVudHNbdHlwZV0sIGxpc3RlbmVyXTtcblxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xuICBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSAmJiAhdGhpcy5fZXZlbnRzW3R5cGVdLndhcm5lZCkge1xuICAgIGlmICghaXNVbmRlZmluZWQodGhpcy5fbWF4TGlzdGVuZXJzKSkge1xuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH1cblxuICAgIGlmIChtICYmIG0gPiAwICYmIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGggPiBtKSB7XG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJyhub2RlKSB3YXJuaW5nOiBwb3NzaWJsZSBFdmVudEVtaXR0ZXIgbWVtb3J5ICcgK1xuICAgICAgICAgICAgICAgICAgICAnbGVhayBkZXRlY3RlZC4gJWQgbGlzdGVuZXJzIGFkZGVkLiAnICtcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2V2ZW50c1t0eXBlXS5sZW5ndGgpO1xuICAgICAgaWYgKHR5cGVvZiBjb25zb2xlLnRyYWNlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcbiAgICAgICAgY29uc29sZS50cmFjZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub25jZSA9IGZ1bmN0aW9uKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcblxuICB2YXIgZmlyZWQgPSBmYWxzZTtcblxuICBmdW5jdGlvbiBnKCkge1xuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XG5cbiAgICBpZiAoIWZpcmVkKSB7XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH1cbiAgfVxuXG4gIGcubGlzdGVuZXIgPSBsaXN0ZW5lcjtcbiAgdGhpcy5vbih0eXBlLCBnKTtcblxuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIGVtaXRzIGEgJ3JlbW92ZUxpc3RlbmVyJyBldmVudCBpZmYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcbiAgdmFyIGxpc3QsIHBvc2l0aW9uLCBsZW5ndGgsIGk7XG5cbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ2xpc3RlbmVyIG11c3QgYmUgYSBmdW5jdGlvbicpO1xuXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcbiAgbGVuZ3RoID0gbGlzdC5sZW5ndGg7XG4gIHBvc2l0aW9uID0gLTE7XG5cbiAgaWYgKGxpc3QgPT09IGxpc3RlbmVyIHx8XG4gICAgICAoaXNGdW5jdGlvbihsaXN0Lmxpc3RlbmVyKSAmJiBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXG4gICAgICB0aGlzLmVtaXQoJ3JlbW92ZUxpc3RlbmVyJywgdHlwZSwgbGlzdGVuZXIpO1xuXG4gIH0gZWxzZSBpZiAoaXNPYmplY3QobGlzdCkpIHtcbiAgICBmb3IgKGkgPSBsZW5ndGg7IGktLSA+IDA7KSB7XG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcbiAgICAgICAgICAobGlzdFtpXS5saXN0ZW5lciAmJiBsaXN0W2ldLmxpc3RlbmVyID09PSBsaXN0ZW5lcikpIHtcbiAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBpZiAocG9zaXRpb24gPCAwKVxuICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpIHtcbiAgICAgIGxpc3QubGVuZ3RoID0gMDtcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGxpc3Quc3BsaWNlKHBvc2l0aW9uLCAxKTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciBrZXksIGxpc3RlbmVycztcblxuICBpZiAoIXRoaXMuX2V2ZW50cylcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XG4gIGlmICghdGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcbiAgICBlbHNlIGlmICh0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAwKSB7XG4gICAgZm9yIChrZXkgaW4gdGhpcy5fZXZlbnRzKSB7XG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGtleSk7XG4gICAgfVxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgIHRoaXMuX2V2ZW50cyA9IHt9O1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgbGlzdGVuZXJzID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIGlmIChpc0Z1bmN0aW9uKGxpc3RlbmVycykpIHtcbiAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVycyk7XG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XG4gICAgLy8gTElGTyBvcmRlclxuICAgIHdoaWxlIChsaXN0ZW5lcnMubGVuZ3RoKVxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcbiAgfVxuICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XG4gIHZhciByZXQ7XG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXG4gICAgcmV0ID0gW107XG4gIGVsc2UgaWYgKGlzRnVuY3Rpb24odGhpcy5fZXZlbnRzW3R5cGVdKSlcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcbiAgZWxzZVxuICAgIHJldCA9IHRoaXMuX2V2ZW50c1t0eXBlXS5zbGljZSgpO1xuICByZXR1cm4gcmV0O1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xuICBpZiAodGhpcy5fZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSB0aGlzLl9ldmVudHNbdHlwZV07XG5cbiAgICBpZiAoaXNGdW5jdGlvbihldmxpc3RlbmVyKSlcbiAgICAgIHJldHVybiAxO1xuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXG4gICAgICByZXR1cm4gZXZsaXN0ZW5lci5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIDA7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgcmV0dXJuIGVtaXR0ZXIubGlzdGVuZXJDb3VudCh0eXBlKTtcbn07XG5cbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnZnVuY3Rpb24nO1xufVxuXG5mdW5jdGlvbiBpc051bWJlcihhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xufVxuXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcbn1cblxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XG4gIHJldHVybiBhcmcgPT09IHZvaWQgMDtcbn1cbiIsImV4cG9ydHMucmVhZCA9IGZ1bmN0aW9uIChidWZmZXIsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XG4gIHZhciBlLCBtXG4gIHZhciBlTGVuID0gbkJ5dGVzICogOCAtIG1MZW4gLSAxXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxuICB2YXIgbkJpdHMgPSAtN1xuICB2YXIgaSA9IGlzTEUgPyAobkJ5dGVzIC0gMSkgOiAwXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxuICB2YXIgcyA9IGJ1ZmZlcltvZmZzZXQgKyBpXVxuXG4gIGkgKz0gZFxuXG4gIGUgPSBzICYgKCgxIDw8ICgtbkJpdHMpKSAtIDEpXG4gIHMgPj49ICgtbkJpdHMpXG4gIG5CaXRzICs9IGVMZW5cbiAgZm9yICg7IG5CaXRzID4gMDsgZSA9IGUgKiAyNTYgKyBidWZmZXJbb2Zmc2V0ICsgaV0sIGkgKz0gZCwgbkJpdHMgLT0gOCkge31cblxuICBtID0gZSAmICgoMSA8PCAoLW5CaXRzKSkgLSAxKVxuICBlID4+PSAoLW5CaXRzKVxuICBuQml0cyArPSBtTGVuXG4gIGZvciAoOyBuQml0cyA+IDA7IG0gPSBtICogMjU2ICsgYnVmZmVyW29mZnNldCArIGldLCBpICs9IGQsIG5CaXRzIC09IDgpIHt9XG5cbiAgaWYgKGUgPT09IDApIHtcbiAgICBlID0gMSAtIGVCaWFzXG4gIH0gZWxzZSBpZiAoZSA9PT0gZU1heCkge1xuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxuICB9IGVsc2Uge1xuICAgIG0gPSBtICsgTWF0aC5wb3coMiwgbUxlbilcbiAgICBlID0gZSAtIGVCaWFzXG4gIH1cbiAgcmV0dXJuIChzID8gLTEgOiAxKSAqIG0gKiBNYXRoLnBvdygyLCBlIC0gbUxlbilcbn1cblxuZXhwb3J0cy53cml0ZSA9IGZ1bmN0aW9uIChidWZmZXIsIHZhbHVlLCBvZmZzZXQsIGlzTEUsIG1MZW4sIG5CeXRlcykge1xuICB2YXIgZSwgbSwgY1xuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxuICB2YXIgZU1heCA9ICgxIDw8IGVMZW4pIC0gMVxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcbiAgdmFyIHJ0ID0gKG1MZW4gPT09IDIzID8gTWF0aC5wb3coMiwgLTI0KSAtIE1hdGgucG93KDIsIC03NykgOiAwKVxuICB2YXIgaSA9IGlzTEUgPyAwIDogKG5CeXRlcyAtIDEpXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxuICB2YXIgcyA9IHZhbHVlIDwgMCB8fCAodmFsdWUgPT09IDAgJiYgMSAvIHZhbHVlIDwgMCkgPyAxIDogMFxuXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXG5cbiAgaWYgKGlzTmFOKHZhbHVlKSB8fCB2YWx1ZSA9PT0gSW5maW5pdHkpIHtcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcbiAgICBlID0gZU1heFxuICB9IGVsc2Uge1xuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxuICAgIGlmICh2YWx1ZSAqIChjID0gTWF0aC5wb3coMiwgLWUpKSA8IDEpIHtcbiAgICAgIGUtLVxuICAgICAgYyAqPSAyXG4gICAgfVxuICAgIGlmIChlICsgZUJpYXMgPj0gMSkge1xuICAgICAgdmFsdWUgKz0gcnQgLyBjXG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbHVlICs9IHJ0ICogTWF0aC5wb3coMiwgMSAtIGVCaWFzKVxuICAgIH1cbiAgICBpZiAodmFsdWUgKiBjID49IDIpIHtcbiAgICAgIGUrK1xuICAgICAgYyAvPSAyXG4gICAgfVxuXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XG4gICAgICBtID0gMFxuICAgICAgZSA9IGVNYXhcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XG4gICAgICBtID0gKHZhbHVlICogYyAtIDEpICogTWF0aC5wb3coMiwgbUxlbilcbiAgICAgIGUgPSBlICsgZUJpYXNcbiAgICB9IGVsc2Uge1xuICAgICAgbSA9IHZhbHVlICogTWF0aC5wb3coMiwgZUJpYXMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXG4gICAgICBlID0gMFxuICAgIH1cbiAgfVxuXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XG5cbiAgZSA9IChlIDw8IG1MZW4pIHwgbVxuICBlTGVuICs9IG1MZW5cbiAgZm9yICg7IGVMZW4gPiAwOyBidWZmZXJbb2Zmc2V0ICsgaV0gPSBlICYgMHhmZiwgaSArPSBkLCBlIC89IDI1NiwgZUxlbiAtPSA4KSB7fVxuXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxufVxuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICBjdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoc3VwZXJDdG9yLnByb3RvdHlwZSwge1xuICAgICAgY29uc3RydWN0b3I6IHtcbiAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICB9XG4gICAgfSk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBvbGQgc2Nob29sIHNoaW0gZm9yIG9sZCBicm93c2Vyc1xuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xuICAgIGN0b3Iuc3VwZXJfID0gc3VwZXJDdG9yXG4gICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXG4gICAgY3Rvci5wcm90b3R5cGUgPSBuZXcgVGVtcEN0b3IoKVxuICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICB9XG59XG4iLCIvKiFcbiAqIERldGVybWluZSBpZiBhbiBvYmplY3QgaXMgYSBCdWZmZXJcbiAqXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8aHR0cHM6Ly9mZXJvc3Mub3JnPlxuICogQGxpY2Vuc2UgIE1JVFxuICovXG5cbi8vIFRoZSBfaXNCdWZmZXIgY2hlY2sgaXMgZm9yIFNhZmFyaSA1LTcgc3VwcG9ydCwgYmVjYXVzZSBpdCdzIG1pc3Npbmdcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKGlzQnVmZmVyKG9iaikgfHwgaXNTbG93QnVmZmVyKG9iaikgfHwgISFvYmouX2lzQnVmZmVyKVxufVxuXG5mdW5jdGlvbiBpc0J1ZmZlciAob2JqKSB7XG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXG59XG5cbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXG5mdW5jdGlvbiBpc1Nsb3dCdWZmZXIgKG9iaikge1xuICByZXR1cm4gdHlwZW9mIG9iai5yZWFkRmxvYXRMRSA9PT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2Ygb2JqLnNsaWNlID09PSAnZnVuY3Rpb24nICYmIGlzQnVmZmVyKG9iai5zbGljZSgwLCAwKSlcbn1cbiIsImV4cG9ydHMucGFyc2UgPSByZXF1aXJlKCcuL2xpYi9wYXJzZScpO1xuZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2xpYi9zdHJpbmdpZnknKTtcbiIsInZhciBhdCwgLy8gVGhlIGluZGV4IG9mIHRoZSBjdXJyZW50IGNoYXJhY3RlclxuICAgIGNoLCAvLyBUaGUgY3VycmVudCBjaGFyYWN0ZXJcbiAgICBlc2NhcGVlID0ge1xuICAgICAgICAnXCInOiAgJ1wiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgICAgICcvJzogICcvJyxcbiAgICAgICAgYjogICAgJ1xcYicsXG4gICAgICAgIGY6ICAgICdcXGYnLFxuICAgICAgICBuOiAgICAnXFxuJyxcbiAgICAgICAgcjogICAgJ1xccicsXG4gICAgICAgIHQ6ICAgICdcXHQnXG4gICAgfSxcbiAgICB0ZXh0LFxuXG4gICAgZXJyb3IgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAvLyBDYWxsIGVycm9yIHdoZW4gc29tZXRoaW5nIGlzIHdyb25nLlxuICAgICAgICB0aHJvdyB7XG4gICAgICAgICAgICBuYW1lOiAgICAnU3ludGF4RXJyb3InLFxuICAgICAgICAgICAgbWVzc2FnZTogbSxcbiAgICAgICAgICAgIGF0OiAgICAgIGF0LFxuICAgICAgICAgICAgdGV4dDogICAgdGV4dFxuICAgICAgICB9O1xuICAgIH0sXG4gICAgXG4gICAgbmV4dCA9IGZ1bmN0aW9uIChjKSB7XG4gICAgICAgIC8vIElmIGEgYyBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQsIHZlcmlmeSB0aGF0IGl0IG1hdGNoZXMgdGhlIGN1cnJlbnQgY2hhcmFjdGVyLlxuICAgICAgICBpZiAoYyAmJiBjICE9PSBjaCkge1xuICAgICAgICAgICAgZXJyb3IoXCJFeHBlY3RlZCAnXCIgKyBjICsgXCInIGluc3RlYWQgb2YgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIC8vIEdldCB0aGUgbmV4dCBjaGFyYWN0ZXIuIFdoZW4gdGhlcmUgYXJlIG5vIG1vcmUgY2hhcmFjdGVycyxcbiAgICAgICAgLy8gcmV0dXJuIHRoZSBlbXB0eSBzdHJpbmcuXG4gICAgICAgIFxuICAgICAgICBjaCA9IHRleHQuY2hhckF0KGF0KTtcbiAgICAgICAgYXQgKz0gMTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG4gICAgXG4gICAgbnVtYmVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIG51bWJlciB2YWx1ZS5cbiAgICAgICAgdmFyIG51bWJlcixcbiAgICAgICAgICAgIHN0cmluZyA9ICcnO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoID09PSAnLScpIHtcbiAgICAgICAgICAgIHN0cmluZyA9ICctJztcbiAgICAgICAgICAgIG5leHQoJy0nKTtcbiAgICAgICAgfVxuICAgICAgICB3aGlsZSAoY2ggPj0gJzAnICYmIGNoIDw9ICc5Jykge1xuICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJy4nKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gJy4nO1xuICAgICAgICAgICAgd2hpbGUgKG5leHQoKSAmJiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknKSB7XG4gICAgICAgICAgICAgICAgc3RyaW5nICs9IGNoO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjaCA9PT0gJ2UnIHx8IGNoID09PSAnRScpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBjaDtcbiAgICAgICAgICAgIG5leHQoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJy0nIHx8IGNoID09PSAnKycpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNoID49ICcwJyAmJiBjaCA8PSAnOScpIHtcbiAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIG51bWJlciA9ICtzdHJpbmc7XG4gICAgICAgIGlmICghaXNGaW5pdGUobnVtYmVyKSkge1xuICAgICAgICAgICAgZXJyb3IoXCJCYWQgbnVtYmVyXCIpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICAgICAgfVxuICAgIH0sXG4gICAgXG4gICAgc3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvLyBQYXJzZSBhIHN0cmluZyB2YWx1ZS5cbiAgICAgICAgdmFyIGhleCxcbiAgICAgICAgICAgIGksXG4gICAgICAgICAgICBzdHJpbmcgPSAnJyxcbiAgICAgICAgICAgIHVmZmZmO1xuICAgICAgICBcbiAgICAgICAgLy8gV2hlbiBwYXJzaW5nIGZvciBzdHJpbmcgdmFsdWVzLCB3ZSBtdXN0IGxvb2sgZm9yIFwiIGFuZCBcXCBjaGFyYWN0ZXJzLlxuICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgIHdoaWxlIChuZXh0KCkpIHtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICdcIicpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV4dCgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoY2ggPT09ICdcXFxcJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjaCA9PT0gJ3UnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNDsgaSArPSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGV4ID0gcGFyc2VJbnQobmV4dCgpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFpc0Zpbml0ZShoZXgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1ZmZmZiA9IHVmZmZmICogMTYgKyBoZXg7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gU3RyaW5nLmZyb21DaGFyQ29kZSh1ZmZmZik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIGVzY2FwZWVbY2hdID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyaW5nICs9IGVzY2FwZWVbY2hdO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzdHJpbmcgKz0gY2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIHN0cmluZ1wiKTtcbiAgICB9LFxuXG4gICAgd2hpdGUgPSBmdW5jdGlvbiAoKSB7XG5cbi8vIFNraXAgd2hpdGVzcGFjZS5cblxuICAgICAgICB3aGlsZSAoY2ggJiYgY2ggPD0gJyAnKSB7XG4gICAgICAgICAgICBuZXh0KCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgd29yZCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gdHJ1ZSwgZmFsc2UsIG9yIG51bGwuXG5cbiAgICAgICAgc3dpdGNoIChjaCkge1xuICAgICAgICBjYXNlICd0JzpcbiAgICAgICAgICAgIG5leHQoJ3QnKTtcbiAgICAgICAgICAgIG5leHQoJ3InKTtcbiAgICAgICAgICAgIG5leHQoJ3UnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICBjYXNlICdmJzpcbiAgICAgICAgICAgIG5leHQoJ2YnKTtcbiAgICAgICAgICAgIG5leHQoJ2EnKTtcbiAgICAgICAgICAgIG5leHQoJ2wnKTtcbiAgICAgICAgICAgIG5leHQoJ3MnKTtcbiAgICAgICAgICAgIG5leHQoJ2UnKTtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY2FzZSAnbic6XG4gICAgICAgICAgICBuZXh0KCduJyk7XG4gICAgICAgICAgICBuZXh0KCd1Jyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICBuZXh0KCdsJyk7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlcnJvcihcIlVuZXhwZWN0ZWQgJ1wiICsgY2ggKyBcIidcIik7XG4gICAgfSxcblxuICAgIHZhbHVlLCAgLy8gUGxhY2UgaG9sZGVyIGZvciB0aGUgdmFsdWUgZnVuY3Rpb24uXG5cbiAgICBhcnJheSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gYXJyYXkgdmFsdWUuXG5cbiAgICAgICAgdmFyIGFycmF5ID0gW107XG5cbiAgICAgICAgaWYgKGNoID09PSAnWycpIHtcbiAgICAgICAgICAgIG5leHQoJ1snKTtcbiAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgIG5leHQoJ10nKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXJyYXk7ICAgLy8gZW1wdHkgYXJyYXlcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjaCkge1xuICAgICAgICAgICAgICAgIGFycmF5LnB1c2godmFsdWUoKSk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICddJykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCddJyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBhcnJheTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbmV4dCgnLCcpO1xuICAgICAgICAgICAgICAgIHdoaXRlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZXJyb3IoXCJCYWQgYXJyYXlcIik7XG4gICAgfSxcblxuICAgIG9iamVjdCA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYW4gb2JqZWN0IHZhbHVlLlxuXG4gICAgICAgIHZhciBrZXksXG4gICAgICAgICAgICBvYmplY3QgPSB7fTtcblxuICAgICAgICBpZiAoY2ggPT09ICd7Jykge1xuICAgICAgICAgICAgbmV4dCgneycpO1xuICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgIGlmIChjaCA9PT0gJ30nKSB7XG4gICAgICAgICAgICAgICAgbmV4dCgnfScpO1xuICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7ICAgLy8gZW1wdHkgb2JqZWN0XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAoY2gpIHtcbiAgICAgICAgICAgICAgICBrZXkgPSBzdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgICAgIG5leHQoJzonKTtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yKCdEdXBsaWNhdGUga2V5IFwiJyArIGtleSArICdcIicpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBvYmplY3Rba2V5XSA9IHZhbHVlKCk7XG4gICAgICAgICAgICAgICAgd2hpdGUoKTtcbiAgICAgICAgICAgICAgICBpZiAoY2ggPT09ICd9Jykge1xuICAgICAgICAgICAgICAgICAgICBuZXh0KCd9Jyk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIG5leHQoJywnKTtcbiAgICAgICAgICAgICAgICB3aGl0ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVycm9yKFwiQmFkIG9iamVjdFwiKTtcbiAgICB9O1xuXG52YWx1ZSA9IGZ1bmN0aW9uICgpIHtcblxuLy8gUGFyc2UgYSBKU09OIHZhbHVlLiBJdCBjb3VsZCBiZSBhbiBvYmplY3QsIGFuIGFycmF5LCBhIHN0cmluZywgYSBudW1iZXIsXG4vLyBvciBhIHdvcmQuXG5cbiAgICB3aGl0ZSgpO1xuICAgIHN3aXRjaCAoY2gpIHtcbiAgICBjYXNlICd7JzpcbiAgICAgICAgcmV0dXJuIG9iamVjdCgpO1xuICAgIGNhc2UgJ1snOlxuICAgICAgICByZXR1cm4gYXJyYXkoKTtcbiAgICBjYXNlICdcIic6XG4gICAgICAgIHJldHVybiBzdHJpbmcoKTtcbiAgICBjYXNlICctJzpcbiAgICAgICAgcmV0dXJuIG51bWJlcigpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBjaCA+PSAnMCcgJiYgY2ggPD0gJzknID8gbnVtYmVyKCkgOiB3b3JkKCk7XG4gICAgfVxufTtcblxuLy8gUmV0dXJuIHRoZSBqc29uX3BhcnNlIGZ1bmN0aW9uLiBJdCB3aWxsIGhhdmUgYWNjZXNzIHRvIGFsbCBvZiB0aGUgYWJvdmVcbi8vIGZ1bmN0aW9ucyBhbmQgdmFyaWFibGVzLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzb3VyY2UsIHJldml2ZXIpIHtcbiAgICB2YXIgcmVzdWx0O1xuICAgIFxuICAgIHRleHQgPSBzb3VyY2U7XG4gICAgYXQgPSAwO1xuICAgIGNoID0gJyAnO1xuICAgIHJlc3VsdCA9IHZhbHVlKCk7XG4gICAgd2hpdGUoKTtcbiAgICBpZiAoY2gpIHtcbiAgICAgICAgZXJyb3IoXCJTeW50YXggZXJyb3JcIik7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSByZWN1cnNpdmVseSB3YWxrIHRoZSBuZXcgc3RydWN0dXJlLFxuICAgIC8vIHBhc3NpbmcgZWFjaCBuYW1lL3ZhbHVlIHBhaXIgdG8gdGhlIHJldml2ZXIgZnVuY3Rpb24gZm9yIHBvc3NpYmxlXG4gICAgLy8gdHJhbnNmb3JtYXRpb24sIHN0YXJ0aW5nIHdpdGggYSB0ZW1wb3Jhcnkgcm9vdCBvYmplY3QgdGhhdCBob2xkcyB0aGUgcmVzdWx0XG4gICAgLy8gaW4gYW4gZW1wdHkga2V5LiBJZiB0aGVyZSBpcyBub3QgYSByZXZpdmVyIGZ1bmN0aW9uLCB3ZSBzaW1wbHkgcmV0dXJuIHRoZVxuICAgIC8vIHJlc3VsdC5cblxuICAgIHJldHVybiB0eXBlb2YgcmV2aXZlciA9PT0gJ2Z1bmN0aW9uJyA/IChmdW5jdGlvbiB3YWxrKGhvbGRlciwga2V5KSB7XG4gICAgICAgIHZhciBrLCB2LCB2YWx1ZSA9IGhvbGRlcltrZXldO1xuICAgICAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgaykpIHtcbiAgICAgICAgICAgICAgICAgICAgdiA9IHdhbGsodmFsdWUsIGspO1xuICAgICAgICAgICAgICAgICAgICBpZiAodiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZVtrXSA9IHY7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdmFsdWVba107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJldml2ZXIuY2FsbChob2xkZXIsIGtleSwgdmFsdWUpO1xuICAgIH0oeycnOiByZXN1bHR9LCAnJykpIDogcmVzdWx0O1xufTtcbiIsInZhciBjeCA9IC9bXFx1MDAwMFxcdTAwYWRcXHUwNjAwLVxcdTA2MDRcXHUwNzBmXFx1MTdiNFxcdTE3YjVcXHUyMDBjLVxcdTIwMGZcXHUyMDI4LVxcdTIwMmZcXHUyMDYwLVxcdTIwNmZcXHVmZWZmXFx1ZmZmMC1cXHVmZmZmXS9nLFxuICAgIGVzY2FwYWJsZSA9IC9bXFxcXFxcXCJcXHgwMC1cXHgxZlxceDdmLVxceDlmXFx1MDBhZFxcdTA2MDAtXFx1MDYwNFxcdTA3MGZcXHUxN2I0XFx1MTdiNVxcdTIwMGMtXFx1MjAwZlxcdTIwMjgtXFx1MjAyZlxcdTIwNjAtXFx1MjA2ZlxcdWZlZmZcXHVmZmYwLVxcdWZmZmZdL2csXG4gICAgZ2FwLFxuICAgIGluZGVudCxcbiAgICBtZXRhID0geyAgICAvLyB0YWJsZSBvZiBjaGFyYWN0ZXIgc3Vic3RpdHV0aW9uc1xuICAgICAgICAnXFxiJzogJ1xcXFxiJyxcbiAgICAgICAgJ1xcdCc6ICdcXFxcdCcsXG4gICAgICAgICdcXG4nOiAnXFxcXG4nLFxuICAgICAgICAnXFxmJzogJ1xcXFxmJyxcbiAgICAgICAgJ1xccic6ICdcXFxccicsXG4gICAgICAgICdcIicgOiAnXFxcXFwiJyxcbiAgICAgICAgJ1xcXFwnOiAnXFxcXFxcXFwnXG4gICAgfSxcbiAgICByZXA7XG5cbmZ1bmN0aW9uIHF1b3RlKHN0cmluZykge1xuICAgIC8vIElmIHRoZSBzdHJpbmcgY29udGFpbnMgbm8gY29udHJvbCBjaGFyYWN0ZXJzLCBubyBxdW90ZSBjaGFyYWN0ZXJzLCBhbmQgbm9cbiAgICAvLyBiYWNrc2xhc2ggY2hhcmFjdGVycywgdGhlbiB3ZSBjYW4gc2FmZWx5IHNsYXAgc29tZSBxdW90ZXMgYXJvdW5kIGl0LlxuICAgIC8vIE90aGVyd2lzZSB3ZSBtdXN0IGFsc28gcmVwbGFjZSB0aGUgb2ZmZW5kaW5nIGNoYXJhY3RlcnMgd2l0aCBzYWZlIGVzY2FwZVxuICAgIC8vIHNlcXVlbmNlcy5cbiAgICBcbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSA/ICdcIicgKyBzdHJpbmcucmVwbGFjZShlc2NhcGFibGUsIGZ1bmN0aW9uIChhKSB7XG4gICAgICAgIHZhciBjID0gbWV0YVthXTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBjID09PSAnc3RyaW5nJyA/IGMgOlxuICAgICAgICAgICAgJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgfSkgKyAnXCInIDogJ1wiJyArIHN0cmluZyArICdcIic7XG59XG5cbmZ1bmN0aW9uIHN0cihrZXksIGhvbGRlcikge1xuICAgIC8vIFByb2R1Y2UgYSBzdHJpbmcgZnJvbSBob2xkZXJba2V5XS5cbiAgICB2YXIgaSwgICAgICAgICAgLy8gVGhlIGxvb3AgY291bnRlci5cbiAgICAgICAgaywgICAgICAgICAgLy8gVGhlIG1lbWJlciBrZXkuXG4gICAgICAgIHYsICAgICAgICAgIC8vIFRoZSBtZW1iZXIgdmFsdWUuXG4gICAgICAgIGxlbmd0aCxcbiAgICAgICAgbWluZCA9IGdhcCxcbiAgICAgICAgcGFydGlhbCxcbiAgICAgICAgdmFsdWUgPSBob2xkZXJba2V5XTtcbiAgICBcbiAgICAvLyBJZiB0aGUgdmFsdWUgaGFzIGEgdG9KU09OIG1ldGhvZCwgY2FsbCBpdCB0byBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodmFsdWUgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlLnRvSlNPTiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvSlNPTihrZXkpO1xuICAgIH1cbiAgICBcbiAgICAvLyBJZiB3ZSB3ZXJlIGNhbGxlZCB3aXRoIGEgcmVwbGFjZXIgZnVuY3Rpb24sIHRoZW4gY2FsbCB0aGUgcmVwbGFjZXIgdG9cbiAgICAvLyBvYnRhaW4gYSByZXBsYWNlbWVudCB2YWx1ZS5cbiAgICBpZiAodHlwZW9mIHJlcCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IHJlcC5jYWxsKGhvbGRlciwga2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIFxuICAgIC8vIFdoYXQgaGFwcGVucyBuZXh0IGRlcGVuZHMgb24gdGhlIHZhbHVlJ3MgdHlwZS5cbiAgICBzd2l0Y2ggKHR5cGVvZiB2YWx1ZSkge1xuICAgICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIHF1b3RlKHZhbHVlKTtcbiAgICAgICAgXG4gICAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgICAgICAvLyBKU09OIG51bWJlcnMgbXVzdCBiZSBmaW5pdGUuIEVuY29kZSBub24tZmluaXRlIG51bWJlcnMgYXMgbnVsbC5cbiAgICAgICAgICAgIHJldHVybiBpc0Zpbml0ZSh2YWx1ZSkgPyBTdHJpbmcodmFsdWUpIDogJ251bGwnO1xuICAgICAgICBcbiAgICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIGNhc2UgJ251bGwnOlxuICAgICAgICAgICAgLy8gSWYgdGhlIHZhbHVlIGlzIGEgYm9vbGVhbiBvciBudWxsLCBjb252ZXJ0IGl0IHRvIGEgc3RyaW5nLiBOb3RlOlxuICAgICAgICAgICAgLy8gdHlwZW9mIG51bGwgZG9lcyBub3QgcHJvZHVjZSAnbnVsbCcuIFRoZSBjYXNlIGlzIGluY2x1ZGVkIGhlcmUgaW5cbiAgICAgICAgICAgIC8vIHRoZSByZW1vdGUgY2hhbmNlIHRoYXQgdGhpcyBnZXRzIGZpeGVkIHNvbWVkYXkuXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgICAgIFxuICAgICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICAgICAgaWYgKCF2YWx1ZSkgcmV0dXJuICdudWxsJztcbiAgICAgICAgICAgIGdhcCArPSBpbmRlbnQ7XG4gICAgICAgICAgICBwYXJ0aWFsID0gW107XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIEFycmF5LmlzQXJyYXlcbiAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmFwcGx5KHZhbHVlKSA9PT0gJ1tvYmplY3QgQXJyYXldJykge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFydGlhbFtpXSA9IHN0cihpLCB2YWx1ZSkgfHwgJ251bGwnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBcbiAgICAgICAgICAgICAgICAvLyBKb2luIGFsbCBvZiB0aGUgZWxlbWVudHMgdG9nZXRoZXIsIHNlcGFyYXRlZCB3aXRoIGNvbW1hcywgYW5kXG4gICAgICAgICAgICAgICAgLy8gd3JhcCB0aGVtIGluIGJyYWNrZXRzLlxuICAgICAgICAgICAgICAgIHYgPSBwYXJ0aWFsLmxlbmd0aCA9PT0gMCA/ICdbXScgOiBnYXAgP1xuICAgICAgICAgICAgICAgICAgICAnW1xcbicgKyBnYXAgKyBwYXJ0aWFsLmpvaW4oJyxcXG4nICsgZ2FwKSArICdcXG4nICsgbWluZCArICddJyA6XG4gICAgICAgICAgICAgICAgICAgICdbJyArIHBhcnRpYWwuam9pbignLCcpICsgJ10nO1xuICAgICAgICAgICAgICAgIGdhcCA9IG1pbmQ7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgICAgIC8vIElmIHRoZSByZXBsYWNlciBpcyBhbiBhcnJheSwgdXNlIGl0IHRvIHNlbGVjdCB0aGUgbWVtYmVycyB0byBiZVxuICAgICAgICAgICAgLy8gc3RyaW5naWZpZWQuXG4gICAgICAgICAgICBpZiAocmVwICYmIHR5cGVvZiByZXAgPT09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gcmVwLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgayA9IHJlcFtpXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdiA9IHN0cihrLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcnRpYWwucHVzaChxdW90ZShrKSArIChnYXAgPyAnOiAnIDogJzonKSArIHYpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gT3RoZXJ3aXNlLCBpdGVyYXRlIHRocm91Z2ggYWxsIG9mIHRoZSBrZXlzIGluIHRoZSBvYmplY3QuXG4gICAgICAgICAgICAgICAgZm9yIChrIGluIHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodmFsdWUsIGspKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2ID0gc3RyKGssIHZhbHVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh2KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFydGlhbC5wdXNoKHF1b3RlKGspICsgKGdhcCA/ICc6ICcgOiAnOicpICsgdik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBcbiAgICAgICAgLy8gSm9pbiBhbGwgb2YgdGhlIG1lbWJlciB0ZXh0cyB0b2dldGhlciwgc2VwYXJhdGVkIHdpdGggY29tbWFzLFxuICAgICAgICAvLyBhbmQgd3JhcCB0aGVtIGluIGJyYWNlcy5cblxuICAgICAgICB2ID0gcGFydGlhbC5sZW5ndGggPT09IDAgPyAne30nIDogZ2FwID9cbiAgICAgICAgICAgICd7XFxuJyArIGdhcCArIHBhcnRpYWwuam9pbignLFxcbicgKyBnYXApICsgJ1xcbicgKyBtaW5kICsgJ30nIDpcbiAgICAgICAgICAgICd7JyArIHBhcnRpYWwuam9pbignLCcpICsgJ30nO1xuICAgICAgICBnYXAgPSBtaW5kO1xuICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbHVlLCByZXBsYWNlciwgc3BhY2UpIHtcbiAgICB2YXIgaTtcbiAgICBnYXAgPSAnJztcbiAgICBpbmRlbnQgPSAnJztcbiAgICBcbiAgICAvLyBJZiB0aGUgc3BhY2UgcGFyYW1ldGVyIGlzIGEgbnVtYmVyLCBtYWtlIGFuIGluZGVudCBzdHJpbmcgY29udGFpbmluZyB0aGF0XG4gICAgLy8gbWFueSBzcGFjZXMuXG4gICAgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNwYWNlOyBpICs9IDEpIHtcbiAgICAgICAgICAgIGluZGVudCArPSAnICc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gSWYgdGhlIHNwYWNlIHBhcmFtZXRlciBpcyBhIHN0cmluZywgaXQgd2lsbCBiZSB1c2VkIGFzIHRoZSBpbmRlbnQgc3RyaW5nLlxuICAgIGVsc2UgaWYgKHR5cGVvZiBzcGFjZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaW5kZW50ID0gc3BhY2U7XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlcmUgaXMgYSByZXBsYWNlciwgaXQgbXVzdCBiZSBhIGZ1bmN0aW9uIG9yIGFuIGFycmF5LlxuICAgIC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3IuXG4gICAgcmVwID0gcmVwbGFjZXI7XG4gICAgaWYgKHJlcGxhY2VyICYmIHR5cGVvZiByZXBsYWNlciAhPT0gJ2Z1bmN0aW9uJ1xuICAgICYmICh0eXBlb2YgcmVwbGFjZXIgIT09ICdvYmplY3QnIHx8IHR5cGVvZiByZXBsYWNlci5sZW5ndGggIT09ICdudW1iZXInKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0pTT04uc3RyaW5naWZ5Jyk7XG4gICAgfVxuICAgIFxuICAgIC8vIE1ha2UgYSBmYWtlIHJvb3Qgb2JqZWN0IGNvbnRhaW5pbmcgb3VyIHZhbHVlIHVuZGVyIHRoZSBrZXkgb2YgJycuXG4gICAgLy8gUmV0dXJuIHRoZSByZXN1bHQgb2Ygc3RyaW5naWZ5aW5nIHRoZSB2YWx1ZS5cbiAgICByZXR1cm4gc3RyKCcnLCB7Jyc6IHZhbHVlfSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5pZiAoIXByb2Nlc3MudmVyc2lvbiB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MC4nKSA9PT0gMCB8fFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xuICBtb2R1bGUuZXhwb3J0cyA9IG5leHRUaWNrO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xufVxuXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJjYWxsYmFja1wiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB9XG4gIHZhciBsZW4gPSBhcmd1bWVudHMubGVuZ3RoO1xuICB2YXIgYXJncywgaTtcbiAgc3dpdGNoIChsZW4pIHtcbiAgY2FzZSAwOlxuICBjYXNlIDE6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZm4pO1xuICBjYXNlIDI6XG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xuICAgICAgZm4uY2FsbChudWxsLCBhcmcxKTtcbiAgICB9KTtcbiAgY2FzZSAzOlxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1R3bygpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMik7XG4gICAgfSk7XG4gIGNhc2UgNDpcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUaHJlZSgpIHtcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gICAgfSk7XG4gIGRlZmF1bHQ6XG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcbiAgICBpID0gMDtcbiAgICB3aGlsZSAoaSA8IGFyZ3MubGVuZ3RoKSB7XG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGljaygpIHtcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0pO1xuICB9XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiLyohIGh0dHBzOi8vbXRocy5iZS9wdW55Y29kZSB2MS40LjEgYnkgQG1hdGhpYXMgKi9cbjsoZnVuY3Rpb24ocm9vdCkge1xuXG5cdC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgKi9cblx0dmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJlxuXHRcdCFleHBvcnRzLm5vZGVUeXBlICYmIGV4cG9ydHM7XG5cdHZhciBmcmVlTW9kdWxlID0gdHlwZW9mIG1vZHVsZSA9PSAnb2JqZWN0JyAmJiBtb2R1bGUgJiZcblx0XHQhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblx0dmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcblx0aWYgKFxuXHRcdGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8XG5cdFx0ZnJlZUdsb2JhbC53aW5kb3cgPT09IGZyZWVHbG9iYWwgfHxcblx0XHRmcmVlR2xvYmFsLnNlbGYgPT09IGZyZWVHbG9iYWxcblx0KSB7XG5cdFx0cm9vdCA9IGZyZWVHbG9iYWw7XG5cdH1cblxuXHQvKipcblx0ICogVGhlIGBwdW55Y29kZWAgb2JqZWN0LlxuXHQgKiBAbmFtZSBwdW55Y29kZVxuXHQgKiBAdHlwZSBPYmplY3Rcblx0ICovXG5cdHZhciBwdW55Y29kZSxcblxuXHQvKiogSGlnaGVzdCBwb3NpdGl2ZSBzaWduZWQgMzItYml0IGZsb2F0IHZhbHVlICovXG5cdG1heEludCA9IDIxNDc0ODM2NDcsIC8vIGFrYS4gMHg3RkZGRkZGRiBvciAyXjMxLTFcblxuXHQvKiogQm9vdHN0cmluZyBwYXJhbWV0ZXJzICovXG5cdGJhc2UgPSAzNixcblx0dE1pbiA9IDEsXG5cdHRNYXggPSAyNixcblx0c2tldyA9IDM4LFxuXHRkYW1wID0gNzAwLFxuXHRpbml0aWFsQmlhcyA9IDcyLFxuXHRpbml0aWFsTiA9IDEyOCwgLy8gMHg4MFxuXHRkZWxpbWl0ZXIgPSAnLScsIC8vICdcXHgyRCdcblxuXHQvKiogUmVndWxhciBleHByZXNzaW9ucyAqL1xuXHRyZWdleFB1bnljb2RlID0gL154bi0tLyxcblx0cmVnZXhOb25BU0NJSSA9IC9bXlxceDIwLVxceDdFXS8sIC8vIHVucHJpbnRhYmxlIEFTQ0lJIGNoYXJzICsgbm9uLUFTQ0lJIGNoYXJzXG5cdHJlZ2V4U2VwYXJhdG9ycyA9IC9bXFx4MkVcXHUzMDAyXFx1RkYwRVxcdUZGNjFdL2csIC8vIFJGQyAzNDkwIHNlcGFyYXRvcnNcblxuXHQvKiogRXJyb3IgbWVzc2FnZXMgKi9cblx0ZXJyb3JzID0ge1xuXHRcdCdvdmVyZmxvdyc6ICdPdmVyZmxvdzogaW5wdXQgbmVlZHMgd2lkZXIgaW50ZWdlcnMgdG8gcHJvY2VzcycsXG5cdFx0J25vdC1iYXNpYyc6ICdJbGxlZ2FsIGlucHV0ID49IDB4ODAgKG5vdCBhIGJhc2ljIGNvZGUgcG9pbnQpJyxcblx0XHQnaW52YWxpZC1pbnB1dCc6ICdJbnZhbGlkIGlucHV0J1xuXHR9LFxuXG5cdC8qKiBDb252ZW5pZW5jZSBzaG9ydGN1dHMgKi9cblx0YmFzZU1pbnVzVE1pbiA9IGJhc2UgLSB0TWluLFxuXHRmbG9vciA9IE1hdGguZmxvb3IsXG5cdHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGUsXG5cblx0LyoqIFRlbXBvcmFyeSB2YXJpYWJsZSAqL1xuXHRrZXk7XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqXG5cdCAqIEEgZ2VuZXJpYyBlcnJvciB1dGlsaXR5IGZ1bmN0aW9uLlxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gdHlwZSBUaGUgZXJyb3IgdHlwZS5cblx0ICogQHJldHVybnMge0Vycm9yfSBUaHJvd3MgYSBgUmFuZ2VFcnJvcmAgd2l0aCB0aGUgYXBwbGljYWJsZSBlcnJvciBtZXNzYWdlLlxuXHQgKi9cblx0ZnVuY3Rpb24gZXJyb3IodHlwZSkge1xuXHRcdHRocm93IG5ldyBSYW5nZUVycm9yKGVycm9yc1t0eXBlXSk7XG5cdH1cblxuXHQvKipcblx0ICogQSBnZW5lcmljIGBBcnJheSNtYXBgIHV0aWxpdHkgZnVuY3Rpb24uXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeSBhcnJheVxuXHQgKiBpdGVtLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IEEgbmV3IGFycmF5IG9mIHZhbHVlcyByZXR1cm5lZCBieSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24uXG5cdCAqL1xuXHRmdW5jdGlvbiBtYXAoYXJyYXksIGZuKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblx0XHR2YXIgcmVzdWx0ID0gW107XG5cdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRyZXN1bHRbbGVuZ3RoXSA9IGZuKGFycmF5W2xlbmd0aF0pO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cblx0LyoqXG5cdCAqIEEgc2ltcGxlIGBBcnJheSNtYXBgLWxpa2Ugd3JhcHBlciB0byB3b3JrIHdpdGggZG9tYWluIG5hbWUgc3RyaW5ncyBvciBlbWFpbFxuXHQgKiBhZGRyZXNzZXMuXG5cdCAqIEBwcml2YXRlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBkb21haW4gVGhlIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MuXG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiB0aGF0IGdldHMgY2FsbGVkIGZvciBldmVyeVxuXHQgKiBjaGFyYWN0ZXIuXG5cdCAqIEByZXR1cm5zIHtBcnJheX0gQSBuZXcgc3RyaW5nIG9mIGNoYXJhY3RlcnMgcmV0dXJuZWQgYnkgdGhlIGNhbGxiYWNrXG5cdCAqIGZ1bmN0aW9uLlxuXHQgKi9cblx0ZnVuY3Rpb24gbWFwRG9tYWluKHN0cmluZywgZm4pIHtcblx0XHR2YXIgcGFydHMgPSBzdHJpbmcuc3BsaXQoJ0AnKTtcblx0XHR2YXIgcmVzdWx0ID0gJyc7XG5cdFx0aWYgKHBhcnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdC8vIEluIGVtYWlsIGFkZHJlc3Nlcywgb25seSB0aGUgZG9tYWluIG5hbWUgc2hvdWxkIGJlIHB1bnljb2RlZC4gTGVhdmVcblx0XHRcdC8vIHRoZSBsb2NhbCBwYXJ0IChpLmUuIGV2ZXJ5dGhpbmcgdXAgdG8gYEBgKSBpbnRhY3QuXG5cdFx0XHRyZXN1bHQgPSBwYXJ0c1swXSArICdAJztcblx0XHRcdHN0cmluZyA9IHBhcnRzWzFdO1xuXHRcdH1cblx0XHQvLyBBdm9pZCBgc3BsaXQocmVnZXgpYCBmb3IgSUU4IGNvbXBhdGliaWxpdHkuIFNlZSAjMTcuXG5cdFx0c3RyaW5nID0gc3RyaW5nLnJlcGxhY2UocmVnZXhTZXBhcmF0b3JzLCAnXFx4MkUnKTtcblx0XHR2YXIgbGFiZWxzID0gc3RyaW5nLnNwbGl0KCcuJyk7XG5cdFx0dmFyIGVuY29kZWQgPSBtYXAobGFiZWxzLCBmbikuam9pbignLicpO1xuXHRcdHJldHVybiByZXN1bHQgKyBlbmNvZGVkO1xuXHR9XG5cblx0LyoqXG5cdCAqIENyZWF0ZXMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgbnVtZXJpYyBjb2RlIHBvaW50cyBvZiBlYWNoIFVuaWNvZGVcblx0ICogY2hhcmFjdGVyIGluIHRoZSBzdHJpbmcuIFdoaWxlIEphdmFTY3JpcHQgdXNlcyBVQ1MtMiBpbnRlcm5hbGx5LFxuXHQgKiB0aGlzIGZ1bmN0aW9uIHdpbGwgY29udmVydCBhIHBhaXIgb2Ygc3Vycm9nYXRlIGhhbHZlcyAoZWFjaCBvZiB3aGljaFxuXHQgKiBVQ1MtMiBleHBvc2VzIGFzIHNlcGFyYXRlIGNoYXJhY3RlcnMpIGludG8gYSBzaW5nbGUgY29kZSBwb2ludCxcblx0ICogbWF0Y2hpbmcgVVRGLTE2LlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmVuY29kZWBcblx0ICogQHNlZSA8aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL2phdmFzY3JpcHQtZW5jb2Rpbmc+XG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZS51Y3MyXG5cdCAqIEBuYW1lIGRlY29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gc3RyaW5nIFRoZSBVbmljb2RlIGlucHV0IHN0cmluZyAoVUNTLTIpLlxuXHQgKiBAcmV0dXJucyB7QXJyYXl9IFRoZSBuZXcgYXJyYXkgb2YgY29kZSBwb2ludHMuXG5cdCAqL1xuXHRmdW5jdGlvbiB1Y3MyZGVjb2RlKHN0cmluZykge1xuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgY291bnRlciA9IDAsXG5cdFx0ICAgIGxlbmd0aCA9IHN0cmluZy5sZW5ndGgsXG5cdFx0ICAgIHZhbHVlLFxuXHRcdCAgICBleHRyYTtcblx0XHR3aGlsZSAoY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0dmFsdWUgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0aWYgKHZhbHVlID49IDB4RDgwMCAmJiB2YWx1ZSA8PSAweERCRkYgJiYgY291bnRlciA8IGxlbmd0aCkge1xuXHRcdFx0XHQvLyBoaWdoIHN1cnJvZ2F0ZSwgYW5kIHRoZXJlIGlzIGEgbmV4dCBjaGFyYWN0ZXJcblx0XHRcdFx0ZXh0cmEgPSBzdHJpbmcuY2hhckNvZGVBdChjb3VudGVyKyspO1xuXHRcdFx0XHRpZiAoKGV4dHJhICYgMHhGQzAwKSA9PSAweERDMDApIHsgLy8gbG93IHN1cnJvZ2F0ZVxuXHRcdFx0XHRcdG91dHB1dC5wdXNoKCgodmFsdWUgJiAweDNGRikgPDwgMTApICsgKGV4dHJhICYgMHgzRkYpICsgMHgxMDAwMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Ly8gdW5tYXRjaGVkIHN1cnJvZ2F0ZTsgb25seSBhcHBlbmQgdGhpcyBjb2RlIHVuaXQsIGluIGNhc2UgdGhlIG5leHRcblx0XHRcdFx0XHQvLyBjb2RlIHVuaXQgaXMgdGhlIGhpZ2ggc3Vycm9nYXRlIG9mIGEgc3Vycm9nYXRlIHBhaXJcblx0XHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHRcdFx0Y291bnRlci0tO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvdXRwdXQucHVzaCh2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQ7XG5cdH1cblxuXHQvKipcblx0ICogQ3JlYXRlcyBhIHN0cmluZyBiYXNlZCBvbiBhbiBhcnJheSBvZiBudW1lcmljIGNvZGUgcG9pbnRzLlxuXHQgKiBAc2VlIGBwdW55Y29kZS51Y3MyLmRlY29kZWBcblx0ICogQG1lbWJlck9mIHB1bnljb2RlLnVjczJcblx0ICogQG5hbWUgZW5jb2RlXG5cdCAqIEBwYXJhbSB7QXJyYXl9IGNvZGVQb2ludHMgVGhlIGFycmF5IG9mIG51bWVyaWMgY29kZSBwb2ludHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBuZXcgVW5pY29kZSBzdHJpbmcgKFVDUy0yKS5cblx0ICovXG5cdGZ1bmN0aW9uIHVjczJlbmNvZGUoYXJyYXkpIHtcblx0XHRyZXR1cm4gbWFwKGFycmF5LCBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG91dHB1dCA9ICcnO1xuXHRcdFx0aWYgKHZhbHVlID4gMHhGRkZGKSB7XG5cdFx0XHRcdHZhbHVlIC09IDB4MTAwMDA7XG5cdFx0XHRcdG91dHB1dCArPSBzdHJpbmdGcm9tQ2hhckNvZGUodmFsdWUgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xuXHRcdFx0XHR2YWx1ZSA9IDB4REMwMCB8IHZhbHVlICYgMHgzRkY7XG5cdFx0XHR9XG5cdFx0XHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKHZhbHVlKTtcblx0XHRcdHJldHVybiBvdXRwdXQ7XG5cdFx0fSkuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBiYXNpYyBjb2RlIHBvaW50IGludG8gYSBkaWdpdC9pbnRlZ2VyLlxuXHQgKiBAc2VlIGBkaWdpdFRvQmFzaWMoKWBcblx0ICogQHByaXZhdGVcblx0ICogQHBhcmFtIHtOdW1iZXJ9IGNvZGVQb2ludCBUaGUgYmFzaWMgbnVtZXJpYyBjb2RlIHBvaW50IHZhbHVlLlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgbnVtZXJpYyB2YWx1ZSBvZiBhIGJhc2ljIGNvZGUgcG9pbnQgKGZvciB1c2UgaW5cblx0ICogcmVwcmVzZW50aW5nIGludGVnZXJzKSBpbiB0aGUgcmFuZ2UgYDBgIHRvIGBiYXNlIC0gMWAsIG9yIGBiYXNlYCBpZlxuXHQgKiB0aGUgY29kZSBwb2ludCBkb2VzIG5vdCByZXByZXNlbnQgYSB2YWx1ZS5cblx0ICovXG5cdGZ1bmN0aW9uIGJhc2ljVG9EaWdpdChjb2RlUG9pbnQpIHtcblx0XHRpZiAoY29kZVBvaW50IC0gNDggPCAxMCkge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDIyO1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gNjUgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDY1O1xuXHRcdH1cblx0XHRpZiAoY29kZVBvaW50IC0gOTcgPCAyNikge1xuXHRcdFx0cmV0dXJuIGNvZGVQb2ludCAtIDk3O1xuXHRcdH1cblx0XHRyZXR1cm4gYmFzZTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIGRpZ2l0L2ludGVnZXIgaW50byBhIGJhc2ljIGNvZGUgcG9pbnQuXG5cdCAqIEBzZWUgYGJhc2ljVG9EaWdpdCgpYFxuXHQgKiBAcHJpdmF0ZVxuXHQgKiBAcGFyYW0ge051bWJlcn0gZGlnaXQgVGhlIG51bWVyaWMgdmFsdWUgb2YgYSBiYXNpYyBjb2RlIHBvaW50LlxuXHQgKiBAcmV0dXJucyB7TnVtYmVyfSBUaGUgYmFzaWMgY29kZSBwb2ludCB3aG9zZSB2YWx1ZSAod2hlbiB1c2VkIGZvclxuXHQgKiByZXByZXNlbnRpbmcgaW50ZWdlcnMpIGlzIGBkaWdpdGAsIHdoaWNoIG5lZWRzIHRvIGJlIGluIHRoZSByYW5nZVxuXHQgKiBgMGAgdG8gYGJhc2UgLSAxYC4gSWYgYGZsYWdgIGlzIG5vbi16ZXJvLCB0aGUgdXBwZXJjYXNlIGZvcm0gaXNcblx0ICogdXNlZDsgZWxzZSwgdGhlIGxvd2VyY2FzZSBmb3JtIGlzIHVzZWQuIFRoZSBiZWhhdmlvciBpcyB1bmRlZmluZWRcblx0ICogaWYgYGZsYWdgIGlzIG5vbi16ZXJvIGFuZCBgZGlnaXRgIGhhcyBubyB1cHBlcmNhc2UgZm9ybS5cblx0ICovXG5cdGZ1bmN0aW9uIGRpZ2l0VG9CYXNpYyhkaWdpdCwgZmxhZykge1xuXHRcdC8vICAwLi4yNSBtYXAgdG8gQVNDSUkgYS4ueiBvciBBLi5aXG5cdFx0Ly8gMjYuLjM1IG1hcCB0byBBU0NJSSAwLi45XG5cdFx0cmV0dXJuIGRpZ2l0ICsgMjIgKyA3NSAqIChkaWdpdCA8IDI2KSAtICgoZmxhZyAhPSAwKSA8PCA1KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBCaWFzIGFkYXB0YXRpb24gZnVuY3Rpb24gYXMgcGVyIHNlY3Rpb24gMy40IG9mIFJGQyAzNDkyLlxuXHQgKiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjMzQ5MiNzZWN0aW9uLTMuNFxuXHQgKiBAcHJpdmF0ZVxuXHQgKi9cblx0ZnVuY3Rpb24gYWRhcHQoZGVsdGEsIG51bVBvaW50cywgZmlyc3RUaW1lKSB7XG5cdFx0dmFyIGsgPSAwO1xuXHRcdGRlbHRhID0gZmlyc3RUaW1lID8gZmxvb3IoZGVsdGEgLyBkYW1wKSA6IGRlbHRhID4+IDE7XG5cdFx0ZGVsdGEgKz0gZmxvb3IoZGVsdGEgLyBudW1Qb2ludHMpO1xuXHRcdGZvciAoLyogbm8gaW5pdGlhbGl6YXRpb24gKi87IGRlbHRhID4gYmFzZU1pbnVzVE1pbiAqIHRNYXggPj4gMTsgayArPSBiYXNlKSB7XG5cdFx0XHRkZWx0YSA9IGZsb29yKGRlbHRhIC8gYmFzZU1pbnVzVE1pbik7XG5cdFx0fVxuXHRcdHJldHVybiBmbG9vcihrICsgKGJhc2VNaW51c1RNaW4gKyAxKSAqIGRlbHRhIC8gKGRlbHRhICsgc2tldykpO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgUHVueWNvZGUgc3RyaW5nIG9mIEFTQ0lJLW9ubHkgc3ltYm9scyB0byBhIHN0cmluZyBvZiBVbmljb2RlXG5cdCAqIHN5bWJvbHMuXG5cdCAqIEBtZW1iZXJPZiBwdW55Y29kZVxuXHQgKiBAcGFyYW0ge1N0cmluZ30gaW5wdXQgVGhlIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSByZXN1bHRpbmcgc3RyaW5nIG9mIFVuaWNvZGUgc3ltYm9scy5cblx0ICovXG5cdGZ1bmN0aW9uIGRlY29kZShpbnB1dCkge1xuXHRcdC8vIERvbid0IHVzZSBVQ1MtMlxuXHRcdHZhciBvdXRwdXQgPSBbXSxcblx0XHQgICAgaW5wdXRMZW5ndGggPSBpbnB1dC5sZW5ndGgsXG5cdFx0ICAgIG91dCxcblx0XHQgICAgaSA9IDAsXG5cdFx0ICAgIG4gPSBpbml0aWFsTixcblx0XHQgICAgYmlhcyA9IGluaXRpYWxCaWFzLFxuXHRcdCAgICBiYXNpYyxcblx0XHQgICAgaixcblx0XHQgICAgaW5kZXgsXG5cdFx0ICAgIG9sZGksXG5cdFx0ICAgIHcsXG5cdFx0ICAgIGssXG5cdFx0ICAgIGRpZ2l0LFxuXHRcdCAgICB0LFxuXHRcdCAgICAvKiogQ2FjaGVkIGNhbGN1bGF0aW9uIHJlc3VsdHMgKi9cblx0XHQgICAgYmFzZU1pbnVzVDtcblxuXHRcdC8vIEhhbmRsZSB0aGUgYmFzaWMgY29kZSBwb2ludHM6IGxldCBgYmFzaWNgIGJlIHRoZSBudW1iZXIgb2YgaW5wdXQgY29kZVxuXHRcdC8vIHBvaW50cyBiZWZvcmUgdGhlIGxhc3QgZGVsaW1pdGVyLCBvciBgMGAgaWYgdGhlcmUgaXMgbm9uZSwgdGhlbiBjb3B5XG5cdFx0Ly8gdGhlIGZpcnN0IGJhc2ljIGNvZGUgcG9pbnRzIHRvIHRoZSBvdXRwdXQuXG5cblx0XHRiYXNpYyA9IGlucHV0Lmxhc3RJbmRleE9mKGRlbGltaXRlcik7XG5cdFx0aWYgKGJhc2ljIDwgMCkge1xuXHRcdFx0YmFzaWMgPSAwO1xuXHRcdH1cblxuXHRcdGZvciAoaiA9IDA7IGogPCBiYXNpYzsgKytqKSB7XG5cdFx0XHQvLyBpZiBpdCdzIG5vdCBhIGJhc2ljIGNvZGUgcG9pbnRcblx0XHRcdGlmIChpbnB1dC5jaGFyQ29kZUF0KGopID49IDB4ODApIHtcblx0XHRcdFx0ZXJyb3IoJ25vdC1iYXNpYycpO1xuXHRcdFx0fVxuXHRcdFx0b3V0cHV0LnB1c2goaW5wdXQuY2hhckNvZGVBdChqKSk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFpbiBkZWNvZGluZyBsb29wOiBzdGFydCBqdXN0IGFmdGVyIHRoZSBsYXN0IGRlbGltaXRlciBpZiBhbnkgYmFzaWMgY29kZVxuXHRcdC8vIHBvaW50cyB3ZXJlIGNvcGllZDsgc3RhcnQgYXQgdGhlIGJlZ2lubmluZyBvdGhlcndpc2UuXG5cblx0XHRmb3IgKGluZGV4ID0gYmFzaWMgPiAwID8gYmFzaWMgKyAxIDogMDsgaW5kZXggPCBpbnB1dExlbmd0aDsgLyogbm8gZmluYWwgZXhwcmVzc2lvbiAqLykge1xuXG5cdFx0XHQvLyBgaW5kZXhgIGlzIHRoZSBpbmRleCBvZiB0aGUgbmV4dCBjaGFyYWN0ZXIgdG8gYmUgY29uc3VtZWQuXG5cdFx0XHQvLyBEZWNvZGUgYSBnZW5lcmFsaXplZCB2YXJpYWJsZS1sZW5ndGggaW50ZWdlciBpbnRvIGBkZWx0YWAsXG5cdFx0XHQvLyB3aGljaCBnZXRzIGFkZGVkIHRvIGBpYC4gVGhlIG92ZXJmbG93IGNoZWNraW5nIGlzIGVhc2llclxuXHRcdFx0Ly8gaWYgd2UgaW5jcmVhc2UgYGlgIGFzIHdlIGdvLCB0aGVuIHN1YnRyYWN0IG9mZiBpdHMgc3RhcnRpbmdcblx0XHRcdC8vIHZhbHVlIGF0IHRoZSBlbmQgdG8gb2J0YWluIGBkZWx0YWAuXG5cdFx0XHRmb3IgKG9sZGkgPSBpLCB3ID0gMSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cblx0XHRcdFx0aWYgKGluZGV4ID49IGlucHV0TGVuZ3RoKSB7XG5cdFx0XHRcdFx0ZXJyb3IoJ2ludmFsaWQtaW5wdXQnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRpZ2l0ID0gYmFzaWNUb0RpZ2l0KGlucHV0LmNoYXJDb2RlQXQoaW5kZXgrKykpO1xuXG5cdFx0XHRcdGlmIChkaWdpdCA+PSBiYXNlIHx8IGRpZ2l0ID4gZmxvb3IoKG1heEludCAtIGkpIC8gdykpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGkgKz0gZGlnaXQgKiB3O1xuXHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblxuXHRcdFx0XHRpZiAoZGlnaXQgPCB0KSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRiYXNlTWludXNUID0gYmFzZSAtIHQ7XG5cdFx0XHRcdGlmICh3ID4gZmxvb3IobWF4SW50IC8gYmFzZU1pbnVzVCkpIHtcblx0XHRcdFx0XHRlcnJvcignb3ZlcmZsb3cnKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHcgKj0gYmFzZU1pbnVzVDtcblxuXHRcdFx0fVxuXG5cdFx0XHRvdXQgPSBvdXRwdXQubGVuZ3RoICsgMTtcblx0XHRcdGJpYXMgPSBhZGFwdChpIC0gb2xkaSwgb3V0LCBvbGRpID09IDApO1xuXG5cdFx0XHQvLyBgaWAgd2FzIHN1cHBvc2VkIHRvIHdyYXAgYXJvdW5kIGZyb20gYG91dGAgdG8gYDBgLFxuXHRcdFx0Ly8gaW5jcmVtZW50aW5nIGBuYCBlYWNoIHRpbWUsIHNvIHdlJ2xsIGZpeCB0aGF0IG5vdzpcblx0XHRcdGlmIChmbG9vcihpIC8gb3V0KSA+IG1heEludCAtIG4pIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdG4gKz0gZmxvb3IoaSAvIG91dCk7XG5cdFx0XHRpICU9IG91dDtcblxuXHRcdFx0Ly8gSW5zZXJ0IGBuYCBhdCBwb3NpdGlvbiBgaWAgb2YgdGhlIG91dHB1dFxuXHRcdFx0b3V0cHV0LnNwbGljZShpKyssIDAsIG4pO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHVjczJlbmNvZGUob3V0cHV0KTtcblx0fVxuXG5cdC8qKlxuXHQgKiBDb252ZXJ0cyBhIHN0cmluZyBvZiBVbmljb2RlIHN5bWJvbHMgKGUuZy4gYSBkb21haW4gbmFtZSBsYWJlbCkgdG8gYVxuXHQgKiBQdW55Y29kZSBzdHJpbmcgb2YgQVNDSUktb25seSBzeW1ib2xzLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgb2YgVW5pY29kZSBzeW1ib2xzLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgcmVzdWx0aW5nIFB1bnljb2RlIHN0cmluZyBvZiBBU0NJSS1vbmx5IHN5bWJvbHMuXG5cdCAqL1xuXHRmdW5jdGlvbiBlbmNvZGUoaW5wdXQpIHtcblx0XHR2YXIgbixcblx0XHQgICAgZGVsdGEsXG5cdFx0ICAgIGhhbmRsZWRDUENvdW50LFxuXHRcdCAgICBiYXNpY0xlbmd0aCxcblx0XHQgICAgYmlhcyxcblx0XHQgICAgaixcblx0XHQgICAgbSxcblx0XHQgICAgcSxcblx0XHQgICAgayxcblx0XHQgICAgdCxcblx0XHQgICAgY3VycmVudFZhbHVlLFxuXHRcdCAgICBvdXRwdXQgPSBbXSxcblx0XHQgICAgLyoqIGBpbnB1dExlbmd0aGAgd2lsbCBob2xkIHRoZSBudW1iZXIgb2YgY29kZSBwb2ludHMgaW4gYGlucHV0YC4gKi9cblx0XHQgICAgaW5wdXRMZW5ndGgsXG5cdFx0ICAgIC8qKiBDYWNoZWQgY2FsY3VsYXRpb24gcmVzdWx0cyAqL1xuXHRcdCAgICBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsXG5cdFx0ICAgIGJhc2VNaW51c1QsXG5cdFx0ICAgIHFNaW51c1Q7XG5cblx0XHQvLyBDb252ZXJ0IHRoZSBpbnB1dCBpbiBVQ1MtMiB0byBVbmljb2RlXG5cdFx0aW5wdXQgPSB1Y3MyZGVjb2RlKGlucHV0KTtcblxuXHRcdC8vIENhY2hlIHRoZSBsZW5ndGhcblx0XHRpbnB1dExlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblxuXHRcdC8vIEluaXRpYWxpemUgdGhlIHN0YXRlXG5cdFx0biA9IGluaXRpYWxOO1xuXHRcdGRlbHRhID0gMDtcblx0XHRiaWFzID0gaW5pdGlhbEJpYXM7XG5cblx0XHQvLyBIYW5kbGUgdGhlIGJhc2ljIGNvZGUgcG9pbnRzXG5cdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdGN1cnJlbnRWYWx1ZSA9IGlucHV0W2pdO1xuXHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IDB4ODApIHtcblx0XHRcdFx0b3V0cHV0LnB1c2goc3RyaW5nRnJvbUNoYXJDb2RlKGN1cnJlbnRWYWx1ZSkpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGhhbmRsZWRDUENvdW50ID0gYmFzaWNMZW5ndGggPSBvdXRwdXQubGVuZ3RoO1xuXG5cdFx0Ly8gYGhhbmRsZWRDUENvdW50YCBpcyB0aGUgbnVtYmVyIG9mIGNvZGUgcG9pbnRzIHRoYXQgaGF2ZSBiZWVuIGhhbmRsZWQ7XG5cdFx0Ly8gYGJhc2ljTGVuZ3RoYCBpcyB0aGUgbnVtYmVyIG9mIGJhc2ljIGNvZGUgcG9pbnRzLlxuXG5cdFx0Ly8gRmluaXNoIHRoZSBiYXNpYyBzdHJpbmcgLSBpZiBpdCBpcyBub3QgZW1wdHkgLSB3aXRoIGEgZGVsaW1pdGVyXG5cdFx0aWYgKGJhc2ljTGVuZ3RoKSB7XG5cdFx0XHRvdXRwdXQucHVzaChkZWxpbWl0ZXIpO1xuXHRcdH1cblxuXHRcdC8vIE1haW4gZW5jb2RpbmcgbG9vcDpcblx0XHR3aGlsZSAoaGFuZGxlZENQQ291bnQgPCBpbnB1dExlbmd0aCkge1xuXG5cdFx0XHQvLyBBbGwgbm9uLWJhc2ljIGNvZGUgcG9pbnRzIDwgbiBoYXZlIGJlZW4gaGFuZGxlZCBhbHJlYWR5LiBGaW5kIHRoZSBuZXh0XG5cdFx0XHQvLyBsYXJnZXIgb25lOlxuXHRcdFx0Zm9yIChtID0gbWF4SW50LCBqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cdFx0XHRcdGlmIChjdXJyZW50VmFsdWUgPj0gbiAmJiBjdXJyZW50VmFsdWUgPCBtKSB7XG5cdFx0XHRcdFx0bSA9IGN1cnJlbnRWYWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBJbmNyZWFzZSBgZGVsdGFgIGVub3VnaCB0byBhZHZhbmNlIHRoZSBkZWNvZGVyJ3MgPG4saT4gc3RhdGUgdG8gPG0sMD4sXG5cdFx0XHQvLyBidXQgZ3VhcmQgYWdhaW5zdCBvdmVyZmxvd1xuXHRcdFx0aGFuZGxlZENQQ291bnRQbHVzT25lID0gaGFuZGxlZENQQ291bnQgKyAxO1xuXHRcdFx0aWYgKG0gLSBuID4gZmxvb3IoKG1heEludCAtIGRlbHRhKSAvIGhhbmRsZWRDUENvdW50UGx1c09uZSkpIHtcblx0XHRcdFx0ZXJyb3IoJ292ZXJmbG93Jyk7XG5cdFx0XHR9XG5cblx0XHRcdGRlbHRhICs9IChtIC0gbikgKiBoYW5kbGVkQ1BDb3VudFBsdXNPbmU7XG5cdFx0XHRuID0gbTtcblxuXHRcdFx0Zm9yIChqID0gMDsgaiA8IGlucHV0TGVuZ3RoOyArK2opIHtcblx0XHRcdFx0Y3VycmVudFZhbHVlID0gaW5wdXRbal07XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA8IG4gJiYgKytkZWx0YSA+IG1heEludCkge1xuXHRcdFx0XHRcdGVycm9yKCdvdmVyZmxvdycpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKGN1cnJlbnRWYWx1ZSA9PSBuKSB7XG5cdFx0XHRcdFx0Ly8gUmVwcmVzZW50IGRlbHRhIGFzIGEgZ2VuZXJhbGl6ZWQgdmFyaWFibGUtbGVuZ3RoIGludGVnZXJcblx0XHRcdFx0XHRmb3IgKHEgPSBkZWx0YSwgayA9IGJhc2U7IC8qIG5vIGNvbmRpdGlvbiAqLzsgayArPSBiYXNlKSB7XG5cdFx0XHRcdFx0XHR0ID0gayA8PSBiaWFzID8gdE1pbiA6IChrID49IGJpYXMgKyB0TWF4ID8gdE1heCA6IGsgLSBiaWFzKTtcblx0XHRcdFx0XHRcdGlmIChxIDwgdCkge1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHFNaW51c1QgPSBxIC0gdDtcblx0XHRcdFx0XHRcdGJhc2VNaW51c1QgPSBiYXNlIC0gdDtcblx0XHRcdFx0XHRcdG91dHB1dC5wdXNoKFxuXHRcdFx0XHRcdFx0XHRzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHQgKyBxTWludXNUICUgYmFzZU1pbnVzVCwgMCkpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cSA9IGZsb29yKHFNaW51c1QgLyBiYXNlTWludXNUKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRvdXRwdXQucHVzaChzdHJpbmdGcm9tQ2hhckNvZGUoZGlnaXRUb0Jhc2ljKHEsIDApKSk7XG5cdFx0XHRcdFx0YmlhcyA9IGFkYXB0KGRlbHRhLCBoYW5kbGVkQ1BDb3VudFBsdXNPbmUsIGhhbmRsZWRDUENvdW50ID09IGJhc2ljTGVuZ3RoKTtcblx0XHRcdFx0XHRkZWx0YSA9IDA7XG5cdFx0XHRcdFx0KytoYW5kbGVkQ1BDb3VudDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQrK2RlbHRhO1xuXHRcdFx0KytuO1xuXG5cdFx0fVxuXHRcdHJldHVybiBvdXRwdXQuam9pbignJyk7XG5cdH1cblxuXHQvKipcblx0ICogQ29udmVydHMgYSBQdW55Y29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzc1xuXHQgKiB0byBVbmljb2RlLiBPbmx5IHRoZSBQdW55Y29kZWQgcGFydHMgb2YgdGhlIGlucHV0IHdpbGwgYmUgY29udmVydGVkLCBpLmUuXG5cdCAqIGl0IGRvZXNuJ3QgbWF0dGVyIGlmIHlvdSBjYWxsIGl0IG9uIGEgc3RyaW5nIHRoYXQgaGFzIGFscmVhZHkgYmVlblxuXHQgKiBjb252ZXJ0ZWQgdG8gVW5pY29kZS5cblx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdCAqIEBwYXJhbSB7U3RyaW5nfSBpbnB1dCBUaGUgUHVueWNvZGVkIGRvbWFpbiBuYW1lIG9yIGVtYWlsIGFkZHJlc3MgdG9cblx0ICogY29udmVydCB0byBVbmljb2RlLlxuXHQgKiBAcmV0dXJucyB7U3RyaW5nfSBUaGUgVW5pY29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gUHVueWNvZGVcblx0ICogc3RyaW5nLlxuXHQgKi9cblx0ZnVuY3Rpb24gdG9Vbmljb2RlKGlucHV0KSB7XG5cdFx0cmV0dXJuIG1hcERvbWFpbihpbnB1dCwgZnVuY3Rpb24oc3RyaW5nKSB7XG5cdFx0XHRyZXR1cm4gcmVnZXhQdW55Y29kZS50ZXN0KHN0cmluZylcblx0XHRcdFx0PyBkZWNvZGUoc3RyaW5nLnNsaWNlKDQpLnRvTG93ZXJDYXNlKCkpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIENvbnZlcnRzIGEgVW5pY29kZSBzdHJpbmcgcmVwcmVzZW50aW5nIGEgZG9tYWluIG5hbWUgb3IgYW4gZW1haWwgYWRkcmVzcyB0b1xuXHQgKiBQdW55Y29kZS4gT25seSB0aGUgbm9uLUFTQ0lJIHBhcnRzIG9mIHRoZSBkb21haW4gbmFtZSB3aWxsIGJlIGNvbnZlcnRlZCxcblx0ICogaS5lLiBpdCBkb2Vzbid0IG1hdHRlciBpZiB5b3UgY2FsbCBpdCB3aXRoIGEgZG9tYWluIHRoYXQncyBhbHJlYWR5IGluXG5cdCAqIEFTQ0lJLlxuXHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0ICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBkb21haW4gbmFtZSBvciBlbWFpbCBhZGRyZXNzIHRvIGNvbnZlcnQsIGFzIGFcblx0ICogVW5pY29kZSBzdHJpbmcuXG5cdCAqIEByZXR1cm5zIHtTdHJpbmd9IFRoZSBQdW55Y29kZSByZXByZXNlbnRhdGlvbiBvZiB0aGUgZ2l2ZW4gZG9tYWluIG5hbWUgb3Jcblx0ICogZW1haWwgYWRkcmVzcy5cblx0ICovXG5cdGZ1bmN0aW9uIHRvQVNDSUkoaW5wdXQpIHtcblx0XHRyZXR1cm4gbWFwRG9tYWluKGlucHV0LCBmdW5jdGlvbihzdHJpbmcpIHtcblx0XHRcdHJldHVybiByZWdleE5vbkFTQ0lJLnRlc3Qoc3RyaW5nKVxuXHRcdFx0XHQ/ICd4bi0tJyArIGVuY29kZShzdHJpbmcpXG5cdFx0XHRcdDogc3RyaW5nO1xuXHRcdH0pO1xuXHR9XG5cblx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cblx0LyoqIERlZmluZSB0aGUgcHVibGljIEFQSSAqL1xuXHRwdW55Y29kZSA9IHtcblx0XHQvKipcblx0XHQgKiBBIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIGN1cnJlbnQgUHVueWNvZGUuanMgdmVyc2lvbiBudW1iZXIuXG5cdFx0ICogQG1lbWJlck9mIHB1bnljb2RlXG5cdFx0ICogQHR5cGUgU3RyaW5nXG5cdFx0ICovXG5cdFx0J3ZlcnNpb24nOiAnMS40LjEnLFxuXHRcdC8qKlxuXHRcdCAqIEFuIG9iamVjdCBvZiBtZXRob2RzIHRvIGNvbnZlcnQgZnJvbSBKYXZhU2NyaXB0J3MgaW50ZXJuYWwgY2hhcmFjdGVyXG5cdFx0ICogcmVwcmVzZW50YXRpb24gKFVDUy0yKSB0byBVbmljb2RlIGNvZGUgcG9pbnRzLCBhbmQgYmFjay5cblx0XHQgKiBAc2VlIDxodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZz5cblx0XHQgKiBAbWVtYmVyT2YgcHVueWNvZGVcblx0XHQgKiBAdHlwZSBPYmplY3Rcblx0XHQgKi9cblx0XHQndWNzMic6IHtcblx0XHRcdCdkZWNvZGUnOiB1Y3MyZGVjb2RlLFxuXHRcdFx0J2VuY29kZSc6IHVjczJlbmNvZGVcblx0XHR9LFxuXHRcdCdkZWNvZGUnOiBkZWNvZGUsXG5cdFx0J2VuY29kZSc6IGVuY29kZSxcblx0XHQndG9BU0NJSSc6IHRvQVNDSUksXG5cdFx0J3RvVW5pY29kZSc6IHRvVW5pY29kZVxuXHR9O1xuXG5cdC8qKiBFeHBvc2UgYHB1bnljb2RlYCAqL1xuXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcblx0Ly8gbGlrZSB0aGUgZm9sbG93aW5nOlxuXHRpZiAoXG5cdFx0dHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmXG5cdFx0dHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiZcblx0XHRkZWZpbmUuYW1kXG5cdCkge1xuXHRcdGRlZmluZSgncHVueWNvZGUnLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBwdW55Y29kZTtcblx0XHR9KTtcblx0fSBlbHNlIGlmIChmcmVlRXhwb3J0cyAmJiBmcmVlTW9kdWxlKSB7XG5cdFx0aWYgKG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzKSB7XG5cdFx0XHQvLyBpbiBOb2RlLmpzLCBpby5qcywgb3IgUmluZ29KUyB2MC44LjArXG5cdFx0XHRmcmVlTW9kdWxlLmV4cG9ydHMgPSBwdW55Y29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gaW4gTmFyd2hhbCBvciBSaW5nb0pTIHYwLjcuMC1cblx0XHRcdGZvciAoa2V5IGluIHB1bnljb2RlKSB7XG5cdFx0XHRcdHB1bnljb2RlLmhhc093blByb3BlcnR5KGtleSkgJiYgKGZyZWVFeHBvcnRzW2tleV0gPSBwdW55Y29kZVtrZXldKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSB7XG5cdFx0Ly8gaW4gUmhpbm8gb3IgYSB3ZWIgYnJvd3NlclxuXHRcdHJvb3QucHVueWNvZGUgPSBwdW55Y29kZTtcblx0fVxuXG59KHRoaXMpKTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4ndXNlIHN0cmljdCc7XG5cbi8vIElmIG9iai5oYXNPd25Qcm9wZXJ0eSBoYXMgYmVlbiBvdmVycmlkZGVuLCB0aGVuIGNhbGxpbmdcbi8vIG9iai5oYXNPd25Qcm9wZXJ0eShwcm9wKSB3aWxsIGJyZWFrLlxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vam95ZW50L25vZGUvaXNzdWVzLzE3MDdcbmZ1bmN0aW9uIGhhc093blByb3BlcnR5KG9iaiwgcHJvcCkge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24ocXMsIHNlcCwgZXEsIG9wdGlvbnMpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIHZhciBvYmogPSB7fTtcblxuICBpZiAodHlwZW9mIHFzICE9PSAnc3RyaW5nJyB8fCBxcy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gb2JqO1xuICB9XG5cbiAgdmFyIHJlZ2V4cCA9IC9cXCsvZztcbiAgcXMgPSBxcy5zcGxpdChzZXApO1xuXG4gIHZhciBtYXhLZXlzID0gMTAwMDtcbiAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIG9wdGlvbnMubWF4S2V5cyA9PT0gJ251bWJlcicpIHtcbiAgICBtYXhLZXlzID0gb3B0aW9ucy5tYXhLZXlzO1xuICB9XG5cbiAgdmFyIGxlbiA9IHFzLmxlbmd0aDtcbiAgLy8gbWF4S2V5cyA8PSAwIG1lYW5zIHRoYXQgd2Ugc2hvdWxkIG5vdCBsaW1pdCBrZXlzIGNvdW50XG4gIGlmIChtYXhLZXlzID4gMCAmJiBsZW4gPiBtYXhLZXlzKSB7XG4gICAgbGVuID0gbWF4S2V5cztcbiAgfVxuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpIHtcbiAgICB2YXIgeCA9IHFzW2ldLnJlcGxhY2UocmVnZXhwLCAnJTIwJyksXG4gICAgICAgIGlkeCA9IHguaW5kZXhPZihlcSksXG4gICAgICAgIGtzdHIsIHZzdHIsIGssIHY7XG5cbiAgICBpZiAoaWR4ID49IDApIHtcbiAgICAgIGtzdHIgPSB4LnN1YnN0cigwLCBpZHgpO1xuICAgICAgdnN0ciA9IHguc3Vic3RyKGlkeCArIDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrc3RyID0geDtcbiAgICAgIHZzdHIgPSAnJztcbiAgICB9XG5cbiAgICBrID0gZGVjb2RlVVJJQ29tcG9uZW50KGtzdHIpO1xuICAgIHYgPSBkZWNvZGVVUklDb21wb25lbnQodnN0cik7XG5cbiAgICBpZiAoIWhhc093blByb3BlcnR5KG9iaiwgaykpIHtcbiAgICAgIG9ialtrXSA9IHY7XG4gICAgfSBlbHNlIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgIG9ialtrXS5wdXNoKHYpO1xuICAgIH0gZWxzZSB7XG4gICAgICBvYmpba10gPSBbb2JqW2tdLCB2XTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gb2JqO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgc3RyaW5naWZ5UHJpbWl0aXZlID0gZnVuY3Rpb24odikge1xuICBzd2l0Y2ggKHR5cGVvZiB2KSB7XG4gICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIHJldHVybiB2O1xuXG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICByZXR1cm4gdiA/ICd0cnVlJyA6ICdmYWxzZSc7XG5cbiAgICBjYXNlICdudW1iZXInOlxuICAgICAgcmV0dXJuIGlzRmluaXRlKHYpID8gdiA6ICcnO1xuXG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiAnJztcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihvYmosIHNlcCwgZXEsIG5hbWUpIHtcbiAgc2VwID0gc2VwIHx8ICcmJztcbiAgZXEgPSBlcSB8fCAnPSc7XG4gIGlmIChvYmogPT09IG51bGwpIHtcbiAgICBvYmogPSB1bmRlZmluZWQ7XG4gIH1cblxuICBpZiAodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbWFwKG9iamVjdEtleXMob2JqKSwgZnVuY3Rpb24oaykge1xuICAgICAgdmFyIGtzID0gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShrKSkgKyBlcTtcbiAgICAgIGlmIChpc0FycmF5KG9ialtrXSkpIHtcbiAgICAgICAgcmV0dXJuIG1hcChvYmpba10sIGZ1bmN0aW9uKHYpIHtcbiAgICAgICAgICByZXR1cm4ga3MgKyBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKHYpKTtcbiAgICAgICAgfSkuam9pbihzZXApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGtzICsgZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShvYmpba10pKTtcbiAgICAgIH1cbiAgICB9KS5qb2luKHNlcCk7XG5cbiAgfVxuXG4gIGlmICghbmFtZSkgcmV0dXJuICcnO1xuICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KHN0cmluZ2lmeVByaW1pdGl2ZShuYW1lKSkgKyBlcSArXG4gICAgICAgICBlbmNvZGVVUklDb21wb25lbnQoc3RyaW5naWZ5UHJpbWl0aXZlKG9iaikpO1xufTtcblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uICh4cykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHhzKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5cbmZ1bmN0aW9uIG1hcCAoeHMsIGYpIHtcbiAgaWYgKHhzLm1hcCkgcmV0dXJuIHhzLm1hcChmKTtcbiAgdmFyIHJlcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgcmVzLnB1c2goZih4c1tpXSwgaSkpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkgcmVzLnB1c2goa2V5KTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuZXhwb3J0cy5kZWNvZGUgPSBleHBvcnRzLnBhcnNlID0gcmVxdWlyZSgnLi9kZWNvZGUnKTtcbmV4cG9ydHMuZW5jb2RlID0gZXhwb3J0cy5zdHJpbmdpZnkgPSByZXF1aXJlKCcuL2VuY29kZScpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgbm9kZS9uby1kZXByZWNhdGVkLWFwaSAqL1xudmFyIGJ1ZmZlciA9IHJlcXVpcmUoJ2J1ZmZlcicpXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxuXG4vLyBhbHRlcm5hdGl2ZSB0byB1c2luZyBPYmplY3Qua2V5cyBmb3Igb2xkIGJyb3dzZXJzXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XG4gIGZvciAodmFyIGtleSBpbiBzcmMpIHtcbiAgICBkc3Rba2V5XSA9IHNyY1trZXldXG4gIH1cbn1cbmlmIChCdWZmZXIuZnJvbSAmJiBCdWZmZXIuYWxsb2MgJiYgQnVmZmVyLmFsbG9jVW5zYWZlICYmIEJ1ZmZlci5hbGxvY1Vuc2FmZVNsb3cpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcbn0gZWxzZSB7XG4gIC8vIENvcHkgcHJvcGVydGllcyBmcm9tIHJlcXVpcmUoJ2J1ZmZlcicpXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXG4gIGV4cG9ydHMuQnVmZmVyID0gU2FmZUJ1ZmZlclxufVxuXG5mdW5jdGlvbiBTYWZlQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xuICByZXR1cm4gQnVmZmVyKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxufVxuXG4vLyBDb3B5IHN0YXRpYyBtZXRob2RzIGZyb20gQnVmZmVyXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxuXG5TYWZlQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXG59XG5cblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxuICB9XG4gIHZhciBidWYgPSBCdWZmZXIoc2l6ZSlcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XG4gICAgICBidWYuZmlsbChmaWxsLCBlbmNvZGluZylcbiAgICB9IGVsc2Uge1xuICAgICAgYnVmLmZpbGwoZmlsbClcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYnVmLmZpbGwoMClcbiAgfVxuICByZXR1cm4gYnVmXG59XG5cblNhZmVCdWZmZXIuYWxsb2NVbnNhZmUgPSBmdW5jdGlvbiAoc2l6ZSkge1xuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXG4gIH1cbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxufVxuXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgbnVtYmVyJylcbiAgfVxuICByZXR1cm4gYnVmZmVyLlNsb3dCdWZmZXIoc2l6ZSlcbn1cbiIsInZhciBTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKTtcbnZhciBzb2NranMgPSByZXF1aXJlKCdzb2NranMtY2xpZW50Jyk7XG52YXIgcmVzb2x2ZSA9IHJlcXVpcmUoJ3VybCcpLnJlc29sdmU7XG52YXIgcGFyc2UgPSByZXF1aXJlKCd1cmwnKS5wYXJzZTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodSwgY2IpIHtcbiAgICB2YXIgdXJpID0gcGFyc2UodSkucHJvdG9jb2wgPyB1IDogcmVzb2x2ZSh3aW5kb3cubG9jYXRpb24uaHJlZiwgdSk7XG4gICAgXG4gICAgdmFyIHN0cmVhbSA9IG5ldyBTdHJlYW07XG4gICAgc3RyZWFtLnJlYWRhYmxlID0gdHJ1ZTtcbiAgICBzdHJlYW0ud3JpdGFibGUgPSB0cnVlO1xuICAgIFxuICAgIHZhciByZWFkeSA9IGZhbHNlO1xuICAgIHZhciBidWZmZXIgPSBbXTtcbiAgICBcbiAgICB2YXIgc29jayA9IHNvY2tqcyh1cmkpO1xuICAgIHN0cmVhbS5zb2NrID0gc29jaztcbiAgICBcbiAgICBzdHJlYW0ud3JpdGUgPSBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIGlmICghcmVhZHkgfHwgYnVmZmVyLmxlbmd0aCkgYnVmZmVyLnB1c2gobXNnKVxuICAgICAgICBlbHNlIHNvY2suc2VuZChtc2cpXG4gICAgfTtcbiAgICBcbiAgICBzdHJlYW0uZW5kID0gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICBpZiAobXNnICE9PSB1bmRlZmluZWQpIHN0cmVhbS53cml0ZShtc2cpO1xuICAgICAgICBpZiAoIXJlYWR5KSB7XG4gICAgICAgICAgICBzdHJlYW0uX2VuZGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgc29jay5jbG9zZSgpO1xuICAgIH07XG4gICAgXG4gICAgc3RyZWFtLmRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5fZW5kZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW0ud3JpdGFibGUgPSBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICAgICAgYnVmZmVyLmxlbmd0aCA9IDBcbiAgICAgICAgc29jay5jbG9zZSgpO1xuICAgIH07XG4gICAgXG4gICAgc29jay5vbm9wZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2IgPT09ICdmdW5jdGlvbicpIGNiKCk7XG4gICAgICAgIHJlYWR5ID0gdHJ1ZTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHNvY2suc2VuZChidWZmZXJbaV0pO1xuICAgICAgICB9XG4gICAgICAgIGJ1ZmZlciA9IFtdO1xuICAgICAgICBzdHJlYW0uZW1pdCgnY29ubmVjdCcpO1xuICAgICAgICBpZiAoc3RyZWFtLl9lbmRlZCkgc3RyZWFtLmVuZCgpO1xuICAgIH07XG4gICAgXG4gICAgc29jay5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGUuZGF0YSk7XG4gICAgfTtcbiAgICBcbiAgICBzb2NrLm9uY2xvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlbmQnKTtcbiAgICAgICAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XG4gICAgICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xuICAgIH07XG4gICAgXG4gICAgcmV0dXJuIHN0cmVhbTtcbn07XG4iLCIvKiBTb2NrSlMgY2xpZW50LCB2ZXJzaW9uIDAuMy4xLjcuZ2E2N2YuZGlydHksIGh0dHA6Ly9zb2NranMub3JnLCBNSVQgTGljZW5zZVxuXG5Db3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cblxuUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxub2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xudG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG5mdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuXG5UaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cblRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbklNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG5BVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG5MSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTlxuVEhFIFNPRlRXQVJFLlxuKi9cblxuLy8gSlNPTjIgYnkgRG91Z2xhcyBDcm9ja2ZvcmQgKG1pbmlmaWVkKS5cbnZhciBKU09OO0pTT058fChKU09OPXt9KSxmdW5jdGlvbigpe2Z1bmN0aW9uIHN0cihhLGIpe3ZhciBjLGQsZSxmLGc9Z2FwLGgsaT1iW2FdO2kmJnR5cGVvZiBpPT1cIm9iamVjdFwiJiZ0eXBlb2YgaS50b0pTT049PVwiZnVuY3Rpb25cIiYmKGk9aS50b0pTT04oYSkpLHR5cGVvZiByZXA9PVwiZnVuY3Rpb25cIiYmKGk9cmVwLmNhbGwoYixhLGkpKTtzd2l0Y2godHlwZW9mIGkpe2Nhc2VcInN0cmluZ1wiOnJldHVybiBxdW90ZShpKTtjYXNlXCJudW1iZXJcIjpyZXR1cm4gaXNGaW5pdGUoaSk/U3RyaW5nKGkpOlwibnVsbFwiO2Nhc2VcImJvb2xlYW5cIjpjYXNlXCJudWxsXCI6cmV0dXJuIFN0cmluZyhpKTtjYXNlXCJvYmplY3RcIjppZighaSlyZXR1cm5cIm51bGxcIjtnYXArPWluZGVudCxoPVtdO2lmKE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuYXBwbHkoaSk9PT1cIltvYmplY3QgQXJyYXldXCIpe2Y9aS5sZW5ndGg7Zm9yKGM9MDtjPGY7Yys9MSloW2NdPXN0cihjLGkpfHxcIm51bGxcIjtlPWgubGVuZ3RoPT09MD9cIltdXCI6Z2FwP1wiW1xcblwiK2dhcCtoLmpvaW4oXCIsXFxuXCIrZ2FwKStcIlxcblwiK2crXCJdXCI6XCJbXCIraC5qb2luKFwiLFwiKStcIl1cIixnYXA9ZztyZXR1cm4gZX1pZihyZXAmJnR5cGVvZiByZXA9PVwib2JqZWN0XCIpe2Y9cmVwLmxlbmd0aDtmb3IoYz0wO2M8ZjtjKz0xKXR5cGVvZiByZXBbY109PVwic3RyaW5nXCImJihkPXJlcFtjXSxlPXN0cihkLGkpLGUmJmgucHVzaChxdW90ZShkKSsoZ2FwP1wiOiBcIjpcIjpcIikrZSkpfWVsc2UgZm9yKGQgaW4gaSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaSxkKSYmKGU9c3RyKGQsaSksZSYmaC5wdXNoKHF1b3RlKGQpKyhnYXA/XCI6IFwiOlwiOlwiKStlKSk7ZT1oLmxlbmd0aD09PTA/XCJ7fVwiOmdhcD9cIntcXG5cIitnYXAraC5qb2luKFwiLFxcblwiK2dhcCkrXCJcXG5cIitnK1wifVwiOlwie1wiK2guam9pbihcIixcIikrXCJ9XCIsZ2FwPWc7cmV0dXJuIGV9fWZ1bmN0aW9uIHF1b3RlKGEpe2VzY2FwYWJsZS5sYXN0SW5kZXg9MDtyZXR1cm4gZXNjYXBhYmxlLnRlc3QoYSk/J1wiJythLnJlcGxhY2UoZXNjYXBhYmxlLGZ1bmN0aW9uKGEpe3ZhciBiPW1ldGFbYV07cmV0dXJuIHR5cGVvZiBiPT1cInN0cmluZ1wiP2I6XCJcXFxcdVwiKyhcIjAwMDBcIithLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCl9KSsnXCInOidcIicrYSsnXCInfWZ1bmN0aW9uIGYoYSl7cmV0dXJuIGE8MTA/XCIwXCIrYTphfVwidXNlIHN0cmljdFwiLHR5cGVvZiBEYXRlLnByb3RvdHlwZS50b0pTT04hPVwiZnVuY3Rpb25cIiYmKERhdGUucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbihhKXtyZXR1cm4gaXNGaW5pdGUodGhpcy52YWx1ZU9mKCkpP3RoaXMuZ2V0VVRDRnVsbFllYXIoKStcIi1cIitmKHRoaXMuZ2V0VVRDTW9udGgoKSsxKStcIi1cIitmKHRoaXMuZ2V0VVRDRGF0ZSgpKStcIlRcIitmKHRoaXMuZ2V0VVRDSG91cnMoKSkrXCI6XCIrZih0aGlzLmdldFVUQ01pbnV0ZXMoKSkrXCI6XCIrZih0aGlzLmdldFVUQ1NlY29uZHMoKSkrXCJaXCI6bnVsbH0sU3RyaW5nLnByb3RvdHlwZS50b0pTT049TnVtYmVyLnByb3RvdHlwZS50b0pTT049Qm9vbGVhbi5wcm90b3R5cGUudG9KU09OPWZ1bmN0aW9uKGEpe3JldHVybiB0aGlzLnZhbHVlT2YoKX0pO3ZhciBjeD0vW1xcdTAwMDBcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxlc2NhcGFibGU9L1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxnYXAsaW5kZW50LG1ldGE9e1wiXFxiXCI6XCJcXFxcYlwiLFwiXFx0XCI6XCJcXFxcdFwiLFwiXFxuXCI6XCJcXFxcblwiLFwiXFxmXCI6XCJcXFxcZlwiLFwiXFxyXCI6XCJcXFxcclwiLCdcIic6J1xcXFxcIicsXCJcXFxcXCI6XCJcXFxcXFxcXFwifSxyZXA7dHlwZW9mIEpTT04uc3RyaW5naWZ5IT1cImZ1bmN0aW9uXCImJihKU09OLnN0cmluZ2lmeT1mdW5jdGlvbihhLGIsYyl7dmFyIGQ7Z2FwPVwiXCIsaW5kZW50PVwiXCI7aWYodHlwZW9mIGM9PVwibnVtYmVyXCIpZm9yKGQ9MDtkPGM7ZCs9MSlpbmRlbnQrPVwiIFwiO2Vsc2UgdHlwZW9mIGM9PVwic3RyaW5nXCImJihpbmRlbnQ9Yyk7cmVwPWI7aWYoIWJ8fHR5cGVvZiBiPT1cImZ1bmN0aW9uXCJ8fHR5cGVvZiBiPT1cIm9iamVjdFwiJiZ0eXBlb2YgYi5sZW5ndGg9PVwibnVtYmVyXCIpcmV0dXJuIHN0cihcIlwiLHtcIlwiOmF9KTt0aHJvdyBuZXcgRXJyb3IoXCJKU09OLnN0cmluZ2lmeVwiKX0pLHR5cGVvZiBKU09OLnBhcnNlIT1cImZ1bmN0aW9uXCImJihKU09OLnBhcnNlPWZ1bmN0aW9uKHRleHQscmV2aXZlcil7ZnVuY3Rpb24gd2FsayhhLGIpe3ZhciBjLGQsZT1hW2JdO2lmKGUmJnR5cGVvZiBlPT1cIm9iamVjdFwiKWZvcihjIGluIGUpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsYykmJihkPXdhbGsoZSxjKSxkIT09dW5kZWZpbmVkP2VbY109ZDpkZWxldGUgZVtjXSk7cmV0dXJuIHJldml2ZXIuY2FsbChhLGIsZSl9dmFyIGo7dGV4dD1TdHJpbmcodGV4dCksY3gubGFzdEluZGV4PTAsY3gudGVzdCh0ZXh0KSYmKHRleHQ9dGV4dC5yZXBsYWNlKGN4LGZ1bmN0aW9uKGEpe3JldHVyblwiXFxcXHVcIisoXCIwMDAwXCIrYS5jaGFyQ29kZUF0KDApLnRvU3RyaW5nKDE2KSkuc2xpY2UoLTQpfSkpO2lmKC9eW1xcXSw6e31cXHNdKiQvLnRlc3QodGV4dC5yZXBsYWNlKC9cXFxcKD86W1wiXFxcXFxcL2JmbnJ0XXx1WzAtOWEtZkEtRl17NH0pL2csXCJAXCIpLnJlcGxhY2UoL1wiW15cIlxcXFxcXG5cXHJdKlwifHRydWV8ZmFsc2V8bnVsbHwtP1xcZCsoPzpcXC5cXGQqKT8oPzpbZUVdWytcXC1dP1xcZCspPy9nLFwiXVwiKS5yZXBsYWNlKC8oPzpefDp8LCkoPzpcXHMqXFxbKSsvZyxcIlwiKSkpe2o9ZXZhbChcIihcIit0ZXh0K1wiKVwiKTtyZXR1cm4gdHlwZW9mIHJldml2ZXI9PVwiZnVuY3Rpb25cIj93YWxrKHtcIlwiOmp9LFwiXCIpOmp9dGhyb3cgbmV3IFN5bnRheEVycm9yKFwiSlNPTi5wYXJzZVwiKX0pfSgpXG5cblxuLy8gICAgIFsqXSBJbmNsdWRpbmcgbGliL2luZGV4LmpzXG4vLyBQdWJsaWMgb2JqZWN0XG52YXIgU29ja0pTID0gKGZ1bmN0aW9uKCl7XG4gICAgICAgICAgICAgIHZhciBfZG9jdW1lbnQgPSBkb2N1bWVudDtcbiAgICAgICAgICAgICAgdmFyIF93aW5kb3cgPSB3aW5kb3c7XG4gICAgICAgICAgICAgIHZhciB1dGlscyA9IHt9O1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvcmV2ZW50dGFyZ2V0LmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG4vKiBTaW1wbGlmaWVkIGltcGxlbWVudGF0aW9uIG9mIERPTTIgRXZlbnRUYXJnZXQuXG4gKiAgIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0yLUV2ZW50cy9ldmVudHMuaHRtbCNFdmVudHMtRXZlbnRUYXJnZXRcbiAqL1xudmFyIFJFdmVudFRhcmdldCA9IGZ1bmN0aW9uKCkge307XG5SRXZlbnRUYXJnZXQucHJvdG90eXBlLmFkZEV2ZW50TGlzdGVuZXIgPSBmdW5jdGlvbiAoZXZlbnRUeXBlLCBsaXN0ZW5lcikge1xuICAgIGlmKCF0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHt9O1xuICAgIH1cbiAgICBpZighKGV2ZW50VHlwZSBpbiB0aGlzLl9saXN0ZW5lcnMpKSB7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVyc1tldmVudFR5cGVdID0gW107XG4gICAgfVxuICAgIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICBpZih1dGlscy5hcnJJbmRleE9mKGFyciwgbGlzdGVuZXIpID09PSAtMSkge1xuICAgICAgICBhcnIucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5cblJFdmVudFRhcmdldC5wcm90b3R5cGUucmVtb3ZlRXZlbnRMaXN0ZW5lciA9IGZ1bmN0aW9uIChldmVudFR5cGUsIGxpc3RlbmVyKSB7XG4gICAgaWYoISh0aGlzLl9saXN0ZW5lcnMgJiYgKGV2ZW50VHlwZSBpbiB0aGlzLl9saXN0ZW5lcnMpKSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciBhcnIgPSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICB2YXIgaWR4ID0gdXRpbHMuYXJySW5kZXhPZihhcnIsIGxpc3RlbmVyKTtcbiAgICBpZiAoaWR4ICE9PSAtMSkge1xuICAgICAgICBpZihhcnIubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgdGhpcy5fbGlzdGVuZXJzW2V2ZW50VHlwZV0gPSBhcnIuc2xpY2UoMCwgaWR4KS5jb25jYXQoIGFyci5zbGljZShpZHgrMSkgKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9saXN0ZW5lcnNbZXZlbnRUeXBlXTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5cblJFdmVudFRhcmdldC5wcm90b3R5cGUuZGlzcGF0Y2hFdmVudCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB0ID0gZXZlbnQudHlwZTtcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gICAgaWYgKHRoaXNbJ29uJyt0XSkge1xuICAgICAgICB0aGlzWydvbicrdF0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9saXN0ZW5lcnMgJiYgdCBpbiB0aGlzLl9saXN0ZW5lcnMpIHtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCB0aGlzLl9saXN0ZW5lcnNbdF0ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHRoaXMuX2xpc3RlbmVyc1t0XVtpXS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgfVxuICAgIH1cbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3JldmVudHRhcmdldC5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvc2ltcGxlZXZlbnQuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBTaW1wbGVFdmVudCA9IGZ1bmN0aW9uKHR5cGUsIG9iaikge1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgaWYgKHR5cGVvZiBvYmogIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGZvcih2YXIgayBpbiBvYmopIHtcbiAgICAgICAgICAgIGlmICghb2JqLmhhc093blByb3BlcnR5KGspKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRoaXNba10gPSBvYmpba107XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5TaW1wbGVFdmVudC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgciA9IFtdO1xuICAgIGZvcih2YXIgayBpbiB0aGlzKSB7XG4gICAgICAgIGlmICghdGhpcy5oYXNPd25Qcm9wZXJ0eShrKSkgY29udGludWU7XG4gICAgICAgIHZhciB2ID0gdGhpc1trXTtcbiAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnZnVuY3Rpb24nKSB2ID0gJ1tmdW5jdGlvbl0nO1xuICAgICAgICByLnB1c2goayArICc9JyArIHYpO1xuICAgIH1cbiAgICByZXR1cm4gJ1NpbXBsZUV2ZW50KCcgKyByLmpvaW4oJywgJykgKyAnKSc7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9zaW1wbGVldmVudC5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvZXZlbnRlbWl0dGVyLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgRXZlbnRFbWl0dGVyID0gZnVuY3Rpb24oZXZlbnRzKSB7XG4gICAgdGhpcy5ldmVudHMgPSBldmVudHMgfHwgW107XG59O1xuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgaWYgKCF0aGF0Lm51a2VkICYmIHRoYXRbJ29uJyt0eXBlXSkge1xuICAgICAgICB0aGF0WydvbicrdHlwZV0uYXBwbHkodGhhdCwgYXJncyk7XG4gICAgfVxuICAgIGlmICh1dGlscy5hcnJJbmRleE9mKHRoYXQuZXZlbnRzLCB0eXBlKSA9PT0gLTEpIHtcbiAgICAgICAgdXRpbHMubG9nKCdFdmVudCAnICsgSlNPTi5zdHJpbmdpZnkodHlwZSkgK1xuICAgICAgICAgICAgICAgICAgJyBub3QgbGlzdGVkICcgKyBKU09OLnN0cmluZ2lmeSh0aGF0LmV2ZW50cykgK1xuICAgICAgICAgICAgICAgICAgJyBpbiAnICsgdGhhdCk7XG4gICAgfVxufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5udWtlID0gZnVuY3Rpb24odHlwZSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Lm51a2VkID0gdHJ1ZTtcbiAgICBmb3IodmFyIGk9MDsgaTx0aGF0LmV2ZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBkZWxldGUgdGhhdFt0aGF0LmV2ZW50c1tpXV07XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvZXZlbnRlbWl0dGVyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi91dGlscy5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIHJhbmRvbV9zdHJpbmdfY2hhcnMgPSAnYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Xyc7XG51dGlscy5yYW5kb21fc3RyaW5nID0gZnVuY3Rpb24obGVuZ3RoLCBtYXgpIHtcbiAgICBtYXggPSBtYXggfHwgcmFuZG9tX3N0cmluZ19jaGFycy5sZW5ndGg7XG4gICAgdmFyIGksIHJldCA9IFtdO1xuICAgIGZvcihpPTA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXQucHVzaCggcmFuZG9tX3N0cmluZ19jaGFycy5zdWJzdHIoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KSwxKSApO1xuICAgIH1cbiAgICByZXR1cm4gcmV0LmpvaW4oJycpO1xufTtcbnV0aWxzLnJhbmRvbV9udW1iZXIgPSBmdW5jdGlvbihtYXgpIHtcbiAgICByZXR1cm4gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogbWF4KTtcbn07XG51dGlscy5yYW5kb21fbnVtYmVyX3N0cmluZyA9IGZ1bmN0aW9uKG1heCkge1xuICAgIHZhciB0ID0gKCcnKyhtYXggLSAxKSkubGVuZ3RoO1xuICAgIHZhciBwID0gQXJyYXkodCsxKS5qb2luKCcwJyk7XG4gICAgcmV0dXJuIChwICsgdXRpbHMucmFuZG9tX251bWJlcihtYXgpKS5zbGljZSgtdCk7XG59O1xuXG4vLyBBc3N1bWluZyB0aGF0IHVybCBsb29rcyBsaWtlOiBodHRwOi8vYXNkYXNkOjExMS9hc2RcbnV0aWxzLmdldE9yaWdpbiA9IGZ1bmN0aW9uKHVybCkge1xuICAgIHVybCArPSAnLyc7XG4gICAgdmFyIHBhcnRzID0gdXJsLnNwbGl0KCcvJykuc2xpY2UoMCwgMyk7XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oJy8nKTtcbn07XG5cbnV0aWxzLmlzU2FtZU9yaWdpblVybCA9IGZ1bmN0aW9uKHVybF9hLCB1cmxfYikge1xuICAgIC8vIGxvY2F0aW9uLm9yaWdpbiB3b3VsZCBkbywgYnV0IGl0J3Mgbm90IGFsd2F5cyBhdmFpbGFibGUuXG4gICAgaWYgKCF1cmxfYikgdXJsX2IgPSBfd2luZG93LmxvY2F0aW9uLmhyZWY7XG5cbiAgICByZXR1cm4gKHVybF9hLnNwbGl0KCcvJykuc2xpY2UoMCwzKS5qb2luKCcvJylcbiAgICAgICAgICAgICAgICA9PT1cbiAgICAgICAgICAgIHVybF9iLnNwbGl0KCcvJykuc2xpY2UoMCwzKS5qb2luKCcvJykpO1xufTtcblxudXRpbHMuZ2V0UGFyZW50RG9tYWluID0gZnVuY3Rpb24odXJsKSB7XG4gICAgLy8gaXB2NCBpcCBhZGRyZXNzXG4gICAgaWYgKC9eWzAtOS5dKiQvLnRlc3QodXJsKSkgcmV0dXJuIHVybDtcbiAgICAvLyBpcHY2IGlwIGFkZHJlc3NcbiAgICBpZiAoL15cXFsvLnRlc3QodXJsKSkgcmV0dXJuIHVybDtcbiAgICAvLyBubyBkb3RzXG4gICAgaWYgKCEoL1suXS8udGVzdCh1cmwpKSkgcmV0dXJuIHVybDtcblxuICAgIHZhciBwYXJ0cyA9IHVybC5zcGxpdCgnLicpLnNsaWNlKDEpO1xuICAgIHJldHVybiBwYXJ0cy5qb2luKCcuJyk7XG59O1xuXG51dGlscy5vYmplY3RFeHRlbmQgPSBmdW5jdGlvbihkc3QsIHNyYykge1xuICAgIGZvcih2YXIgayBpbiBzcmMpIHtcbiAgICAgICAgaWYgKHNyYy5oYXNPd25Qcm9wZXJ0eShrKSkge1xuICAgICAgICAgICAgZHN0W2tdID0gc3JjW2tdO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkc3Q7XG59O1xuXG52YXIgV1ByZWZpeCA9ICdfanAnO1xuXG51dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlID0gZnVuY3Rpb24oKSB7XG4gICAgaWYgKCEoV1ByZWZpeCBpbiBfd2luZG93KSkge1xuICAgICAgICBfd2luZG93W1dQcmVmaXhdID0ge307XG4gICAgfVxufTtcblxudXRpbHMuY2xvc2VGcmFtZSA9IGZ1bmN0aW9uIChjb2RlLCByZWFzb24pIHtcbiAgICByZXR1cm4gJ2MnK0pTT04uc3RyaW5naWZ5KFtjb2RlLCByZWFzb25dKTtcbn07XG5cbnV0aWxzLnVzZXJTZXRDb2RlID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gY29kZSA9PT0gMTAwMCB8fCAoY29kZSA+PSAzMDAwICYmIGNvZGUgPD0gNDk5OSk7XG59O1xuXG4vLyBTZWU6IGh0dHA6Ly93d3cuZXJnLmFiZG4uYWMudWsvfmdlcnJpdC9kY2NwL25vdGVzL2NjaWQyL3J0b19lc3RpbWF0b3IvXG4vLyBhbmQgUkZDIDI5ODguXG51dGlscy5jb3VudFJUTyA9IGZ1bmN0aW9uIChydHQpIHtcbiAgICB2YXIgcnRvO1xuICAgIGlmIChydHQgPiAxMDApIHtcbiAgICAgICAgcnRvID0gMyAqIHJ0dDsgLy8gcnRvID4gMzAwbXNlY1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJ0byA9IHJ0dCArIDIwMDsgLy8gMjAwbXNlYyA8IHJ0byA8PSAzMDBtc2VjXG4gICAgfVxuICAgIHJldHVybiBydG87XG59XG5cbnV0aWxzLmxvZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChfd2luZG93LmNvbnNvbGUgJiYgY29uc29sZS5sb2cgJiYgY29uc29sZS5sb2cuYXBwbHkpIHtcbiAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJndW1lbnRzKTtcbiAgICB9XG59O1xuXG51dGlscy5iaW5kID0gZnVuY3Rpb24oZnVuLCB0aGF0KSB7XG4gICAgaWYgKGZ1bi5iaW5kKSB7XG4gICAgICAgIHJldHVybiBmdW4uYmluZCh0aGF0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgfVxufTtcblxudXRpbHMuZmxhdFVybCA9IGZ1bmN0aW9uKHVybCkge1xuICAgIHJldHVybiB1cmwuaW5kZXhPZignPycpID09PSAtMSAmJiB1cmwuaW5kZXhPZignIycpID09PSAtMTtcbn07XG5cbnV0aWxzLmFtZW5kVXJsID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIGRsID0gX2RvY3VtZW50LmxvY2F0aW9uO1xuICAgIGlmICghdXJsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignV3JvbmcgdXJsIGZvciBTb2NrSlMnKTtcbiAgICB9XG4gICAgaWYgKCF1dGlscy5mbGF0VXJsKHVybCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdPbmx5IGJhc2ljIHVybHMgYXJlIHN1cHBvcnRlZCBpbiBTb2NrSlMnKTtcbiAgICB9XG5cbiAgICAvLyAgJy8vYWJjJyAtLT4gJ2h0dHA6Ly9hYmMnXG4gICAgaWYgKHVybC5pbmRleE9mKCcvLycpID09PSAwKSB7XG4gICAgICAgIHVybCA9IGRsLnByb3RvY29sICsgdXJsO1xuICAgIH1cbiAgICAvLyAnL2FiYycgLS0+ICdodHRwOi8vbG9jYWxob3N0OjgwL2FiYydcbiAgICBpZiAodXJsLmluZGV4T2YoJy8nKSA9PT0gMCkge1xuICAgICAgICB1cmwgPSBkbC5wcm90b2NvbCArICcvLycgKyBkbC5ob3N0ICsgdXJsO1xuICAgIH1cbiAgICAvLyBzdHJpcCB0cmFpbGluZyBzbGFzaGVzXG4gICAgdXJsID0gdXJsLnJlcGxhY2UoL1svXSskLywnJyk7XG4gICAgcmV0dXJuIHVybDtcbn07XG5cbi8vIElFIGRvZXNuJ3Qgc3VwcG9ydCBbXS5pbmRleE9mLlxudXRpbHMuYXJySW5kZXhPZiA9IGZ1bmN0aW9uKGFyciwgb2JqKXtcbiAgICBmb3IodmFyIGk9MDsgaSA8IGFyci5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmKGFycltpXSA9PT0gb2JqKXtcbiAgICAgICAgICAgIHJldHVybiBpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbn07XG5cbnV0aWxzLmFyclNraXAgPSBmdW5jdGlvbihhcnIsIG9iaikge1xuICAgIHZhciBpZHggPSB1dGlscy5hcnJJbmRleE9mKGFyciwgb2JqKTtcbiAgICBpZiAoaWR4ID09PSAtMSkge1xuICAgICAgICByZXR1cm4gYXJyLnNsaWNlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGRzdCA9IGFyci5zbGljZSgwLCBpZHgpO1xuICAgICAgICByZXR1cm4gZHN0LmNvbmNhdChhcnIuc2xpY2UoaWR4KzEpKTtcbiAgICB9XG59O1xuXG4vLyBWaWE6IGh0dHBzOi8vZ2lzdC5naXRodWIuY29tLzExMzMxMjIvMjEyMWM2MDFjNTU0OTE1NTQ4M2Y1MGJlM2RhNTMwNWU4M2I4YzVkZlxudXRpbHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4ge30udG9TdHJpbmcuY2FsbCh2YWx1ZSkuaW5kZXhPZignQXJyYXknKSA+PSAwXG59O1xuXG51dGlscy5kZWxheSA9IGZ1bmN0aW9uKHQsIGZ1bikge1xuICAgIGlmKHR5cGVvZiB0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGZ1biA9IHQ7XG4gICAgICAgIHQgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIHQpO1xufTtcblxuXG4vLyBDaGFycyB3b3J0aCBlc2NhcGluZywgYXMgZGVmaW5lZCBieSBEb3VnbGFzIENyb2NrZm9yZDpcbi8vICAgaHR0cHM6Ly9naXRodWIuY29tL2RvdWdsYXNjcm9ja2ZvcmQvSlNPTi1qcy9ibG9iLzQ3YTk4ODJjZGRlYjFlODUyOWUwN2FmOTczNjIxODA3NTM3MmI4YWMvanNvbjIuanMjTDE5NlxudmFyIGpzb25fZXNjYXBhYmxlID0gL1tcXFxcXFxcIlxceDAwLVxceDFmXFx4N2YtXFx4OWZcXHUwMGFkXFx1MDYwMC1cXHUwNjA0XFx1MDcwZlxcdTE3YjRcXHUxN2I1XFx1MjAwYy1cXHUyMDBmXFx1MjAyOC1cXHUyMDJmXFx1MjA2MC1cXHUyMDZmXFx1ZmVmZlxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBqc29uX2xvb2t1cCA9IHtcblwiXFx1MDAwMFwiOlwiXFxcXHUwMDAwXCIsXCJcXHUwMDAxXCI6XCJcXFxcdTAwMDFcIixcIlxcdTAwMDJcIjpcIlxcXFx1MDAwMlwiLFwiXFx1MDAwM1wiOlwiXFxcXHUwMDAzXCIsXG5cIlxcdTAwMDRcIjpcIlxcXFx1MDAwNFwiLFwiXFx1MDAwNVwiOlwiXFxcXHUwMDA1XCIsXCJcXHUwMDA2XCI6XCJcXFxcdTAwMDZcIixcIlxcdTAwMDdcIjpcIlxcXFx1MDAwN1wiLFxuXCJcXGJcIjpcIlxcXFxiXCIsXCJcXHRcIjpcIlxcXFx0XCIsXCJcXG5cIjpcIlxcXFxuXCIsXCJcXHUwMDBiXCI6XCJcXFxcdTAwMGJcIixcIlxcZlwiOlwiXFxcXGZcIixcIlxcclwiOlwiXFxcXHJcIixcblwiXFx1MDAwZVwiOlwiXFxcXHUwMDBlXCIsXCJcXHUwMDBmXCI6XCJcXFxcdTAwMGZcIixcIlxcdTAwMTBcIjpcIlxcXFx1MDAxMFwiLFwiXFx1MDAxMVwiOlwiXFxcXHUwMDExXCIsXG5cIlxcdTAwMTJcIjpcIlxcXFx1MDAxMlwiLFwiXFx1MDAxM1wiOlwiXFxcXHUwMDEzXCIsXCJcXHUwMDE0XCI6XCJcXFxcdTAwMTRcIixcIlxcdTAwMTVcIjpcIlxcXFx1MDAxNVwiLFxuXCJcXHUwMDE2XCI6XCJcXFxcdTAwMTZcIixcIlxcdTAwMTdcIjpcIlxcXFx1MDAxN1wiLFwiXFx1MDAxOFwiOlwiXFxcXHUwMDE4XCIsXCJcXHUwMDE5XCI6XCJcXFxcdTAwMTlcIixcblwiXFx1MDAxYVwiOlwiXFxcXHUwMDFhXCIsXCJcXHUwMDFiXCI6XCJcXFxcdTAwMWJcIixcIlxcdTAwMWNcIjpcIlxcXFx1MDAxY1wiLFwiXFx1MDAxZFwiOlwiXFxcXHUwMDFkXCIsXG5cIlxcdTAwMWVcIjpcIlxcXFx1MDAxZVwiLFwiXFx1MDAxZlwiOlwiXFxcXHUwMDFmXCIsXCJcXFwiXCI6XCJcXFxcXFxcIlwiLFwiXFxcXFwiOlwiXFxcXFxcXFxcIixcblwiXFx1MDA3ZlwiOlwiXFxcXHUwMDdmXCIsXCJcXHUwMDgwXCI6XCJcXFxcdTAwODBcIixcIlxcdTAwODFcIjpcIlxcXFx1MDA4MVwiLFwiXFx1MDA4MlwiOlwiXFxcXHUwMDgyXCIsXG5cIlxcdTAwODNcIjpcIlxcXFx1MDA4M1wiLFwiXFx1MDA4NFwiOlwiXFxcXHUwMDg0XCIsXCJcXHUwMDg1XCI6XCJcXFxcdTAwODVcIixcIlxcdTAwODZcIjpcIlxcXFx1MDA4NlwiLFxuXCJcXHUwMDg3XCI6XCJcXFxcdTAwODdcIixcIlxcdTAwODhcIjpcIlxcXFx1MDA4OFwiLFwiXFx1MDA4OVwiOlwiXFxcXHUwMDg5XCIsXCJcXHUwMDhhXCI6XCJcXFxcdTAwOGFcIixcblwiXFx1MDA4YlwiOlwiXFxcXHUwMDhiXCIsXCJcXHUwMDhjXCI6XCJcXFxcdTAwOGNcIixcIlxcdTAwOGRcIjpcIlxcXFx1MDA4ZFwiLFwiXFx1MDA4ZVwiOlwiXFxcXHUwMDhlXCIsXG5cIlxcdTAwOGZcIjpcIlxcXFx1MDA4ZlwiLFwiXFx1MDA5MFwiOlwiXFxcXHUwMDkwXCIsXCJcXHUwMDkxXCI6XCJcXFxcdTAwOTFcIixcIlxcdTAwOTJcIjpcIlxcXFx1MDA5MlwiLFxuXCJcXHUwMDkzXCI6XCJcXFxcdTAwOTNcIixcIlxcdTAwOTRcIjpcIlxcXFx1MDA5NFwiLFwiXFx1MDA5NVwiOlwiXFxcXHUwMDk1XCIsXCJcXHUwMDk2XCI6XCJcXFxcdTAwOTZcIixcblwiXFx1MDA5N1wiOlwiXFxcXHUwMDk3XCIsXCJcXHUwMDk4XCI6XCJcXFxcdTAwOThcIixcIlxcdTAwOTlcIjpcIlxcXFx1MDA5OVwiLFwiXFx1MDA5YVwiOlwiXFxcXHUwMDlhXCIsXG5cIlxcdTAwOWJcIjpcIlxcXFx1MDA5YlwiLFwiXFx1MDA5Y1wiOlwiXFxcXHUwMDljXCIsXCJcXHUwMDlkXCI6XCJcXFxcdTAwOWRcIixcIlxcdTAwOWVcIjpcIlxcXFx1MDA5ZVwiLFxuXCJcXHUwMDlmXCI6XCJcXFxcdTAwOWZcIixcIlxcdTAwYWRcIjpcIlxcXFx1MDBhZFwiLFwiXFx1MDYwMFwiOlwiXFxcXHUwNjAwXCIsXCJcXHUwNjAxXCI6XCJcXFxcdTA2MDFcIixcblwiXFx1MDYwMlwiOlwiXFxcXHUwNjAyXCIsXCJcXHUwNjAzXCI6XCJcXFxcdTA2MDNcIixcIlxcdTA2MDRcIjpcIlxcXFx1MDYwNFwiLFwiXFx1MDcwZlwiOlwiXFxcXHUwNzBmXCIsXG5cIlxcdTE3YjRcIjpcIlxcXFx1MTdiNFwiLFwiXFx1MTdiNVwiOlwiXFxcXHUxN2I1XCIsXCJcXHUyMDBjXCI6XCJcXFxcdTIwMGNcIixcIlxcdTIwMGRcIjpcIlxcXFx1MjAwZFwiLFxuXCJcXHUyMDBlXCI6XCJcXFxcdTIwMGVcIixcIlxcdTIwMGZcIjpcIlxcXFx1MjAwZlwiLFwiXFx1MjAyOFwiOlwiXFxcXHUyMDI4XCIsXCJcXHUyMDI5XCI6XCJcXFxcdTIwMjlcIixcblwiXFx1MjAyYVwiOlwiXFxcXHUyMDJhXCIsXCJcXHUyMDJiXCI6XCJcXFxcdTIwMmJcIixcIlxcdTIwMmNcIjpcIlxcXFx1MjAyY1wiLFwiXFx1MjAyZFwiOlwiXFxcXHUyMDJkXCIsXG5cIlxcdTIwMmVcIjpcIlxcXFx1MjAyZVwiLFwiXFx1MjAyZlwiOlwiXFxcXHUyMDJmXCIsXCJcXHUyMDYwXCI6XCJcXFxcdTIwNjBcIixcIlxcdTIwNjFcIjpcIlxcXFx1MjA2MVwiLFxuXCJcXHUyMDYyXCI6XCJcXFxcdTIwNjJcIixcIlxcdTIwNjNcIjpcIlxcXFx1MjA2M1wiLFwiXFx1MjA2NFwiOlwiXFxcXHUyMDY0XCIsXCJcXHUyMDY1XCI6XCJcXFxcdTIwNjVcIixcblwiXFx1MjA2NlwiOlwiXFxcXHUyMDY2XCIsXCJcXHUyMDY3XCI6XCJcXFxcdTIwNjdcIixcIlxcdTIwNjhcIjpcIlxcXFx1MjA2OFwiLFwiXFx1MjA2OVwiOlwiXFxcXHUyMDY5XCIsXG5cIlxcdTIwNmFcIjpcIlxcXFx1MjA2YVwiLFwiXFx1MjA2YlwiOlwiXFxcXHUyMDZiXCIsXCJcXHUyMDZjXCI6XCJcXFxcdTIwNmNcIixcIlxcdTIwNmRcIjpcIlxcXFx1MjA2ZFwiLFxuXCJcXHUyMDZlXCI6XCJcXFxcdTIwNmVcIixcIlxcdTIwNmZcIjpcIlxcXFx1MjA2ZlwiLFwiXFx1ZmVmZlwiOlwiXFxcXHVmZWZmXCIsXCJcXHVmZmYwXCI6XCJcXFxcdWZmZjBcIixcblwiXFx1ZmZmMVwiOlwiXFxcXHVmZmYxXCIsXCJcXHVmZmYyXCI6XCJcXFxcdWZmZjJcIixcIlxcdWZmZjNcIjpcIlxcXFx1ZmZmM1wiLFwiXFx1ZmZmNFwiOlwiXFxcXHVmZmY0XCIsXG5cIlxcdWZmZjVcIjpcIlxcXFx1ZmZmNVwiLFwiXFx1ZmZmNlwiOlwiXFxcXHVmZmY2XCIsXCJcXHVmZmY3XCI6XCJcXFxcdWZmZjdcIixcIlxcdWZmZjhcIjpcIlxcXFx1ZmZmOFwiLFxuXCJcXHVmZmY5XCI6XCJcXFxcdWZmZjlcIixcIlxcdWZmZmFcIjpcIlxcXFx1ZmZmYVwiLFwiXFx1ZmZmYlwiOlwiXFxcXHVmZmZiXCIsXCJcXHVmZmZjXCI6XCJcXFxcdWZmZmNcIixcblwiXFx1ZmZmZFwiOlwiXFxcXHVmZmZkXCIsXCJcXHVmZmZlXCI6XCJcXFxcdWZmZmVcIixcIlxcdWZmZmZcIjpcIlxcXFx1ZmZmZlwifTtcblxuLy8gU29tZSBleHRyYSBjaGFyYWN0ZXJzIHRoYXQgQ2hyb21lIGdldHMgd3JvbmcsIGFuZCBzdWJzdGl0dXRlcyB3aXRoXG4vLyBzb21ldGhpbmcgZWxzZSBvbiB0aGUgd2lyZS5cbnZhciBleHRyYV9lc2NhcGFibGUgPSAvW1xceDAwLVxceDFmXFx1ZDgwMC1cXHVkZmZmXFx1ZmZmZVxcdWZmZmZcXHUwMzAwLVxcdTAzMzNcXHUwMzNkLVxcdTAzNDZcXHUwMzRhLVxcdTAzNGNcXHUwMzUwLVxcdTAzNTJcXHUwMzU3LVxcdTAzNThcXHUwMzVjLVxcdTAzNjJcXHUwMzc0XFx1MDM3ZVxcdTAzODdcXHUwNTkxLVxcdTA1YWZcXHUwNWM0XFx1MDYxMC1cXHUwNjE3XFx1MDY1My1cXHUwNjU0XFx1MDY1Ny1cXHUwNjViXFx1MDY1ZC1cXHUwNjVlXFx1MDZkZi1cXHUwNmUyXFx1MDZlYi1cXHUwNmVjXFx1MDczMFxcdTA3MzItXFx1MDczM1xcdTA3MzUtXFx1MDczNlxcdTA3M2FcXHUwNzNkXFx1MDczZi1cXHUwNzQxXFx1MDc0M1xcdTA3NDVcXHUwNzQ3XFx1MDdlYi1cXHUwN2YxXFx1MDk1MVxcdTA5NTgtXFx1MDk1ZlxcdTA5ZGMtXFx1MDlkZFxcdTA5ZGZcXHUwYTMzXFx1MGEzNlxcdTBhNTktXFx1MGE1YlxcdTBhNWVcXHUwYjVjLVxcdTBiNWRcXHUwZTM4LVxcdTBlMzlcXHUwZjQzXFx1MGY0ZFxcdTBmNTJcXHUwZjU3XFx1MGY1Y1xcdTBmNjlcXHUwZjcyLVxcdTBmNzZcXHUwZjc4XFx1MGY4MC1cXHUwZjgzXFx1MGY5M1xcdTBmOWRcXHUwZmEyXFx1MGZhN1xcdTBmYWNcXHUwZmI5XFx1MTkzOS1cXHUxOTNhXFx1MWExN1xcdTFiNmJcXHUxY2RhLVxcdTFjZGJcXHUxZGMwLVxcdTFkY2ZcXHUxZGZjXFx1MWRmZVxcdTFmNzFcXHUxZjczXFx1MWY3NVxcdTFmNzdcXHUxZjc5XFx1MWY3YlxcdTFmN2RcXHUxZmJiXFx1MWZiZVxcdTFmYzlcXHUxZmNiXFx1MWZkM1xcdTFmZGJcXHUxZmUzXFx1MWZlYlxcdTFmZWUtXFx1MWZlZlxcdTFmZjlcXHUxZmZiXFx1MWZmZFxcdTIwMDAtXFx1MjAwMVxcdTIwZDAtXFx1MjBkMVxcdTIwZDQtXFx1MjBkN1xcdTIwZTctXFx1MjBlOVxcdTIxMjZcXHUyMTJhLVxcdTIxMmJcXHUyMzI5LVxcdTIzMmFcXHUyYWRjXFx1MzAyYi1cXHUzMDJjXFx1YWFiMi1cXHVhYWIzXFx1ZjkwMC1cXHVmYTBkXFx1ZmExMFxcdWZhMTJcXHVmYTE1LVxcdWZhMWVcXHVmYTIwXFx1ZmEyMlxcdWZhMjUtXFx1ZmEyNlxcdWZhMmEtXFx1ZmEyZFxcdWZhMzAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMWRcXHVmYjFmXFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDAtXFx1ZmI0MVxcdWZiNDMtXFx1ZmI0NFxcdWZiNDYtXFx1ZmI0ZVxcdWZmZjAtXFx1ZmZmZl0vZyxcbiAgICBleHRyYV9sb29rdXA7XG5cbi8vIEpTT04gUXVvdGUgc3RyaW5nLiBVc2UgbmF0aXZlIGltcGxlbWVudGF0aW9uIHdoZW4gcG9zc2libGUuXG52YXIgSlNPTlF1b3RlID0gKEpTT04gJiYgSlNPTi5zdHJpbmdpZnkpIHx8IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIGpzb25fZXNjYXBhYmxlLmxhc3RJbmRleCA9IDA7XG4gICAgaWYgKGpzb25fZXNjYXBhYmxlLnRlc3Qoc3RyaW5nKSkge1xuICAgICAgICBzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShqc29uX2VzY2FwYWJsZSwgZnVuY3Rpb24oYSkge1xuICAgICAgICAgICAgcmV0dXJuIGpzb25fbG9va3VwW2FdO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuICdcIicgKyBzdHJpbmcgKyAnXCInO1xufTtcblxuLy8gVGhpcyBtYXkgYmUgcXVpdGUgc2xvdywgc28gbGV0J3MgZGVsYXkgdW50aWwgdXNlciBhY3R1YWxseSB1c2VzIGJhZFxuLy8gY2hhcmFjdGVycy5cbnZhciB1bnJvbGxfbG9va3VwID0gZnVuY3Rpb24oZXNjYXBhYmxlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHVucm9sbGVkID0ge31cbiAgICB2YXIgYyA9IFtdXG4gICAgZm9yKGk9MDsgaTw2NTUzNjsgaSsrKSB7XG4gICAgICAgIGMucHVzaCggU3RyaW5nLmZyb21DaGFyQ29kZShpKSApO1xuICAgIH1cbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBjLmpvaW4oJycpLnJlcGxhY2UoZXNjYXBhYmxlLCBmdW5jdGlvbiAoYSkge1xuICAgICAgICB1bnJvbGxlZFsgYSBdID0gJ1xcXFx1JyArICgnMDAwMCcgKyBhLmNoYXJDb2RlQXQoMCkudG9TdHJpbmcoMTYpKS5zbGljZSgtNCk7XG4gICAgICAgIHJldHVybiAnJztcbiAgICB9KTtcbiAgICBlc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICByZXR1cm4gdW5yb2xsZWQ7XG59O1xuXG4vLyBRdW90ZSBzdHJpbmcsIGFsc28gdGFraW5nIGNhcmUgb2YgdW5pY29kZSBjaGFyYWN0ZXJzIHRoYXQgYnJvd3NlcnNcbi8vIG9mdGVuIGJyZWFrLiBFc3BlY2lhbGx5LCB0YWtlIGNhcmUgb2YgdW5pY29kZSBzdXJyb2dhdGVzOlxuLy8gICAgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYXBwaW5nX29mX1VuaWNvZGVfY2hhcmFjdGVycyNTdXJyb2dhdGVzXG51dGlscy5xdW90ZSA9IGZ1bmN0aW9uKHN0cmluZykge1xuICAgIHZhciBxdW90ZWQgPSBKU09OUXVvdGUoc3RyaW5nKTtcblxuICAgIC8vIEluIG1vc3QgY2FzZXMgdGhpcyBzaG91bGQgYmUgdmVyeSBmYXN0IGFuZCBnb29kIGVub3VnaC5cbiAgICBleHRyYV9lc2NhcGFibGUubGFzdEluZGV4ID0gMDtcbiAgICBpZighZXh0cmFfZXNjYXBhYmxlLnRlc3QocXVvdGVkKSkge1xuICAgICAgICByZXR1cm4gcXVvdGVkO1xuICAgIH1cblxuICAgIGlmKCFleHRyYV9sb29rdXApIGV4dHJhX2xvb2t1cCA9IHVucm9sbF9sb29rdXAoZXh0cmFfZXNjYXBhYmxlKTtcblxuICAgIHJldHVybiBxdW90ZWQucmVwbGFjZShleHRyYV9lc2NhcGFibGUsIGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgcmV0dXJuIGV4dHJhX2xvb2t1cFthXTtcbiAgICB9KTtcbn1cblxudmFyIF9hbGxfcHJvdG9jb2xzID0gWyd3ZWJzb2NrZXQnLFxuICAgICAgICAgICAgICAgICAgICAgICd4ZHItc3RyZWFtaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAneGhyLXN0cmVhbWluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS1ldmVudHNvdXJjZScsXG4gICAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS1odG1sZmlsZScsXG4gICAgICAgICAgICAgICAgICAgICAgJ3hkci1wb2xsaW5nJyxcbiAgICAgICAgICAgICAgICAgICAgICAneGhyLXBvbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdpZnJhbWUteGhyLXBvbGxpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdqc29ucC1wb2xsaW5nJ107XG5cbnV0aWxzLnByb2JlUHJvdG9jb2xzID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHByb2JlZCA9IHt9O1xuICAgIGZvcih2YXIgaT0wOyBpPF9hbGxfcHJvdG9jb2xzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwcm90b2NvbCA9IF9hbGxfcHJvdG9jb2xzW2ldO1xuICAgICAgICAvLyBVc2VyIGNhbiBoYXZlIGEgdHlwbyBpbiBwcm90b2NvbCBuYW1lLlxuICAgICAgICBwcm9iZWRbcHJvdG9jb2xdID0gU29ja0pTW3Byb3RvY29sXSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgU29ja0pTW3Byb3RvY29sXS5lbmFibGVkKCk7XG4gICAgfVxuICAgIHJldHVybiBwcm9iZWQ7XG59O1xuXG51dGlscy5kZXRlY3RQcm90b2NvbHMgPSBmdW5jdGlvbihwcm9iZWQsIHByb3RvY29sc193aGl0ZWxpc3QsIGluZm8pIHtcbiAgICB2YXIgcGUgPSB7fSxcbiAgICAgICAgcHJvdG9jb2xzID0gW107XG4gICAgaWYgKCFwcm90b2NvbHNfd2hpdGVsaXN0KSBwcm90b2NvbHNfd2hpdGVsaXN0ID0gX2FsbF9wcm90b2NvbHM7XG4gICAgZm9yKHZhciBpPTA7IGk8cHJvdG9jb2xzX3doaXRlbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHJvdG9jb2wgPSBwcm90b2NvbHNfd2hpdGVsaXN0W2ldO1xuICAgICAgICBwZVtwcm90b2NvbF0gPSBwcm9iZWRbcHJvdG9jb2xdO1xuICAgIH1cbiAgICB2YXIgbWF5YmVfcHVzaCA9IGZ1bmN0aW9uKHByb3Rvcykge1xuICAgICAgICB2YXIgcHJvdG8gPSBwcm90b3Muc2hpZnQoKTtcbiAgICAgICAgaWYgKHBlW3Byb3RvXSkge1xuICAgICAgICAgICAgcHJvdG9jb2xzLnB1c2gocHJvdG8pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHByb3Rvcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgbWF5YmVfcHVzaChwcm90b3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gMS4gV2Vic29ja2V0XG4gICAgaWYgKGluZm8ud2Vic29ja2V0ICE9PSBmYWxzZSkge1xuICAgICAgICBtYXliZV9wdXNoKFsnd2Vic29ja2V0J10pO1xuICAgIH1cblxuICAgIC8vIDIuIFN0cmVhbWluZ1xuICAgIGlmIChwZVsneGhyLXN0cmVhbWluZyddICYmICFpbmZvLm51bGxfb3JpZ2luKSB7XG4gICAgICAgIHByb3RvY29scy5wdXNoKCd4aHItc3RyZWFtaW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBlWyd4ZHItc3RyZWFtaW5nJ10gJiYgIWluZm8uY29va2llX25lZWRlZCAmJiAhaW5mby5udWxsX29yaWdpbikge1xuICAgICAgICAgICAgcHJvdG9jb2xzLnB1c2goJ3hkci1zdHJlYW1pbmcnKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1heWJlX3B1c2goWydpZnJhbWUtZXZlbnRzb3VyY2UnLFxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lmcmFtZS1odG1sZmlsZSddKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIDMuIFBvbGxpbmdcbiAgICBpZiAocGVbJ3hoci1wb2xsaW5nJ10gJiYgIWluZm8ubnVsbF9vcmlnaW4pIHtcbiAgICAgICAgcHJvdG9jb2xzLnB1c2goJ3hoci1wb2xsaW5nJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBlWyd4ZHItcG9sbGluZyddICYmICFpbmZvLmNvb2tpZV9uZWVkZWQgJiYgIWluZm8ubnVsbF9vcmlnaW4pIHtcbiAgICAgICAgICAgIHByb3RvY29scy5wdXNoKCd4ZHItcG9sbGluZycpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbWF5YmVfcHVzaChbJ2lmcmFtZS14aHItcG9sbGluZycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnanNvbnAtcG9sbGluZyddKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcHJvdG9jb2xzO1xufVxuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi91dGlscy5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvZG9tLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG4vLyBNYXkgYmUgdXNlZCBieSBodG1sZmlsZSBqc29ucCBhbmQgdHJhbnNwb3J0cy5cbnZhciBNUHJlZml4ID0gJ19zb2NranNfZ2xvYmFsJztcbnV0aWxzLmNyZWF0ZUhvb2sgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgd2luZG93X2lkID0gJ2EnICsgdXRpbHMucmFuZG9tX3N0cmluZyg4KTtcbiAgICBpZiAoIShNUHJlZml4IGluIF93aW5kb3cpKSB7XG4gICAgICAgIHZhciBtYXAgPSB7fTtcbiAgICAgICAgX3dpbmRvd1tNUHJlZml4XSA9IGZ1bmN0aW9uKHdpbmRvd19pZCkge1xuICAgICAgICAgICAgaWYgKCEod2luZG93X2lkIGluIG1hcCkpIHtcbiAgICAgICAgICAgICAgICBtYXBbd2luZG93X2lkXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHdpbmRvd19pZCxcbiAgICAgICAgICAgICAgICAgICAgZGVsOiBmdW5jdGlvbigpIHtkZWxldGUgbWFwW3dpbmRvd19pZF07fVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbWFwW3dpbmRvd19pZF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF93aW5kb3dbTVByZWZpeF0od2luZG93X2lkKTtcbn07XG5cblxuXG51dGlscy5hdHRhY2hNZXNzYWdlID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB1dGlscy5hdHRhY2hFdmVudCgnbWVzc2FnZScsIGxpc3RlbmVyKTtcbn07XG51dGlscy5hdHRhY2hFdmVudCA9IGZ1bmN0aW9uKGV2ZW50LCBsaXN0ZW5lcikge1xuICAgIGlmICh0eXBlb2YgX3dpbmRvdy5hZGRFdmVudExpc3RlbmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBfd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGxpc3RlbmVyLCBmYWxzZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gSUUgcXVpcmtzLlxuICAgICAgICAvLyBBY2NvcmRpbmcgdG86IGh0dHA6Ly9zdGV2ZXNvdWRlcnMuY29tL21pc2MvdGVzdC1wb3N0bWVzc2FnZS5waHBcbiAgICAgICAgLy8gdGhlIG1lc3NhZ2UgZ2V0cyBkZWxpdmVyZWQgb25seSB0byAnZG9jdW1lbnQnLCBub3QgJ3dpbmRvdycuXG4gICAgICAgIF9kb2N1bWVudC5hdHRhY2hFdmVudChcIm9uXCIgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICAvLyBJIGdldCAnd2luZG93JyBmb3IgaWU4LlxuICAgICAgICBfd2luZG93LmF0dGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxufTtcblxudXRpbHMuZGV0YWNoTWVzc2FnZSA9IGZ1bmN0aW9uKGxpc3RlbmVyKSB7XG4gICAgdXRpbHMuZGV0YWNoRXZlbnQoJ21lc3NhZ2UnLCBsaXN0ZW5lcik7XG59O1xudXRpbHMuZGV0YWNoRXZlbnQgPSBmdW5jdGlvbihldmVudCwgbGlzdGVuZXIpIHtcbiAgICBpZiAodHlwZW9mIF93aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgX3dpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKGV2ZW50LCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIF9kb2N1bWVudC5kZXRhY2hFdmVudChcIm9uXCIgKyBldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICBfd2luZG93LmRldGFjaEV2ZW50KFwib25cIiArIGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgfVxufTtcblxuXG52YXIgb25fdW5sb2FkID0ge307XG4vLyBUaGluZ3MgcmVnaXN0ZXJlZCBhZnRlciBiZWZvcmV1bmxvYWQgYXJlIHRvIGJlIGNhbGxlZCBpbW1lZGlhdGVseS5cbnZhciBhZnRlcl91bmxvYWQgPSBmYWxzZTtcblxudmFyIHRyaWdnZXJfdW5sb2FkX2NhbGxiYWNrcyA9IGZ1bmN0aW9uKCkge1xuICAgIGZvcih2YXIgcmVmIGluIG9uX3VubG9hZCkge1xuICAgICAgICBvbl91bmxvYWRbcmVmXSgpO1xuICAgICAgICBkZWxldGUgb25fdW5sb2FkW3JlZl07XG4gICAgfTtcbn07XG5cbnZhciB1bmxvYWRfdHJpZ2dlcmVkID0gZnVuY3Rpb24oKSB7XG4gICAgaWYoYWZ0ZXJfdW5sb2FkKSByZXR1cm47XG4gICAgYWZ0ZXJfdW5sb2FkID0gdHJ1ZTtcbiAgICB0cmlnZ2VyX3VubG9hZF9jYWxsYmFja3MoKTtcbn07XG5cbi8vIE9uYmVmb3JldW5sb2FkIGFsb25lIGlzIG5vdCByZWxpYWJsZS4gV2UgY291bGQgdXNlIG9ubHkgJ3VubG9hZCdcbi8vIGJ1dCBpdCdzIG5vdCB3b3JraW5nIGluIG9wZXJhIHdpdGhpbiBhbiBpZnJhbWUuIExldCdzIHVzZSBib3RoLlxudXRpbHMuYXR0YWNoRXZlbnQoJ2JlZm9yZXVubG9hZCcsIHVubG9hZF90cmlnZ2VyZWQpO1xudXRpbHMuYXR0YWNoRXZlbnQoJ3VubG9hZCcsIHVubG9hZF90cmlnZ2VyZWQpO1xuXG51dGlscy51bmxvYWRfYWRkID0gZnVuY3Rpb24obGlzdGVuZXIpIHtcbiAgICB2YXIgcmVmID0gdXRpbHMucmFuZG9tX3N0cmluZyg4KTtcbiAgICBvbl91bmxvYWRbcmVmXSA9IGxpc3RlbmVyO1xuICAgIGlmIChhZnRlcl91bmxvYWQpIHtcbiAgICAgICAgdXRpbHMuZGVsYXkodHJpZ2dlcl91bmxvYWRfY2FsbGJhY2tzKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlZjtcbn07XG51dGlscy51bmxvYWRfZGVsID0gZnVuY3Rpb24ocmVmKSB7XG4gICAgaWYgKHJlZiBpbiBvbl91bmxvYWQpXG4gICAgICAgIGRlbGV0ZSBvbl91bmxvYWRbcmVmXTtcbn07XG5cblxudXRpbHMuY3JlYXRlSWZyYW1lID0gZnVuY3Rpb24gKGlmcmFtZV91cmwsIGVycm9yX2NhbGxiYWNrKSB7XG4gICAgdmFyIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICB2YXIgdHJlZiwgdW5sb2FkX3JlZjtcbiAgICB2YXIgdW5hdHRhY2ggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgICAvLyBFeHBsb3JlciBoYWQgcHJvYmxlbXMgd2l0aCB0aGF0LlxuICAgICAgICB0cnkge2lmcmFtZS5vbmxvYWQgPSBudWxsO30gY2F0Y2ggKHgpIHt9XG4gICAgICAgIGlmcmFtZS5vbmVycm9yID0gbnVsbDtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChpZnJhbWUpIHtcbiAgICAgICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgICAgICAvLyBUaGlzIHRpbWVvdXQgbWFrZXMgY2hyb21lIGZpcmUgb25iZWZvcmV1bmxvYWQgZXZlbnRcbiAgICAgICAgICAgIC8vIHdpdGhpbiBpZnJhbWUuIFdpdGhvdXQgdGhlIHRpbWVvdXQgaXQgZ29lcyBzdHJhaWdodCB0b1xuICAgICAgICAgICAgLy8gb251bmxvYWQuXG4gICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmKGlmcmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZnJhbWUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChpZnJhbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZnJhbWUgPSBudWxsO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB1dGlscy51bmxvYWRfZGVsKHVubG9hZF9yZWYpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpIHtcbiAgICAgICAgaWYgKGlmcmFtZSkge1xuICAgICAgICAgICAgY2xlYW51cCgpO1xuICAgICAgICAgICAgZXJyb3JfY2FsbGJhY2socik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHZhciBwb3N0ID0gZnVuY3Rpb24obXNnLCBvcmlnaW4pIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgICBpZiAoaWZyYW1lICYmIGlmcmFtZS5jb250ZW50V2luZG93KSB7XG4gICAgICAgICAgICAgICAgaWZyYW1lLmNvbnRlbnRXaW5kb3cucG9zdE1lc3NhZ2UobXNnLCBvcmlnaW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoICh4KSB7fTtcbiAgICB9O1xuXG4gICAgaWZyYW1lLnNyYyA9IGlmcmFtZV91cmw7XG4gICAgaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gICAgaWZyYW1lLnN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcbiAgICBpZnJhbWUub25lcnJvciA9IGZ1bmN0aW9uKCl7b25lcnJvcignb25lcnJvcicpO307XG4gICAgaWZyYW1lLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAvLyBgb25sb2FkYCBpcyB0cmlnZ2VyZWQgYmVmb3JlIHNjcmlwdHMgb24gdGhlIGlmcmFtZSBhcmVcbiAgICAgICAgLy8gZXhlY3V0ZWQuIEdpdmUgaXQgZmV3IHNlY29uZHMgdG8gYWN0dWFsbHkgbG9hZCBzdHVmZi5cbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpe29uZXJyb3IoJ29ubG9hZCB0aW1lb3V0Jyk7fSwgMjAwMCk7XG4gICAgfTtcbiAgICBfZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7b25lcnJvcigndGltZW91dCcpO30sIDE1MDAwKTtcbiAgICB1bmxvYWRfcmVmID0gdXRpbHMudW5sb2FkX2FkZChjbGVhbnVwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBwb3N0OiBwb3N0LFxuICAgICAgICBjbGVhbnVwOiBjbGVhbnVwLFxuICAgICAgICBsb2FkZWQ6IHVuYXR0YWNoXG4gICAgfTtcbn07XG5cbnV0aWxzLmNyZWF0ZUh0bWxmaWxlID0gZnVuY3Rpb24gKGlmcmFtZV91cmwsIGVycm9yX2NhbGxiYWNrKSB7XG4gICAgdmFyIGRvYyA9IG5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICAgIHZhciB0cmVmLCB1bmxvYWRfcmVmO1xuICAgIHZhciBpZnJhbWU7XG4gICAgdmFyIHVuYXR0YWNoID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICB9O1xuICAgIHZhciBjbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgIHVuYXR0YWNoKCk7XG4gICAgICAgICAgICB1dGlscy51bmxvYWRfZGVsKHVubG9hZF9yZWYpO1xuICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgIGlmcmFtZSA9IGRvYyA9IG51bGw7XG4gICAgICAgICAgICBDb2xsZWN0R2FyYmFnZSgpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgb25lcnJvciA9IGZ1bmN0aW9uKHIpICB7XG4gICAgICAgIGlmIChkb2MpIHtcbiAgICAgICAgICAgIGNsZWFudXAoKTtcbiAgICAgICAgICAgIGVycm9yX2NhbGxiYWNrKHIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICB2YXIgcG9zdCA9IGZ1bmN0aW9uKG1zZywgb3JpZ2luKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHRoZSBpZnJhbWUgaXMgbm90IGxvYWRlZCwgSUUgcmFpc2VzIGFuIGV4Y2VwdGlvblxuICAgICAgICAgICAgLy8gb24gJ2NvbnRlbnRXaW5kb3cnLlxuICAgICAgICAgICAgaWYgKGlmcmFtZSAmJiBpZnJhbWUuY29udGVudFdpbmRvdykge1xuICAgICAgICAgICAgICAgIGlmcmFtZS5jb250ZW50V2luZG93LnBvc3RNZXNzYWdlKG1zZywgb3JpZ2luKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBjYXRjaCAoeCkge307XG4gICAgfTtcblxuICAgIGRvYy5vcGVuKCk7XG4gICAgZG9jLndyaXRlKCc8aHRtbD48cycgKyAnY3JpcHQ+JyArXG4gICAgICAgICAgICAgICdkb2N1bWVudC5kb21haW49XCInICsgZG9jdW1lbnQuZG9tYWluICsgJ1wiOycgK1xuICAgICAgICAgICAgICAnPC9zJyArICdjcmlwdD48L2h0bWw+Jyk7XG4gICAgZG9jLmNsb3NlKCk7XG4gICAgZG9jLnBhcmVudFdpbmRvd1tXUHJlZml4XSA9IF93aW5kb3dbV1ByZWZpeF07XG4gICAgdmFyIGMgPSBkb2MuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZG9jLmJvZHkuYXBwZW5kQ2hpbGQoYyk7XG4gICAgaWZyYW1lID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuICAgIGMuYXBwZW5kQ2hpbGQoaWZyYW1lKTtcbiAgICBpZnJhbWUuc3JjID0gaWZyYW1lX3VybDtcbiAgICB0cmVmID0gc2V0VGltZW91dChmdW5jdGlvbigpe29uZXJyb3IoJ3RpbWVvdXQnKTt9LCAxNTAwMCk7XG4gICAgdW5sb2FkX3JlZiA9IHV0aWxzLnVubG9hZF9hZGQoY2xlYW51cCk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgcG9zdDogcG9zdCxcbiAgICAgICAgY2xlYW51cDogY2xlYW51cCxcbiAgICAgICAgbG9hZGVkOiB1bmF0dGFjaFxuICAgIH07XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9kb20uanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL2RvbTIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBBYnN0cmFjdFhIUk9iamVjdCA9IGZ1bmN0aW9uKCl7fTtcbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoWydjaHVuaycsICdmaW5pc2gnXSk7XG5cbkFic3RyYWN0WEhST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCwgb3B0cykge1xuICAgIHZhciB0aGF0ID0gdGhpcztcblxuICAgIHRyeSB7XG4gICAgICAgIHRoYXQueGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgfSBjYXRjaCh4KSB7fTtcblxuICAgIGlmICghdGhhdC54aHIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoYXQueGhyID0gbmV3IF93aW5kb3cuQWN0aXZlWE9iamVjdCgnTWljcm9zb2Z0LlhNTEhUVFAnKTtcbiAgICAgICAgfSBjYXRjaCh4KSB7fTtcbiAgICB9XG4gICAgaWYgKF93aW5kb3cuQWN0aXZlWE9iamVjdCB8fCBfd2luZG93LlhEb21haW5SZXF1ZXN0KSB7XG4gICAgICAgIC8vIElFOCBjYWNoZXMgZXZlbiBQT1NUc1xuICAgICAgICB1cmwgKz0gKCh1cmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgJ3Q9JysoK25ldyBEYXRlKTtcbiAgICB9XG5cbiAgICAvLyBFeHBsb3JlciB0ZW5kcyB0byBrZWVwIGNvbm5lY3Rpb24gb3BlbiwgZXZlbiBhZnRlciB0aGVcbiAgICAvLyB0YWIgZ2V0cyBjbG9zZWQ6IGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzUyODBcbiAgICB0aGF0LnVubG9hZF9yZWYgPSB1dGlscy51bmxvYWRfYWRkKGZ1bmN0aW9uKCl7dGhhdC5fY2xlYW51cCh0cnVlKTt9KTtcbiAgICB0cnkge1xuICAgICAgICB0aGF0Lnhoci5vcGVuKG1ldGhvZCwgdXJsLCB0cnVlKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgICAgLy8gSUUgcmFpc2VzIGFuIGV4Y2VwdGlvbiBvbiB3cm9uZyBwb3J0LlxuICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcsIDAsICcnKTtcbiAgICAgICAgdGhhdC5fY2xlYW51cCgpO1xuICAgICAgICByZXR1cm47XG4gICAgfTtcblxuICAgIGlmICghb3B0cyB8fCAhb3B0cy5ub19jcmVkZW50aWFscykge1xuICAgICAgICAvLyBNb3ppbGxhIGRvY3Mgc2F5cyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi9YTUxIdHRwUmVxdWVzdCA6XG4gICAgICAgIC8vIFwiVGhpcyBuZXZlciBhZmZlY3RzIHNhbWUtc2l0ZSByZXF1ZXN0cy5cIlxuICAgICAgICB0aGF0Lnhoci53aXRoQ3JlZGVudGlhbHMgPSAndHJ1ZSc7XG4gICAgfVxuICAgIGlmIChvcHRzICYmIG9wdHMuaGVhZGVycykge1xuICAgICAgICBmb3IodmFyIGtleSBpbiBvcHRzLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIHRoYXQueGhyLnNldFJlcXVlc3RIZWFkZXIoa2V5LCBvcHRzLmhlYWRlcnNba2V5XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB0aGF0Lnhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKHRoYXQueGhyKSB7XG4gICAgICAgICAgICB2YXIgeCA9IHRoYXQueGhyO1xuICAgICAgICAgICAgc3dpdGNoICh4LnJlYWR5U3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgICAgICAvLyBJRSBkb2Vzbid0IGxpa2UgcGVla2luZyBpbnRvIHJlc3BvbnNlVGV4dCBvciBzdGF0dXNcbiAgICAgICAgICAgICAgICAvLyBvbiBNaWNyb3NvZnQuWE1MSFRUUCBhbmQgcmVhZHlzdGF0ZT0zXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHN0YXR1cyA9IHguc3RhdHVzO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdGV4dCA9IHgucmVzcG9uc2VUZXh0O1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9O1xuICAgICAgICAgICAgICAgIC8vIElFIGRvZXMgcmV0dXJuIHJlYWR5c3RhdGUgPT0gMyBmb3IgNDA0IGFuc3dlcnMuXG4gICAgICAgICAgICAgICAgaWYgKHRleHQgJiYgdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgnY2h1bmsnLCBzdGF0dXMsIHRleHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcsIHguc3RhdHVzLCB4LnJlc3BvbnNlVGV4dCk7XG4gICAgICAgICAgICAgICAgdGhhdC5fY2xlYW51cChmYWxzZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoYXQueGhyLnNlbmQocGF5bG9hZCk7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuX2NsZWFudXAgPSBmdW5jdGlvbihhYm9ydCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAoIXRoYXQueGhyKSByZXR1cm47XG4gICAgdXRpbHMudW5sb2FkX2RlbCh0aGF0LnVubG9hZF9yZWYpO1xuXG4gICAgLy8gSUUgbmVlZHMgdGhpcyBmaWVsZCB0byBiZSBhIGZ1bmN0aW9uXG4gICAgdGhhdC54aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKXt9O1xuXG4gICAgaWYgKGFib3J0KSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGF0Lnhoci5hYm9ydCgpO1xuICAgICAgICB9IGNhdGNoKHgpIHt9O1xuICAgIH1cbiAgICB0aGF0LnVubG9hZF9yZWYgPSB0aGF0LnhociA9IG51bGw7XG59O1xuXG5BYnN0cmFjdFhIUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5udWtlKCk7XG4gICAgdGhhdC5fY2xlYW51cCh0cnVlKTtcbn07XG5cbnZhciBYSFJDb3JzT2JqZWN0ID0gdXRpbHMuWEhSQ29yc09iamVjdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcywgYXJncyA9IGFyZ3VtZW50cztcbiAgICB1dGlscy5kZWxheShmdW5jdGlvbigpe3RoYXQuX3N0YXJ0LmFwcGx5KHRoYXQsIGFyZ3MpO30pO1xufTtcblhIUkNvcnNPYmplY3QucHJvdG90eXBlID0gbmV3IEFic3RyYWN0WEhST2JqZWN0KCk7XG5cbnZhciBYSFJMb2NhbE9iamVjdCA9IHV0aWxzLlhIUkxvY2FsT2JqZWN0ID0gZnVuY3Rpb24obWV0aG9kLCB1cmwsIHBheWxvYWQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdXRpbHMuZGVsYXkoZnVuY3Rpb24oKXtcbiAgICAgICAgdGhhdC5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQsIHtcbiAgICAgICAgICAgIG5vX2NyZWRlbnRpYWxzOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0pO1xufTtcblhIUkxvY2FsT2JqZWN0LnByb3RvdHlwZSA9IG5ldyBBYnN0cmFjdFhIUk9iamVjdCgpO1xuXG5cblxuLy8gUmVmZXJlbmNlczpcbi8vICAgaHR0cDovL2FqYXhpYW4uY29tL2FyY2hpdmVzLzEwMC1saW5lLWFqYXgtd3JhcHBlclxuLy8gICBodHRwOi8vbXNkbi5taWNyb3NvZnQuY29tL2VuLXVzL2xpYnJhcnkvY2MyODgwNjAodj1WUy44NSkuYXNweFxudmFyIFhEUk9iamVjdCA9IHV0aWxzLlhEUk9iamVjdCA9IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBwYXlsb2FkKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHV0aWxzLmRlbGF5KGZ1bmN0aW9uKCl7dGhhdC5fc3RhcnQobWV0aG9kLCB1cmwsIHBheWxvYWQpO30pO1xufTtcblhEUk9iamVjdC5wcm90b3R5cGUgPSBuZXcgRXZlbnRFbWl0dGVyKFsnY2h1bmsnLCAnZmluaXNoJ10pO1xuWERST2JqZWN0LnByb3RvdHlwZS5fc3RhcnQgPSBmdW5jdGlvbihtZXRob2QsIHVybCwgcGF5bG9hZCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgeGRyID0gbmV3IFhEb21haW5SZXF1ZXN0KCk7XG4gICAgLy8gSUUgY2FjaGVzIGV2ZW4gUE9TVHNcbiAgICB1cmwgKz0gKCh1cmwuaW5kZXhPZignPycpID09PSAtMSkgPyAnPycgOiAnJicpICsgJ3Q9JysoK25ldyBEYXRlKTtcblxuICAgIHZhciBvbmVycm9yID0geGRyLm9udGltZW91dCA9IHhkci5vbmVycm9yID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJywgMCwgJycpO1xuICAgICAgICB0aGF0Ll9jbGVhbnVwKGZhbHNlKTtcbiAgICB9O1xuICAgIHhkci5vbnByb2dyZXNzID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuZW1pdCgnY2h1bmsnLCAyMDAsIHhkci5yZXNwb25zZVRleHQpO1xuICAgIH07XG4gICAgeGRyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcsIDIwMCwgeGRyLnJlc3BvbnNlVGV4dCk7XG4gICAgICAgIHRoYXQuX2NsZWFudXAoZmFsc2UpO1xuICAgIH07XG4gICAgdGhhdC54ZHIgPSB4ZHI7XG4gICAgdGhhdC51bmxvYWRfcmVmID0gdXRpbHMudW5sb2FkX2FkZChmdW5jdGlvbigpe3RoYXQuX2NsZWFudXAodHJ1ZSk7fSk7XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gRmFpbHMgd2l0aCBBY2Nlc3NEZW5pZWQgaWYgcG9ydCBudW1iZXIgaXMgYm9ndXNcbiAgICAgICAgdGhhdC54ZHIub3BlbihtZXRob2QsIHVybCk7XG4gICAgICAgIHRoYXQueGRyLnNlbmQocGF5bG9hZCk7XG4gICAgfSBjYXRjaCh4KSB7XG4gICAgICAgIG9uZXJyb3IoKTtcbiAgICB9XG59O1xuXG5YRFJPYmplY3QucHJvdG90eXBlLl9jbGVhbnVwID0gZnVuY3Rpb24oYWJvcnQpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKCF0aGF0LnhkcikgcmV0dXJuO1xuICAgIHV0aWxzLnVubG9hZF9kZWwodGhhdC51bmxvYWRfcmVmKTtcblxuICAgIHRoYXQueGRyLm9udGltZW91dCA9IHRoYXQueGRyLm9uZXJyb3IgPSB0aGF0Lnhkci5vbnByb2dyZXNzID1cbiAgICAgICAgdGhhdC54ZHIub25sb2FkID0gbnVsbDtcbiAgICBpZiAoYWJvcnQpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoYXQueGRyLmFib3J0KCk7XG4gICAgICAgIH0gY2F0Y2goeCkge307XG4gICAgfVxuICAgIHRoYXQudW5sb2FkX3JlZiA9IHRoYXQueGRyID0gbnVsbDtcbn07XG5cblhEUk9iamVjdC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5udWtlKCk7XG4gICAgdGhhdC5fY2xlYW51cCh0cnVlKTtcbn07XG5cbi8vIDEuIElzIG5hdGl2ZWx5IHZpYSBYSFJcbi8vIDIuIElzIG5hdGl2ZWx5IHZpYSBYRFJcbi8vIDMuIE5vcGUsIGJ1dCBwb3N0TWVzc2FnZSBpcyB0aGVyZSBzbyBpdCBzaG91bGQgd29yayB2aWEgdGhlIElmcmFtZS5cbi8vIDQuIE5vcGUsIHNvcnJ5LlxudXRpbHMuaXNYSFJDb3JzQ2FwYWJsZSA9IGZ1bmN0aW9uKCkge1xuICAgIGlmIChfd2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmICd3aXRoQ3JlZGVudGlhbHMnIGluIG5ldyBYTUxIdHRwUmVxdWVzdCgpKSB7XG4gICAgICAgIHJldHVybiAxO1xuICAgIH1cbiAgICAvLyBYRG9tYWluUmVxdWVzdCBkb2Vzbid0IHdvcmsgaWYgcGFnZSBpcyBzZXJ2ZWQgZnJvbSBmaWxlOi8vXG4gICAgaWYgKF93aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgX2RvY3VtZW50LmRvbWFpbikge1xuICAgICAgICByZXR1cm4gMjtcbiAgICB9XG4gICAgaWYgKElmcmFtZVRyYW5zcG9ydC5lbmFibGVkKCkpIHtcbiAgICAgICAgcmV0dXJuIDM7XG4gICAgfVxuICAgIHJldHVybiA0O1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvZG9tMi5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvc29ja2pzLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgU29ja0pTID0gZnVuY3Rpb24odXJsLCBkZXBfcHJvdG9jb2xzX3doaXRlbGlzdCwgb3B0aW9ucykge1xuICAgIGlmICh0aGlzID09PSB3aW5kb3cpIHtcbiAgICAgICAgLy8gbWFrZXMgYG5ld2Agb3B0aW9uYWxcbiAgICAgICAgcmV0dXJuIG5ldyBTb2NrSlModXJsLCBkZXBfcHJvdG9jb2xzX3doaXRlbGlzdCwgb3B0aW9ucyk7XG4gICAgfVxuICAgIFxuICAgIHZhciB0aGF0ID0gdGhpcywgcHJvdG9jb2xzX3doaXRlbGlzdDtcbiAgICB0aGF0Ll9vcHRpb25zID0ge2RldmVsOiBmYWxzZSwgZGVidWc6IGZhbHNlLCBwcm90b2NvbHNfd2hpdGVsaXN0OiBbXSxcbiAgICAgICAgICAgICAgICAgICAgIGluZm86IHVuZGVmaW5lZCwgcnR0OiB1bmRlZmluZWR9O1xuICAgIGlmIChvcHRpb25zKSB7XG4gICAgICAgIHV0aWxzLm9iamVjdEV4dGVuZCh0aGF0Ll9vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhhdC5fYmFzZV91cmwgPSB1dGlscy5hbWVuZFVybCh1cmwpO1xuICAgIHRoYXQuX3NlcnZlciA9IHRoYXQuX29wdGlvbnMuc2VydmVyIHx8IHV0aWxzLnJhbmRvbV9udW1iZXJfc3RyaW5nKDEwMDApO1xuICAgIGlmICh0aGF0Ll9vcHRpb25zLnByb3RvY29sc193aGl0ZWxpc3QgJiZcbiAgICAgICAgdGhhdC5fb3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0Lmxlbmd0aCkge1xuICAgICAgICBwcm90b2NvbHNfd2hpdGVsaXN0ID0gdGhhdC5fb3B0aW9ucy5wcm90b2NvbHNfd2hpdGVsaXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIERlcHJlY2F0ZWQgQVBJXG4gICAgICAgIGlmICh0eXBlb2YgZGVwX3Byb3RvY29sc193aGl0ZWxpc3QgPT09ICdzdHJpbmcnICYmXG4gICAgICAgICAgICBkZXBfcHJvdG9jb2xzX3doaXRlbGlzdC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBwcm90b2NvbHNfd2hpdGVsaXN0ID0gW2RlcF9wcm90b2NvbHNfd2hpdGVsaXN0XTtcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc0FycmF5KGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0KSkge1xuICAgICAgICAgICAgcHJvdG9jb2xzX3doaXRlbGlzdCA9IGRlcF9wcm90b2NvbHNfd2hpdGVsaXN0XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBwcm90b2NvbHNfd2hpdGVsaXN0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgICAgICAgICAgdGhhdC5fZGVidWcoJ0RlcHJlY2F0ZWQgQVBJOiBVc2UgXCJwcm90b2NvbHNfd2hpdGVsaXN0XCIgb3B0aW9uICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ2luc3RlYWQgb2Ygc3VwcGx5aW5nIHByb3RvY29sIGxpc3QgYXMgYSBzZWNvbmQgJyArXG4gICAgICAgICAgICAgICAgICAgICAgICAncGFyYW1ldGVyIHRvIFNvY2tKUyBjb25zdHJ1Y3Rvci4nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aGF0Ll9wcm90b2NvbHMgPSBbXTtcbiAgICB0aGF0LnByb3RvY29sID0gbnVsbDtcbiAgICB0aGF0LnJlYWR5U3RhdGUgPSBTb2NrSlMuQ09OTkVDVElORztcbiAgICB0aGF0Ll9pciA9IGNyZWF0ZUluZm9SZWNlaXZlcih0aGF0Ll9iYXNlX3VybCk7XG4gICAgdGhhdC5faXIub25maW5pc2ggPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICAgICAgdGhhdC5faXIgPSBudWxsO1xuICAgICAgICBpZiAoaW5mbykge1xuICAgICAgICAgICAgaWYgKHRoYXQuX29wdGlvbnMuaW5mbykge1xuICAgICAgICAgICAgICAgIC8vIE92ZXJyaWRlIGlmIHVzZXIgc3VwcGxpZXMgdGhlIG9wdGlvblxuICAgICAgICAgICAgICAgIGluZm8gPSB1dGlscy5vYmplY3RFeHRlbmQoaW5mbywgdGhhdC5fb3B0aW9ucy5pbmZvKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGF0Ll9vcHRpb25zLnJ0dCkge1xuICAgICAgICAgICAgICAgIHJ0dCA9IHRoYXQuX29wdGlvbnMucnR0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhhdC5fYXBwbHlJbmZvKGluZm8sIHJ0dCwgcHJvdG9jb2xzX3doaXRlbGlzdCk7XG4gICAgICAgICAgICB0aGF0Ll9kaWRDbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5fZGlkQ2xvc2UoMTAwMiwgJ0NhblxcJ3QgY29ubmVjdCB0byBzZXJ2ZXInLCB0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG59O1xuLy8gSW5oZXJpdGFuY2VcblNvY2tKUy5wcm90b3R5cGUgPSBuZXcgUkV2ZW50VGFyZ2V0KCk7XG5cblNvY2tKUy52ZXJzaW9uID0gXCIwLjMuMS43LmdhNjdmLmRpcnR5XCI7XG5cblNvY2tKUy5DT05ORUNUSU5HID0gMDtcblNvY2tKUy5PUEVOID0gMTtcblNvY2tKUy5DTE9TSU5HID0gMjtcblNvY2tKUy5DTE9TRUQgPSAzO1xuXG5Tb2NrSlMucHJvdG90eXBlLl9kZWJ1ZyA9IGZ1bmN0aW9uKCkge1xuICAgIGlmICh0aGlzLl9vcHRpb25zLmRlYnVnKVxuICAgICAgICB1dGlscy5sb2cuYXBwbHkodXRpbHMsIGFyZ3VtZW50cyk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9kaXNwYXRjaE9wZW4gPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgaWYgKHRoYXQuX3RyYW5zcG9ydF90cmVmKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhhdC5fdHJhbnNwb3J0X3RyZWYpO1xuICAgICAgICAgICAgdGhhdC5fdHJhbnNwb3J0X3RyZWYgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoYXQucmVhZHlTdGF0ZSA9IFNvY2tKUy5PUEVOO1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KFwib3BlblwiKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIHNlcnZlciBtaWdodCBoYXZlIGJlZW4gcmVzdGFydGVkLCBhbmQgbG9zdCB0cmFjayBvZiBvdXJcbiAgICAgICAgLy8gY29ubmVjdGlvbi5cbiAgICAgICAgdGhhdC5fZGlkQ2xvc2UoMTAwNiwgXCJTZXJ2ZXIgbG9zdCBzZXNzaW9uXCIpO1xuICAgIH1cbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2Rpc3BhdGNoTWVzc2FnZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pXG4gICAgICAgICAgICByZXR1cm47XG4gICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudChcIm1lc3NhZ2VcIiwge2RhdGE6IGRhdGF9KSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9kaXNwYXRjaEhlYXJ0YmVhdCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4pXG4gICAgICAgIHJldHVybjtcbiAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdoZWFydGJlYXQnLCB7fSkpO1xufTtcblxuU29ja0pTLnByb3RvdHlwZS5fZGlkQ2xvc2UgPSBmdW5jdGlvbihjb2RlLCByZWFzb24sIGZvcmNlKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnJlYWR5U3RhdGUgIT09IFNvY2tKUy5DT05ORUNUSU5HICYmXG4gICAgICAgIHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLk9QRU4gJiZcbiAgICAgICAgdGhhdC5yZWFkeVN0YXRlICE9PSBTb2NrSlMuQ0xPU0lORylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSU5WQUxJRF9TVEFURV9FUlInKTtcbiAgICBpZiAodGhhdC5faXIpIHtcbiAgICAgICAgdGhhdC5faXIubnVrZSgpO1xuICAgICAgICB0aGF0Ll9pciA9IG51bGw7XG4gICAgfVxuXG4gICAgaWYgKHRoYXQuX3RyYW5zcG9ydCkge1xuICAgICAgICB0aGF0Ll90cmFuc3BvcnQuZG9DbGVhbnVwKCk7XG4gICAgICAgIHRoYXQuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgfVxuXG4gICAgdmFyIGNsb3NlX2V2ZW50ID0gbmV3IFNpbXBsZUV2ZW50KFwiY2xvc2VcIiwge1xuICAgICAgICBjb2RlOiBjb2RlLFxuICAgICAgICByZWFzb246IHJlYXNvbixcbiAgICAgICAgd2FzQ2xlYW46IHV0aWxzLnVzZXJTZXRDb2RlKGNvZGUpfSk7XG5cbiAgICBpZiAoIXV0aWxzLnVzZXJTZXRDb2RlKGNvZGUpICYmXG4gICAgICAgIHRoYXQucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcgJiYgIWZvcmNlKSB7XG4gICAgICAgIGlmICh0aGF0Ll90cnlfbmV4dF9wcm90b2NvbChjbG9zZV9ldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjbG9zZV9ldmVudCA9IG5ldyBTaW1wbGVFdmVudChcImNsb3NlXCIsIHtjb2RlOiAyMDAwLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uOiBcIkFsbCB0cmFuc3BvcnRzIGZhaWxlZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgd2FzQ2xlYW46IGZhbHNlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF9ldmVudDogY2xvc2VfZXZlbnR9KTtcbiAgICB9XG4gICAgdGhhdC5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NFRDtcblxuICAgIHV0aWxzLmRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChjbG9zZV9ldmVudCk7XG4gICAgICAgICAgICAgICAgfSk7XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLl9kaWRNZXNzYWdlID0gZnVuY3Rpb24oZGF0YSkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgdHlwZSA9IGRhdGEuc2xpY2UoMCwgMSk7XG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlICdvJzpcbiAgICAgICAgdGhhdC5fZGlzcGF0Y2hPcGVuKCk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2EnOlxuICAgICAgICB2YXIgcGF5bG9hZCA9IEpTT04ucGFyc2UoZGF0YS5zbGljZSgxKSB8fCAnW10nKTtcbiAgICAgICAgZm9yKHZhciBpPTA7IGkgPCBwYXlsb2FkLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIHRoYXQuX2Rpc3BhdGNoTWVzc2FnZShwYXlsb2FkW2ldKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdtJzpcbiAgICAgICAgdmFyIHBheWxvYWQgPSBKU09OLnBhcnNlKGRhdGEuc2xpY2UoMSkgfHwgJ251bGwnKTtcbiAgICAgICAgdGhhdC5fZGlzcGF0Y2hNZXNzYWdlKHBheWxvYWQpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdjJzpcbiAgICAgICAgdmFyIHBheWxvYWQgPSBKU09OLnBhcnNlKGRhdGEuc2xpY2UoMSkgfHwgJ1tdJyk7XG4gICAgICAgIHRoYXQuX2RpZENsb3NlKHBheWxvYWRbMF0sIHBheWxvYWRbMV0pO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdoJzpcbiAgICAgICAgdGhhdC5fZGlzcGF0Y2hIZWFydGJlYXQoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuU29ja0pTLnByb3RvdHlwZS5fdHJ5X25leHRfcHJvdG9jb2wgPSBmdW5jdGlvbihjbG9zZV9ldmVudCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5wcm90b2NvbCkge1xuICAgICAgICB0aGF0Ll9kZWJ1ZygnQ2xvc2VkIHRyYW5zcG9ydDonLCB0aGF0LnByb3RvY29sLCAnJytjbG9zZV9ldmVudCk7XG4gICAgICAgIHRoYXQucHJvdG9jb2wgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhhdC5fdHJhbnNwb3J0X3RyZWYpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRoYXQuX3RyYW5zcG9ydF90cmVmKTtcbiAgICAgICAgdGhhdC5fdHJhbnNwb3J0X3RyZWYgPSBudWxsO1xuICAgIH1cblxuICAgIHdoaWxlKDEpIHtcbiAgICAgICAgdmFyIHByb3RvY29sID0gdGhhdC5wcm90b2NvbCA9IHRoYXQuX3Byb3RvY29scy5zaGlmdCgpO1xuICAgICAgICBpZiAoIXByb3RvY29sKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29tZSBwcm90b2NvbHMgcmVxdWlyZSBhY2Nlc3MgdG8gYGJvZHlgLCB3aGF0IGlmIHdlcmUgaW5cbiAgICAgICAgLy8gdGhlIGBoZWFkYD9cbiAgICAgICAgaWYgKFNvY2tKU1twcm90b2NvbF0gJiZcbiAgICAgICAgICAgIFNvY2tKU1twcm90b2NvbF0ubmVlZF9ib2R5ID09PSB0cnVlICYmXG4gICAgICAgICAgICAoIV9kb2N1bWVudC5ib2R5IHx8XG4gICAgICAgICAgICAgKHR5cGVvZiBfZG9jdW1lbnQucmVhZHlTdGF0ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgICAgICAgJiYgX2RvY3VtZW50LnJlYWR5U3RhdGUgIT09ICdjb21wbGV0ZScpKSkge1xuICAgICAgICAgICAgdGhhdC5fcHJvdG9jb2xzLnVuc2hpZnQocHJvdG9jb2wpO1xuICAgICAgICAgICAgdGhhdC5wcm90b2NvbCA9ICd3YWl0aW5nLWZvci1sb2FkJztcbiAgICAgICAgICAgIHV0aWxzLmF0dGFjaEV2ZW50KCdsb2FkJywgZnVuY3Rpb24oKXtcbiAgICAgICAgICAgICAgICB0aGF0Ll90cnlfbmV4dF9wcm90b2NvbCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghU29ja0pTW3Byb3RvY29sXSB8fFxuICAgICAgICAgICAgICAhU29ja0pTW3Byb3RvY29sXS5lbmFibGVkKHRoYXQuX29wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aGF0Ll9kZWJ1ZygnU2tpcHBpbmcgdHJhbnNwb3J0OicsIHByb3RvY29sKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHZhciByb3VuZFRyaXBzID0gU29ja0pTW3Byb3RvY29sXS5yb3VuZFRyaXBzIHx8IDE7XG4gICAgICAgICAgICB2YXIgdG8gPSAoKHRoYXQuX29wdGlvbnMucnRvIHx8IDApICogcm91bmRUcmlwcykgfHwgNTAwMDtcbiAgICAgICAgICAgIHRoYXQuX3RyYW5zcG9ydF90cmVmID0gdXRpbHMuZGVsYXkodG8sIGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGF0LnJlYWR5U3RhdGUgPT09IFNvY2tKUy5DT05ORUNUSU5HKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEkgY2FuJ3QgdW5kZXJzdGFuZCBob3cgaXQgaXMgcG9zc2libGUgdG8gcnVuXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgdGltZXIsIHdoZW4gdGhlIHN0YXRlIGlzIENMT1NFRCwgYnV0XG4gICAgICAgICAgICAgICAgICAgIC8vIGFwcGFyZW50bHkgaW4gSUUgZXZlcnl0aGluIGlzIHBvc3NpYmxlLlxuICAgICAgICAgICAgICAgICAgICB0aGF0Ll9kaWRDbG9zZSgyMDA3LCBcIlRyYW5zcG9ydCB0aW1lb3V0ZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIHZhciBjb25uaWQgPSB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgICAgICAgICAgdmFyIHRyYW5zX3VybCA9IHRoYXQuX2Jhc2VfdXJsICsgJy8nICsgdGhhdC5fc2VydmVyICsgJy8nICsgY29ubmlkO1xuICAgICAgICAgICAgdGhhdC5fZGVidWcoJ09wZW5pbmcgdHJhbnNwb3J0OicsIHByb3RvY29sLCAnIHVybDonK3RyYW5zX3VybCxcbiAgICAgICAgICAgICAgICAgICAgICAgICcgUlRPOicrdGhhdC5fb3B0aW9ucy5ydG8pO1xuICAgICAgICAgICAgdGhhdC5fdHJhbnNwb3J0ID0gbmV3IFNvY2tKU1twcm90b2NvbF0odGhhdCwgdHJhbnNfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5fYmFzZV91cmwpO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG59O1xuXG5Tb2NrSlMucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oY29kZSwgcmVhc29uKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmIChjb2RlICYmICF1dGlscy51c2VyU2V0Q29kZShjb2RlKSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSU5WQUxJRF9BQ0NFU1NfRVJSXCIpO1xuICAgIGlmKHRoYXQucmVhZHlTdGF0ZSAhPT0gU29ja0pTLkNPTk5FQ1RJTkcgJiZcbiAgICAgICB0aGF0LnJlYWR5U3RhdGUgIT09IFNvY2tKUy5PUEVOKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdGhhdC5yZWFkeVN0YXRlID0gU29ja0pTLkNMT1NJTkc7XG4gICAgdGhhdC5fZGlkQ2xvc2UoY29kZSB8fCAxMDAwLCByZWFzb24gfHwgXCJOb3JtYWwgY2xvc3VyZVwiKTtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQucmVhZHlTdGF0ZSA9PT0gU29ja0pTLkNPTk5FQ1RJTkcpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSU5WQUxJRF9TVEFURV9FUlInKTtcbiAgICBpZiAodGhhdC5yZWFkeVN0YXRlID09PSBTb2NrSlMuT1BFTikge1xuICAgICAgICB0aGF0Ll90cmFuc3BvcnQuZG9TZW5kKHV0aWxzLnF1b3RlKCcnICsgZGF0YSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cblNvY2tKUy5wcm90b3R5cGUuX2FwcGx5SW5mbyA9IGZ1bmN0aW9uKGluZm8sIHJ0dCwgcHJvdG9jb2xzX3doaXRlbGlzdCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Ll9vcHRpb25zLmluZm8gPSBpbmZvO1xuICAgIHRoYXQuX29wdGlvbnMucnR0ID0gcnR0O1xuICAgIHRoYXQuX29wdGlvbnMucnRvID0gdXRpbHMuY291bnRSVE8ocnR0KTtcbiAgICB0aGF0Ll9vcHRpb25zLmluZm8ubnVsbF9vcmlnaW4gPSAhX2RvY3VtZW50LmRvbWFpbjtcbiAgICB2YXIgcHJvYmVkID0gdXRpbHMucHJvYmVQcm90b2NvbHMoKTtcbiAgICB0aGF0Ll9wcm90b2NvbHMgPSB1dGlscy5kZXRlY3RQcm90b2NvbHMocHJvYmVkLCBwcm90b2NvbHNfd2hpdGVsaXN0LCBpbmZvKTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3NvY2tqcy5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtd2Vic29ja2V0LmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgV2ViU29ja2V0VHJhbnNwb3J0ID0gU29ja0pTLndlYnNvY2tldCA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHVybCA9IHRyYW5zX3VybCArICcvd2Vic29ja2V0JztcbiAgICBpZiAodXJsLnNsaWNlKDAsIDUpID09PSAnaHR0cHMnKSB7XG4gICAgICAgIHVybCA9ICd3c3MnICsgdXJsLnNsaWNlKDUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHVybCA9ICd3cycgKyB1cmwuc2xpY2UoNCk7XG4gICAgfVxuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0LnVybCA9IHVybDtcbiAgICB2YXIgQ29uc3RydWN0b3IgPSBfd2luZG93LldlYlNvY2tldCB8fCBfd2luZG93Lk1veldlYlNvY2tldDtcblxuICAgIHRoYXQud3MgPSBuZXcgQ29uc3RydWN0b3IodGhhdC51cmwpO1xuICAgIHRoYXQud3Mub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICB0aGF0LnJpLl9kaWRNZXNzYWdlKGUuZGF0YSk7XG4gICAgfTtcbiAgICAvLyBGaXJlZm94IGhhcyBhbiBpbnRlcmVzdGluZyBidWcuIElmIGEgd2Vic29ja2V0IGNvbm5lY3Rpb24gaXNcbiAgICAvLyBjcmVhdGVkIGFmdGVyIG9uYmVmb3JldW5sb2FkLCBpdCBzdGF5cyBhbGl2ZSBldmVuIHdoZW4gdXNlclxuICAgIC8vIG5hdmlnYXRlcyBhd2F5IGZyb20gdGhlIHBhZ2UuIEluIHN1Y2ggc2l0dWF0aW9uIGxldCdzIGxpZSAtXG4gICAgLy8gbGV0J3Mgbm90IG9wZW4gdGhlIHdzIGNvbm5lY3Rpb24gYXQgYWxsLiBTZWU6XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3NvY2tqcy9zb2NranMtY2xpZW50L2lzc3Vlcy8yOFxuICAgIC8vIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY5NjA4NVxuICAgIHRoYXQudW5sb2FkX3JlZiA9IHV0aWxzLnVubG9hZF9hZGQoZnVuY3Rpb24oKXt0aGF0LndzLmNsb3NlKCl9KTtcbiAgICB0aGF0LndzLm9uY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdGhhdC5yaS5fZGlkTWVzc2FnZSh1dGlscy5jbG9zZUZyYW1lKDEwMDYsIFwiV2ViU29ja2V0IGNvbm5lY3Rpb24gYnJva2VuXCIpKTtcbiAgICB9O1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5kb1NlbmQgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgdGhpcy53cy5zZW5kKCdbJyArIGRhdGEgKyAnXScpO1xufTtcblxuV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdmFyIHdzID0gdGhhdC53cztcbiAgICBpZiAod3MpIHtcbiAgICAgICAgd3Mub25tZXNzYWdlID0gd3Mub25jbG9zZSA9IG51bGw7XG4gICAgICAgIHdzLmNsb3NlKCk7XG4gICAgICAgIHV0aWxzLnVubG9hZF9kZWwodGhhdC51bmxvYWRfcmVmKTtcbiAgICAgICAgdGhhdC51bmxvYWRfcmVmID0gdGhhdC5yaSA9IHRoYXQud3MgPSBudWxsO1xuICAgIH1cbn07XG5cbldlYlNvY2tldFRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICEhKF93aW5kb3cuV2ViU29ja2V0IHx8IF93aW5kb3cuTW96V2ViU29ja2V0KTtcbn07XG5cbi8vIEluIHRoZW9yeSwgd3Mgc2hvdWxkIHJlcXVpcmUgMSByb3VuZCB0cmlwLiBCdXQgaW4gY2hyb21lLCB0aGlzIGlzXG4vLyBub3QgdmVyeSBzdGFibGUgb3ZlciBTU0wuIE1vc3QgbGlrZWx5IGEgd3MgY29ubmVjdGlvbiByZXF1aXJlcyBhXG4vLyBzZXBhcmF0ZSBTU0wgY29ubmVjdGlvbiwgaW4gd2hpY2ggY2FzZSAyIHJvdW5kIHRyaXBzIGFyZSBhblxuLy8gYWJzb2x1dGUgbWludW11bS5cbldlYlNvY2tldFRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtd2Vic29ja2V0LmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1zZW5kZXIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBCdWZmZXJlZFNlbmRlciA9IGZ1bmN0aW9uKCkge307XG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZF9jb25zdHJ1Y3RvciA9IGZ1bmN0aW9uKHNlbmRlcikge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnNlbmRfYnVmZmVyID0gW107XG4gICAgdGhhdC5zZW5kZXIgPSBzZW5kZXI7XG59O1xuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLmRvU2VuZCA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5zZW5kX2J1ZmZlci5wdXNoKG1lc3NhZ2UpO1xuICAgIGlmICghdGhhdC5zZW5kX3N0b3ApIHtcbiAgICAgICAgdGhhdC5zZW5kX3NjaGVkdWxlKCk7XG4gICAgfVxufTtcblxuLy8gRm9yIHBvbGxpbmcgdHJhbnNwb3J0cyBpbiBhIHNpdHVhdGlvbiB3aGVuIGluIHRoZSBtZXNzYWdlIGNhbGxiYWNrLFxuLy8gbmV3IG1lc3NhZ2UgaXMgYmVpbmcgc2VuZC4gSWYgdGhlIHNlbmRpbmcgY29ubmVjdGlvbiB3YXMgc3RhcnRlZFxuLy8gYmVmb3JlIHJlY2VpdmluZyBvbmUsIGl0IGlzIHBvc3NpYmxlIHRvIHNhdHVyYXRlIHRoZSBuZXR3b3JrIGFuZFxuLy8gdGltZW91dCBkdWUgdG8gdGhlIGxhY2sgb2YgcmVjZWl2aW5nIHNvY2tldC4gVG8gYXZvaWQgdGhhdCB3ZSBkZWxheVxuLy8gc2VuZGluZyBtZXNzYWdlcyBieSBzb21lIHNtYWxsIHRpbWUsIGluIG9yZGVyIHRvIGxldCByZWNlaXZpbmdcbi8vIGNvbm5lY3Rpb24gYmUgc3RhcnRlZCBiZWZvcmVoYW5kLiBUaGlzIGlzIG9ubHkgYSBoYWxmbWVhc3VyZSBhbmRcbi8vIGRvZXMgbm90IGZpeCB0aGUgYmlnIHByb2JsZW0sIGJ1dCBpdCBkb2VzIG1ha2UgdGhlIHRlc3RzIGdvIG1vcmVcbi8vIHN0YWJsZSBvbiBzbG93IG5ldHdvcmtzLlxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRfc2NoZWR1bGVfd2FpdCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgdHJlZjtcbiAgICB0aGF0LnNlbmRfc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LnNlbmRfc3RvcCA9IG51bGw7XG4gICAgICAgIGNsZWFyVGltZW91dCh0cmVmKTtcbiAgICB9O1xuICAgIHRyZWYgPSB1dGlscy5kZWxheSgyNSwgZnVuY3Rpb24oKSB7XG4gICAgICAgIHRoYXQuc2VuZF9zdG9wID0gbnVsbDtcbiAgICAgICAgdGhhdC5zZW5kX3NjaGVkdWxlKCk7XG4gICAgfSk7XG59O1xuXG5CdWZmZXJlZFNlbmRlci5wcm90b3R5cGUuc2VuZF9zY2hlZHVsZSA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5zZW5kX2J1ZmZlci5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBwYXlsb2FkID0gJ1snICsgdGhhdC5zZW5kX2J1ZmZlci5qb2luKCcsJykgKyAnXSc7XG4gICAgICAgIHRoYXQuc2VuZF9zdG9wID0gdGhhdC5zZW5kZXIodGhhdC50cmFuc191cmwsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhhdC5zZW5kX3N0b3AgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnNlbmRfc2NoZWR1bGVfd2FpdCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB0aGF0LnNlbmRfYnVmZmVyID0gW107XG4gICAgfVxufTtcblxuQnVmZmVyZWRTZW5kZXIucHJvdG90eXBlLnNlbmRfZGVzdHJ1Y3RvciA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICBpZiAodGhhdC5fc2VuZF9zdG9wKSB7XG4gICAgICAgIHRoYXQuX3NlbmRfc3RvcCgpO1xuICAgIH1cbiAgICB0aGF0Ll9zZW5kX3N0b3AgPSBudWxsO1xufTtcblxudmFyIGpzb25QR2VuZXJpY1NlbmRlciA9IGZ1bmN0aW9uKHVybCwgcGF5bG9hZCwgY2FsbGJhY2spIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICBpZiAoISgnX3NlbmRfZm9ybScgaW4gdGhhdCkpIHtcbiAgICAgICAgdmFyIGZvcm0gPSB0aGF0Ll9zZW5kX2Zvcm0gPSBfZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZm9ybScpO1xuICAgICAgICB2YXIgYXJlYSA9IHRoYXQuX3NlbmRfYXJlYSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCd0ZXh0YXJlYScpO1xuICAgICAgICBhcmVhLm5hbWUgPSAnZCc7XG4gICAgICAgIGZvcm0uc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgICAgZm9ybS5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG4gICAgICAgIGZvcm0ubWV0aG9kID0gJ1BPU1QnO1xuICAgICAgICBmb3JtLmVuY3R5cGUgPSAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJztcbiAgICAgICAgZm9ybS5hY2NlcHRDaGFyc2V0ID0gXCJVVEYtOFwiO1xuICAgICAgICBmb3JtLmFwcGVuZENoaWxkKGFyZWEpO1xuICAgICAgICBfZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChmb3JtKTtcbiAgICB9XG4gICAgdmFyIGZvcm0gPSB0aGF0Ll9zZW5kX2Zvcm07XG4gICAgdmFyIGFyZWEgPSB0aGF0Ll9zZW5kX2FyZWE7XG4gICAgdmFyIGlkID0gJ2EnICsgdXRpbHMucmFuZG9tX3N0cmluZyg4KTtcbiAgICBmb3JtLnRhcmdldCA9IGlkO1xuICAgIGZvcm0uYWN0aW9uID0gdXJsICsgJy9qc29ucF9zZW5kP2k9JyArIGlkO1xuXG4gICAgdmFyIGlmcmFtZTtcbiAgICB0cnkge1xuICAgICAgICAvLyBpZTYgZHluYW1pYyBpZnJhbWVzIHdpdGggdGFyZ2V0PVwiXCIgc3VwcG9ydCAodGhhbmtzIENocmlzIExhbWJhY2hlcilcbiAgICAgICAgaWZyYW1lID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJzxpZnJhbWUgbmFtZT1cIicrIGlkICsnXCI+Jyk7XG4gICAgfSBjYXRjaCh4KSB7XG4gICAgICAgIGlmcmFtZSA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdpZnJhbWUnKTtcbiAgICAgICAgaWZyYW1lLm5hbWUgPSBpZDtcbiAgICB9XG4gICAgaWZyYW1lLmlkID0gaWQ7XG4gICAgZm9ybS5hcHBlbmRDaGlsZChpZnJhbWUpO1xuICAgIGlmcmFtZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuXG4gICAgdHJ5IHtcbiAgICAgICAgYXJlYS52YWx1ZSA9IHBheWxvYWQ7XG4gICAgfSBjYXRjaChlKSB7XG4gICAgICAgIHV0aWxzLmxvZygnWW91ciBicm93c2VyIGlzIHNlcmlvdXNseSBicm9rZW4uIEdvIGhvbWUhICcgKyBlLm1lc3NhZ2UpO1xuICAgIH1cbiAgICBmb3JtLnN1Ym1pdCgpO1xuXG4gICAgdmFyIGNvbXBsZXRlZCA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgaWYgKCFpZnJhbWUub25lcnJvcikgcmV0dXJuO1xuICAgICAgICBpZnJhbWUub25yZWFkeXN0YXRlY2hhbmdlID0gaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gbnVsbDtcbiAgICAgICAgLy8gT3BlcmEgbWluaSBkb2Vzbid0IGxpa2UgaWYgd2UgR0MgaWZyYW1lXG4gICAgICAgIC8vIGltbWVkaWF0ZWx5LCB0aHVzIHRoaXMgdGltZW91dC5cbiAgICAgICAgdXRpbHMuZGVsYXkoNTAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoaWZyYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgICAgaWZyYW1lID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgYXJlYS52YWx1ZSA9ICcnO1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgIH07XG4gICAgaWZyYW1lLm9uZXJyb3IgPSBpZnJhbWUub25sb2FkID0gY29tcGxldGVkO1xuICAgIGlmcmFtZS5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmIChpZnJhbWUucmVhZHlTdGF0ZSA9PSAnY29tcGxldGUnKSBjb21wbGV0ZWQoKTtcbiAgICB9O1xuICAgIHJldHVybiBjb21wbGV0ZWQ7XG59O1xuXG52YXIgY3JlYXRlQWpheFNlbmRlciA9IGZ1bmN0aW9uKEFqYXhPYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24odXJsLCBwYXlsb2FkLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgeG8gPSBuZXcgQWpheE9iamVjdCgnUE9TVCcsIHVybCArICcveGhyX3NlbmQnLCBwYXlsb2FkKTtcbiAgICAgICAgeG8ub25maW5pc2ggPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKHN0YXR1cyk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmdW5jdGlvbihhYm9ydF9yZWFzb24pIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKDAsIGFib3J0X3JlYXNvbik7XG4gICAgICAgIH07XG4gICAgfTtcbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLXNlbmRlci5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtanNvbnAtcmVjZWl2ZXIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbi8vIFBhcnRzIGRlcml2ZWQgZnJvbSBTb2NrZXQuaW86XG4vLyAgICBodHRwczovL2dpdGh1Yi5jb20vTGVhcm5Cb29zdC9zb2NrZXQuaW8vYmxvYi8wLjYuMTcvbGliL3NvY2tldC5pby90cmFuc3BvcnRzL2pzb25wLXBvbGxpbmcuanNcbi8vIGFuZCBqUXVlcnktSlNPTlA6XG4vLyAgICBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2pxdWVyeS1qc29ucC9zb3VyY2UvYnJvd3NlL3RydW5rL2NvcmUvanF1ZXJ5Lmpzb25wLmpzXG52YXIganNvblBHZW5lcmljUmVjZWl2ZXIgPSBmdW5jdGlvbih1cmwsIGNhbGxiYWNrKSB7XG4gICAgdmFyIHRyZWY7XG4gICAgdmFyIHNjcmlwdCA9IF9kb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTtcbiAgICB2YXIgc2NyaXB0MjsgIC8vIE9wZXJhIHN5bmNocm9ub3VzIGxvYWQgdHJpY2suXG4gICAgdmFyIGNsb3NlX3NjcmlwdCA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICAgIGlmIChzY3JpcHQyKSB7XG4gICAgICAgICAgICBzY3JpcHQyLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0Mik7XG4gICAgICAgICAgICBzY3JpcHQyID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2NyaXB0KSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodHJlZik7XG4gICAgICAgICAgICBzY3JpcHQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzY3JpcHQpO1xuICAgICAgICAgICAgc2NyaXB0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IHNjcmlwdC5vbmVycm9yID1cbiAgICAgICAgICAgICAgICBzY3JpcHQub25sb2FkID0gc2NyaXB0Lm9uY2xpY2sgPSBudWxsO1xuICAgICAgICAgICAgc2NyaXB0ID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrKGZyYW1lKTtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBJRTkgZmlyZXMgJ2Vycm9yJyBldmVudCBhZnRlciBvcnNjIG9yIGJlZm9yZSwgaW4gcmFuZG9tIG9yZGVyLlxuICAgIHZhciBsb2FkZWRfb2theSA9IGZhbHNlO1xuICAgIHZhciBlcnJvcl90aW1lciA9IG51bGw7XG5cbiAgICBzY3JpcHQuaWQgPSAnYScgKyB1dGlscy5yYW5kb21fc3RyaW5nKDgpO1xuICAgIHNjcmlwdC5zcmMgPSB1cmw7XG4gICAgc2NyaXB0LnR5cGUgPSAndGV4dC9qYXZhc2NyaXB0JztcbiAgICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gICAgc2NyaXB0Lm9uZXJyb3IgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICghZXJyb3JfdGltZXIpIHtcbiAgICAgICAgICAgIC8vIERlbGF5IGZpcmluZyBjbG9zZV9zY3JpcHQuXG4gICAgICAgICAgICBlcnJvcl90aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFsb2FkZWRfb2theSkge1xuICAgICAgICAgICAgICAgICAgICBjbG9zZV9zY3JpcHQodXRpbHMuY2xvc2VGcmFtZShcbiAgICAgICAgICAgICAgICAgICAgICAgIDEwMDYsXG4gICAgICAgICAgICAgICAgICAgICAgICBcIkpTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25lcnJvcilcIikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBzY3JpcHQub25sb2FkID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBjbG9zZV9zY3JpcHQodXRpbHMuY2xvc2VGcmFtZSgxMDA2LCBcIkpTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAob25sb2FkKVwiKSk7XG4gICAgfTtcblxuICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmICgvbG9hZGVkfGNsb3NlZC8udGVzdChzY3JpcHQucmVhZHlTdGF0ZSkpIHtcbiAgICAgICAgICAgIGlmIChzY3JpcHQgJiYgc2NyaXB0Lmh0bWxGb3IgJiYgc2NyaXB0Lm9uY2xpY2spIHtcbiAgICAgICAgICAgICAgICBsb2FkZWRfb2theSA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gSUUsIGFjdHVhbGx5IGV4ZWN1dGUgdGhlIHNjcmlwdC5cbiAgICAgICAgICAgICAgICAgICAgc2NyaXB0Lm9uY2xpY2soKTtcbiAgICAgICAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNjcmlwdCkge1xuICAgICAgICAgICAgICAgIGNsb3NlX3NjcmlwdCh1dGlscy5jbG9zZUZyYW1lKDEwMDYsIFwiSlNPTlAgc2NyaXB0IGxvYWRlZCBhYm5vcm1hbGx5IChvbnJlYWR5c3RhdGVjaGFuZ2UpXCIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLy8gSUU6IGV2ZW50L2h0bWxGb3Ivb25jbGljayB0cmljay5cbiAgICAvLyBPbmUgY2FuJ3QgcmVseSBvbiBwcm9wZXIgb3JkZXIgZm9yIG9ucmVhZHlzdGF0ZWNoYW5nZS4gSW4gb3JkZXIgdG9cbiAgICAvLyBtYWtlIHN1cmUsIHNldCBhICdodG1sRm9yJyBhbmQgJ2V2ZW50JyBwcm9wZXJ0aWVzLCBzbyB0aGF0XG4gICAgLy8gc2NyaXB0IGNvZGUgd2lsbCBiZSBpbnN0YWxsZWQgYXMgJ29uY2xpY2snIGhhbmRsZXIgZm9yIHRoZVxuICAgIC8vIHNjcmlwdCBvYmplY3QuIExhdGVyLCBvbnJlYWR5c3RhdGVjaGFuZ2UsIG1hbnVhbGx5IGV4ZWN1dGUgdGhpc1xuICAgIC8vIGNvZGUuIEZGIGFuZCBDaHJvbWUgZG9lc24ndCB3b3JrIHdpdGggJ2V2ZW50JyBhbmQgJ2h0bWxGb3InXG4gICAgLy8gc2V0LiBGb3IgcmVmZXJlbmNlIHNlZTpcbiAgICAvLyAgIGh0dHA6Ly9qYXVib3VyZy5uZXQvMjAxMC8wNy9sb2FkaW5nLXNjcmlwdC1hcy1vbmNsaWNrLWhhbmRsZXItb2YuaHRtbFxuICAgIC8vIEFsc28sIHJlYWQgb24gdGhhdCBhYm91dCBzY3JpcHQgb3JkZXJpbmc6XG4gICAgLy8gICBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvRHluYW1pY19TY3JpcHRfRXhlY3V0aW9uX09yZGVyXG4gICAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgPT09ICd1bmRlZmluZWQnICYmIF9kb2N1bWVudC5hdHRhY2hFdmVudCkge1xuICAgICAgICAvLyBBY2NvcmRpbmcgdG8gbW96aWxsYSBkb2NzLCBpbiByZWNlbnQgYnJvd3NlcnMgc2NyaXB0LmFzeW5jIGRlZmF1bHRzXG4gICAgICAgIC8vIHRvICd0cnVlJywgc28gd2UgbWF5IHVzZSBpdCB0byBkZXRlY3QgYSBnb29kIGJyb3dzZXI6XG4gICAgICAgIC8vIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0hUTUwvRWxlbWVudC9zY3JpcHRcbiAgICAgICAgaWYgKCEvb3BlcmEvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSB7XG4gICAgICAgICAgICAvLyBOYWl2ZWx5IGFzc3VtZSB3ZSdyZSBpbiBJRVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBzY3JpcHQuaHRtbEZvciA9IHNjcmlwdC5pZDtcbiAgICAgICAgICAgICAgICBzY3JpcHQuZXZlbnQgPSBcIm9uY2xpY2tcIjtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gT3BlcmEsIHNlY29uZCBzeW5jIHNjcmlwdCBoYWNrXG4gICAgICAgICAgICBzY3JpcHQyID0gX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpO1xuICAgICAgICAgICAgc2NyaXB0Mi50ZXh0ID0gXCJ0cnl7dmFyIGEgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnXCIrc2NyaXB0LmlkK1wiJyk7IGlmKGEpYS5vbmVycm9yKCk7fWNhdGNoKHgpe307XCI7XG4gICAgICAgICAgICBzY3JpcHQuYXN5bmMgPSBzY3JpcHQyLmFzeW5jID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzY3JpcHQuYXN5bmMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHNjcmlwdC5hc3luYyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgbW9zdGx5IGZvciBLb25xdWVyb3IgLSBzdHVwaWQgdGltZXIsIDM1IHNlY29uZHMgc2hhbGwgYmUgcGxlbnR5LlxuICAgIHRyZWYgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjbG9zZV9zY3JpcHQodXRpbHMuY2xvc2VGcmFtZSgxMDA2LCBcIkpTT05QIHNjcmlwdCBsb2FkZWQgYWJub3JtYWxseSAodGltZW91dClcIikpO1xuICAgICAgICAgICAgICAgICAgICAgIH0sIDM1MDAwKTtcblxuICAgIHZhciBoZWFkID0gX2RvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgaGVhZC5pbnNlcnRCZWZvcmUoc2NyaXB0LCBoZWFkLmZpcnN0Q2hpbGQpO1xuICAgIGlmIChzY3JpcHQyKSB7XG4gICAgICAgIGhlYWQuaW5zZXJ0QmVmb3JlKHNjcmlwdDIsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfVxuICAgIHJldHVybiBjbG9zZV9zY3JpcHQ7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1qc29ucC1yZWNlaXZlci5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtanNvbnAtcG9sbGluZy5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxuLy8gVGhlIHNpbXBsZXN0IGFuZCBtb3N0IHJvYnVzdCB0cmFuc3BvcnQsIHVzaW5nIHRoZSB3ZWxsLWtub3cgY3Jvc3Ncbi8vIGRvbWFpbiBoYWNrIC0gSlNPTlAuIFRoaXMgdHJhbnNwb3J0IGlzIHF1aXRlIGluZWZmaWNpZW50IC0gb25lXG4vLyBtc3NhZ2UgY291bGQgdXNlIHVwIHRvIG9uZSBodHRwIHJlcXVlc3QuIEJ1dCBhdCBsZWFzdCBpdCB3b3JrcyBhbG1vc3Rcbi8vIGV2ZXJ5d2hlcmUuXG4vLyBLbm93biBsaW1pdGF0aW9uczpcbi8vICAgbyB5b3Ugd2lsbCBnZXQgYSBzcGlubmluZyBjdXJzb3Jcbi8vICAgbyBmb3IgS29ucXVlcm9yIGEgZHVtYiB0aW1lciBpcyBuZWVkZWQgdG8gZGV0ZWN0IGVycm9yc1xuXG5cbnZhciBKc29uUFRyYW5zcG9ydCA9IFNvY2tKU1snanNvbnAtcG9sbGluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHV0aWxzLnBvbGx1dGVHbG9iYWxOYW1lc3BhY2UoKTtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5yaSA9IHJpO1xuICAgIHRoYXQudHJhbnNfdXJsID0gdHJhbnNfdXJsO1xuICAgIHRoYXQuc2VuZF9jb25zdHJ1Y3Rvcihqc29uUEdlbmVyaWNTZW5kZXIpO1xuICAgIHRoYXQuX3NjaGVkdWxlX3JlY3YoKTtcbn07XG5cbi8vIEluaGVyaXRuYWNlXG5Kc29uUFRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQnVmZmVyZWRTZW5kZXIoKTtcblxuSnNvblBUcmFuc3BvcnQucHJvdG90eXBlLl9zY2hlZHVsZV9yZWN2ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgICAgdGhhdC5fcmVjdl9zdG9wID0gbnVsbDtcbiAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIC8vIG5vIGRhdGEgLSBoZWFydGJlYXQ7XG4gICAgICAgICAgICBpZiAoIXRoYXQuX2lzX2Nsb3NpbmcpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnJpLl9kaWRNZXNzYWdlKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFRoZSBtZXNzYWdlIGNhbiBiZSBhIGNsb3NlIG1lc3NhZ2UsIGFuZCBjaGFuZ2UgaXNfY2xvc2luZyBzdGF0ZS5cbiAgICAgICAgaWYgKCF0aGF0Ll9pc19jbG9zaW5nKSB7XG4gICAgICAgICAgICB0aGF0Ll9zY2hlZHVsZV9yZWN2KCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoYXQuX3JlY3Zfc3RvcCA9IGpzb25QUmVjZWl2ZXJXcmFwcGVyKHRoYXQudHJhbnNfdXJsICsgJy9qc29ucCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAganNvblBHZW5lcmljUmVjZWl2ZXIsIGNhbGxiYWNrKTtcbn07XG5cbkpzb25QVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbn07XG5cbkpzb25QVHJhbnNwb3J0Lm5lZWRfYm9keSA9IHRydWU7XG5cblxuSnNvblBUcmFuc3BvcnQucHJvdG90eXBlLmRvQ2xlYW51cCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0Ll9pc19jbG9zaW5nID0gdHJ1ZTtcbiAgICBpZiAodGhhdC5fcmVjdl9zdG9wKSB7XG4gICAgICAgIHRoYXQuX3JlY3Zfc3RvcCgpO1xuICAgIH1cbiAgICB0aGF0LnJpID0gdGhhdC5fcmVjdl9zdG9wID0gbnVsbDtcbiAgICB0aGF0LnNlbmRfZGVzdHJ1Y3RvcigpO1xufTtcblxuXG4vLyBBYnN0cmFjdCBhd2F5IGNvZGUgdGhhdCBoYW5kbGVzIGdsb2JhbCBuYW1lc3BhY2UgcG9sbHV0aW9uLlxudmFyIGpzb25QUmVjZWl2ZXJXcmFwcGVyID0gZnVuY3Rpb24odXJsLCBjb25zdHJ1Y3RSZWNlaXZlciwgdXNlcl9jYWxsYmFjaykge1xuICAgIHZhciBpZCA9ICdhJyArIHV0aWxzLnJhbmRvbV9zdHJpbmcoNik7XG4gICAgdmFyIHVybF9pZCA9IHVybCArICc/Yz0nICsgZXNjYXBlKFdQcmVmaXggKyAnLicgKyBpZCk7XG4gICAgLy8gQ2FsbGJhY2sgd2lsbCBiZSBjYWxsZWQgZXhhY3RseSBvbmNlLlxuICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uKGZyYW1lKSB7XG4gICAgICAgIGRlbGV0ZSBfd2luZG93W1dQcmVmaXhdW2lkXTtcbiAgICAgICAgdXNlcl9jYWxsYmFjayhmcmFtZSk7XG4gICAgfTtcblxuICAgIHZhciBjbG9zZV9zY3JpcHQgPSBjb25zdHJ1Y3RSZWNlaXZlcih1cmxfaWQsIGNhbGxiYWNrKTtcbiAgICBfd2luZG93W1dQcmVmaXhdW2lkXSA9IGNsb3NlX3NjcmlwdDtcbiAgICB2YXIgc3RvcCA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoX3dpbmRvd1tXUHJlZml4XVtpZF0pIHtcbiAgICAgICAgICAgIF93aW5kb3dbV1ByZWZpeF1baWRdKHV0aWxzLmNsb3NlRnJhbWUoMTAwMCwgXCJKU09OUCB1c2VyIGFib3J0ZWQgcmVhZFwiKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBzdG9wO1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtanNvbnAtcG9sbGluZy5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMteGhyLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG52YXIgQWpheEJhc2VkVHJhbnNwb3J0ID0gZnVuY3Rpb24oKSB7fTtcbkFqYXhCYXNlZFRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQnVmZmVyZWRTZW5kZXIoKTtcblxuQWpheEJhc2VkVHJhbnNwb3J0LnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmxfc3VmZml4LCBSZWNlaXZlciwgQWpheE9iamVjdCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnJpID0gcmk7XG4gICAgdGhhdC50cmFuc191cmwgPSB0cmFuc191cmw7XG4gICAgdGhhdC5zZW5kX2NvbnN0cnVjdG9yKGNyZWF0ZUFqYXhTZW5kZXIoQWpheE9iamVjdCkpO1xuICAgIHRoYXQucG9sbCA9IG5ldyBQb2xsaW5nKHJpLCBSZWNlaXZlcixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmFuc191cmwgKyB1cmxfc3VmZml4LCBBamF4T2JqZWN0KTtcbn07XG5cbkFqYXhCYXNlZFRyYW5zcG9ydC5wcm90b3R5cGUuZG9DbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LnBvbGwpIHtcbiAgICAgICAgdGhhdC5wb2xsLmFib3J0KCk7XG4gICAgICAgIHRoYXQucG9sbCA9IG51bGw7XG4gICAgfVxufTtcblxuLy8geGhyLXN0cmVhbWluZ1xudmFyIFhoclN0cmVhbWluZ1RyYW5zcG9ydCA9IFNvY2tKU1sneGhyLXN0cmVhbWluZyddID0gZnVuY3Rpb24ocmksIHRyYW5zX3VybCkge1xuICAgIHRoaXMucnVuKHJpLCB0cmFuc191cmwsICcveGhyX3N0cmVhbWluZycsIFhoclJlY2VpdmVyLCB1dGlscy5YSFJDb3JzT2JqZWN0KTtcbn07XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG5cblhoclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gU3VwcG9ydCBmb3IgQ09SUyBBamF4IGFrYSBBamF4Mj8gT3BlcmEgMTIgY2xhaW1zIENPUlMgYnV0XG4gICAgLy8gZG9lc24ndCBkbyBzdHJlYW1pbmcuXG4gICAgcmV0dXJuIChfd2luZG93LlhNTEh0dHBSZXF1ZXN0ICYmXG4gICAgICAgICAgICAnd2l0aENyZWRlbnRpYWxzJyBpbiBuZXcgWE1MSHR0cFJlcXVlc3QoKSAmJlxuICAgICAgICAgICAgKCEvb3BlcmEvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSk7XG59O1xuWGhyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuLy8gU2FmYXJpIGdldHMgY29uZnVzZWQgd2hlbiBhIHN0cmVhbWluZyBhamF4IHJlcXVlc3QgaXMgc3RhcnRlZFxuLy8gYmVmb3JlIG9ubG9hZC4gVGhpcyBjYXVzZXMgdGhlIGxvYWQgaW5kaWNhdG9yIHRvIHNwaW4gaW5kZWZpbmV0ZWx5LlxuWGhyU3RyZWFtaW5nVHJhbnNwb3J0Lm5lZWRfYm9keSA9IHRydWU7XG5cblxuLy8gQWNjb3JkaW5nIHRvOlxuLy8gICBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzE2NDE1MDcvZGV0ZWN0LWJyb3dzZXItc3VwcG9ydC1mb3ItY3Jvc3MtZG9tYWluLXhtbGh0dHByZXF1ZXN0c1xuLy8gICBodHRwOi8vaGFja3MubW96aWxsYS5vcmcvMjAwOS8wNy9jcm9zcy1zaXRlLXhtbGh0dHByZXF1ZXN0LXdpdGgtY29ycy9cblxuXG4vLyB4ZHItc3RyZWFtaW5nXG52YXIgWGRyU3RyZWFtaW5nVHJhbnNwb3J0ID0gU29ja0pTWyd4ZHItc3RyZWFtaW5nJ10gPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsKSB7XG4gICAgdGhpcy5ydW4ocmksIHRyYW5zX3VybCwgJy94aHJfc3RyZWFtaW5nJywgWGhyUmVjZWl2ZXIsIHV0aWxzLlhEUk9iamVjdCk7XG59O1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQucHJvdG90eXBlID0gbmV3IEFqYXhCYXNlZFRyYW5zcG9ydCgpO1xuXG5YZHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhIV93aW5kb3cuWERvbWFpblJlcXVlc3Q7XG59O1xuWGRyU3RyZWFtaW5nVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAyOyAvLyBwcmVmbGlnaHQsIGFqYXhcblxuXG5cbi8vIHhoci1wb2xsaW5nXG52YXIgWGhyUG9sbGluZ1RyYW5zcG9ydCA9IFNvY2tKU1sneGhyLXBvbGxpbmcnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCB1dGlscy5YSFJDb3JzT2JqZWN0KTtcbn07XG5cblhoclBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlID0gbmV3IEFqYXhCYXNlZFRyYW5zcG9ydCgpO1xuXG5YaHJQb2xsaW5nVHJhbnNwb3J0LmVuYWJsZWQgPSBYaHJTdHJlYW1pbmdUcmFuc3BvcnQuZW5hYmxlZDtcblhoclBvbGxpbmdUcmFuc3BvcnQucm91bmRUcmlwcyA9IDI7IC8vIHByZWZsaWdodCwgYWpheFxuXG5cbi8vIHhkci1wb2xsaW5nXG52YXIgWGRyUG9sbGluZ1RyYW5zcG9ydCA9IFNvY2tKU1sneGRyLXBvbGxpbmcnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCB1dGlscy5YRFJPYmplY3QpO1xufTtcblxuWGRyUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG5cblhkclBvbGxpbmdUcmFuc3BvcnQuZW5hYmxlZCA9IFhkclN0cmVhbWluZ1RyYW5zcG9ydC5lbmFibGVkO1xuWGRyUG9sbGluZ1RyYW5zcG9ydC5yb3VuZFRyaXBzID0gMjsgLy8gcHJlZmxpZ2h0LCBhamF4XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLXhoci5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtaWZyYW1lLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG4vLyBGZXcgY29vbCB0cmFuc3BvcnRzIGRvIHdvcmsgb25seSBmb3Igc2FtZS1vcmlnaW4uIEluIG9yZGVyIHRvIG1ha2Vcbi8vIHRoZW0gd29ya2luZyBjcm9zcy1kb21haW4gd2Ugc2hhbGwgdXNlIGlmcmFtZSwgc2VydmVkIGZvcm0gdGhlXG4vLyByZW1vdGUgZG9tYWluLiBOZXcgYnJvd3NlcnMsIGhhdmUgY2FwYWJpbGl0aWVzIHRvIGNvbW11bmljYXRlIHdpdGhcbi8vIGNyb3NzIGRvbWFpbiBpZnJhbWUsIHVzaW5nIHBvc3RNZXNzYWdlKCkuIEluIElFIGl0IHdhcyBpbXBsZW1lbnRlZFxuLy8gZnJvbSBJRSA4KywgYnV0IG9mIGNvdXJzZSwgSUUgZ290IHNvbWUgZGV0YWlscyB3cm9uZzpcbi8vICAgIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9jYzE5NzAxNSh2PVZTLjg1KS5hc3B4XG4vLyAgICBodHRwOi8vc3RldmVzb3VkZXJzLmNvbS9taXNjL3Rlc3QtcG9zdG1lc3NhZ2UucGhwXG5cbnZhciBJZnJhbWVUcmFuc3BvcnQgPSBmdW5jdGlvbigpIHt9O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLmlfY29uc3RydWN0b3IgPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsLCBiYXNlX3VybCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnJpID0gcmk7XG4gICAgdGhhdC5vcmlnaW4gPSB1dGlscy5nZXRPcmlnaW4oYmFzZV91cmwpO1xuICAgIHRoYXQuYmFzZV91cmwgPSBiYXNlX3VybDtcbiAgICB0aGF0LnRyYW5zX3VybCA9IHRyYW5zX3VybDtcblxuICAgIHZhciBpZnJhbWVfdXJsID0gYmFzZV91cmwgKyAnL2lmcmFtZS5odG1sJztcbiAgICBpZiAodGhhdC5yaS5fb3B0aW9ucy5kZXZlbCkge1xuICAgICAgICBpZnJhbWVfdXJsICs9ICc/dD0nICsgKCtuZXcgRGF0ZSk7XG4gICAgfVxuICAgIHRoYXQud2luZG93X2lkID0gdXRpbHMucmFuZG9tX3N0cmluZyg4KTtcbiAgICBpZnJhbWVfdXJsICs9ICcjJyArIHRoYXQud2luZG93X2lkO1xuXG4gICAgdGhhdC5pZnJhbWVPYmogPSB1dGlscy5jcmVhdGVJZnJhbWUoaWZyYW1lX3VybCwgZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGF0LnJpLl9kaWRDbG9zZSgxMDA2LCBcIlVuYWJsZSB0byBsb2FkIGFuIGlmcmFtZSAoXCIgKyByICsgXCIpXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuXG4gICAgdGhhdC5vbm1lc3NhZ2VfY2IgPSB1dGlscy5iaW5kKHRoYXQub25tZXNzYWdlLCB0aGF0KTtcbiAgICB1dGlscy5hdHRhY2hNZXNzYWdlKHRoYXQub25tZXNzYWdlX2NiKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuZG9DbGVhbnVwID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LmlmcmFtZU9iaikge1xuICAgICAgICB1dGlscy5kZXRhY2hNZXNzYWdlKHRoYXQub25tZXNzYWdlX2NiKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gdGhlIGlmcmFtZSBpcyBub3QgbG9hZGVkLCBJRSByYWlzZXMgYW4gZXhjZXB0aW9uXG4gICAgICAgICAgICAvLyBvbiAnY29udGVudFdpbmRvdycuXG4gICAgICAgICAgICBpZiAodGhhdC5pZnJhbWVPYmouaWZyYW1lLmNvbnRlbnRXaW5kb3cpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnBvc3RNZXNzYWdlKCdjJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKHgpIHt9XG4gICAgICAgIHRoYXQuaWZyYW1lT2JqLmNsZWFudXAoKTtcbiAgICAgICAgdGhhdC5pZnJhbWVPYmogPSBudWxsO1xuICAgICAgICB0aGF0Lm9ubWVzc2FnZV9jYiA9IHRoYXQuaWZyYW1lT2JqID0gbnVsbDtcbiAgICB9XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKGUub3JpZ2luICE9PSB0aGF0Lm9yaWdpbikgcmV0dXJuO1xuICAgIHZhciB3aW5kb3dfaWQgPSBlLmRhdGEuc2xpY2UoMCwgOCk7XG4gICAgdmFyIHR5cGUgPSBlLmRhdGEuc2xpY2UoOCwgOSk7XG4gICAgdmFyIGRhdGEgPSBlLmRhdGEuc2xpY2UoOSk7XG5cbiAgICBpZiAod2luZG93X2lkICE9PSB0aGF0LndpbmRvd19pZCkgcmV0dXJuO1xuXG4gICAgc3dpdGNoKHR5cGUpIHtcbiAgICBjYXNlICdzJzpcbiAgICAgICAgdGhhdC5pZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgICAgIHRoYXQucG9zdE1lc3NhZ2UoJ3MnLCBKU09OLnN0cmluZ2lmeShbU29ja0pTLnZlcnNpb24sIHRoYXQucHJvdG9jb2wsIHRoYXQudHJhbnNfdXJsLCB0aGF0LmJhc2VfdXJsXSkpO1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICd0JzpcbiAgICAgICAgdGhhdC5yaS5fZGlkTWVzc2FnZShkYXRhKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufTtcblxuSWZyYW1lVHJhbnNwb3J0LnByb3RvdHlwZS5wb3N0TWVzc2FnZSA9IGZ1bmN0aW9uKHR5cGUsIGRhdGEpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5pZnJhbWVPYmoucG9zdCh0aGF0LndpbmRvd19pZCArIHR5cGUgKyAoZGF0YSB8fCAnJyksIHRoYXQub3JpZ2luKTtcbn07XG5cbklmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUuZG9TZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICB0aGlzLnBvc3RNZXNzYWdlKCdtJywgbWVzc2FnZSk7XG59O1xuXG5JZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCA9IGZ1bmN0aW9uKCkge1xuICAgIC8vIHBvc3RNZXNzYWdlIG1pc2JlaGF2ZXMgaW4ga29ucXVlcm9yIDQuNi41IC0gdGhlIG1lc3NhZ2VzIGFyZSBkZWxpdmVyZWQgd2l0aFxuICAgIC8vIGh1Z2UgZGVsYXksIG9yIG5vdCBhdCBhbGwuXG4gICAgdmFyIGtvbnF1ZXJvciA9IG5hdmlnYXRvciAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZignS29ucXVlcm9yJykgIT09IC0xO1xuICAgIHJldHVybiAoKHR5cGVvZiBfd2luZG93LnBvc3RNZXNzYWdlID09PSAnZnVuY3Rpb24nIHx8XG4gICAgICAgICAgICB0eXBlb2YgX3dpbmRvdy5wb3N0TWVzc2FnZSA9PT0gJ29iamVjdCcpICYmICgha29ucXVlcm9yKSk7XG59O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1pZnJhbWUuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLWlmcmFtZS13aXRoaW4uanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBjdXJyX3dpbmRvd19pZDtcblxudmFyIHBvc3RNZXNzYWdlID0gZnVuY3Rpb24gKHR5cGUsIGRhdGEpIHtcbiAgICBpZihwYXJlbnQgIT09IF93aW5kb3cpIHtcbiAgICAgICAgcGFyZW50LnBvc3RNZXNzYWdlKGN1cnJfd2luZG93X2lkICsgdHlwZSArIChkYXRhIHx8ICcnKSwgJyonKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB1dGlscy5sb2coXCJDYW4ndCBwb3N0TWVzc2FnZSwgbm8gcGFyZW50IHdpbmRvdy5cIiwgdHlwZSwgZGF0YSk7XG4gICAgfVxufTtcblxudmFyIEZhY2FkZUpTID0gZnVuY3Rpb24oKSB7fTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fZGlkQ2xvc2UgPSBmdW5jdGlvbiAoY29kZSwgcmVhc29uKSB7XG4gICAgcG9zdE1lc3NhZ2UoJ3QnLCB1dGlscy5jbG9zZUZyYW1lKGNvZGUsIHJlYXNvbikpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fZGlkTWVzc2FnZSA9IGZ1bmN0aW9uIChmcmFtZSkge1xuICAgIHBvc3RNZXNzYWdlKCd0JywgZnJhbWUpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fZG9TZW5kID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB0aGlzLl90cmFuc3BvcnQuZG9TZW5kKGRhdGEpO1xufTtcbkZhY2FkZUpTLnByb3RvdHlwZS5fZG9DbGVhbnVwID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuX3RyYW5zcG9ydC5kb0NsZWFudXAoKTtcbn07XG5cbnV0aWxzLnBhcmVudF9vcmlnaW4gPSB1bmRlZmluZWQ7XG5cblNvY2tKUy5ib290c3RyYXBfaWZyYW1lID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZhY2FkZTtcbiAgICBjdXJyX3dpbmRvd19pZCA9IF9kb2N1bWVudC5sb2NhdGlvbi5oYXNoLnNsaWNlKDEpO1xuICAgIHZhciBvbk1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIGlmKGUuc291cmNlICE9PSBwYXJlbnQpIHJldHVybjtcbiAgICAgICAgaWYodHlwZW9mIHV0aWxzLnBhcmVudF9vcmlnaW4gPT09ICd1bmRlZmluZWQnKVxuICAgICAgICAgICAgdXRpbHMucGFyZW50X29yaWdpbiA9IGUub3JpZ2luO1xuICAgICAgICBpZiAoZS5vcmlnaW4gIT09IHV0aWxzLnBhcmVudF9vcmlnaW4pIHJldHVybjtcblxuICAgICAgICB2YXIgd2luZG93X2lkID0gZS5kYXRhLnNsaWNlKDAsIDgpO1xuICAgICAgICB2YXIgdHlwZSA9IGUuZGF0YS5zbGljZSg4LCA5KTtcbiAgICAgICAgdmFyIGRhdGEgPSBlLmRhdGEuc2xpY2UoOSk7XG4gICAgICAgIGlmICh3aW5kb3dfaWQgIT09IGN1cnJfd2luZG93X2lkKSByZXR1cm47XG4gICAgICAgIHN3aXRjaCh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgdmFyIHAgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgdmFyIHZlcnNpb24gPSBwWzBdO1xuICAgICAgICAgICAgdmFyIHByb3RvY29sID0gcFsxXTtcbiAgICAgICAgICAgIHZhciB0cmFuc191cmwgPSBwWzJdO1xuICAgICAgICAgICAgdmFyIGJhc2VfdXJsID0gcFszXTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uICE9PSBTb2NrSlMudmVyc2lvbikge1xuICAgICAgICAgICAgICAgIHV0aWxzLmxvZyhcIkluY29tcGF0aWJpbGUgU29ja0pTISBNYWluIHNpdGUgdXNlczpcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFwiIFxcXCJcIiArIHZlcnNpb24gKyBcIlxcXCIsIHRoZSBpZnJhbWU6XCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcIiBcXFwiXCIgKyBTb2NrSlMudmVyc2lvbiArIFwiXFxcIi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXV0aWxzLmZsYXRVcmwodHJhbnNfdXJsKSB8fCAhdXRpbHMuZmxhdFVybChiYXNlX3VybCkpIHtcbiAgICAgICAgICAgICAgICB1dGlscy5sb2coXCJPbmx5IGJhc2ljIHVybHMgYXJlIHN1cHBvcnRlZCBpbiBTb2NrSlNcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXV0aWxzLmlzU2FtZU9yaWdpblVybCh0cmFuc191cmwpIHx8XG4gICAgICAgICAgICAgICAgIXV0aWxzLmlzU2FtZU9yaWdpblVybChiYXNlX3VybCkpIHtcbiAgICAgICAgICAgICAgICB1dGlscy5sb2coXCJDYW4ndCBjb25uZWN0IHRvIGRpZmZlcmVudCBkb21haW4gZnJvbSB3aXRoaW4gYW4gXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICBcImlmcmFtZS4gKFwiICsgSlNPTi5zdHJpbmdpZnkoW193aW5kb3cubG9jYXRpb24uaHJlZiwgdHJhbnNfdXJsLCBiYXNlX3VybF0pICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCIpXCIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZhY2FkZSA9IG5ldyBGYWNhZGVKUygpO1xuICAgICAgICAgICAgZmFjYWRlLl90cmFuc3BvcnQgPSBuZXcgRmFjYWRlSlNbcHJvdG9jb2xdKGZhY2FkZSwgdHJhbnNfdXJsLCBiYXNlX3VybCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnbSc6XG4gICAgICAgICAgICBmYWNhZGUuX2RvU2VuZChkYXRhKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdjJzpcbiAgICAgICAgICAgIGlmIChmYWNhZGUpXG4gICAgICAgICAgICAgICAgZmFjYWRlLl9kb0NsZWFudXAoKTtcbiAgICAgICAgICAgIGZhY2FkZSA9IG51bGw7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBhbGVydCgndGVzdCB0aWNrZXInKTtcbiAgICAvLyBmYWNhZGUgPSBuZXcgRmFjYWRlSlMoKTtcbiAgICAvLyBmYWNhZGUuX3RyYW5zcG9ydCA9IG5ldyBGYWNhZGVKU1sndy1pZnJhbWUteGhyLXBvbGxpbmcnXShmYWNhZGUsICdodHRwOi8vaG9zdC5jb206OTk5OS90aWNrZXIvMTIvYmFzZCcpO1xuXG4gICAgdXRpbHMuYXR0YWNoTWVzc2FnZShvbk1lc3NhZ2UpO1xuXG4gICAgLy8gU3RhcnRcbiAgICBwb3N0TWVzc2FnZSgncycpO1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtaWZyYW1lLXdpdGhpbi5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvaW5mby5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIEluZm9SZWNlaXZlciA9IGZ1bmN0aW9uKGJhc2VfdXJsLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHV0aWxzLmRlbGF5KGZ1bmN0aW9uKCl7dGhhdC5kb1hocihiYXNlX3VybCwgQWpheE9iamVjdCk7fSk7XG59O1xuXG5JbmZvUmVjZWl2ZXIucHJvdG90eXBlID0gbmV3IEV2ZW50RW1pdHRlcihbJ2ZpbmlzaCddKTtcblxuSW5mb1JlY2VpdmVyLnByb3RvdHlwZS5kb1hociA9IGZ1bmN0aW9uKGJhc2VfdXJsLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciB0MCA9IChuZXcgRGF0ZSgpKS5nZXRUaW1lKCk7XG4gICAgdmFyIHhvID0gbmV3IEFqYXhPYmplY3QoJ0dFVCcsIGJhc2VfdXJsICsgJy9pbmZvJyk7XG5cbiAgICB2YXIgdHJlZiA9IHV0aWxzLmRlbGF5KDgwMDAsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBmdW5jdGlvbigpe3hvLm9udGltZW91dCgpO30pO1xuXG4gICAgeG8ub25maW5pc2ggPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHRyZWYpO1xuICAgICAgICB0cmVmID0gbnVsbDtcbiAgICAgICAgaWYgKHN0YXR1cyA9PT0gMjAwKSB7XG4gICAgICAgICAgICB2YXIgcnR0ID0gKG5ldyBEYXRlKCkpLmdldFRpbWUoKSAtIHQwO1xuICAgICAgICAgICAgdmFyIGluZm8gPSBKU09OLnBhcnNlKHRleHQpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBpbmZvICE9PSAnb2JqZWN0JykgaW5mbyA9IHt9O1xuICAgICAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnLCBpbmZvLCBydHQpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhhdC5lbWl0KCdmaW5pc2gnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgeG8ub250aW1lb3V0ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHhvLmNsb3NlKCk7XG4gICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJyk7XG4gICAgfTtcbn07XG5cbnZhciBJbmZvUmVjZWl2ZXJJZnJhbWUgPSBmdW5jdGlvbihiYXNlX3VybCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgZ28gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGlmciA9IG5ldyBJZnJhbWVUcmFuc3BvcnQoKTtcbiAgICAgICAgaWZyLnByb3RvY29sID0gJ3ctaWZyYW1lLWluZm8tcmVjZWl2ZXInO1xuICAgICAgICB2YXIgZnVuID0gZnVuY3Rpb24ocikge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByID09PSAnc3RyaW5nJyAmJiByLnN1YnN0cigwLDEpID09PSAnbScpIHtcbiAgICAgICAgICAgICAgICB2YXIgZCA9IEpTT04ucGFyc2Uoci5zdWJzdHIoMSkpO1xuICAgICAgICAgICAgICAgIHZhciBpbmZvID0gZFswXSwgcnR0ID0gZFsxXTtcbiAgICAgICAgICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcsIGluZm8sIHJ0dCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoYXQuZW1pdCgnZmluaXNoJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZnIuZG9DbGVhbnVwKCk7XG4gICAgICAgICAgICBpZnIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgbW9ja19yaSA9IHtcbiAgICAgICAgICAgIF9vcHRpb25zOiB7fSxcbiAgICAgICAgICAgIF9kaWRDbG9zZTogZnVuLFxuICAgICAgICAgICAgX2RpZE1lc3NhZ2U6IGZ1blxuICAgICAgICB9O1xuICAgICAgICBpZnIuaV9jb25zdHJ1Y3Rvcihtb2NrX3JpLCBiYXNlX3VybCwgYmFzZV91cmwpO1xuICAgIH1cbiAgICBpZighX2RvY3VtZW50LmJvZHkpIHtcbiAgICAgICAgdXRpbHMuYXR0YWNoRXZlbnQoJ2xvYWQnLCBnbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZ28oKTtcbiAgICB9XG59O1xuSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoWydmaW5pc2gnXSk7XG5cblxudmFyIEluZm9SZWNlaXZlckZha2UgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBJdCBtYXkgbm90IGJlIHBvc3NpYmxlIHRvIGRvIGNyb3NzIGRvbWFpbiBBSkFYIHRvIGdldCB0aGUgaW5mb1xuICAgIC8vIGRhdGEsIGZvciBleGFtcGxlIGZvciBJRTcuIEJ1dCB3ZSB3YW50IHRvIHJ1biBKU09OUCwgc28gbGV0J3NcbiAgICAvLyBmYWtlIHRoZSByZXNwb25zZSwgd2l0aCBydHQ9MnMgKHJ0bz02cykuXG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHV0aWxzLmRlbGF5KGZ1bmN0aW9uKCkge1xuICAgICAgICB0aGF0LmVtaXQoJ2ZpbmlzaCcsIHt9LCAyMDAwKTtcbiAgICB9KTtcbn07XG5JbmZvUmVjZWl2ZXJGYWtlLnByb3RvdHlwZSA9IG5ldyBFdmVudEVtaXR0ZXIoWydmaW5pc2gnXSk7XG5cbnZhciBjcmVhdGVJbmZvUmVjZWl2ZXIgPSBmdW5jdGlvbihiYXNlX3VybCkge1xuICAgIGlmICh1dGlscy5pc1NhbWVPcmlnaW5VcmwoYmFzZV91cmwpKSB7XG4gICAgICAgIC8vIElmLCBmb3Igc29tZSByZWFzb24sIHdlIGhhdmUgU29ja0pTIGxvY2FsbHkgLSB0aGVyZSdzIG5vXG4gICAgICAgIC8vIG5lZWQgdG8gc3RhcnQgdXAgdGhlIGNvbXBsZXggbWFjaGluZXJ5LiBKdXN0IHVzZSBhamF4LlxuICAgICAgICByZXR1cm4gbmV3IEluZm9SZWNlaXZlcihiYXNlX3VybCwgdXRpbHMuWEhSTG9jYWxPYmplY3QpO1xuICAgIH1cbiAgICBzd2l0Y2ggKHV0aWxzLmlzWEhSQ29yc0NhcGFibGUoKSkge1xuICAgIGNhc2UgMTpcbiAgICAgICAgcmV0dXJuIG5ldyBJbmZvUmVjZWl2ZXIoYmFzZV91cmwsIHV0aWxzLlhIUkNvcnNPYmplY3QpO1xuICAgIGNhc2UgMjpcbiAgICAgICAgcmV0dXJuIG5ldyBJbmZvUmVjZWl2ZXIoYmFzZV91cmwsIHV0aWxzLlhEUk9iamVjdCk7XG4gICAgY2FzZSAzOlxuICAgICAgICAvLyBPcGVyYVxuICAgICAgICByZXR1cm4gbmV3IEluZm9SZWNlaXZlcklmcmFtZShiYXNlX3VybCk7XG4gICAgZGVmYXVsdDpcbiAgICAgICAgLy8gSUUgN1xuICAgICAgICByZXR1cm4gbmV3IEluZm9SZWNlaXZlckZha2UoKTtcbiAgICB9O1xufTtcblxuXG52YXIgV0luZm9SZWNlaXZlcklmcmFtZSA9IEZhY2FkZUpTWyd3LWlmcmFtZS1pbmZvLXJlY2VpdmVyJ10gPSBmdW5jdGlvbihyaSwgX3RyYW5zX3VybCwgYmFzZV91cmwpIHtcbiAgICB2YXIgaXIgPSBuZXcgSW5mb1JlY2VpdmVyKGJhc2VfdXJsLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG4gICAgaXIub25maW5pc2ggPSBmdW5jdGlvbihpbmZvLCBydHQpIHtcbiAgICAgICAgcmkuX2RpZE1lc3NhZ2UoJ20nK0pTT04uc3RyaW5naWZ5KFtpbmZvLCBydHRdKSk7XG4gICAgICAgIHJpLl9kaWRDbG9zZSgpO1xuICAgIH1cbn07XG5XSW5mb1JlY2VpdmVySWZyYW1lLnByb3RvdHlwZS5kb0NsZWFudXAgPSBmdW5jdGlvbigpIHt9O1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi9pbmZvLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1pZnJhbWUtZXZlbnRzb3VyY2UuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBFdmVudFNvdXJjZUlmcmFtZVRyYW5zcG9ydCA9IFNvY2tKU1snaWZyYW1lLWV2ZW50c291cmNlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucHJvdG9jb2wgPSAndy1pZnJhbWUtZXZlbnRzb3VyY2UnO1xuICAgIHRoYXQuaV9jb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xufTtcblxuRXZlbnRTb3VyY2VJZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlID0gbmV3IElmcmFtZVRyYW5zcG9ydCgpO1xuXG5FdmVudFNvdXJjZUlmcmFtZVRyYW5zcG9ydC5lbmFibGVkID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoJ0V2ZW50U291cmNlJyBpbiBfd2luZG93KSAmJiBJZnJhbWVUcmFuc3BvcnQuZW5hYmxlZCgpO1xufTtcblxuRXZlbnRTb3VyY2VJZnJhbWVUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcbkV2ZW50U291cmNlSWZyYW1lVHJhbnNwb3J0LnJvdW5kVHJpcHMgPSAzOyAvLyBodG1sLCBqYXZhc2NyaXB0LCBldmVudHNvdXJjZVxuXG5cbi8vIHctaWZyYW1lLWV2ZW50c291cmNlXG52YXIgRXZlbnRTb3VyY2VUcmFuc3BvcnQgPSBGYWNhZGVKU1sndy1pZnJhbWUtZXZlbnRzb3VyY2UnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL2V2ZW50c291cmNlJywgRXZlbnRTb3VyY2VSZWNlaXZlciwgdXRpbHMuWEhSTG9jYWxPYmplY3QpO1xufVxuRXZlbnRTb3VyY2VUcmFuc3BvcnQucHJvdG90eXBlID0gbmV3IEFqYXhCYXNlZFRyYW5zcG9ydCgpO1xuLy8gICAgICAgICBbKl0gRW5kIG9mIGxpYi90cmFucy1pZnJhbWUtZXZlbnRzb3VyY2UuanNcblxuXG4vLyAgICAgICAgIFsqXSBJbmNsdWRpbmcgbGliL3RyYW5zLWlmcmFtZS14aHItcG9sbGluZy5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIFhoclBvbGxpbmdJZnJhbWVUcmFuc3BvcnQgPSBTb2NrSlNbJ2lmcmFtZS14aHItcG9sbGluZyddID0gZnVuY3Rpb24gKCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB0aGF0LnByb3RvY29sID0gJ3ctaWZyYW1lLXhoci1wb2xsaW5nJztcbiAgICB0aGF0LmlfY29uc3RydWN0b3IuYXBwbHkodGhhdCwgYXJndW1lbnRzKTtcbn07XG5cblhoclBvbGxpbmdJZnJhbWVUcmFuc3BvcnQucHJvdG90eXBlID0gbmV3IElmcmFtZVRyYW5zcG9ydCgpO1xuXG5YaHJQb2xsaW5nSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF93aW5kb3cuWE1MSHR0cFJlcXVlc3QgJiYgSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cblhoclBvbGxpbmdJZnJhbWVUcmFuc3BvcnQubmVlZF9ib2R5ID0gdHJ1ZTtcblhoclBvbGxpbmdJZnJhbWVUcmFuc3BvcnQucm91bmRUcmlwcyA9IDM7IC8vIGh0bWwsIGphdmFzY3JpcHQsIHhoclxuXG5cbi8vIHctaWZyYW1lLXhoci1wb2xsaW5nXG52YXIgWGhyUG9sbGluZ0lUcmFuc3BvcnQgPSBGYWNhZGVKU1sndy1pZnJhbWUteGhyLXBvbGxpbmcnXSA9IGZ1bmN0aW9uKHJpLCB0cmFuc191cmwpIHtcbiAgICB0aGlzLnJ1bihyaSwgdHJhbnNfdXJsLCAnL3hocicsIFhoclJlY2VpdmVyLCB1dGlscy5YSFJMb2NhbE9iamVjdCk7XG59O1xuXG5YaHJQb2xsaW5nSVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWlmcmFtZS14aHItcG9sbGluZy5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtaWZyYW1lLWh0bWxmaWxlLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG4vLyBUaGlzIHRyYW5zcG9ydCBnZW5lcmFsbHkgd29ya3MgaW4gYW55IGJyb3dzZXIsIGJ1dCB3aWxsIGNhdXNlIGFcbi8vIHNwaW5uaW5nIGN1cnNvciB0byBhcHBlYXIgaW4gYW55IGJyb3dzZXIgb3RoZXIgdGhhbiBJRS5cbi8vIFdlIG1heSB0ZXN0IHRoaXMgdHJhbnNwb3J0IGluIGFsbCBicm93c2VycyAtIHdoeSBub3QsIGJ1dCBpblxuLy8gcHJvZHVjdGlvbiBpdCBzaG91bGQgYmUgb25seSBydW4gaW4gSUUuXG5cbnZhciBIdG1sRmlsZUlmcmFtZVRyYW5zcG9ydCA9IFNvY2tKU1snaWZyYW1lLWh0bWxmaWxlJ10gPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucHJvdG9jb2wgPSAndy1pZnJhbWUtaHRtbGZpbGUnO1xuICAgIHRoYXQuaV9jb25zdHJ1Y3Rvci5hcHBseSh0aGF0LCBhcmd1bWVudHMpO1xufTtcblxuLy8gSW5oZXJpdGFuY2UuXG5IdG1sRmlsZUlmcmFtZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgSWZyYW1lVHJhbnNwb3J0KCk7XG5cbkh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0LmVuYWJsZWQoKTtcbn07XG5cbkh0bWxGaWxlSWZyYW1lVHJhbnNwb3J0Lm5lZWRfYm9keSA9IHRydWU7XG5IdG1sRmlsZUlmcmFtZVRyYW5zcG9ydC5yb3VuZFRyaXBzID0gMzsgLy8gaHRtbCwgamF2YXNjcmlwdCwgaHRtbGZpbGVcblxuXG4vLyB3LWlmcmFtZS1odG1sZmlsZVxudmFyIEh0bWxGaWxlVHJhbnNwb3J0ID0gRmFjYWRlSlNbJ3ctaWZyYW1lLWh0bWxmaWxlJ10gPSBmdW5jdGlvbihyaSwgdHJhbnNfdXJsKSB7XG4gICAgdGhpcy5ydW4ocmksIHRyYW5zX3VybCwgJy9odG1sZmlsZScsIEh0bWxmaWxlUmVjZWl2ZXIsIHV0aWxzLlhIUkxvY2FsT2JqZWN0KTtcbn07XG5IdG1sRmlsZVRyYW5zcG9ydC5wcm90b3R5cGUgPSBuZXcgQWpheEJhc2VkVHJhbnNwb3J0KCk7XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLWlmcmFtZS1odG1sZmlsZS5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtcG9sbGluZy5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIFBvbGxpbmcgPSBmdW5jdGlvbihyaSwgUmVjZWl2ZXIsIHJlY3ZfdXJsLCBBamF4T2JqZWN0KSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHRoYXQucmkgPSByaTtcbiAgICB0aGF0LlJlY2VpdmVyID0gUmVjZWl2ZXI7XG4gICAgdGhhdC5yZWN2X3VybCA9IHJlY3ZfdXJsO1xuICAgIHRoYXQuQWpheE9iamVjdCA9IEFqYXhPYmplY3Q7XG4gICAgdGhhdC5fc2NoZWR1bGVSZWN2KCk7XG59O1xuXG5Qb2xsaW5nLnByb3RvdHlwZS5fc2NoZWR1bGVSZWN2ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBwb2xsID0gdGhhdC5wb2xsID0gbmV3IHRoYXQuUmVjZWl2ZXIodGhhdC5yZWN2X3VybCwgdGhhdC5BamF4T2JqZWN0KTtcbiAgICB2YXIgbXNnX2NvdW50ZXIgPSAwO1xuICAgIHBvbGwub25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xuICAgICAgICBtc2dfY291bnRlciArPSAxO1xuICAgICAgICB0aGF0LnJpLl9kaWRNZXNzYWdlKGUuZGF0YSk7XG4gICAgfTtcbiAgICBwb2xsLm9uY2xvc2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgIHRoYXQucG9sbCA9IHBvbGwgPSBwb2xsLm9ubWVzc2FnZSA9IHBvbGwub25jbG9zZSA9IG51bGw7XG4gICAgICAgIGlmICghdGhhdC5wb2xsX2lzX2Nsb3NpbmcpIHtcbiAgICAgICAgICAgIGlmIChlLnJlYXNvbiA9PT0gJ3Blcm1hbmVudCcpIHtcbiAgICAgICAgICAgICAgICB0aGF0LnJpLl9kaWRDbG9zZSgxMDA2LCAnUG9sbGluZyBlcnJvciAoJyArIGUucmVhc29uICsgJyknKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhhdC5fc2NoZWR1bGVSZWN2KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xufTtcblxuUG9sbGluZy5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgdGhhdC5wb2xsX2lzX2Nsb3NpbmcgPSB0cnVlO1xuICAgIGlmICh0aGF0LnBvbGwpIHtcbiAgICAgICAgdGhhdC5wb2xsLmFib3J0KCk7XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtcG9sbGluZy5qc1xuXG5cbi8vICAgICAgICAgWypdIEluY2x1ZGluZyBsaWIvdHJhbnMtcmVjZWl2ZXItZXZlbnRzb3VyY2UuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBFdmVudFNvdXJjZVJlY2VpdmVyID0gZnVuY3Rpb24odXJsKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIHZhciBlcyA9IG5ldyBFdmVudFNvdXJjZSh1cmwpO1xuICAgIGVzLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnbWVzc2FnZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeydkYXRhJzogdW5lc2NhcGUoZS5kYXRhKX0pKTtcbiAgICB9O1xuICAgIHRoYXQuZXNfY2xvc2UgPSBlcy5vbmVycm9yID0gZnVuY3Rpb24oZSwgYWJvcnRfcmVhc29uKSB7XG4gICAgICAgIC8vIEVTIG9uIHJlY29ubmVjdGlvbiBoYXMgcmVhZHlTdGF0ZSA9IDAgb3IgMS5cbiAgICAgICAgLy8gb24gbmV0d29yayBlcnJvciBpdCdzIENMT1NFRCA9IDJcbiAgICAgICAgdmFyIHJlYXNvbiA9IGFib3J0X3JlYXNvbiA/ICd1c2VyJyA6XG4gICAgICAgICAgICAoZXMucmVhZHlTdGF0ZSAhPT0gMiA/ICduZXR3b3JrJyA6ICdwZXJtYW5lbnQnKTtcbiAgICAgICAgdGhhdC5lc19jbG9zZSA9IGVzLm9ubWVzc2FnZSA9IGVzLm9uZXJyb3IgPSBudWxsO1xuICAgICAgICAvLyBFdmVudFNvdXJjZSByZWNvbm5lY3RzIGF1dG9tYXRpY2FsbHkuXG4gICAgICAgIGVzLmNsb3NlKCk7XG4gICAgICAgIGVzID0gbnVsbDtcbiAgICAgICAgLy8gU2FmYXJpIGFuZCBjaHJvbWUgPCAxNSBjcmFzaCBpZiB3ZSBjbG9zZSB3aW5kb3cgYmVmb3JlXG4gICAgICAgIC8vIHdhaXRpbmcgZm9yIEVTIGNsZWFudXAuIFNlZTpcbiAgICAgICAgLy8gICBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9ODkxNTVcbiAgICAgICAgdXRpbHMuZGVsYXkoMjAwLCBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ2Nsb3NlJywge3JlYXNvbjogcmVhc29ufSkpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICB9O1xufTtcblxuRXZlbnRTb3VyY2VSZWNlaXZlci5wcm90b3R5cGUgPSBuZXcgUkV2ZW50VGFyZ2V0KCk7XG5cbkV2ZW50U291cmNlUmVjZWl2ZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIHRoYXQgPSB0aGlzO1xuICAgIGlmICh0aGF0LmVzX2Nsb3NlKSB7XG4gICAgICAgIHRoYXQuZXNfY2xvc2Uoe30sIHRydWUpO1xuICAgIH1cbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLXJlY2VpdmVyLWV2ZW50c291cmNlLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1yZWNlaXZlci1odG1sZmlsZS5qc1xuLypcbiAqICoqKioqIEJFR0lOIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqIENvcHlyaWdodCAoYykgMjAxMS0yMDEyIFZNd2FyZSwgSW5jLlxuICpcbiAqIEZvciB0aGUgbGljZW5zZSBzZWUgQ09QWUlORy5cbiAqICoqKioqIEVORCBMSUNFTlNFIEJMT0NLICoqKioqXG4gKi9cblxudmFyIF9pc19pZV9odG1sZmlsZV9jYXBhYmxlO1xudmFyIGlzSWVIdG1sZmlsZUNhcGFibGUgPSBmdW5jdGlvbigpIHtcbiAgICBpZiAoX2lzX2llX2h0bWxmaWxlX2NhcGFibGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpZiAoJ0FjdGl2ZVhPYmplY3QnIGluIF93aW5kb3cpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgX2lzX2llX2h0bWxmaWxlX2NhcGFibGUgPSAhIW5ldyBBY3RpdmVYT2JqZWN0KCdodG1sZmlsZScpO1xuICAgICAgICAgICAgfSBjYXRjaCAoeCkge31cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIF9pc19pZV9odG1sZmlsZV9jYXBhYmxlID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIF9pc19pZV9odG1sZmlsZV9jYXBhYmxlO1xufTtcblxuXG52YXIgSHRtbGZpbGVSZWNlaXZlciA9IGZ1bmN0aW9uKHVybCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB1dGlscy5wb2xsdXRlR2xvYmFsTmFtZXNwYWNlKCk7XG5cbiAgICB0aGF0LmlkID0gJ2EnICsgdXRpbHMucmFuZG9tX3N0cmluZyg2LCAyNik7XG4gICAgdXJsICs9ICgodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEpID8gJz8nIDogJyYnKSArXG4gICAgICAgICdjPScgKyBlc2NhcGUoV1ByZWZpeCArICcuJyArIHRoYXQuaWQpO1xuXG4gICAgdmFyIGNvbnN0cnVjdG9yID0gaXNJZUh0bWxmaWxlQ2FwYWJsZSgpID9cbiAgICAgICAgdXRpbHMuY3JlYXRlSHRtbGZpbGUgOiB1dGlscy5jcmVhdGVJZnJhbWU7XG5cbiAgICB2YXIgaWZyYW1lT2JqO1xuICAgIF93aW5kb3dbV1ByZWZpeF1bdGhhdC5pZF0gPSB7XG4gICAgICAgIHN0YXJ0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZnJhbWVPYmoubG9hZGVkKCk7XG4gICAgICAgIH0sXG4gICAgICAgIG1lc3NhZ2U6IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdtZXNzYWdlJywgeydkYXRhJzogZGF0YX0pKTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RvcDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdGhhdC5pZnJhbWVfY2xvc2Uoe30sICduZXR3b3JrJyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoYXQuaWZyYW1lX2Nsb3NlID0gZnVuY3Rpb24oZSwgYWJvcnRfcmVhc29uKSB7XG4gICAgICAgIGlmcmFtZU9iai5jbGVhbnVwKCk7XG4gICAgICAgIHRoYXQuaWZyYW1lX2Nsb3NlID0gaWZyYW1lT2JqID0gbnVsbDtcbiAgICAgICAgZGVsZXRlIF93aW5kb3dbV1ByZWZpeF1bdGhhdC5pZF07XG4gICAgICAgIHRoYXQuZGlzcGF0Y2hFdmVudChuZXcgU2ltcGxlRXZlbnQoJ2Nsb3NlJywge3JlYXNvbjogYWJvcnRfcmVhc29ufSkpO1xuICAgIH07XG4gICAgaWZyYW1lT2JqID0gY29uc3RydWN0b3IodXJsLCBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoYXQuaWZyYW1lX2Nsb3NlKHt9LCAncGVybWFuZW50Jyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG59O1xuXG5IdG1sZmlsZVJlY2VpdmVyLnByb3RvdHlwZSA9IG5ldyBSRXZlbnRUYXJnZXQoKTtcblxuSHRtbGZpbGVSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQuaWZyYW1lX2Nsb3NlKSB7XG4gICAgICAgIHRoYXQuaWZyYW1lX2Nsb3NlKHt9LCAndXNlcicpO1xuICAgIH1cbn07XG4vLyAgICAgICAgIFsqXSBFbmQgb2YgbGliL3RyYW5zLXJlY2VpdmVyLWh0bWxmaWxlLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90cmFucy1yZWNlaXZlci14aHIuanNcbi8qXG4gKiAqKioqKiBCRUdJTiBMSUNFTlNFIEJMT0NLICoqKioqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEtMjAxMiBWTXdhcmUsIEluYy5cbiAqXG4gKiBGb3IgdGhlIGxpY2Vuc2Ugc2VlIENPUFlJTkcuXG4gKiAqKioqKiBFTkQgTElDRU5TRSBCTE9DSyAqKioqKlxuICovXG5cbnZhciBYaHJSZWNlaXZlciA9IGZ1bmN0aW9uKHVybCwgQWpheE9iamVjdCkge1xuICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICB2YXIgYnVmX3BvcyA9IDA7XG5cbiAgICB0aGF0LnhvID0gbmV3IEFqYXhPYmplY3QoJ1BPU1QnLCB1cmwsIG51bGwpO1xuICAgIHRoYXQueG8ub25jaHVuayA9IGZ1bmN0aW9uKHN0YXR1cywgdGV4dCkge1xuICAgICAgICBpZiAoc3RhdHVzICE9PSAyMDApIHJldHVybjtcbiAgICAgICAgd2hpbGUgKDEpIHtcbiAgICAgICAgICAgIHZhciBidWYgPSB0ZXh0LnNsaWNlKGJ1Zl9wb3MpO1xuICAgICAgICAgICAgdmFyIHAgPSBidWYuaW5kZXhPZignXFxuJyk7XG4gICAgICAgICAgICBpZiAocCA9PT0gLTEpIGJyZWFrO1xuICAgICAgICAgICAgYnVmX3BvcyArPSBwKzE7XG4gICAgICAgICAgICB2YXIgbXNnID0gYnVmLnNsaWNlKDAsIHApO1xuICAgICAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnbWVzc2FnZScsIHtkYXRhOiBtc2d9KSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRoYXQueG8ub25maW5pc2ggPSBmdW5jdGlvbihzdGF0dXMsIHRleHQpIHtcbiAgICAgICAgdGhhdC54by5vbmNodW5rKHN0YXR1cywgdGV4dCk7XG4gICAgICAgIHRoYXQueG8gPSBudWxsO1xuICAgICAgICB2YXIgcmVhc29uID0gc3RhdHVzID09PSAyMDAgPyAnbmV0d29yaycgOiAncGVybWFuZW50JztcbiAgICAgICAgdGhhdC5kaXNwYXRjaEV2ZW50KG5ldyBTaW1wbGVFdmVudCgnY2xvc2UnLCB7cmVhc29uOiByZWFzb259KSk7XG4gICAgfVxufTtcblxuWGhyUmVjZWl2ZXIucHJvdG90eXBlID0gbmV3IFJFdmVudFRhcmdldCgpO1xuXG5YaHJSZWNlaXZlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgaWYgKHRoYXQueG8pIHtcbiAgICAgICAgdGhhdC54by5jbG9zZSgpO1xuICAgICAgICB0aGF0LmRpc3BhdGNoRXZlbnQobmV3IFNpbXBsZUV2ZW50KCdjbG9zZScsIHtyZWFzb246ICd1c2VyJ30pKTtcbiAgICAgICAgdGhhdC54byA9IG51bGw7XG4gICAgfVxufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdHJhbnMtcmVjZWl2ZXIteGhyLmpzXG5cblxuLy8gICAgICAgICBbKl0gSW5jbHVkaW5nIGxpYi90ZXN0LWhvb2tzLmpzXG4vKlxuICogKioqKiogQkVHSU4gTElDRU5TRSBCTE9DSyAqKioqKlxuICogQ29weXJpZ2h0IChjKSAyMDExLTIwMTIgVk13YXJlLCBJbmMuXG4gKlxuICogRm9yIHRoZSBsaWNlbnNlIHNlZSBDT1BZSU5HLlxuICogKioqKiogRU5EIExJQ0VOU0UgQkxPQ0sgKioqKipcbiAqL1xuXG4vLyBGb3IgdGVzdGluZ1xuU29ja0pTLmdldFV0aWxzID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gdXRpbHM7XG59O1xuXG5Tb2NrSlMuZ2V0SWZyYW1lVHJhbnNwb3J0ID0gZnVuY3Rpb24oKXtcbiAgICByZXR1cm4gSWZyYW1lVHJhbnNwb3J0O1xufTtcbi8vICAgICAgICAgWypdIEVuZCBvZiBsaWIvdGVzdC1ob29rcy5qc1xuXG4gICAgICAgICAgICAgICAgICByZXR1cm4gU29ja0pTO1xuICAgICAgICAgIH0pKCk7XG5pZiAoJ19zb2NranNfb25sb2FkJyBpbiB3aW5kb3cpIHNldFRpbWVvdXQoX3NvY2tqc19vbmxvYWQsIDEpO1xuXG4vLyBBTUQgY29tcGxpYW5jZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgnc29ja2pzJywgW10sIGZ1bmN0aW9uKCl7cmV0dXJuIFNvY2tKUzt9KTtcbn1cblxuaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gU29ja0pTO1xufVxuLy8gICAgIFsqXSBFbmQgb2YgbGliL2luZGV4LmpzXG5cbi8vIFsqXSBFbmQgb2YgbGliL2FsbC5qc1xuXG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxubW9kdWxlLmV4cG9ydHMgPSBTdHJlYW07XG5cbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG5cbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xuU3RyZWFtLlJlYWRhYmxlID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3JlYWRhYmxlLmpzJyk7XG5TdHJlYW0uV3JpdGFibGUgPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanMnKTtcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XG5TdHJlYW0uVHJhbnNmb3JtID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3RyYW5zZm9ybS5qcycpO1xuU3RyZWFtLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoLmpzJyk7XG5cbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuNC54XG5TdHJlYW0uU3RyZWFtID0gU3RyZWFtO1xuXG5cblxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxuLy8gcGFydCBvZiB0aGlzIGNsYXNzKSBpcyBvdmVycmlkZGVuIGluIHRoZSBSZWFkYWJsZSBjbGFzcy5cblxuZnVuY3Rpb24gU3RyZWFtKCkge1xuICBFRS5jYWxsKHRoaXMpO1xufVxuXG5TdHJlYW0ucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbihkZXN0LCBvcHRpb25zKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzO1xuXG4gIGZ1bmN0aW9uIG9uZGF0YShjaHVuaykge1xuICAgIGlmIChkZXN0LndyaXRhYmxlKSB7XG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xuICAgICAgICBzb3VyY2UucGF1c2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xuXG4gIGZ1bmN0aW9uIG9uZHJhaW4oKSB7XG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XG4gICAgICBzb3VyY2UucmVzdW1lKCk7XG4gICAgfVxuICB9XG5cbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICAvLyBJZiB0aGUgJ2VuZCcgb3B0aW9uIGlzIG5vdCBzdXBwbGllZCwgZGVzdC5lbmQoKSB3aWxsIGJlIGNhbGxlZCB3aGVuXG4gIC8vIHNvdXJjZSBnZXRzIHRoZSAnZW5kJyBvciAnY2xvc2UnIGV2ZW50cy4gIE9ubHkgZGVzdC5lbmQoKSBvbmNlLlxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcbiAgICBzb3VyY2Uub24oJ2VuZCcsIG9uZW5kKTtcbiAgICBzb3VyY2Uub24oJ2Nsb3NlJywgb25jbG9zZSk7XG4gIH1cblxuICB2YXIgZGlkT25FbmQgPSBmYWxzZTtcbiAgZnVuY3Rpb24gb25lbmQoKSB7XG4gICAgaWYgKGRpZE9uRW5kKSByZXR1cm47XG4gICAgZGlkT25FbmQgPSB0cnVlO1xuXG4gICAgZGVzdC5lbmQoKTtcbiAgfVxuXG5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcbiAgICBkaWRPbkVuZCA9IHRydWU7XG5cbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XG4gIH1cblxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcbiAgICBjbGVhbnVwKCk7XG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcbiAgICAgIHRocm93IGVyOyAvLyBVbmhhbmRsZWQgc3RyZWFtIGVycm9yIGluIHBpcGUuXG4gICAgfVxuICB9XG5cbiAgc291cmNlLm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xuXG4gIC8vIHJlbW92ZSBhbGwgdGhlIGV2ZW50IGxpc3RlbmVycyB0aGF0IHdlcmUgYWRkZWQuXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdkcmFpbicsIG9uZHJhaW4pO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBjbGVhbnVwKTtcblxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgY2xlYW51cCk7XG4gIH1cblxuICBzb3VyY2Uub24oJ2VuZCcsIGNsZWFudXApO1xuICBzb3VyY2Uub24oJ2Nsb3NlJywgY2xlYW51cCk7XG5cbiAgZGVzdC5vbignY2xvc2UnLCBjbGVhbnVwKTtcblxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xuXG4gIC8vIEFsbG93IGZvciB1bml4LWxpa2UgdXNhZ2U6IEEucGlwZShCKS5waXBlKEMpXG4gIHJldHVybiBkZXN0O1xufTtcbiIsInZhciB0b1N0cmluZyA9IHt9LnRvU3RyaW5nO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24gKGFycikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChhcnIpID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xuIiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIGEgZHVwbGV4IHN0cmVhbSBpcyBqdXN0IGEgc3RyZWFtIHRoYXQgaXMgYm90aCByZWFkYWJsZSBhbmQgd3JpdGFibGUuXG4vLyBTaW5jZSBKUyBkb2Vzbid0IGhhdmUgbXVsdGlwbGUgcHJvdG90eXBhbCBpbmhlcml0YW5jZSwgdGhpcyBjbGFzc1xuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxuLy8gV3JpdGFibGUuXG5cbid1c2Ugc3RyaWN0JztcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cblxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24gKG9iaikge1xuICB2YXIga2V5cyA9IFtdO1xuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gIH1yZXR1cm4ga2V5cztcbn07XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxubW9kdWxlLmV4cG9ydHMgPSBEdXBsZXg7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIFJlYWRhYmxlID0gcmVxdWlyZSgnLi9fc3RyZWFtX3JlYWRhYmxlJyk7XG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcblxudXRpbC5pbmhlcml0cyhEdXBsZXgsIFJlYWRhYmxlKTtcblxudmFyIGtleXMgPSBvYmplY3RLZXlzKFdyaXRhYmxlLnByb3RvdHlwZSk7XG5mb3IgKHZhciB2ID0gMDsgdiA8IGtleXMubGVuZ3RoOyB2KyspIHtcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XG4gIGlmICghRHVwbGV4LnByb3RvdHlwZVttZXRob2RdKSBEdXBsZXgucHJvdG90eXBlW21ldGhvZF0gPSBXcml0YWJsZS5wcm90b3R5cGVbbWV0aG9kXTtcbn1cblxuZnVuY3Rpb24gRHVwbGV4KG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHJldHVybiBuZXcgRHVwbGV4KG9wdGlvbnMpO1xuXG4gIFJlYWRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG4gIFdyaXRhYmxlLmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkYWJsZSA9PT0gZmFsc2UpIHRoaXMucmVhZGFibGUgPSBmYWxzZTtcblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xuXG4gIHRoaXMuYWxsb3dIYWxmT3BlbiA9IHRydWU7XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xuXG4gIHRoaXMub25jZSgnZW5kJywgb25lbmQpO1xufVxuXG4vLyB0aGUgbm8taGFsZi1vcGVuIGVuZm9yY2VyXG5mdW5jdGlvbiBvbmVuZCgpIHtcbiAgLy8gaWYgd2UgYWxsb3cgaGFsZi1vcGVuIHN0YXRlLCBvciBpZiB0aGUgd3JpdGFibGUgc2lkZSBlbmRlZCxcbiAgLy8gdGhlbiB3ZSdyZSBvay5cbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XG5cbiAgLy8gbm8gbW9yZSBkYXRhIGNhbiBiZSB3cml0dGVuLlxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cbiAgcHJvY2Vzc05leHRUaWNrKG9uRW5kTlQsIHRoaXMpO1xufVxuXG5mdW5jdGlvbiBvbkVuZE5UKHNlbGYpIHtcbiAgc2VsZi5lbmQoKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KER1cGxleC5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl9yZWFkYWJsZVN0YXRlID09PSB1bmRlZmluZWQgfHwgdGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcbiAgfSxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cbiAgICAvLyBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWQgeWV0XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHRoaXMucHVzaChudWxsKTtcbiAgdGhpcy5lbmQoKTtcblxuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVycik7XG59O1xuXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZih4c1tpXSwgaSk7XG4gIH1cbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSBwYXNzdGhyb3VnaCBzdHJlYW0uXG4vLyBiYXNpY2FsbHkganVzdCB0aGUgbW9zdCBtaW5pbWFsIHNvcnQgb2YgVHJhbnNmb3JtIHN0cmVhbS5cbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXG5cbid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSBQYXNzVGhyb3VnaDtcblxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG51dGlsLmluaGVyaXRzKFBhc3NUaHJvdWdoLCBUcmFuc2Zvcm0pO1xuXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBQYXNzVGhyb3VnaCkpIHJldHVybiBuZXcgUGFzc1Rocm91Z2gob3B0aW9ucyk7XG5cbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XG59XG5cblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgY2IobnVsbCwgY2h1bmspO1xufTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFJlYWRhYmxlO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGlzQXJyYXkgPSByZXF1aXJlKCdpc2FycmF5Jyk7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciBEdXBsZXg7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XG5cbnZhciBFRWxpc3RlbmVyQ291bnQgPSBmdW5jdGlvbiAoZW1pdHRlciwgdHlwZSkge1xuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xufTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vLyBUT0RPKGJtZXVyZXIpOiBDaGFuZ2UgdGhpcyBiYWNrIHRvIGNvbnN0IG9uY2UgaG9sZSBjaGVja3MgYXJlXG4vLyBwcm9wZXJseSBvcHRpbWl6ZWQgYXdheSBlYXJseSBpbiBJZ25pdGlvbitUdXJib0Zhbi5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcbnZhciBkZWJ1ZyA9IHZvaWQgMDtcbmlmIChkZWJ1Z1V0aWwgJiYgZGVidWdVdGlsLmRlYnVnbG9nKSB7XG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcbn0gZWxzZSB7XG4gIGRlYnVnID0gZnVuY3Rpb24gKCkge307XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcbnZhciBTdHJpbmdEZWNvZGVyO1xuXG51dGlsLmluaGVyaXRzKFJlYWRhYmxlLCBTdHJlYW0pO1xuXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xuXG5mdW5jdGlvbiBwcmVwZW5kTGlzdGVuZXIoZW1pdHRlciwgZXZlbnQsIGZuKSB7XG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXG4gIC8vIGV2ZW50IGVtaXR0ZXIgaW1wbGVtZW50YXRpb24gd2l0aCB0aGVtLlxuICBpZiAodHlwZW9mIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XG4gIH0gZWxzZSB7XG4gICAgLy8gVGhpcyBpcyBhIGhhY2sgdG8gbWFrZSBzdXJlIHRoYXQgb3VyIGVycm9yIGhhbmRsZXIgaXMgYXR0YWNoZWQgYmVmb3JlIGFueVxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xuICAgIC8vIHRvIGNvbnRpbnVlIHRvIHdvcmsgd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiBOb2RlLmpzIHRoYXQgZG8gbm90IGluY2x1ZGVcbiAgICAvLyB0aGUgcHJlcGVuZExpc3RlbmVyKCkgbWV0aG9kLiBUaGUgZ29hbCBpcyB0byBldmVudHVhbGx5IHJlbW92ZSB0aGlzIGhhY2suXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xuICAvLyBtYWtlIGFsbCB0aGUgYnVmZmVyIG1lcmdpbmcgYW5kIGxlbmd0aCBjaGVja3MgZ28gYXdheVxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLnJlYWRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxuICAvLyBOb3RlOiAwIGlzIGEgdmFsaWQgdmFsdWUsIG1lYW5zIFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclwiXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XG4gIHZhciBkZWZhdWx0SHdtID0gdGhpcy5vYmplY3RNb2RlID8gMTYgOiAxNiAqIDEwMjQ7XG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xuXG4gIC8vIGNhc3QgdG8gaW50cy5cbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xuXG4gIC8vIEEgbGlua2VkIGxpc3QgaXMgdXNlZCB0byBzdG9yZSBkYXRhIGNodW5rcyBpbnN0ZWFkIG9mIGFuIGFycmF5IGJlY2F1c2UgdGhlXG4gIC8vIGxpbmtlZCBsaXN0IGNhbiByZW1vdmUgZWxlbWVudHMgZnJvbSB0aGUgYmVnaW5uaW5nIGZhc3RlciB0aGFuXG4gIC8vIGFycmF5LnNoaWZ0KClcbiAgdGhpcy5idWZmZXIgPSBuZXcgQnVmZmVyTGlzdCgpO1xuICB0aGlzLmxlbmd0aCA9IDA7XG4gIHRoaXMucGlwZXMgPSBudWxsO1xuICB0aGlzLnBpcGVzQ291bnQgPSAwO1xuICB0aGlzLmZsb3dpbmcgPSBudWxsO1xuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIHRoaXMuZW5kRW1pdHRlZCA9IGZhbHNlO1xuICB0aGlzLnJlYWRpbmcgPSBmYWxzZTtcblxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBldmVudCAncmVhZGFibGUnLydkYXRhJyBpcyBlbWl0dGVkXG4gIC8vIGltbWVkaWF0ZWx5LCBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCByZWFkIGNhbGwuXG4gIHRoaXMuc3luYyA9IHRydWU7XG5cbiAgLy8gd2hlbmV2ZXIgd2UgcmV0dXJuIG51bGwsIHRoZW4gd2Ugc2V0IGEgZmxhZyB0byBzYXlcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXG4gIHRoaXMubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcbiAgdGhpcy5yZXN1bWVTY2hlZHVsZWQgPSBmYWxzZTtcblxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcbiAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcblxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXG4gIC8vIGVuY29kaW5nIGlzICdiaW5hcnknIHNvIHdlIGhhdmUgdG8gbWFrZSB0aGlzIGNvbmZpZ3VyYWJsZS5cbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcblxuICAvLyB0aGUgbnVtYmVyIG9mIHdyaXRlcnMgdGhhdCBhcmUgYXdhaXRpbmcgYSBkcmFpbiBldmVudCBpbiAucGlwZSgpc1xuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xuXG4gIC8vIGlmIHRydWUsIGEgbWF5YmVSZWFkTW9yZSBoYXMgYmVlbiBzY2hlZHVsZWRcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xuXG4gIHRoaXMuZGVjb2RlciA9IG51bGw7XG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xuICBpZiAob3B0aW9ucy5lbmNvZGluZykge1xuICAgIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XG4gICAgdGhpcy5lbmNvZGluZyA9IG9wdGlvbnMuZW5jb2Rpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gUmVhZGFibGUob3B0aW9ucykge1xuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBSZWFkYWJsZSkpIHJldHVybiBuZXcgUmVhZGFibGUob3B0aW9ucyk7XG5cbiAgdGhpcy5fcmVhZGFibGVTdGF0ZSA9IG5ldyBSZWFkYWJsZVN0YXRlKG9wdGlvbnMsIHRoaXMpO1xuXG4gIC8vIGxlZ2FjeVxuICB0aGlzLnJlYWRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5yZWFkID09PSAnZnVuY3Rpb24nKSB0aGlzLl9yZWFkID0gb3B0aW9ucy5yZWFkO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XG4gIH1cblxuICBTdHJlYW0uY2FsbCh0aGlzKTtcbn1cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxuICAgIGlmICghdGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIC8vIGJhY2t3YXJkIGNvbXBhdGliaWxpdHksIHRoZSB1c2VyIGlzIGV4cGxpY2l0bHlcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IHZhbHVlO1xuICB9XG59KTtcblxuUmVhZGFibGUucHJvdG90eXBlLmRlc3Ryb3kgPSBkZXN0cm95SW1wbC5kZXN0cm95O1xuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XG5SZWFkYWJsZS5wcm90b3R5cGUuX2Rlc3Ryb3kgPSBmdW5jdGlvbiAoZXJyLCBjYikge1xuICB0aGlzLnB1c2gobnVsbCk7XG4gIGNiKGVycik7XG59O1xuXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cbi8vIFRoaXMgcmV0dXJucyB0cnVlIGlmIHRoZSBoaWdoV2F0ZXJNYXJrIGhhcyBub3QgYmVlbiBoaXQgeWV0LFxuLy8gc2ltaWxhciB0byBob3cgV3JpdGFibGUud3JpdGUoKSByZXR1cm5zIHRydWUgaWYgeW91IHNob3VsZFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXG5SZWFkYWJsZS5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xuXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSkge1xuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XG4gICAgICBlbmNvZGluZyA9IGVuY29kaW5nIHx8IHN0YXRlLmRlZmF1bHRFbmNvZGluZztcbiAgICAgIGlmIChlbmNvZGluZyAhPT0gc3RhdGUuZW5jb2RpbmcpIHtcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xuICAgICAgICBlbmNvZGluZyA9ICcnO1xuICAgICAgfVxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XG4gIH1cblxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XG59O1xuXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxuUmVhZGFibGUucHJvdG90eXBlLnVuc2hpZnQgPSBmdW5jdGlvbiAoY2h1bmspIHtcbiAgcmV0dXJuIHJlYWRhYmxlQWRkQ2h1bmsodGhpcywgY2h1bmssIG51bGwsIHRydWUsIGZhbHNlKTtcbn07XG5cbmZ1bmN0aW9uIHJlYWRhYmxlQWRkQ2h1bmsoc3RyZWFtLCBjaHVuaywgZW5jb2RpbmcsIGFkZFRvRnJvbnQsIHNraXBDaHVua0NoZWNrKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGVyO1xuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XG4gICAgaWYgKGVyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcbiAgICAgIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmICFzdGF0ZS5vYmplY3RNb2RlICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihjaHVuaykgIT09IEJ1ZmZlci5wcm90b3R5cGUpIHtcbiAgICAgICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGFkZFRvRnJvbnQpIHtcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmVuZGVkKSB7XG4gICAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnB1c2goKSBhZnRlciBFT0YnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XG4gICAgICAgIGlmIChzdGF0ZS5kZWNvZGVyICYmICFlbmNvZGluZykge1xuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XG4gICAgICAgICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgfHwgY2h1bmsubGVuZ3RoICE9PSAwKSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO2Vsc2UgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xuICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZWVkTW9yZURhdGEoc3RhdGUpO1xufVxuXG5mdW5jdGlvbiBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgYWRkVG9Gcm9udCkge1xuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcbiAgICBzdHJlYW0uZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfSBlbHNlIHtcbiAgICAvLyB1cGRhdGUgdGhlIGJ1ZmZlciBpbmZvLlxuICAgIHN0YXRlLmxlbmd0aCArPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xuXG4gICAgaWYgKHN0YXRlLm5lZWRSZWFkYWJsZSkgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG4gIH1cbiAgbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuZnVuY3Rpb24gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuaykge1xuICB2YXIgZXI7XG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XG4gICAgZXIgPSBuZXcgVHlwZUVycm9yKCdJbnZhbGlkIG5vbi1zdHJpbmcvYnVmZmVyIGNodW5rJyk7XG4gIH1cbiAgcmV0dXJuIGVyO1xufVxuXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxuLy8gQWxzbywgaWYgd2UgaGF2ZSBubyBkYXRhIHlldCwgd2UgY2FuIHN0YW5kIHNvbWVcbi8vIG1vcmUgYnl0ZXMuICBUaGlzIGlzIHRvIHdvcmsgYXJvdW5kIGNhc2VzIHdoZXJlIGh3bT0wLFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcbi8vIHJlYWRhYmxlIGV2ZW50LCBhbmQgdGhlIHVzZXIgY2FsbGVkIHJlYWQobGFyZ2VOdW1iZXIpIHN1Y2ggdGhhdFxuLy8gbmVlZFJlYWRhYmxlIHdhcyBzZXQsIHRoZW4gd2Ugb3VnaHQgdG8gcHVzaCBtb3JlLCBzbyB0aGF0IGFub3RoZXJcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXG5mdW5jdGlvbiBuZWVkTW9yZURhdGEoc3RhdGUpIHtcbiAgcmV0dXJuICFzdGF0ZS5lbmRlZCAmJiAoc3RhdGUubmVlZFJlYWRhYmxlIHx8IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUubGVuZ3RoID09PSAwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLmlzUGF1c2VkID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcbn07XG5cbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuUmVhZGFibGUucHJvdG90eXBlLnNldEVuY29kaW5nID0gZnVuY3Rpb24gKGVuYykge1xuICBpZiAoIVN0cmluZ0RlY29kZXIpIFN0cmluZ0RlY29kZXIgPSByZXF1aXJlKCdzdHJpbmdfZGVjb2Rlci8nKS5TdHJpbmdEZWNvZGVyO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuY29kaW5nID0gZW5jO1xuICByZXR1cm4gdGhpcztcbn07XG5cbi8vIERvbid0IHJhaXNlIHRoZSBod20gPiA4TUJcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XG5mdW5jdGlvbiBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKSB7XG4gIGlmIChuID49IE1BWF9IV00pIHtcbiAgICBuID0gTUFYX0hXTTtcbiAgfSBlbHNlIHtcbiAgICAvLyBHZXQgdGhlIG5leHQgaGlnaGVzdCBwb3dlciBvZiAyIHRvIHByZXZlbnQgaW5jcmVhc2luZyBod20gZXhjZXNzaXZlbHkgaW5cbiAgICAvLyB0aW55IGFtb3VudHNcbiAgICBuLS07XG4gICAgbiB8PSBuID4+PiAxO1xuICAgIG4gfD0gbiA+Pj4gMjtcbiAgICBuIHw9IG4gPj4+IDQ7XG4gICAgbiB8PSBuID4+PiA4O1xuICAgIG4gfD0gbiA+Pj4gMTY7XG4gICAgbisrO1xuICB9XG4gIHJldHVybiBuO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGhvd011Y2hUb1JlYWQobiwgc3RhdGUpIHtcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xuICBpZiAoc3RhdGUub2JqZWN0TW9kZSkgcmV0dXJuIDE7XG4gIGlmIChuICE9PSBuKSB7XG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXG4gICAgaWYgKHN0YXRlLmZsb3dpbmcgJiYgc3RhdGUubGVuZ3RoKSByZXR1cm4gc3RhdGUuYnVmZmVyLmhlYWQuZGF0YS5sZW5ndGg7ZWxzZSByZXR1cm4gc3RhdGUubGVuZ3RoO1xuICB9XG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxuICBpZiAobiA+IHN0YXRlLmhpZ2hXYXRlck1hcmspIHN0YXRlLmhpZ2hXYXRlck1hcmsgPSBjb21wdXRlTmV3SGlnaFdhdGVyTWFyayhuKTtcbiAgaWYgKG4gPD0gc3RhdGUubGVuZ3RoKSByZXR1cm4gbjtcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcbiAgaWYgKCFzdGF0ZS5lbmRlZCkge1xuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgcmV0dXJuIDA7XG4gIH1cbiAgcmV0dXJuIHN0YXRlLmxlbmd0aDtcbn1cblxuLy8geW91IGNhbiBvdmVycmlkZSBlaXRoZXIgdGhpcyBtZXRob2QsIG9yIHRoZSBhc3luYyBfcmVhZChuKSBiZWxvdy5cblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgZGVidWcoJ3JlYWQnLCBuKTtcbiAgbiA9IHBhcnNlSW50KG4sIDEwKTtcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcbiAgdmFyIG5PcmlnID0gbjtcblxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG5cbiAgLy8gaWYgd2UncmUgZG9pbmcgcmVhZCgwKSB0byB0cmlnZ2VyIGEgcmVhZGFibGUgZXZlbnQsIGJ1dCB3ZVxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXG4gIC8vIHRoZSAncmVhZGFibGUnIGV2ZW50IGFuZCBtb3ZlIG9uLlxuICBpZiAobiA9PT0gMCAmJiBzdGF0ZS5uZWVkUmVhZGFibGUgJiYgKHN0YXRlLmxlbmd0aCA+PSBzdGF0ZS5oaWdoV2F0ZXJNYXJrIHx8IHN0YXRlLmVuZGVkKSkge1xuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcbiAgICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtlbHNlIGVtaXRSZWFkYWJsZSh0aGlzKTtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIG4gPSBob3dNdWNoVG9SZWFkKG4sIHN0YXRlKTtcblxuICAvLyBpZiB3ZSd2ZSBlbmRlZCwgYW5kIHdlJ3JlIG5vdyBjbGVhciwgdGhlbiBmaW5pc2ggaXQgdXAuXG4gIGlmIChuID09PSAwICYmIHN0YXRlLmVuZGVkKSB7XG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICAvLyBBbGwgdGhlIGFjdHVhbCBjaHVuayBnZW5lcmF0aW9uIGxvZ2ljIG5lZWRzIHRvIGJlXG4gIC8vICpiZWxvdyogdGhlIGNhbGwgdG8gX3JlYWQuICBUaGUgcmVhc29uIGlzIHRoYXQgaW4gY2VydGFpblxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXG4gIC8vIG1heSBiZSBhIGNvbXBsZXRlbHkgc3luY2hyb25vdXMgb3BlcmF0aW9uIHdoaWNoIG1heSBjaGFuZ2VcbiAgLy8gdGhlIHN0YXRlIG9mIHRoZSByZWFkIGJ1ZmZlciwgcHJvdmlkaW5nIGVub3VnaCBkYXRhIHdoZW5cbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXG4gIC8vXG4gIC8vIFNvLCB0aGUgc3RlcHMgYXJlOlxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXG4gIC8vIGEgcmVhZCBmcm9tIHRoZSBidWZmZXIuXG4gIC8vXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXG4gIC8vIE5vdGUgdGhhdCB0aGlzIG1heSBiZSBhc3luY2hyb25vdXMsIG9yIHN5bmNocm9ub3VzLiAgWWVzLCBpdCBpc1xuICAvLyBkZWVwbHkgdWdseSB0byB3cml0ZSBBUElzIHRoaXMgd2F5LCBidXQgdGhhdCBzdGlsbCBkb2Vzbid0IG1lYW5cbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxuICAvLyBkZXNpZ25lZCB0byBiZSBzeW5jL2FzeW5jIGFnbm9zdGljLlxuICAvLyBUYWtlIG5vdGUgaWYgdGhlIF9yZWFkIGNhbGwgaXMgc3luYyBvciBhc3luYyAoaWUsIGlmIHRoZSByZWFkIGNhbGxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxuICAvLyAncmVhZGFibGUnIGV0Yy5cbiAgLy9cbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxuXG4gIC8vIGlmIHdlIG5lZWQgYSByZWFkYWJsZSBldmVudCwgdGhlbiB3ZSBuZWVkIHRvIGRvIHNvbWUgcmVhZGluZy5cbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcbiAgZGVidWcoJ25lZWQgcmVhZGFibGUnLCBkb1JlYWQpO1xuXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwIHx8IHN0YXRlLmxlbmd0aCAtIG4gPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XG4gICAgZG9SZWFkID0gdHJ1ZTtcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xuICB9XG5cbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcbiAgLy8gcmVhZGluZywgdGhlbiBpdCdzIHVubmVjZXNzYXJ5LlxuICBpZiAoc3RhdGUuZW5kZWQgfHwgc3RhdGUucmVhZGluZykge1xuICAgIGRvUmVhZCA9IGZhbHNlO1xuICAgIGRlYnVnKCdyZWFkaW5nIG9yIGVuZGVkJywgZG9SZWFkKTtcbiAgfSBlbHNlIGlmIChkb1JlYWQpIHtcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xuICAgIHN0YXRlLnJlYWRpbmcgPSB0cnVlO1xuICAgIHN0YXRlLnN5bmMgPSB0cnVlO1xuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcbiAgICAvLyBjYWxsIGludGVybmFsIHJlYWQgbWV0aG9kXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcbiAgICBzdGF0ZS5zeW5jID0gZmFsc2U7XG4gICAgLy8gSWYgX3JlYWQgcHVzaGVkIGRhdGEgc3luY2hyb25vdXNseSwgdGhlbiBgcmVhZGluZ2Agd2lsbCBiZSBmYWxzZSxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXG4gICAgaWYgKCFzdGF0ZS5yZWFkaW5nKSBuID0gaG93TXVjaFRvUmVhZChuT3JpZywgc3RhdGUpO1xuICB9XG5cbiAgdmFyIHJldDtcbiAgaWYgKG4gPiAwKSByZXQgPSBmcm9tTGlzdChuLCBzdGF0ZSk7ZWxzZSByZXQgPSBudWxsO1xuXG4gIGlmIChyZXQgPT09IG51bGwpIHtcbiAgICBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgIG4gPSAwO1xuICB9IGVsc2Uge1xuICAgIHN0YXRlLmxlbmd0aCAtPSBuO1xuICB9XG5cbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkge1xuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xuICAgIC8vIGFzIHNvb24gYXMgd2UgKmRvKiBnZXQgc29tZXRoaW5nIGludG8gdGhlIGJ1ZmZlci5cbiAgICBpZiAoIXN0YXRlLmVuZGVkKSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuXG4gICAgLy8gSWYgd2UgdHJpZWQgdG8gcmVhZCgpIHBhc3QgdGhlIEVPRiwgdGhlbiBlbWl0IGVuZCBvbiB0aGUgbmV4dCB0aWNrLlxuICAgIGlmIChuT3JpZyAhPT0gbiAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7XG4gIH1cblxuICBpZiAocmV0ICE9PSBudWxsKSB0aGlzLmVtaXQoJ2RhdGEnLCByZXQpO1xuXG4gIHJldHVybiByZXQ7XG59O1xuXG5mdW5jdGlvbiBvbkVvZkNodW5rKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKHN0YXRlLmVuZGVkKSByZXR1cm47XG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XG4gICAgdmFyIGNodW5rID0gc3RhdGUuZGVjb2Rlci5lbmQoKTtcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSB7XG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XG4gICAgICBzdGF0ZS5sZW5ndGggKz0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG4gICAgfVxuICB9XG4gIHN0YXRlLmVuZGVkID0gdHJ1ZTtcblxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cbiAgZW1pdFJlYWRhYmxlKHN0cmVhbSk7XG59XG5cbi8vIERvbid0IGVtaXQgcmVhZGFibGUgcmlnaHQgYXdheSBpbiBzeW5jIG1vZGUsIGJlY2F1c2UgdGhpcyBjYW4gdHJpZ2dlclxuLy8gYW5vdGhlciByZWFkKCkgY2FsbCA9PiBzdGFjayBvdmVyZmxvdy4gIFRoaXMgd2F5LCBpdCBtaWdodCB0cmlnZ2VyXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXG5mdW5jdGlvbiBlbWl0UmVhZGFibGUoc3RyZWFtKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XG4gIGlmICghc3RhdGUuZW1pdHRlZFJlYWRhYmxlKSB7XG4gICAgZGVidWcoJ2VtaXRSZWFkYWJsZScsIHN0YXRlLmZsb3dpbmcpO1xuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XG4gICAgaWYgKHN0YXRlLnN5bmMpIHByb2Nlc3NOZXh0VGljayhlbWl0UmVhZGFibGVfLCBzdHJlYW0pO2Vsc2UgZW1pdFJlYWRhYmxlXyhzdHJlYW0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRSZWFkYWJsZV8oc3RyZWFtKSB7XG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XG4gIHN0cmVhbS5lbWl0KCdyZWFkYWJsZScpO1xuICBmbG93KHN0cmVhbSk7XG59XG5cbi8vIGF0IHRoaXMgcG9pbnQsIHRoZSB1c2VyIGhhcyBwcmVzdW1hYmx5IHNlZW4gdGhlICdyZWFkYWJsZScgZXZlbnQsXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXG4vLyBpbiB0dXJuIGFub3RoZXIgX3JlYWQobikgY2FsbCwgaW4gd2hpY2ggY2FzZSByZWFkaW5nID0gdHJ1ZSBpZlxuLy8gaXQncyBpbiBwcm9ncmVzcy5cbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXG4vLyB0aGVuIGdvIGFoZWFkIGFuZCB0cnkgdG8gcmVhZCBzb21lIG1vcmUgcHJlZW1wdGl2ZWx5LlxuZnVuY3Rpb24gbWF5YmVSZWFkTW9yZShzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcbiAgICBzdGF0ZS5yZWFkaW5nTW9yZSA9IHRydWU7XG4gICAgcHJvY2Vzc05leHRUaWNrKG1heWJlUmVhZE1vcmVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XG4gIHZhciBsZW4gPSBzdGF0ZS5sZW5ndGg7XG4gIHdoaWxlICghc3RhdGUucmVhZGluZyAmJiAhc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUuZW5kZWQgJiYgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xuICAgIHN0cmVhbS5yZWFkKDApO1xuICAgIGlmIChsZW4gPT09IHN0YXRlLmxlbmd0aClcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXG4gICAgICBicmVhaztlbHNlIGxlbiA9IHN0YXRlLmxlbmd0aDtcbiAgfVxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xufVxuXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyBjYWxsIGNiKGVyLCBkYXRhKSB3aGVyZSBkYXRhIGlzIDw9IG4gaW4gbGVuZ3RoLlxuLy8gZm9yIHZpcnR1YWwgKG5vbi1zdHJpbmcsIG5vbi1idWZmZXIpIHN0cmVhbXMsIFwibGVuZ3RoXCIgaXMgc29tZXdoYXRcbi8vIGFyYml0cmFyeSwgYW5kIHBlcmhhcHMgbm90IHZlcnkgbWVhbmluZ2Z1bC5cblJlYWRhYmxlLnByb3RvdHlwZS5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcbiAgdmFyIHNyYyA9IHRoaXM7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG5cbiAgc3dpdGNoIChzdGF0ZS5waXBlc0NvdW50KSB7XG4gICAgY2FzZSAwOlxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAxOlxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XG4gICAgICBicmVhaztcbiAgfVxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XG4gIGRlYnVnKCdwaXBlIGNvdW50PSVkIG9wdHM9JWonLCBzdGF0ZS5waXBlc0NvdW50LCBwaXBlT3B0cyk7XG5cbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcblxuICB2YXIgZW5kRm4gPSBkb0VuZCA/IG9uZW5kIDogdW5waXBlO1xuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XG5cbiAgZGVzdC5vbigndW5waXBlJywgb251bnBpcGUpO1xuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xuICAgIGRlYnVnKCdvbnVucGlwZScpO1xuICAgIGlmIChyZWFkYWJsZSA9PT0gc3JjKSB7XG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XG4gICAgICAgIHVucGlwZUluZm8uaGFzVW5waXBlZCA9IHRydWU7XG4gICAgICAgIGNsZWFudXAoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBvbmVuZCgpIHtcbiAgICBkZWJ1Zygnb25lbmQnKTtcbiAgICBkZXN0LmVuZCgpO1xuICB9XG5cbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxuICAvLyBvbiB0aGUgc291cmNlLiAgVGhpcyB3b3VsZCBiZSBtb3JlIGVsZWdhbnQgd2l0aCBhIC5vbmNlKClcbiAgLy8gaGFuZGxlciBpbiBmbG93KCksIGJ1dCBhZGRpbmcgYW5kIHJlbW92aW5nIHJlcGVhdGVkbHkgaXNcbiAgLy8gdG9vIHNsb3cuXG4gIHZhciBvbmRyYWluID0gcGlwZU9uRHJhaW4oc3JjKTtcbiAgZGVzdC5vbignZHJhaW4nLCBvbmRyYWluKTtcblxuICB2YXIgY2xlYW5lZFVwID0gZmFsc2U7XG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XG4gICAgZGVidWcoJ2NsZWFudXAnKTtcbiAgICAvLyBjbGVhbnVwIGV2ZW50IGhhbmRsZXJzIG9uY2UgdGhlIHBpcGUgaXMgYnJva2VuXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignY2xvc2UnLCBvbmNsb3NlKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZHJhaW4nLCBvbmRyYWluKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIG9uZW5kKTtcbiAgICBzcmMucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIHVucGlwZSk7XG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcblxuICAgIGNsZWFuZWRVcCA9IHRydWU7XG5cbiAgICAvLyBpZiB0aGUgcmVhZGVyIGlzIHdhaXRpbmcgZm9yIGEgZHJhaW4gZXZlbnQgZnJvbSB0aGlzXG4gICAgLy8gc3BlY2lmaWMgd3JpdGVyLCB0aGVuIGl0IHdvdWxkIGNhdXNlIGl0IHRvIG5ldmVyIHN0YXJ0XG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cbiAgICAvLyBTbywgaWYgdGhpcyBpcyBhd2FpdGluZyBhIGRyYWluLCB0aGVuIHdlIGp1c3QgY2FsbCBpdCBub3cuXG4gICAgLy8gSWYgd2UgZG9uJ3Qga25vdywgdGhlbiBhc3N1bWUgdGhhdCB3ZSBhcmUgd2FpdGluZyBmb3Igb25lLlxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcbiAgfVxuXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXG4gIC8vIGluIG9uZGF0YSBhZ2Fpbi4gSG93ZXZlciwgd2Ugb25seSB3YW50IHRvIGluY3JlYXNlIGF3YWl0RHJhaW4gb25jZSBiZWNhdXNlXG4gIC8vIGRlc3Qgd2lsbCBvbmx5IGVtaXQgb25lICdkcmFpbicgZXZlbnQgZm9yIHRoZSBtdWx0aXBsZSB3cml0ZXMuXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cbiAgdmFyIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgc3JjLm9uKCdkYXRhJywgb25kYXRhKTtcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XG4gICAgZGVidWcoJ29uZGF0YScpO1xuICAgIGluY3JlYXNlZEF3YWl0RHJhaW4gPSBmYWxzZTtcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XG4gICAgaWYgKGZhbHNlID09PSByZXQgJiYgIWluY3JlYXNlZEF3YWl0RHJhaW4pIHtcbiAgICAgIC8vIElmIHRoZSB1c2VyIHVucGlwZWQgZHVyaW5nIGBkZXN0LndyaXRlKClgLCBpdCBpcyBwb3NzaWJsZVxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcbiAgICAgIC8vIGFsc28gcmV0dXJuZWQgZmFsc2UuXG4gICAgICAvLyA9PiBDaGVjayB3aGV0aGVyIGBkZXN0YCBpcyBzdGlsbCBhIHBpcGluZyBkZXN0aW5hdGlvbi5cbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcbiAgICAgICAgZGVidWcoJ2ZhbHNlIHdyaXRlIHJlc3BvbnNlLCBwYXVzZScsIHNyYy5fcmVhZGFibGVTdGF0ZS5hd2FpdERyYWluKTtcbiAgICAgICAgc3JjLl9yZWFkYWJsZVN0YXRlLmF3YWl0RHJhaW4rKztcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XG4gICAgICB9XG4gICAgICBzcmMucGF1c2UoKTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cbiAgLy8gaG93ZXZlciwgZG9uJ3Qgc3VwcHJlc3MgdGhlIHRocm93aW5nIGJlaGF2aW9yIGZvciB0aGlzLlxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XG4gICAgdW5waXBlKCk7XG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9XG5cbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxuICBwcmVwZW5kTGlzdGVuZXIoZGVzdCwgJ2Vycm9yJywgb25lcnJvcik7XG5cbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cbiAgZnVuY3Rpb24gb25jbG9zZSgpIHtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XG4gICAgdW5waXBlKCk7XG4gIH1cbiAgZGVzdC5vbmNlKCdjbG9zZScsIG9uY2xvc2UpO1xuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcbiAgICBkZWJ1Zygnb25maW5pc2gnKTtcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xuICAgIHVucGlwZSgpO1xuICB9XG4gIGRlc3Qub25jZSgnZmluaXNoJywgb25maW5pc2gpO1xuXG4gIGZ1bmN0aW9uIHVucGlwZSgpIHtcbiAgICBkZWJ1ZygndW5waXBlJyk7XG4gICAgc3JjLnVucGlwZShkZXN0KTtcbiAgfVxuXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXG4gIGRlc3QuZW1pdCgncGlwZScsIHNyYyk7XG5cbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxuICBpZiAoIXN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGlwZSByZXN1bWUnKTtcbiAgICBzcmMucmVzdW1lKCk7XG4gIH1cblxuICByZXR1cm4gZGVzdDtcbn07XG5cbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzdGF0ZSA9IHNyYy5fcmVhZGFibGVTdGF0ZTtcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcbiAgICBpZiAoc3RhdGUuYXdhaXREcmFpbikgc3RhdGUuYXdhaXREcmFpbi0tO1xuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluID09PSAwICYmIEVFbGlzdGVuZXJDb3VudChzcmMsICdkYXRhJykpIHtcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xuICAgICAgZmxvdyhzcmMpO1xuICAgIH1cbiAgfTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIHZhciB1bnBpcGVJbmZvID0geyBoYXNVbnBpcGVkOiBmYWxzZSB9O1xuXG4gIC8vIGlmIHdlJ3JlIG5vdCBwaXBpbmcgYW55d2hlcmUsIHRoZW4gZG8gbm90aGluZy5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDApIHJldHVybiB0aGlzO1xuXG4gIC8vIGp1c3Qgb25lIGRlc3RpbmF0aW9uLiAgbW9zdCBjb21tb24gY2FzZS5cbiAgaWYgKHN0YXRlLnBpcGVzQ291bnQgPT09IDEpIHtcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cbiAgICBpZiAoZGVzdCAmJiBkZXN0ICE9PSBzdGF0ZS5waXBlcykgcmV0dXJuIHRoaXM7XG5cbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcblxuICAgIC8vIGdvdCBhIG1hdGNoLlxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcbiAgICBzdGF0ZS5waXBlc0NvdW50ID0gMDtcbiAgICBzdGF0ZS5mbG93aW5nID0gZmFsc2U7XG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICAvLyBzbG93IGNhc2UuIG11bHRpcGxlIHBpcGUgZGVzdGluYXRpb25zLlxuXG4gIGlmICghZGVzdCkge1xuICAgIC8vIHJlbW92ZSBhbGwuXG4gICAgdmFyIGRlc3RzID0gc3RhdGUucGlwZXM7XG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XG4gICAgc3RhdGUucGlwZXMgPSBudWxsO1xuICAgIHN0YXRlLnBpcGVzQ291bnQgPSAwO1xuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xuICAgIH1yZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vIHRyeSB0byBmaW5kIHRoZSByaWdodCBvbmUuXG4gIHZhciBpbmRleCA9IGluZGV4T2Yoc3RhdGUucGlwZXMsIGRlc3QpO1xuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcblxuICBzdGF0ZS5waXBlcy5zcGxpY2UoaW5kZXgsIDEpO1xuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XG4gIGlmIChzdGF0ZS5waXBlc0NvdW50ID09PSAxKSBzdGF0ZS5waXBlcyA9IHN0YXRlLnBpcGVzWzBdO1xuXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XG5cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG4vLyBzZXQgdXAgZGF0YSBldmVudHMgaWYgdGhleSBhcmUgYXNrZWQgZm9yXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xuUmVhZGFibGUucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKGV2LCBmbikge1xuICB2YXIgcmVzID0gU3RyZWFtLnByb3RvdHlwZS5vbi5jYWxsKHRoaXMsIGV2LCBmbik7XG5cbiAgaWYgKGV2ID09PSAnZGF0YScpIHtcbiAgICAvLyBTdGFydCBmbG93aW5nIG9uIG5leHQgdGljayBpZiBzdHJlYW0gaXNuJ3QgZXhwbGljaXRseSBwYXVzZWRcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcbiAgfSBlbHNlIGlmIChldiA9PT0gJ3JlYWRhYmxlJykge1xuICAgIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xuICAgICAgc3RhdGUucmVhZGFibGVMaXN0ZW5pbmcgPSBzdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xuICAgICAgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcbiAgICAgICAgcHJvY2Vzc05leHRUaWNrKG5SZWFkaW5nTmV4dFRpY2ssIHRoaXMpO1xuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5sZW5ndGgpIHtcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiByZXM7XG59O1xuUmVhZGFibGUucHJvdG90eXBlLmFkZExpc3RlbmVyID0gUmVhZGFibGUucHJvdG90eXBlLm9uO1xuXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcbiAgZGVidWcoJ3JlYWRhYmxlIG5leHR0aWNrIHJlYWQgMCcpO1xuICBzZWxmLnJlYWQoMCk7XG59XG5cbi8vIHBhdXNlKCkgYW5kIHJlc3VtZSgpIGFyZSByZW1uYW50cyBvZiB0aGUgbGVnYWN5IHJlYWRhYmxlIHN0cmVhbSBBUElcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cblJlYWRhYmxlLnByb3RvdHlwZS5yZXN1bWUgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3JlYWRhYmxlU3RhdGU7XG4gIGlmICghc3RhdGUuZmxvd2luZykge1xuICAgIGRlYnVnKCdyZXN1bWUnKTtcbiAgICBzdGF0ZS5mbG93aW5nID0gdHJ1ZTtcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xuICB9XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gcmVzdW1lKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcbiAgICBzdGF0ZS5yZXN1bWVTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhyZXN1bWVfLCBzdHJlYW0sIHN0YXRlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcbiAgaWYgKCFzdGF0ZS5yZWFkaW5nKSB7XG4gICAgZGVidWcoJ3Jlc3VtZSByZWFkIDAnKTtcbiAgICBzdHJlYW0ucmVhZCgwKTtcbiAgfVxuXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xuICBzdGF0ZS5hd2FpdERyYWluID0gMDtcbiAgc3RyZWFtLmVtaXQoJ3Jlc3VtZScpO1xuICBmbG93KHN0cmVhbSk7XG4gIGlmIChzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5yZWFkaW5nKSBzdHJlYW0ucmVhZCgwKTtcbn1cblxuUmVhZGFibGUucHJvdG90eXBlLnBhdXNlID0gZnVuY3Rpb24gKCkge1xuICBkZWJ1ZygnY2FsbCBwYXVzZSBmbG93aW5nPSVqJywgdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nKTtcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcbiAgICBkZWJ1ZygncGF1c2UnKTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5mdW5jdGlvbiBmbG93KHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG4gIGRlYnVnKCdmbG93Jywgc3RhdGUuZmxvd2luZyk7XG4gIHdoaWxlIChzdGF0ZS5mbG93aW5nICYmIHN0cmVhbS5yZWFkKCkgIT09IG51bGwpIHt9XG59XG5cbi8vIHdyYXAgYW4gb2xkLXN0eWxlIHN0cmVhbSBhcyB0aGUgYXN5bmMgZGF0YSBzb3VyY2UuXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXG4vLyBJdCBpcyBhbiB1Z2x5IHVuZm9ydHVuYXRlIG1lc3Mgb2YgaGlzdG9yeS5cblJlYWRhYmxlLnByb3RvdHlwZS53cmFwID0gZnVuY3Rpb24gKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICB2YXIgcGF1c2VkID0gZmFsc2U7XG5cbiAgdmFyIHNlbGYgPSB0aGlzO1xuICBzdHJlYW0ub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcbiAgICBkZWJ1Zygnd3JhcHBlZCBlbmQnKTtcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcbiAgICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XG4gICAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoKSBzZWxmLnB1c2goY2h1bmspO1xuICAgIH1cblxuICAgIHNlbGYucHVzaChudWxsKTtcbiAgfSk7XG5cbiAgc3RyZWFtLm9uKCdkYXRhJywgZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xuICAgIGlmIChzdGF0ZS5kZWNvZGVyKSBjaHVuayA9IHN0YXRlLmRlY29kZXIud3JpdGUoY2h1bmspO1xuXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXG4gICAgaWYgKHN0YXRlLm9iamVjdE1vZGUgJiYgKGNodW5rID09PSBudWxsIHx8IGNodW5rID09PSB1bmRlZmluZWQpKSByZXR1cm47ZWxzZSBpZiAoIXN0YXRlLm9iamVjdE1vZGUgJiYgKCFjaHVuayB8fCAhY2h1bmsubGVuZ3RoKSkgcmV0dXJuO1xuXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XG4gICAgaWYgKCFyZXQpIHtcbiAgICAgIHBhdXNlZCA9IHRydWU7XG4gICAgICBzdHJlYW0ucGF1c2UoKTtcbiAgICB9XG4gIH0pO1xuXG4gIC8vIHByb3h5IGFsbCB0aGUgb3RoZXIgbWV0aG9kcy5cbiAgLy8gaW1wb3J0YW50IHdoZW4gd3JhcHBpbmcgZmlsdGVycyBhbmQgZHVwbGV4ZXMuXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XG4gICAgaWYgKHRoaXNbaV0gPT09IHVuZGVmaW5lZCAmJiB0eXBlb2Ygc3RyZWFtW2ldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICB0aGlzW2ldID0gZnVuY3Rpb24gKG1ldGhvZCkge1xuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgICAgIHJldHVybiBzdHJlYW1bbWV0aG9kXS5hcHBseShzdHJlYW0sIGFyZ3VtZW50cyk7XG4gICAgICAgIH07XG4gICAgICB9KGkpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHByb3h5IGNlcnRhaW4gaW1wb3J0YW50IGV2ZW50cy5cbiAgZm9yICh2YXIgbiA9IDA7IG4gPCBrUHJveHlFdmVudHMubGVuZ3RoOyBuKyspIHtcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCBzZWxmLmVtaXQuYmluZChzZWxmLCBrUHJveHlFdmVudHNbbl0pKTtcbiAgfVxuXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcbiAgLy8gdW5kZXJseWluZyBzdHJlYW0uXG4gIHNlbGYuX3JlYWQgPSBmdW5jdGlvbiAobikge1xuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XG4gICAgaWYgKHBhdXNlZCkge1xuICAgICAgcGF1c2VkID0gZmFsc2U7XG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBzZWxmO1xufTtcblxuLy8gZXhwb3NlZCBmb3IgdGVzdGluZyBwdXJwb3NlcyBvbmx5LlxuUmVhZGFibGUuX2Zyb21MaXN0ID0gZnJvbUxpc3Q7XG5cbi8vIFBsdWNrIG9mZiBuIGJ5dGVzIGZyb20gYW4gYXJyYXkgb2YgYnVmZmVycy5cbi8vIExlbmd0aCBpcyB0aGUgY29tYmluZWQgbGVuZ3RocyBvZiBhbGwgdGhlIGJ1ZmZlcnMgaW4gdGhlIGxpc3QuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0KG4sIHN0YXRlKSB7XG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG5cbiAgdmFyIHJldDtcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldCA9IHN0YXRlLmJ1ZmZlci5zaGlmdCgpO2Vsc2UgaWYgKCFuIHx8IG4gPj0gc3RhdGUubGVuZ3RoKSB7XG4gICAgLy8gcmVhZCBpdCBhbGwsIHRydW5jYXRlIHRoZSBsaXN0XG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xuICAgIHN0YXRlLmJ1ZmZlci5jbGVhcigpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XG4gICAgcmV0ID0gZnJvbUxpc3RQYXJ0aWFsKG4sIHN0YXRlLmJ1ZmZlciwgc3RhdGUuZGVjb2Rlcik7XG4gIH1cblxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBFeHRyYWN0cyBvbmx5IGVub3VnaCBidWZmZXJlZCBkYXRhIHRvIHNhdGlzZnkgdGhlIGFtb3VudCByZXF1ZXN0ZWQuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGZyb21MaXN0UGFydGlhbChuLCBsaXN0LCBoYXNTdHJpbmdzKSB7XG4gIHZhciByZXQ7XG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XG4gICAgLy8gc2xpY2UgaXMgdGhlIHNhbWUgZm9yIGJ1ZmZlcnMgYW5kIHN0cmluZ3NcbiAgICByZXQgPSBsaXN0LmhlYWQuZGF0YS5zbGljZSgwLCBuKTtcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xuICB9IGVsc2UgaWYgKG4gPT09IGxpc3QuaGVhZC5kYXRhLmxlbmd0aCkge1xuICAgIC8vIGZpcnN0IGNodW5rIGlzIGEgcGVyZmVjdCBtYXRjaFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcbiAgfSBlbHNlIHtcbiAgICAvLyByZXN1bHQgc3BhbnMgbW9yZSB0aGFuIG9uZSBidWZmZXJcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcbiAgfVxuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGNoYXJhY3RlcnMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhXG4vLyBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgdmFyIHJldCA9IHAuZGF0YTtcbiAgbiAtPSByZXQubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBzdHIgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IHN0ci5sZW5ndGggPyBzdHIubGVuZ3RoIDogbjtcbiAgICBpZiAobmIgPT09IHN0ci5sZW5ndGgpIHJldCArPSBzdHI7ZWxzZSByZXQgKz0gc3RyLnNsaWNlKDAsIG4pO1xuICAgIG4gLT0gbmI7XG4gICAgaWYgKG4gPT09IDApIHtcbiAgICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkge1xuICAgICAgICArK2M7XG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsaXN0LmhlYWQgPSBwO1xuICAgICAgICBwLmRhdGEgPSBzdHIuc2xpY2UobmIpO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICsrYztcbiAgfVxuICBsaXN0Lmxlbmd0aCAtPSBjO1xuICByZXR1cm4gcmV0O1xufVxuXG4vLyBDb3BpZXMgYSBzcGVjaWZpZWQgYW1vdW50IG9mIGJ5dGVzIGZyb20gdGhlIGxpc3Qgb2YgYnVmZmVyZWQgZGF0YSBjaHVua3MuXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyKG4sIGxpc3QpIHtcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcbiAgdmFyIHAgPSBsaXN0LmhlYWQ7XG4gIHZhciBjID0gMTtcbiAgcC5kYXRhLmNvcHkocmV0KTtcbiAgbiAtPSBwLmRhdGEubGVuZ3RoO1xuICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgIHZhciBidWYgPSBwLmRhdGE7XG4gICAgdmFyIG5iID0gbiA+IGJ1Zi5sZW5ndGggPyBidWYubGVuZ3RoIDogbjtcbiAgICBidWYuY29weShyZXQsIHJldC5sZW5ndGggLSBuLCAwLCBuYik7XG4gICAgbiAtPSBuYjtcbiAgICBpZiAobiA9PT0gMCkge1xuICAgICAgaWYgKG5iID09PSBidWYubGVuZ3RoKSB7XG4gICAgICAgICsrYztcbiAgICAgICAgaWYgKHAubmV4dCkgbGlzdC5oZWFkID0gcC5uZXh0O2Vsc2UgbGlzdC5oZWFkID0gbGlzdC50YWlsID0gbnVsbDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XG4gICAgICAgIHAuZGF0YSA9IGJ1Zi5zbGljZShuYik7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgKytjO1xuICB9XG4gIGxpc3QubGVuZ3RoIC09IGM7XG4gIHJldHVybiByZXQ7XG59XG5cbmZ1bmN0aW9uIGVuZFJlYWRhYmxlKHN0cmVhbSkge1xuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XG5cbiAgLy8gSWYgd2UgZ2V0IGhlcmUgYmVmb3JlIGNvbnN1bWluZyBhbGwgdGhlIGJ5dGVzLCB0aGVuIHRoYXQgaXMgYVxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXG4gIGlmIChzdGF0ZS5sZW5ndGggPiAwKSB0aHJvdyBuZXcgRXJyb3IoJ1wiZW5kUmVhZGFibGUoKVwiIGNhbGxlZCBvbiBub24tZW1wdHkgc3RyZWFtJyk7XG5cbiAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkKSB7XG4gICAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbmRSZWFkYWJsZU5UKHN0YXRlLCBzdHJlYW0pIHtcbiAgLy8gQ2hlY2sgdGhhdCB3ZSBkaWRuJ3QgZ2V0IG9uZSBsYXN0IHVuc2hpZnQuXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcbiAgICBzdGF0ZS5lbmRFbWl0dGVkID0gdHJ1ZTtcbiAgICBzdHJlYW0ucmVhZGFibGUgPSBmYWxzZTtcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZm9yRWFjaCh4cywgZikge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGYoeHNbaV0sIGkpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGluZGV4T2YoeHMsIHgpIHtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB4cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xuICB9XG4gIHJldHVybiAtMTtcbn0iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gYSB0cmFuc2Zvcm0gc3RyZWFtIGlzIGEgcmVhZGFibGUvd3JpdGFibGUgc3RyZWFtIHdoZXJlIHlvdSBkb1xuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcImZpbHRlclwiLFxuLy8gYnV0IHRoYXQncyBub3QgYSBncmVhdCBuYW1lIGZvciBpdCwgc2luY2UgdGhhdCBpbXBsaWVzIGEgdGhpbmcgd2hlcmVcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcbi8vIGJlIGEgdmFsaWQgZXhhbXBsZSBvZiBhIHRyYW5zZm9ybSwgb2YgY291cnNlLilcbi8vXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXG4vLyBuZWNlc3NhcmlseSBzeW1tZXRyaWMgb3Igc3luY2hyb25vdXMgdHJhbnNmb3JtYXRpb24uICBGb3IgZXhhbXBsZSxcbi8vIGEgemxpYiBzdHJlYW0gbWlnaHQgdGFrZSBtdWx0aXBsZSBwbGFpbi10ZXh0IHdyaXRlcygpLCBhbmQgdGhlblxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxuLy9cbi8vIEhlcmUncyBob3cgdGhpcyB3b3Jrczpcbi8vXG4vLyBUaGUgVHJhbnNmb3JtIHN0cmVhbSBoYXMgYWxsIHRoZSBhc3BlY3RzIG9mIHRoZSByZWFkYWJsZSBhbmQgd3JpdGFibGVcbi8vIHN0cmVhbSBjbGFzc2VzLiAgV2hlbiB5b3Ugd3JpdGUoY2h1bmspLCB0aGF0IGNhbGxzIF93cml0ZShjaHVuayxjYilcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcbi8vIGJ1ZmZlcmVkIHVwLiAgV2hlbiB5b3UgY2FsbCByZWFkKCksIHRoYXQgY2FsbHMgX3JlYWQobikgdW50aWxcbi8vIHRoZXJlJ3MgZW5vdWdoIHBlbmRpbmcgcmVhZGFibGUgZGF0YSBidWZmZXJlZCB1cC5cbi8vXG4vLyBJbiBhIHRyYW5zZm9ybSBzdHJlYW0sIHRoZSB3cml0dGVuIGRhdGEgaXMgcGxhY2VkIGluIGEgYnVmZmVyLiAgV2hlblxuLy8gX3JlYWQobikgaXMgY2FsbGVkLCBpdCB0cmFuc2Zvcm1zIHRoZSBxdWV1ZWQgdXAgZGF0YSwgY2FsbGluZyB0aGVcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxuLy8gd3JpdHRlbiBjaHVuayB3b3VsZCByZXN1bHQgaW4gbXVsdGlwbGUgb3V0cHV0IGNodW5rcywgdGhlbiB0aGUgZmlyc3Rcbi8vIG91dHB1dHRlZCBiaXQgY2FsbHMgdGhlIHJlYWRjYiwgYW5kIHN1YnNlcXVlbnQgY2h1bmtzIGp1c3QgZ28gaW50b1xuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5LlxuLy9cbi8vIFRoaXMgd2F5LCBiYWNrLXByZXNzdXJlIGlzIGFjdHVhbGx5IGRldGVybWluZWQgYnkgdGhlIHJlYWRpbmcgc2lkZSxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXG4vLyBhIHBhdGhvbG9naWNhbCBpbmZsYXRlIHR5cGUgb2YgdHJhbnNmb3JtIGNhbiBjYXVzZSBleGNlc3NpdmUgYnVmZmVyaW5nXG4vLyBoZXJlLiAgRm9yIGV4YW1wbGUsIGltYWdpbmUgYSBzdHJlYW0gd2hlcmUgZXZlcnkgYnl0ZSBvZiBpbnB1dCBpc1xuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxuLy8gYnl0ZXMgb2Ygb3V0cHV0LiAgV3JpdGluZyB0aGUgNCBieXRlcyB7ZmYsZmYsZmYsZmZ9IHdvdWxkIHJlc3VsdCBpblxuLy8gMWtiIG9mIGRhdGEgYmVpbmcgb3V0cHV0LiAgSW4gdGhpcyBjYXNlLCB5b3UgY291bGQgd3JpdGUgYSB2ZXJ5IHNtYWxsXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXG4vLyBzdWNoIGEgcGF0aG9sb2dpY2FsIGluZmxhdGluZyBtZWNoYW5pc20sIHRoZXJlJ2QgYmUgbm8gd2F5IHRvIHRlbGxcbi8vIHRoZSBzeXN0ZW0gdG8gc3RvcCBkb2luZyB0aGUgdHJhbnNmb3JtLiAgQSBzaW5nbGUgNE1CIHdyaXRlIGNvdWxkXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5LlxuLy9cbi8vIEhvd2V2ZXIsIGV2ZW4gaW4gc3VjaCBhIHBhdGhvbG9naWNhbCBjYXNlLCBvbmx5IGEgc2luZ2xlIHdyaXR0ZW4gY2h1bmtcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcbi8vIHRoZSByZXN1bHRzIG9mIHRoZSBwcmV2aW91cyB0cmFuc2Zvcm1lZCBjaHVuayB3ZXJlIGNvbnN1bWVkLlxuXG4ndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gVHJhbnNmb3JtO1xuXG52YXIgRHVwbGV4ID0gcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbnV0aWwuaW5oZXJpdHMoVHJhbnNmb3JtLCBEdXBsZXgpO1xuXG5mdW5jdGlvbiBUcmFuc2Zvcm1TdGF0ZShzdHJlYW0pIHtcbiAgdGhpcy5hZnRlclRyYW5zZm9ybSA9IGZ1bmN0aW9uIChlciwgZGF0YSkge1xuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcbiAgfTtcblxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcbiAgdGhpcy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcbiAgdGhpcy53cml0ZWVuY29kaW5nID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gYWZ0ZXJUcmFuc2Zvcm0oc3RyZWFtLCBlciwgZGF0YSkge1xuICB2YXIgdHMgPSBzdHJlYW0uX3RyYW5zZm9ybVN0YXRlO1xuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcblxuICB2YXIgY2IgPSB0cy53cml0ZWNiO1xuXG4gIGlmICghY2IpIHtcbiAgICByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCd3cml0ZSBjYWxsYmFjayBjYWxsZWQgbXVsdGlwbGUgdGltZXMnKSk7XG4gIH1cblxuICB0cy53cml0ZWNodW5rID0gbnVsbDtcbiAgdHMud3JpdGVjYiA9IG51bGw7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICBjYihlcik7XG5cbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xuICBycy5yZWFkaW5nID0gZmFsc2U7XG4gIGlmIChycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykge1xuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBUcmFuc2Zvcm0ob3B0aW9ucykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVHJhbnNmb3JtKSkgcmV0dXJuIG5ldyBUcmFuc2Zvcm0ob3B0aW9ucyk7XG5cbiAgRHVwbGV4LmNhbGwodGhpcywgb3B0aW9ucyk7XG5cbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XG5cbiAgdmFyIHN0cmVhbSA9IHRoaXM7XG5cbiAgLy8gc3RhcnQgb3V0IGFza2luZyBmb3IgYSByZWFkYWJsZSBldmVudCBvbmNlIGRhdGEgaXMgdHJhbnNmb3JtZWQuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcblxuICAvLyB3ZSBoYXZlIGltcGxlbWVudGVkIHRoZSBfcmVhZCBtZXRob2QsIGFuZCBkb25lIHRoZSBvdGhlciB0aGluZ3NcbiAgLy8gdGhhdCBSZWFkYWJsZSB3YW50cyBiZWZvcmUgdGhlIGZpcnN0IF9yZWFkIGNhbGwsIHNvIHVuc2V0IHRoZVxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUuc3luYyA9IGZhbHNlO1xuXG4gIGlmIChvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnRyYW5zZm9ybSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fdHJhbnNmb3JtID0gb3B0aW9ucy50cmFuc2Zvcm07XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcbiAgfVxuXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cbiAgdGhpcy5vbmNlKCdwcmVmaW5pc2gnLCBmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHR5cGVvZiB0aGlzLl9mbHVzaCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmx1c2goZnVuY3Rpb24gKGVyLCBkYXRhKSB7XG4gICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpO1xuICAgIH0pO2Vsc2UgZG9uZShzdHJlYW0pO1xuICB9KTtcbn1cblxuVHJhbnNmb3JtLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZykge1xuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XG4gIHJldHVybiBEdXBsZXgucHJvdG90eXBlLnB1c2guY2FsbCh0aGlzLCBjaHVuaywgZW5jb2RpbmcpO1xufTtcblxuLy8gVGhpcyBpcyB0aGUgcGFydCB3aGVyZSB5b3UgZG8gc3R1ZmYhXG4vLyBvdmVycmlkZSB0aGlzIGZ1bmN0aW9uIGluIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxuLy9cbi8vIENhbGwgYHB1c2gobmV3Q2h1bmspYCB0byBwYXNzIGFsb25nIHRyYW5zZm9ybWVkIG91dHB1dFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cbi8vXG4vLyBDYWxsIGBjYihlcnIpYCB3aGVuIHlvdSBhcmUgZG9uZSB3aXRoIHRoaXMgY2h1bmsuICBJZiB5b3UgcGFzc1xuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxuLy8gbmV2ZXIgY2FsbCBjYigpLCB0aGVuIHlvdSdsbCBuZXZlciBnZXQgYW5vdGhlciBjaHVuay5cblRyYW5zZm9ybS5wcm90b3R5cGUuX3RyYW5zZm9ybSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xuICB2YXIgdHMgPSB0aGlzLl90cmFuc2Zvcm1TdGF0ZTtcbiAgdHMud3JpdGVjYiA9IGNiO1xuICB0cy53cml0ZWNodW5rID0gY2h1bms7XG4gIHRzLndyaXRlZW5jb2RpbmcgPSBlbmNvZGluZztcbiAgaWYgKCF0cy50cmFuc2Zvcm1pbmcpIHtcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xuICAgIGlmICh0cy5uZWVkVHJhbnNmb3JtIHx8IHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB0aGlzLl9yZWFkKHJzLmhpZ2hXYXRlck1hcmspO1xuICB9XG59O1xuXG4vLyBEb2Vzbid0IG1hdHRlciB3aGF0IHRoZSBhcmdzIGFyZSBoZXJlLlxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cbi8vIFRoYXQgd2UgZ290IGhlcmUgbWVhbnMgdGhhdCB0aGUgcmVhZGFibGUgc2lkZSB3YW50cyBtb3JlIGRhdGEuXG5UcmFuc2Zvcm0ucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHRzLndyaXRlY2h1bmsgIT09IG51bGwgJiYgdHMud3JpdGVjYiAmJiAhdHMudHJhbnNmb3JtaW5nKSB7XG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcbiAgICB0aGlzLl90cmFuc2Zvcm0odHMud3JpdGVjaHVuaywgdHMud3JpdGVlbmNvZGluZywgdHMuYWZ0ZXJUcmFuc2Zvcm0pO1xuICB9IGVsc2Uge1xuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cbiAgICAvLyB3aWxsIGdldCBwcm9jZXNzZWQsIG5vdyB0aGF0IHdlJ3ZlIGFza2VkIGZvciBpdC5cbiAgICB0cy5uZWVkVHJhbnNmb3JtID0gdHJ1ZTtcbiAgfVxufTtcblxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcbiAgICBjYihlcnIyKTtcbiAgICBfdGhpcy5lbWl0KCdjbG9zZScpO1xuICB9KTtcbn07XG5cbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xuICBpZiAoZXIpIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG5cbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcblxuICAvLyBpZiB0aGVyZSdzIG5vdGhpbmcgaW4gdGhlIHdyaXRlIGJ1ZmZlciwgdGhlbiB0aGF0IG1lYW5zXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxuICB2YXIgd3MgPSBzdHJlYW0uX3dyaXRhYmxlU3RhdGU7XG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XG5cbiAgaWYgKHdzLmxlbmd0aCkgdGhyb3cgbmV3IEVycm9yKCdDYWxsaW5nIHRyYW5zZm9ybSBkb25lIHdoZW4gd3MubGVuZ3RoICE9IDAnKTtcblxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcblxuICByZXR1cm4gc3RyZWFtLnB1c2gobnVsbCk7XG59IiwiLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXG4vL1xuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcbi8vIFwiU29mdHdhcmVcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcbi8vXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG4vL1xuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1Jcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXG5cbi8vIEEgYml0IHNpbXBsZXIgdGhhbiByZWFkYWJsZSBzdHJlYW1zLlxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXG4vLyB0aGUgZHJhaW4gZXZlbnQgZW1pc3Npb24gYW5kIGJ1ZmZlcmluZy5cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG52YXIgcHJvY2Vzc05leHRUaWNrID0gcmVxdWlyZSgncHJvY2Vzcy1uZXh0aWNrLWFyZ3MnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5tb2R1bGUuZXhwb3J0cyA9IFdyaXRhYmxlO1xuXG4vKiA8cmVwbGFjZW1lbnQ+ICovXG5mdW5jdGlvbiBXcml0ZVJlcShjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHRoaXMuY2h1bmsgPSBjaHVuaztcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xuICB0aGlzLmNhbGxiYWNrID0gY2I7XG4gIHRoaXMubmV4dCA9IG51bGw7XG59XG5cbi8vIEl0IHNlZW1zIGEgbGlua2VkIGxpc3QgYnV0IGl0IGlzIG5vdFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXG5mdW5jdGlvbiBDb3JrZWRSZXF1ZXN0KHN0YXRlKSB7XG4gIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgdGhpcy5uZXh0ID0gbnVsbDtcbiAgdGhpcy5lbnRyeSA9IG51bGw7XG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgIG9uQ29ya2VkRmluaXNoKF90aGlzLCBzdGF0ZSk7XG4gIH07XG59XG4vKiA8L3JlcGxhY2VtZW50PiAqL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGFzeW5jV3JpdGUgPSAhcHJvY2Vzcy5icm93c2VyICYmIFsndjAuMTAnLCAndjAuOS4nXS5pbmRleE9mKHByb2Nlc3MudmVyc2lvbi5zbGljZSgwLCA1KSkgPiAtMSA/IHNldEltbWVkaWF0ZSA6IHByb2Nlc3NOZXh0VGljaztcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIER1cGxleDtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG5Xcml0YWJsZS5Xcml0YWJsZVN0YXRlID0gV3JpdGFibGVTdGF0ZTtcblxuLyo8cmVwbGFjZW1lbnQ+Ki9cbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcbi8qPC9yZXBsYWNlbWVudD4qL1xuXG4vKjxyZXBsYWNlbWVudD4qL1xudmFyIGludGVybmFsVXRpbCA9IHtcbiAgZGVwcmVjYXRlOiByZXF1aXJlKCd1dGlsLWRlcHJlY2F0ZScpXG59O1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8qPHJlcGxhY2VtZW50PiovXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xuZnVuY3Rpb24gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuaykge1xuICByZXR1cm4gQnVmZmVyLmZyb20oY2h1bmspO1xufVxuZnVuY3Rpb24gX2lzVWludDhBcnJheShvYmopIHtcbiAgcmV0dXJuIEJ1ZmZlci5pc0J1ZmZlcihvYmopIHx8IG9iaiBpbnN0YW5jZW9mIE91clVpbnQ4QXJyYXk7XG59XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcblxudXRpbC5pbmhlcml0cyhXcml0YWJsZSwgU3RyZWFtKTtcblxuZnVuY3Rpb24gbm9wKCkge31cblxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcgdG8gaW5kaWNhdGUgd2hldGhlciBvciBub3QgdGhpcyBzdHJlYW1cbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxuICB0aGlzLm9iamVjdE1vZGUgPSAhIW9wdGlvbnMub2JqZWN0TW9kZTtcblxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcblxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggd3JpdGUoKSBzdGFydHMgcmV0dXJuaW5nIGZhbHNlXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXG4gIC8vIHRoZSBlbnRpcmUgYnVmZmVyIGlzIG5vdCBmbHVzaGVkIGltbWVkaWF0ZWx5IG9uIHdyaXRlKClcbiAgdmFyIGh3bSA9IG9wdGlvbnMuaGlnaFdhdGVyTWFyaztcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XG5cbiAgLy8gY2FzdCB0byBpbnRzLlxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XG5cbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxuICB0aGlzLmZpbmFsQ2FsbGVkID0gZmFsc2U7XG5cbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cbiAgdGhpcy5uZWVkRHJhaW4gPSBmYWxzZTtcbiAgLy8gYXQgdGhlIHN0YXJ0IG9mIGNhbGxpbmcgZW5kKClcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcbiAgLy8gd2hlbiBlbmQoKSBoYXMgYmVlbiBjYWxsZWQsIGFuZCByZXR1cm5lZFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxuICB0aGlzLmZpbmlzaGVkID0gZmFsc2U7XG5cbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XG5cbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XG4gIC8vIHRoaXMgaXMgaGVyZSBzbyB0aGF0IHNvbWUgbm9kZS1jb3JlIHN0cmVhbXMgY2FuIG9wdGltaXplIHN0cmluZ1xuICAvLyBoYW5kbGluZyBhdCBhIGxvd2VyIGxldmVsLlxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xuICB0aGlzLmRlY29kZVN0cmluZ3MgPSAhbm9EZWNvZGU7XG5cbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXG4gIC8vIEV2ZXJ5dGhpbmcgZWxzZSBpbiB0aGUgdW5pdmVyc2UgdXNlcyAndXRmOCcsIHRob3VnaC5cbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XG5cbiAgLy8gbm90IGFuIGFjdHVhbCBidWZmZXIgd2Uga2VlcCB0cmFjayBvZiwgYnV0IGEgbWVhc3VyZW1lbnRcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xuICAvLyBzb2NrZXQgb3IgZmlsZS5cbiAgdGhpcy5sZW5ndGggPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBzZWUgd2hlbiB3ZSdyZSBpbiB0aGUgbWlkZGxlIG9mIGEgd3JpdGUuXG4gIHRoaXMud3JpdGluZyA9IGZhbHNlO1xuXG4gIC8vIHdoZW4gdHJ1ZSBhbGwgd3JpdGVzIHdpbGwgYmUgYnVmZmVyZWQgdW50aWwgLnVuY29yaygpIGNhbGxcbiAgdGhpcy5jb3JrZWQgPSAwO1xuXG4gIC8vIGEgZmxhZyB0byBiZSBhYmxlIHRvIHRlbGwgaWYgdGhlIG9ud3JpdGUgY2IgaXMgY2FsbGVkIGltbWVkaWF0ZWx5LFxuICAvLyBvciBvbiBhIGxhdGVyIHRpY2suICBXZSBzZXQgdGhpcyB0byB0cnVlIGF0IGZpcnN0LCBiZWNhdXNlIGFueVxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcImxhdGVyXCIgc2hvdWxkIGdlbmVyYWxseSBhbHNvXG4gIC8vIG5vdCBoYXBwZW4gYmVmb3JlIHRoZSBmaXJzdCB3cml0ZSBjYWxsLlxuICB0aGlzLnN5bmMgPSB0cnVlO1xuXG4gIC8vIGEgZmxhZyB0byBrbm93IGlmIHdlJ3JlIHByb2Nlc3NpbmcgcHJldmlvdXNseSBidWZmZXJlZCBpdGVtcywgd2hpY2hcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcbiAgLy8gZW5kIHVwIGluIGFuIG92ZXJsYXBwZWQgb253cml0ZSBzaXR1YXRpb24uXG4gIHRoaXMuYnVmZmVyUHJvY2Vzc2luZyA9IGZhbHNlO1xuXG4gIC8vIHRoZSBjYWxsYmFjayB0aGF0J3MgcGFzc2VkIHRvIF93cml0ZShjaHVuayxjYilcbiAgdGhpcy5vbndyaXRlID0gZnVuY3Rpb24gKGVyKSB7XG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcbiAgfTtcblxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcbiAgdGhpcy53cml0ZWNiID0gbnVsbDtcblxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXG4gIHRoaXMud3JpdGVsZW4gPSAwO1xuXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgdGhpcy5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcblxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xuICAvLyB0aGlzIG11c3QgYmUgMCBiZWZvcmUgJ2ZpbmlzaCcgY2FuIGJlIGVtaXR0ZWRcbiAgdGhpcy5wZW5kaW5nY2IgPSAwO1xuXG4gIC8vIGVtaXQgcHJlZmluaXNoIGlmIHRoZSBvbmx5IHRoaW5nIHdlJ3JlIHdhaXRpbmcgZm9yIGlzIF93cml0ZSBjYnNcbiAgLy8gVGhpcyBpcyByZWxldmFudCBmb3Igc3luY2hyb25vdXMgVHJhbnNmb3JtIHN0cmVhbXNcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xuXG4gIC8vIFRydWUgaWYgdGhlIGVycm9yIHdhcyBhbHJlYWR5IGVtaXR0ZWQgYW5kIHNob3VsZCBub3QgYmUgdGhyb3duIGFnYWluXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XG5cbiAgLy8gY291bnQgYnVmZmVyZWQgcmVxdWVzdHNcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XG5cbiAgLy8gYWxsb2NhdGUgdGhlIGZpcnN0IENvcmtlZFJlcXVlc3QsIHRoZXJlIGlzIGFsd2F5c1xuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXG4gIHRoaXMuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3QodGhpcyk7XG59XG5cbldyaXRhYmxlU3RhdGUucHJvdG90eXBlLmdldEJ1ZmZlciA9IGZ1bmN0aW9uIGdldEJ1ZmZlcigpIHtcbiAgdmFyIGN1cnJlbnQgPSB0aGlzLmJ1ZmZlcmVkUmVxdWVzdDtcbiAgdmFyIG91dCA9IFtdO1xuICB3aGlsZSAoY3VycmVudCkge1xuICAgIG91dC5wdXNoKGN1cnJlbnQpO1xuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XG4gIH1cbiAgcmV0dXJuIG91dDtcbn07XG5cbihmdW5jdGlvbiAoKSB7XG4gIHRyeSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlU3RhdGUucHJvdG90eXBlLCAnYnVmZmVyJywge1xuICAgICAgZ2V0OiBpbnRlcm5hbFV0aWwuZGVwcmVjYXRlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XG4gICAgICB9LCAnX3dyaXRhYmxlU3RhdGUuYnVmZmVyIGlzIGRlcHJlY2F0ZWQuIFVzZSBfd3JpdGFibGVTdGF0ZS5nZXRCdWZmZXIgJyArICdpbnN0ZWFkLicsICdERVAwMDAzJylcbiAgICB9KTtcbiAgfSBjYXRjaCAoXykge31cbn0pKCk7XG5cbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxuLy8gd2hvc2UgcHJvdG90eXBlIGNoYWluIG9ubHkgcG9pbnRzIHRvIFJlYWRhYmxlLlxudmFyIHJlYWxIYXNJbnN0YW5jZTtcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcbiAgcmVhbEhhc0luc3RhbmNlID0gRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV07XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZSwgU3ltYm9sLmhhc0luc3RhbmNlLCB7XG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcbiAgICAgIGlmIChyZWFsSGFzSW5zdGFuY2UuY2FsbCh0aGlzLCBvYmplY3QpKSByZXR1cm4gdHJ1ZTtcblxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xuICAgIH1cbiAgfSk7XG59IGVsc2Uge1xuICByZWFsSGFzSW5zdGFuY2UgPSBmdW5jdGlvbiAob2JqZWN0KSB7XG4gICAgcmV0dXJuIG9iamVjdCBpbnN0YW5jZW9mIHRoaXM7XG4gIH07XG59XG5cbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcbiAgRHVwbGV4ID0gRHVwbGV4IHx8IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcblxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cbiAgLy8gYHJlYWxIYXNJbnN0YW5jZWAgaXMgbmVjZXNzYXJ5IGJlY2F1c2UgdXNpbmcgcGxhaW4gYGluc3RhbmNlb2ZgXG4gIC8vIHdvdWxkIHJldHVybiBmYWxzZSwgYXMgbm8gYF93cml0YWJsZVN0YXRlYCBwcm9wZXJ0eSBpcyBhdHRhY2hlZC5cblxuICAvLyBUcnlpbmcgdG8gdXNlIHRoZSBjdXN0b20gYGluc3RhbmNlb2ZgIGZvciBXcml0YWJsZSBoZXJlIHdpbGwgYWxzbyBicmVhayB0aGVcbiAgLy8gTm9kZS5qcyBMYXp5VHJhbnNmb3JtIGltcGxlbWVudGF0aW9uLCB3aGljaCBoYXMgYSBub24tdHJpdmlhbCBnZXR0ZXIgZm9yXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cbiAgaWYgKCFyZWFsSGFzSW5zdGFuY2UuY2FsbChXcml0YWJsZSwgdGhpcykgJiYgISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkge1xuICAgIHJldHVybiBuZXcgV3JpdGFibGUob3B0aW9ucyk7XG4gIH1cblxuICB0aGlzLl93cml0YWJsZVN0YXRlID0gbmV3IFdyaXRhYmxlU3RhdGUob3B0aW9ucywgdGhpcyk7XG5cbiAgLy8gbGVnYWN5LlxuICB0aGlzLndyaXRhYmxlID0gdHJ1ZTtcblxuICBpZiAob3B0aW9ucykge1xuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGUgPSBvcHRpb25zLndyaXRlO1xuXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRldiA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fd3JpdGV2ID0gb3B0aW9ucy53cml0ZXY7XG5cbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcblxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5maW5hbCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZmluYWwgPSBvcHRpb25zLmZpbmFsO1xuICB9XG5cbiAgU3RyZWFtLmNhbGwodGhpcyk7XG59XG5cbi8vIE90aGVyd2lzZSBwZW9wbGUgY2FuIHBpcGUgV3JpdGFibGUgc3RyZWFtcywgd2hpY2ggaXMganVzdCB3cm9uZy5cbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xuICB0aGlzLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdDYW5ub3QgcGlwZSwgbm90IHJlYWRhYmxlJykpO1xufTtcblxuZnVuY3Rpb24gd3JpdGVBZnRlckVuZChzdHJlYW0sIGNiKSB7XG4gIHZhciBlciA9IG5ldyBFcnJvcignd3JpdGUgYWZ0ZXIgZW5kJyk7XG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXG4gIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG59XG5cbi8vIENoZWNrcyB0aGF0IGEgdXNlci1zdXBwbGllZCBjaHVuayBpcyB2YWxpZCwgZXNwZWNpYWxseSBmb3IgdGhlIHBhcnRpY3VsYXJcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcbi8vIGFuZCB1bmRlZmluZWQvbm9uLXN0cmluZyB2YWx1ZXMgYXJlIG9ubHkgYWxsb3dlZCBpbiBvYmplY3QgbW9kZS5cbmZ1bmN0aW9uIHZhbGlkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGNiKSB7XG4gIHZhciB2YWxpZCA9IHRydWU7XG4gIHZhciBlciA9IGZhbHNlO1xuXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgIGVyID0gbmV3IFR5cGVFcnJvcignTWF5IG5vdCB3cml0ZSBudWxsIHZhbHVlcyB0byBzdHJlYW0nKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgY2h1bmsgIT09ICdzdHJpbmcnICYmIGNodW5rICE9PSB1bmRlZmluZWQgJiYgIXN0YXRlLm9iamVjdE1vZGUpIHtcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcbiAgfVxuICBpZiAoZXIpIHtcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgdmFsaWQgPSBmYWxzZTtcbiAgfVxuICByZXR1cm4gdmFsaWQ7XG59XG5cbldyaXRhYmxlLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG4gIHZhciByZXQgPSBmYWxzZTtcbiAgdmFyIGlzQnVmID0gX2lzVWludDhBcnJheShjaHVuaykgJiYgIXN0YXRlLm9iamVjdE1vZGU7XG5cbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XG4gICAgY2h1bmsgPSBfdWludDhBcnJheVRvQnVmZmVyKGNodW5rKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICBjYiA9IGVuY29kaW5nO1xuICAgIGVuY29kaW5nID0gbnVsbDtcbiAgfVxuXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xuXG4gIGlmICh0eXBlb2YgY2IgIT09ICdmdW5jdGlvbicpIGNiID0gbm9wO1xuXG4gIGlmIChzdGF0ZS5lbmRlZCkgd3JpdGVBZnRlckVuZCh0aGlzLCBjYik7ZWxzZSBpZiAoaXNCdWYgfHwgdmFsaWRDaHVuayh0aGlzLCBzdGF0ZSwgY2h1bmssIGNiKSkge1xuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcbiAgfVxuXG4gIHJldHVybiByZXQ7XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBzdGF0ZS5jb3JrZWQrKztcbn07XG5cbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XG5cbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xuICAgIHN0YXRlLmNvcmtlZC0tO1xuXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xuICB9XG59O1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuc2V0RGVmYXVsdEVuY29kaW5nID0gZnVuY3Rpb24gc2V0RGVmYXVsdEVuY29kaW5nKGVuY29kaW5nKSB7XG4gIC8vIG5vZGU6OlBhcnNlRW5jb2RpbmcoKSByZXF1aXJlcyBsb3dlciBjYXNlLlxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xuICBpZiAoIShbJ2hleCcsICd1dGY4JywgJ3V0Zi04JywgJ2FzY2lpJywgJ2JpbmFyeScsICdiYXNlNjQnLCAndWNzMicsICd1Y3MtMicsICd1dGYxNmxlJywgJ3V0Zi0xNmxlJywgJ3JhdyddLmluZGV4T2YoKGVuY29kaW5nICsgJycpLnRvTG93ZXJDYXNlKCkpID4gLTEpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGVuY29kaW5nOiAnICsgZW5jb2RpbmcpO1xuICB0aGlzLl93cml0YWJsZVN0YXRlLmRlZmF1bHRFbmNvZGluZyA9IGVuY29kaW5nO1xuICByZXR1cm4gdGhpcztcbn07XG5cbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmIHN0YXRlLmRlY29kZVN0cmluZ3MgIT09IGZhbHNlICYmIHR5cGVvZiBjaHVuayA9PT0gJ3N0cmluZycpIHtcbiAgICBjaHVuayA9IEJ1ZmZlci5mcm9tKGNodW5rLCBlbmNvZGluZyk7XG4gIH1cbiAgcmV0dXJuIGNodW5rO1xufVxuXG4vLyBpZiB3ZSdyZSBhbHJlYWR5IHdyaXRpbmcgc29tZXRoaW5nLCB0aGVuIGp1c3QgcHV0IHRoaXNcbi8vIGluIHRoZSBxdWV1ZSwgYW5kIHdhaXQgb3VyIHR1cm4uICBPdGhlcndpc2UsIGNhbGwgX3dyaXRlXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxuZnVuY3Rpb24gd3JpdGVPckJ1ZmZlcihzdHJlYW0sIHN0YXRlLCBpc0J1ZiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBpZiAoIWlzQnVmKSB7XG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XG4gICAgaWYgKGNodW5rICE9PSBuZXdDaHVuaykge1xuICAgICAgaXNCdWYgPSB0cnVlO1xuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcbiAgICAgIGNodW5rID0gbmV3Q2h1bms7XG4gICAgfVxuICB9XG4gIHZhciBsZW4gPSBzdGF0ZS5vYmplY3RNb2RlID8gMSA6IGNodW5rLmxlbmd0aDtcblxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xuXG4gIHZhciByZXQgPSBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrO1xuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cbiAgaWYgKCFyZXQpIHN0YXRlLm5lZWREcmFpbiA9IHRydWU7XG5cbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XG4gICAgdmFyIGxhc3QgPSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0O1xuICAgIHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3QgPSB7XG4gICAgICBjaHVuazogY2h1bmssXG4gICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICBpc0J1ZjogaXNCdWYsXG4gICAgICBjYWxsYmFjazogY2IsXG4gICAgICBuZXh0OiBudWxsXG4gICAgfTtcbiAgICBpZiAobGFzdCkge1xuICAgICAgbGFzdC5uZXh0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcbiAgICB9XG4gICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0Q291bnQgKz0gMTtcbiAgfSBlbHNlIHtcbiAgICBkb1dyaXRlKHN0cmVhbSwgc3RhdGUsIGZhbHNlLCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpO1xuICB9XG5cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCB3cml0ZXYsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYikge1xuICBzdGF0ZS53cml0ZWxlbiA9IGxlbjtcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xuICBzdGF0ZS53cml0aW5nID0gdHJ1ZTtcbiAgc3RhdGUuc3luYyA9IHRydWU7XG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcbiAgc3RhdGUuc3luYyA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKSB7XG4gIC0tc3RhdGUucGVuZGluZ2NiO1xuXG4gIGlmIChzeW5jKSB7XG4gICAgLy8gZGVmZXIgdGhlIGNhbGxiYWNrIGlmIHdlIGFyZSBiZWluZyBjYWxsZWQgc3luY2hyb25vdXNseVxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXG4gICAgcHJvY2Vzc05leHRUaWNrKGNiLCBlcik7XG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGFuZCBpdCB3aWxsIGFsd2F5cyBoYXBwZW5cbiAgICAvLyBhZnRlciBlcnJvclxuICAgIHByb2Nlc3NOZXh0VGljayhmaW5pc2hNYXliZSwgc3RyZWFtLCBzdGF0ZSk7XG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xuICB9IGVsc2Uge1xuICAgIC8vIHRoZSBjYWxsZXIgZXhwZWN0IHRoaXMgdG8gaGFwcGVuIGJlZm9yZSBpZlxuICAgIC8vIGl0IGlzIGFzeW5jXG4gICAgY2IoZXIpO1xuICAgIHN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYnV0IGZpbmlzaCBtdXN0XG4gICAgLy8gYWx3YXlzIGZvbGxvdyBlcnJvclxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSkge1xuICBzdGF0ZS53cml0aW5nID0gZmFsc2U7XG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xuICBzdGF0ZS5sZW5ndGggLT0gc3RhdGUud3JpdGVsZW47XG4gIHN0YXRlLndyaXRlbGVuID0gMDtcbn1cblxuZnVuY3Rpb24gb253cml0ZShzdHJlYW0sIGVyKSB7XG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcbiAgdmFyIHN5bmMgPSBzdGF0ZS5zeW5jO1xuICB2YXIgY2IgPSBzdGF0ZS53cml0ZWNiO1xuXG4gIG9ud3JpdGVTdGF0ZVVwZGF0ZShzdGF0ZSk7XG5cbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcbiAgICAvLyBDaGVjayBpZiB3ZSdyZSBhY3R1YWxseSByZWFkeSB0byBmaW5pc2gsIGJ1dCBkb24ndCBlbWl0IHlldFxuICAgIHZhciBmaW5pc2hlZCA9IG5lZWRGaW5pc2goc3RhdGUpO1xuXG4gICAgaWYgKCFmaW5pc2hlZCAmJiAhc3RhdGUuY29ya2VkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkge1xuICAgICAgY2xlYXJCdWZmZXIoc3RyZWFtLCBzdGF0ZSk7XG4gICAgfVxuXG4gICAgaWYgKHN5bmMpIHtcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXG4gICAgICBhc3luY1dyaXRlKGFmdGVyV3JpdGUsIHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYik7XG4gICAgICAvKjwvcmVwbGFjZW1lbnQ+Ki9cbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJXcml0ZShzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xuICBpZiAoIWZpbmlzaGVkKSBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSk7XG4gIHN0YXRlLnBlbmRpbmdjYi0tO1xuICBjYigpO1xuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcbn1cblxuLy8gTXVzdCBmb3JjZSBjYWxsYmFjayB0byBiZSBjYWxsZWQgb24gbmV4dFRpY2ssIHNvIHRoYXQgd2UgZG9uJ3Rcbi8vIGVtaXQgJ2RyYWluJyBiZWZvcmUgdGhlIHdyaXRlKCkgY29uc3VtZXIgZ2V0cyB0aGUgJ2ZhbHNlJyByZXR1cm5cbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXG5mdW5jdGlvbiBvbndyaXRlRHJhaW4oc3RyZWFtLCBzdGF0ZSkge1xuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLm5lZWREcmFpbikge1xuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xuICAgIHN0cmVhbS5lbWl0KCdkcmFpbicpO1xuICB9XG59XG5cbi8vIGlmIHRoZXJlJ3Mgc29tZXRoaW5nIGluIHRoZSBidWZmZXIgd2FpdGluZywgdGhlbiBwcm9jZXNzIGl0XG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSB0cnVlO1xuICB2YXIgZW50cnkgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3Q7XG5cbiAgaWYgKHN0cmVhbS5fd3JpdGV2ICYmIGVudHJ5ICYmIGVudHJ5Lm5leHQpIHtcbiAgICAvLyBGYXN0IGNhc2UsIHdyaXRlIGV2ZXJ5dGhpbmcgdXNpbmcgX3dyaXRldigpXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5KGwpO1xuICAgIHZhciBob2xkZXIgPSBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWU7XG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XG5cbiAgICB2YXIgY291bnQgPSAwO1xuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcbiAgICB3aGlsZSAoZW50cnkpIHtcbiAgICAgIGJ1ZmZlcltjb3VudF0gPSBlbnRyeTtcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcbiAgICAgIGVudHJ5ID0gZW50cnkubmV4dDtcbiAgICAgIGNvdW50ICs9IDE7XG4gICAgfVxuICAgIGJ1ZmZlci5hbGxCdWZmZXJzID0gYWxsQnVmZmVycztcblxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcblxuICAgIC8vIGRvV3JpdGUgaXMgYWxtb3N0IGFsd2F5cyBhc3luYywgZGVmZXIgdGhlc2UgdG8gc2F2ZSBhIGJpdCBvZiB0aW1lXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XG4gICAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBob2xkZXIubmV4dDtcbiAgICAgIGhvbGRlci5uZXh0ID0gbnVsbDtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gbmV3IENvcmtlZFJlcXVlc3Qoc3RhdGUpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBTbG93IGNhc2UsIHdyaXRlIGNodW5rcyBvbmUtYnktb25lXG4gICAgd2hpbGUgKGVudHJ5KSB7XG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcbiAgICAgIHZhciBlbmNvZGluZyA9IGVudHJ5LmVuY29kaW5nO1xuICAgICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XG5cbiAgICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmFsc2UsIGxlbiwgY2h1bmssIGVuY29kaW5nLCBjYik7XG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gICAgICAvLyBpZiB3ZSBkaWRuJ3QgY2FsbCB0aGUgb253cml0ZSBpbW1lZGlhdGVseSwgdGhlblxuICAgICAgLy8gaXQgbWVhbnMgdGhhdCB3ZSBuZWVkIHRvIHdhaXQgdW50aWwgaXQgZG9lcy5cbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcbiAgICAgIC8vIGJlaW5nIHByb2Nlc3NlZCwgc28gbW92ZSB0aGUgYnVmZmVyIGNvdW50ZXIgcGFzdCB0aGVtLlxuICAgICAgaWYgKHN0YXRlLndyaXRpbmcpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVudHJ5ID09PSBudWxsKSBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcbiAgfVxuXG4gIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdENvdW50ID0gMDtcbiAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gZW50cnk7XG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcbn1cblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XG4gIGNiKG5ldyBFcnJvcignX3dyaXRlKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xufTtcblxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZXYgPSBudWxsO1xuXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcblxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XG4gICAgY2IgPSBjaHVuaztcbiAgICBjaHVuayA9IG51bGw7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNiID0gZW5jb2Rpbmc7XG4gICAgZW5jb2RpbmcgPSBudWxsO1xuICB9XG5cbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcblxuICAvLyAuZW5kKCkgZnVsbHkgdW5jb3Jrc1xuICBpZiAoc3RhdGUuY29ya2VkKSB7XG4gICAgc3RhdGUuY29ya2VkID0gMTtcbiAgICB0aGlzLnVuY29yaygpO1xuICB9XG5cbiAgLy8gaWdub3JlIHVubmVjZXNzYXJ5IGVuZCgpIGNhbGxzLlxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XG59O1xuXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XG4gIHJldHVybiBzdGF0ZS5lbmRpbmcgJiYgc3RhdGUubGVuZ3RoID09PSAwICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCA9PT0gbnVsbCAmJiAhc3RhdGUuZmluaXNoZWQgJiYgIXN0YXRlLndyaXRpbmc7XG59XG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xuICBzdHJlYW0uX2ZpbmFsKGZ1bmN0aW9uIChlcnIpIHtcbiAgICBzdGF0ZS5wZW5kaW5nY2ItLTtcbiAgICBpZiAoZXJyKSB7XG4gICAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgIH1cbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIHByZWZpbmlzaChzdHJlYW0sIHN0YXRlKSB7XG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XG4gICAgaWYgKHR5cGVvZiBzdHJlYW0uX2ZpbmFsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBzdGF0ZS5wZW5kaW5nY2IrKztcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcbiAgICAgIHByb2Nlc3NOZXh0VGljayhjYWxsRmluYWwsIHN0cmVhbSwgc3RhdGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XG4gICAgICBzdHJlYW0uZW1pdCgncHJlZmluaXNoJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcbiAgdmFyIG5lZWQgPSBuZWVkRmluaXNoKHN0YXRlKTtcbiAgaWYgKG5lZWQpIHtcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XG4gICAgaWYgKHN0YXRlLnBlbmRpbmdjYiA9PT0gMCkge1xuICAgICAgc3RhdGUuZmluaXNoZWQgPSB0cnVlO1xuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmVlZDtcbn1cblxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcbiAgc3RhdGUuZW5kaW5nID0gdHJ1ZTtcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XG4gIGlmIChjYikge1xuICAgIGlmIChzdGF0ZS5maW5pc2hlZCkgcHJvY2Vzc05leHRUaWNrKGNiKTtlbHNlIHN0cmVhbS5vbmNlKCdmaW5pc2gnLCBjYik7XG4gIH1cbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xuICBzdHJlYW0ud3JpdGFibGUgPSBmYWxzZTtcbn1cblxuZnVuY3Rpb24gb25Db3JrZWRGaW5pc2goY29ya1JlcSwgc3RhdGUsIGVycikge1xuICB2YXIgZW50cnkgPSBjb3JrUmVxLmVudHJ5O1xuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcbiAgd2hpbGUgKGVudHJ5KSB7XG4gICAgdmFyIGNiID0gZW50cnkuY2FsbGJhY2s7XG4gICAgc3RhdGUucGVuZGluZ2NiLS07XG4gICAgY2IoZXJyKTtcbiAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XG4gIH1cbiAgaWYgKHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSkge1xuICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZS5uZXh0ID0gY29ya1JlcTtcbiAgfSBlbHNlIHtcbiAgICBzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUgPSBjb3JrUmVxO1xuICB9XG59XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZS5wcm90b3R5cGUsICdkZXN0cm95ZWQnLCB7XG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIGlmICh0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkO1xuICB9LFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgIC8vIHdlIGlnbm9yZSB0aGUgdmFsdWUgaWYgdGhlIHN0cmVhbVxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBiYWNrd2FyZCBjb21wYXRpYmlsaXR5LCB0aGUgdXNlciBpcyBleHBsaWNpdGx5XG4gICAgLy8gbWFuYWdpbmcgZGVzdHJveWVkXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcbiAgfVxufSk7XG5cbldyaXRhYmxlLnByb3RvdHlwZS5kZXN0cm95ID0gZGVzdHJveUltcGwuZGVzdHJveTtcbldyaXRhYmxlLnByb3RvdHlwZS5fdW5kZXN0cm95ID0gZGVzdHJveUltcGwudW5kZXN0cm95O1xuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcbiAgdGhpcy5lbmQoKTtcbiAgY2IoZXJyKTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vKjxyZXBsYWNlbWVudD4qL1xuXG5mdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7IGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7IH0gfVxuXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG4vKjwvcmVwbGFjZW1lbnQ+Ki9cblxuZnVuY3Rpb24gY29weUJ1ZmZlcihzcmMsIHRhcmdldCwgb2Zmc2V0KSB7XG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEJ1ZmZlckxpc3QoKSB7XG4gICAgX2NsYXNzQ2FsbENoZWNrKHRoaXMsIEJ1ZmZlckxpc3QpO1xuXG4gICAgdGhpcy5oZWFkID0gbnVsbDtcbiAgICB0aGlzLnRhaWwgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcbiAgfVxuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IG51bGwgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPiAwKSB0aGlzLnRhaWwubmV4dCA9IGVudHJ5O2Vsc2UgdGhpcy5oZWFkID0gZW50cnk7XG4gICAgdGhpcy50YWlsID0gZW50cnk7XG4gICAgKyt0aGlzLmxlbmd0aDtcbiAgfTtcblxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gdW5zaGlmdCh2KSB7XG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiB0aGlzLmhlYWQgfTtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xuICAgIHRoaXMuaGVhZCA9IGVudHJ5O1xuICAgICsrdGhpcy5sZW5ndGg7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuc2hpZnQgPSBmdW5jdGlvbiBzaGlmdCgpIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcbiAgICB2YXIgcmV0ID0gdGhpcy5oZWFkLmRhdGE7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO2Vsc2UgdGhpcy5oZWFkID0gdGhpcy5oZWFkLm5leHQ7XG4gICAgLS10aGlzLmxlbmd0aDtcbiAgICByZXR1cm4gcmV0O1xuICB9O1xuXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgdGhpcy5oZWFkID0gdGhpcy50YWlsID0gbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IDA7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xuICAgIHZhciBwID0gdGhpcy5oZWFkO1xuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcbiAgICB3aGlsZSAocCA9IHAubmV4dCkge1xuICAgICAgcmV0ICs9IHMgKyBwLmRhdGE7XG4gICAgfXJldHVybiByZXQ7XG4gIH07XG5cbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiBCdWZmZXIuYWxsb2MoMCk7XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxKSByZXR1cm4gdGhpcy5oZWFkLmRhdGE7XG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcbiAgICB2YXIgcCA9IHRoaXMuaGVhZDtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKHApIHtcbiAgICAgIGNvcHlCdWZmZXIocC5kYXRhLCByZXQsIGkpO1xuICAgICAgaSArPSBwLmRhdGEubGVuZ3RoO1xuICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG4gICAgcmV0dXJuIHJldDtcbiAgfTtcblxuICByZXR1cm4gQnVmZmVyTGlzdDtcbn0oKTsiLCIndXNlIHN0cmljdCc7XG5cbi8qPHJlcGxhY2VtZW50PiovXG5cbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xuLyo8L3JlcGxhY2VtZW50PiovXG5cbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcbmZ1bmN0aW9uIGRlc3Ryb3koZXJyLCBjYikge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciByZWFkYWJsZURlc3Ryb3llZCA9IHRoaXMuX3JlYWRhYmxlU3RhdGUgJiYgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG4gIHZhciB3cml0YWJsZURlc3Ryb3llZCA9IHRoaXMuX3dyaXRhYmxlU3RhdGUgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XG5cbiAgaWYgKHJlYWRhYmxlRGVzdHJveWVkIHx8IHdyaXRhYmxlRGVzdHJveWVkKSB7XG4gICAgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH0gZWxzZSBpZiAoZXJyICYmICghdGhpcy5fd3JpdGFibGVTdGF0ZSB8fCAhdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQpKSB7XG4gICAgICBwcm9jZXNzTmV4dFRpY2soZW1pdEVycm9yTlQsIHRoaXMsIGVycik7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIHdlIHNldCBkZXN0cm95ZWQgdG8gdHJ1ZSBiZWZvcmUgZmlyaW5nIGVycm9yIGNhbGxiYWNrcyBpbiBvcmRlclxuICAvLyB0byBtYWtlIGl0IHJlLWVudHJhbmNlIHNhZmUgaW4gY2FzZSBkZXN0cm95KCkgaXMgY2FsbGVkIHdpdGhpbiBjYWxsYmFja3NcblxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkID0gdHJ1ZTtcbiAgfVxuXG4gIC8vIGlmIHRoaXMgaXMgYSBkdXBsZXggc3RyZWFtIG1hcmsgdGhlIHdyaXRhYmxlIHBhcnQgYXMgZGVzdHJveWVkIGFzIHdlbGxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZCA9IHRydWU7XG4gIH1cblxuICB0aGlzLl9kZXN0cm95KGVyciB8fCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgaWYgKCFjYiAmJiBlcnIpIHtcbiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XG4gICAgICBpZiAoX3RoaXMuX3dyaXRhYmxlU3RhdGUpIHtcbiAgICAgICAgX3RoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGNiKSB7XG4gICAgICBjYihlcnIpO1xuICAgIH1cbiAgfSk7XG59XG5cbmZ1bmN0aW9uIHVuZGVzdHJveSgpIHtcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUucmVhZGluZyA9IGZhbHNlO1xuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxuXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmZpbmlzaGVkID0gZmFsc2U7XG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcbiAgc2VsZi5lbWl0KCdlcnJvcicsIGVycik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZXN0cm95OiBkZXN0cm95LFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9yZWFkYWJsZScpLlBhc3NUaHJvdWdoXG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XG5leHBvcnRzLlN0cmVhbSA9IGV4cG9ydHM7XG5leHBvcnRzLlJlYWRhYmxlID0gZXhwb3J0cztcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XG5leHBvcnRzLkR1cGxleCA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XG5leHBvcnRzLlRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fdHJhbnNmb3JtLmpzJyk7XG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL3JlYWRhYmxlJykuVHJhbnNmb3JtXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fd3JpdGFibGUuanMnKTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgaXNFbmNvZGluZyA9IEJ1ZmZlci5pc0VuY29kaW5nIHx8IGZ1bmN0aW9uIChlbmNvZGluZykge1xuICBlbmNvZGluZyA9ICcnICsgZW5jb2Rpbmc7XG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xuICAgIGNhc2UgJ2hleCc6Y2FzZSAndXRmOCc6Y2FzZSAndXRmLTgnOmNhc2UgJ2FzY2lpJzpjYXNlICdiaW5hcnknOmNhc2UgJ2Jhc2U2NCc6Y2FzZSAndWNzMic6Y2FzZSAndWNzLTInOmNhc2UgJ3V0ZjE2bGUnOmNhc2UgJ3V0Zi0xNmxlJzpjYXNlICdyYXcnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcblxuZnVuY3Rpb24gX25vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcbiAgdmFyIHJldHJpZWQ7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgc3dpdGNoIChlbmMpIHtcbiAgICAgIGNhc2UgJ3V0ZjgnOlxuICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xuICAgICAgY2FzZSAndWNzMic6XG4gICAgICBjYXNlICd1Y3MtMic6XG4gICAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcbiAgICAgICAgcmV0dXJuICd1dGYxNmxlJztcbiAgICAgIGNhc2UgJ2xhdGluMSc6XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXR1cm4gJ2xhdGluMSc7XG4gICAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgY2FzZSAnYXNjaWknOlxuICAgICAgY2FzZSAnaGV4JzpcbiAgICAgICAgcmV0dXJuIGVuYztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGlmIChyZXRyaWVkKSByZXR1cm47IC8vIHVuZGVmaW5lZFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIHJldHJpZWQgPSB0cnVlO1xuICAgIH1cbiAgfVxufTtcblxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXG4vLyBtb2R1bGVzIG1vbmtleS1wYXRjaCBpdCB0byBzdXBwb3J0IGFkZGl0aW9uYWwgZW5jb2RpbmdzXG5mdW5jdGlvbiBub3JtYWxpemVFbmNvZGluZyhlbmMpIHtcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcbiAgaWYgKHR5cGVvZiBuZW5jICE9PSAnc3RyaW5nJyAmJiAoQnVmZmVyLmlzRW5jb2RpbmcgPT09IGlzRW5jb2RpbmcgfHwgIWlzRW5jb2RpbmcoZW5jKSkpIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuYyk7XG4gIHJldHVybiBuZW5jIHx8IGVuYztcbn1cblxuLy8gU3RyaW5nRGVjb2RlciBwcm92aWRlcyBhbiBpbnRlcmZhY2UgZm9yIGVmZmljaWVudGx5IHNwbGl0dGluZyBhIHNlcmllcyBvZlxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXG4vLyBjaGFyYWN0ZXJzLlxuZXhwb3J0cy5TdHJpbmdEZWNvZGVyID0gU3RyaW5nRGVjb2RlcjtcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcbiAgdGhpcy5lbmNvZGluZyA9IG5vcm1hbGl6ZUVuY29kaW5nKGVuY29kaW5nKTtcbiAgdmFyIG5iO1xuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcbiAgICBjYXNlICd1dGYxNmxlJzpcbiAgICAgIHRoaXMudGV4dCA9IHV0ZjE2VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICd1dGY4JzpcbiAgICAgIHRoaXMuZmlsbExhc3QgPSB1dGY4RmlsbExhc3Q7XG4gICAgICBuYiA9IDQ7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiYXNlNjQnOlxuICAgICAgdGhpcy50ZXh0ID0gYmFzZTY0VGV4dDtcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xuICAgICAgbmIgPSAzO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRoaXMud3JpdGUgPSBzaW1wbGVXcml0ZTtcbiAgICAgIHRoaXMuZW5kID0gc2ltcGxlRW5kO1xuICAgICAgcmV0dXJuO1xuICB9XG4gIHRoaXMubGFzdE5lZWQgPSAwO1xuICB0aGlzLmxhc3RUb3RhbCA9IDA7XG4gIHRoaXMubGFzdENoYXIgPSBCdWZmZXIuYWxsb2NVbnNhZmUobmIpO1xufVxuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS53cml0ZSA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKGJ1Zi5sZW5ndGggPT09IDApIHJldHVybiAnJztcbiAgdmFyIHI7XG4gIHZhciBpO1xuICBpZiAodGhpcy5sYXN0TmVlZCkge1xuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XG4gICAgaWYgKHIgPT09IHVuZGVmaW5lZCkgcmV0dXJuICcnO1xuICAgIGkgPSB0aGlzLmxhc3ROZWVkO1xuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xuICB9IGVsc2Uge1xuICAgIGkgPSAwO1xuICB9XG4gIGlmIChpIDwgYnVmLmxlbmd0aCkgcmV0dXJuIHIgPyByICsgdGhpcy50ZXh0KGJ1ZiwgaSkgOiB0aGlzLnRleHQoYnVmLCBpKTtcbiAgcmV0dXJuIHIgfHwgJyc7XG59O1xuXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5lbmQgPSB1dGY4RW5kO1xuXG4vLyBSZXR1cm5zIG9ubHkgY29tcGxldGUgY2hhcmFjdGVycyBpbiBhIEJ1ZmZlclxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUudGV4dCA9IHV0ZjhUZXh0O1xuXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIHBhcnRpYWwgbm9uLVVURi04IGNoYXJhY3RlciB1c2luZyBieXRlcyBmcm9tIGEgQnVmZmVyXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS5maWxsTGFzdCA9IGZ1bmN0aW9uIChidWYpIHtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgdGhpcy5sYXN0TmVlZCk7XG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xuICB9XG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHRoaXMubGFzdFRvdGFsIC0gdGhpcy5sYXN0TmVlZCwgMCwgYnVmLmxlbmd0aCk7XG4gIHRoaXMubGFzdE5lZWQgLT0gYnVmLmxlbmd0aDtcbn07XG5cbi8vIENoZWNrcyB0aGUgdHlwZSBvZiBhIFVURi04IGJ5dGUsIHdoZXRoZXIgaXQncyBBU0NJSSwgYSBsZWFkaW5nIGJ5dGUsIG9yIGFcbi8vIGNvbnRpbnVhdGlvbiBieXRlLlxuZnVuY3Rpb24gdXRmOENoZWNrQnl0ZShieXRlKSB7XG4gIGlmIChieXRlIDw9IDB4N0YpIHJldHVybiAwO2Vsc2UgaWYgKGJ5dGUgPj4gNSA9PT0gMHgwNikgcmV0dXJuIDI7ZWxzZSBpZiAoYnl0ZSA+PiA0ID09PSAweDBFKSByZXR1cm4gMztlbHNlIGlmIChieXRlID4+IDMgPT09IDB4MUUpIHJldHVybiA0O1xuICByZXR1cm4gLTE7XG59XG5cbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cbi8vIGluY29tcGxldGUgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIuIFRoZSB0b3RhbCBudW1iZXIgb2YgYnl0ZXMgKDIsIDMsIG9yIDQpXG4vLyBuZWVkZWQgdG8gY29tcGxldGUgdGhlIFVURi04IGNoYXJhY3RlciAoaWYgYXBwbGljYWJsZSkgYXJlIHJldHVybmVkLlxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcbiAgdmFyIGogPSBidWYubGVuZ3RoIC0gMTtcbiAgaWYgKGogPCBpKSByZXR1cm4gMDtcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xuICBpZiAobmIgPj0gMCkge1xuICAgIGlmIChuYiA+IDApIHNlbGYubGFzdE5lZWQgPSBuYiAtIDE7XG4gICAgcmV0dXJuIG5iO1xuICB9XG4gIGlmICgtLWogPCBpKSByZXR1cm4gMDtcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XG4gIGlmIChuYiA+PSAwKSB7XG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMjtcbiAgICByZXR1cm4gbmI7XG4gIH1cbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcbiAgaWYgKG5iID49IDApIHtcbiAgICBpZiAobmIgPiAwKSB7XG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XG4gICAgfVxuICAgIHJldHVybiBuYjtcbiAgfVxuICByZXR1cm4gMDtcbn1cblxuLy8gVmFsaWRhdGVzIGFzIG1hbnkgY29udGludWF0aW9uIGJ5dGVzIGZvciBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIGFzXG4vLyBuZWVkZWQgb3IgYXJlIGF2YWlsYWJsZS4gSWYgd2Ugc2VlIGEgbm9uLWNvbnRpbnVhdGlvbiBieXRlIHdoZXJlIHdlIGV4cGVjdFxuLy8gb25lLCB3ZSBcInJlcGxhY2VcIiB0aGUgdmFsaWRhdGVkIGNvbnRpbnVhdGlvbiBieXRlcyB3ZSd2ZSBzZWVuIHNvIGZhciB3aXRoXG4vLyBVVEYtOCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzICgnXFx1ZmZmZCcpLCB0byBtYXRjaCB2OCdzIFVURi04IGRlY29kaW5nXG4vLyBiZWhhdmlvci4gVGhlIGNvbnRpbnVhdGlvbiBieXRlIGNoZWNrIGlzIGluY2x1ZGVkIHRocmVlIHRpbWVzIGluIHRoZSBjYXNlXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxuLy8gSXQgaXMgYWxzbyBkb25lIHRoaXMgd2F5IGFzIGEgc2xpZ2h0IHBlcmZvcm1hbmNlIGluY3JlYXNlIGluc3RlYWQgb2YgdXNpbmcgYVxuLy8gbG9vcC5cbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XG4gIGlmICgoYnVmWzBdICYgMHhDMCkgIT09IDB4ODApIHtcbiAgICBzZWxmLmxhc3ROZWVkID0gMDtcbiAgICByZXR1cm4gJ1xcdWZmZmQnLnJlcGVhdChwKTtcbiAgfVxuICBpZiAoc2VsZi5sYXN0TmVlZCA+IDEgJiYgYnVmLmxlbmd0aCA+IDEpIHtcbiAgICBpZiAoKGJ1ZlsxXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcbiAgICAgIHJldHVybiAnXFx1ZmZmZCcucmVwZWF0KHAgKyAxKTtcbiAgICB9XG4gICAgaWYgKHNlbGYubGFzdE5lZWQgPiAyICYmIGJ1Zi5sZW5ndGggPiAyKSB7XG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XG4gICAgICAgIHNlbGYubGFzdE5lZWQgPSAyO1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnLnJlcGVhdChwICsgMik7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIEF0dGVtcHRzIHRvIGNvbXBsZXRlIGEgbXVsdGktYnl0ZSBVVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlci5cbmZ1bmN0aW9uIHV0ZjhGaWxsTGFzdChidWYpIHtcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XG4gIHZhciByID0gdXRmOENoZWNrRXh0cmFCeXRlcyh0aGlzLCBidWYsIHApO1xuICBpZiAociAhPT0gdW5kZWZpbmVkKSByZXR1cm4gcjtcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xuICAgIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIHAsIDAsIHRoaXMubGFzdE5lZWQpO1xuICAgIHJldHVybiB0aGlzLmxhc3RDaGFyLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcsIDAsIHRoaXMubGFzdFRvdGFsKTtcbiAgfVxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCBidWYubGVuZ3RoKTtcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xufVxuXG4vLyBSZXR1cm5zIGFsbCBjb21wbGV0ZSBVVEYtOCBjaGFyYWN0ZXJzIGluIGEgQnVmZmVyLiBJZiB0aGUgQnVmZmVyIGVuZGVkIG9uIGFcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGFyZSBhdmFpbGFibGUuXG5mdW5jdGlvbiB1dGY4VGV4dChidWYsIGkpIHtcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xuICBpZiAoIXRoaXMubGFzdE5lZWQpIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjgnLCBpKTtcbiAgdGhpcy5sYXN0VG90YWwgPSB0b3RhbDtcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgMCwgZW5kKTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmOCcsIGksIGVuZCk7XG59XG5cbi8vIEZvciBVVEYtOCwgYSByZXBsYWNlbWVudCBjaGFyYWN0ZXIgZm9yIGVhY2ggYnVmZmVyZWQgYnl0ZSBvZiBhIChwYXJ0aWFsKVxuLy8gY2hhcmFjdGVyIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBvdXRwdXQuXG5mdW5jdGlvbiB1dGY4RW5kKGJ1Zikge1xuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXHVmZmZkJy5yZXBlYXQodGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcbiAgcmV0dXJuIHI7XG59XG5cbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXG4vLyBudW1iZXIgb2YgYnl0ZXMgYXZhaWxhYmxlLCB3ZSBuZWVkIHRvIGNoZWNrIGlmIHdlIGVuZCBvbiBhIGxlYWRpbmcvaGlnaFxuLy8gc3Vycm9nYXRlLiBJbiB0aGF0IGNhc2UsIHdlIG5lZWQgdG8gd2FpdCBmb3IgdGhlIG5leHQgdHdvIGJ5dGVzIGluIG9yZGVyIHRvXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxuZnVuY3Rpb24gdXRmMTZUZXh0KGJ1ZiwgaSkge1xuICBpZiAoKGJ1Zi5sZW5ndGggLSBpKSAlIDIgPT09IDApIHtcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xuICAgIGlmIChyKSB7XG4gICAgICB2YXIgYyA9IHIuY2hhckNvZGVBdChyLmxlbmd0aCAtIDEpO1xuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XG4gICAgICAgIHRoaXMubGFzdE5lZWQgPSAyO1xuICAgICAgICB0aGlzLmxhc3RUb3RhbCA9IDQ7XG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xuICAgICAgICB0aGlzLmxhc3RDaGFyWzFdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIHIuc2xpY2UoMCwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuICB0aGlzLmxhc3ROZWVkID0gMTtcbiAgdGhpcy5sYXN0VG90YWwgPSAyO1xuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGksIGJ1Zi5sZW5ndGggLSAxKTtcbn1cblxuLy8gRm9yIFVURi0xNkxFIHdlIGRvIG5vdCBleHBsaWNpdGx5IGFwcGVuZCBzcGVjaWFsIHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgaWYgd2Vcbi8vIGVuZCBvbiBhIHBhcnRpYWwgY2hhcmFjdGVyLCB3ZSBzaW1wbHkgbGV0IHY4IGhhbmRsZSB0aGF0LlxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHtcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xuICAgIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygndXRmMTZsZScsIDAsIGVuZCk7XG4gIH1cbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XG4gIHZhciBuID0gKGJ1Zi5sZW5ndGggLSBpKSAlIDM7XG4gIGlmIChuID09PSAwKSByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpKTtcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xuICB0aGlzLmxhc3RUb3RhbCA9IDM7XG4gIGlmIChuID09PSAxKSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMl07XG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XG4gIH1cbiAgcmV0dXJuIGJ1Zi50b1N0cmluZygnYmFzZTY0JywgaSwgYnVmLmxlbmd0aCAtIG4pO1xufVxuXG5mdW5jdGlvbiBiYXNlNjRFbmQoYnVmKSB7XG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcbiAgaWYgKHRoaXMubGFzdE5lZWQpIHJldHVybiByICsgdGhpcy5sYXN0Q2hhci50b1N0cmluZygnYmFzZTY0JywgMCwgMyAtIHRoaXMubGFzdE5lZWQpO1xuICByZXR1cm4gcjtcbn1cblxuLy8gUGFzcyBieXRlcyBvbiB0aHJvdWdoIGZvciBzaW5nbGUtYnl0ZSBlbmNvZGluZ3MgKGUuZy4gYXNjaWksIGxhdGluMSwgaGV4KVxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XG4gIHJldHVybiBidWYudG9TdHJpbmcodGhpcy5lbmNvZGluZyk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsZUVuZChidWYpIHtcbiAgcmV0dXJuIGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XG59IiwidmFyIHRyYXZlcnNlID0gbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgcmV0dXJuIG5ldyBUcmF2ZXJzZShvYmopO1xufTtcblxuZnVuY3Rpb24gVHJhdmVyc2UgKG9iaikge1xuICAgIHRoaXMudmFsdWUgPSBvYmo7XG59XG5cblRyYXZlcnNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocHMpIHtcbiAgICB2YXIgbm9kZSA9IHRoaXMudmFsdWU7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIW5vZGUgfHwgIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkge1xuICAgICAgICAgICAgbm9kZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIHJldHVybiBub2RlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLmhhcyA9IGZ1bmN0aW9uIChwcykge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aDsgaSArKykge1xuICAgICAgICB2YXIga2V5ID0gcHNbaV07XG4gICAgICAgIGlmICghbm9kZSB8fCAhaGFzT3duUHJvcGVydHkuY2FsbChub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgbm9kZSA9IG5vZGVba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKHBzLCB2YWx1ZSkge1xuICAgIHZhciBub2RlID0gdGhpcy52YWx1ZTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBzLmxlbmd0aCAtIDE7IGkgKyspIHtcbiAgICAgICAgdmFyIGtleSA9IHBzW2ldO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwobm9kZSwga2V5KSkgbm9kZVtrZXldID0ge307XG4gICAgICAgIG5vZGUgPSBub2RlW2tleV07XG4gICAgfVxuICAgIG5vZGVbcHNbaV1dID0gdmFsdWU7XG4gICAgcmV0dXJuIHZhbHVlO1xufTtcblxuVHJhdmVyc2UucHJvdG90eXBlLm1hcCA9IGZ1bmN0aW9uIChjYikge1xuICAgIHJldHVybiB3YWxrKHRoaXMudmFsdWUsIGNiLCB0cnVlKTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gKGNiKSB7XG4gICAgdGhpcy52YWx1ZSA9IHdhbGsodGhpcy52YWx1ZSwgY2IsIGZhbHNlKTtcbiAgICByZXR1cm4gdGhpcy52YWx1ZTtcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5yZWR1Y2UgPSBmdW5jdGlvbiAoY2IsIGluaXQpIHtcbiAgICB2YXIgc2tpcCA9IGFyZ3VtZW50cy5sZW5ndGggPT09IDE7XG4gICAgdmFyIGFjYyA9IHNraXAgPyB0aGlzLnZhbHVlIDogaW5pdDtcbiAgICB0aGlzLmZvckVhY2goZnVuY3Rpb24gKHgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlzUm9vdCB8fCAhc2tpcCkge1xuICAgICAgICAgICAgYWNjID0gY2IuY2FsbCh0aGlzLCBhY2MsIHgpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGFjYztcbn07XG5cblRyYXZlcnNlLnByb3RvdHlwZS5wYXRocyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgYWNjID0gW107XG4gICAgdGhpcy5mb3JFYWNoKGZ1bmN0aW9uICh4KSB7XG4gICAgICAgIGFjYy5wdXNoKHRoaXMucGF0aCk7IFxuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUubm9kZXMgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIGFjYyA9IFtdO1xuICAgIHRoaXMuZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgICAgICBhY2MucHVzaCh0aGlzLm5vZGUpO1xuICAgIH0pO1xuICAgIHJldHVybiBhY2M7XG59O1xuXG5UcmF2ZXJzZS5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHBhcmVudHMgPSBbXSwgbm9kZXMgPSBbXTtcbiAgICBcbiAgICByZXR1cm4gKGZ1bmN0aW9uIGNsb25lIChzcmMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAocGFyZW50c1tpXSA9PT0gc3JjKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICBpZiAodHlwZW9mIHNyYyA9PT0gJ29iamVjdCcgJiYgc3JjICE9PSBudWxsKSB7XG4gICAgICAgICAgICB2YXIgZHN0ID0gY29weShzcmMpO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnB1c2goc3JjKTtcbiAgICAgICAgICAgIG5vZGVzLnB1c2goZHN0KTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yRWFjaChvYmplY3RLZXlzKHNyYyksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICBkc3Rba2V5XSA9IGNsb25lKHNyY1trZXldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgXG4gICAgICAgICAgICBwYXJlbnRzLnBvcCgpO1xuICAgICAgICAgICAgbm9kZXMucG9wKCk7XG4gICAgICAgICAgICByZXR1cm4gZHN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHNyYztcbiAgICAgICAgfVxuICAgIH0pKHRoaXMudmFsdWUpO1xufTtcblxuZnVuY3Rpb24gd2FsayAocm9vdCwgY2IsIGltbXV0YWJsZSkge1xuICAgIHZhciBwYXRoID0gW107XG4gICAgdmFyIHBhcmVudHMgPSBbXTtcbiAgICB2YXIgYWxpdmUgPSB0cnVlO1xuICAgIFxuICAgIHJldHVybiAoZnVuY3Rpb24gd2Fsa2VyIChub2RlXykge1xuICAgICAgICB2YXIgbm9kZSA9IGltbXV0YWJsZSA/IGNvcHkobm9kZV8pIDogbm9kZV87XG4gICAgICAgIHZhciBtb2RpZmllcnMgPSB7fTtcbiAgICAgICAgXG4gICAgICAgIHZhciBrZWVwR29pbmcgPSB0cnVlO1xuICAgICAgICBcbiAgICAgICAgdmFyIHN0YXRlID0ge1xuICAgICAgICAgICAgbm9kZSA6IG5vZGUsXG4gICAgICAgICAgICBub2RlXyA6IG5vZGVfLFxuICAgICAgICAgICAgcGF0aCA6IFtdLmNvbmNhdChwYXRoKSxcbiAgICAgICAgICAgIHBhcmVudCA6IHBhcmVudHNbcGFyZW50cy5sZW5ndGggLSAxXSxcbiAgICAgICAgICAgIHBhcmVudHMgOiBwYXJlbnRzLFxuICAgICAgICAgICAga2V5IDogcGF0aC5zbGljZSgtMSlbMF0sXG4gICAgICAgICAgICBpc1Jvb3QgOiBwYXRoLmxlbmd0aCA9PT0gMCxcbiAgICAgICAgICAgIGxldmVsIDogcGF0aC5sZW5ndGgsXG4gICAgICAgICAgICBjaXJjdWxhciA6IG51bGwsXG4gICAgICAgICAgICB1cGRhdGUgOiBmdW5jdGlvbiAoeCwgc3RvcEhlcmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIXN0YXRlLmlzUm9vdCkge1xuICAgICAgICAgICAgICAgICAgICBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldID0geDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RhdGUubm9kZSA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHN0b3BIZXJlKSBrZWVwR29pbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAnZGVsZXRlJyA6IGZ1bmN0aW9uIChzdG9wSGVyZSkge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBzdGF0ZS5wYXJlbnQubm9kZVtzdGF0ZS5rZXldO1xuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmVtb3ZlIDogZnVuY3Rpb24gKHN0b3BIZXJlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzQXJyYXkoc3RhdGUucGFyZW50Lm5vZGUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLnBhcmVudC5ub2RlLnNwbGljZShzdGF0ZS5rZXksIDEpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnBhcmVudC5ub2RlW3N0YXRlLmtleV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChzdG9wSGVyZSkga2VlcEdvaW5nID0gZmFsc2U7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAga2V5cyA6IG51bGwsXG4gICAgICAgICAgICBiZWZvcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYmVmb3JlID0gZiB9LFxuICAgICAgICAgICAgYWZ0ZXIgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMuYWZ0ZXIgPSBmIH0sXG4gICAgICAgICAgICBwcmUgOiBmdW5jdGlvbiAoZikgeyBtb2RpZmllcnMucHJlID0gZiB9LFxuICAgICAgICAgICAgcG9zdCA6IGZ1bmN0aW9uIChmKSB7IG1vZGlmaWVycy5wb3N0ID0gZiB9LFxuICAgICAgICAgICAgc3RvcCA6IGZ1bmN0aW9uICgpIHsgYWxpdmUgPSBmYWxzZSB9LFxuICAgICAgICAgICAgYmxvY2sgOiBmdW5jdGlvbiAoKSB7IGtlZXBHb2luZyA9IGZhbHNlIH1cbiAgICAgICAgfTtcbiAgICAgICAgXG4gICAgICAgIGlmICghYWxpdmUpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVN0YXRlKCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBzdGF0ZS5ub2RlID09PSAnb2JqZWN0JyAmJiBzdGF0ZS5ub2RlICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFzdGF0ZS5rZXlzIHx8IHN0YXRlLm5vZGVfICE9PSBzdGF0ZS5ub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBvYmplY3RLZXlzKHN0YXRlLm5vZGUpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHN0YXRlLmlzTGVhZiA9IHN0YXRlLmtleXMubGVuZ3RoID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwYXJlbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJlbnRzW2ldLm5vZGVfID09PSBub2RlXykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGUuY2lyY3VsYXIgPSBwYXJlbnRzW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5pc0xlYWYgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHN0YXRlLmtleXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgXG4gICAgICAgICAgICBzdGF0ZS5ub3RMZWFmID0gIXN0YXRlLmlzTGVhZjtcbiAgICAgICAgICAgIHN0YXRlLm5vdFJvb3QgPSAhc3RhdGUuaXNSb290O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICB1cGRhdGVTdGF0ZSgpO1xuICAgICAgICBcbiAgICAgICAgLy8gdXNlIHJldHVybiB2YWx1ZXMgdG8gdXBkYXRlIGlmIGRlZmluZWRcbiAgICAgICAgdmFyIHJldCA9IGNiLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBpZiAocmV0ICE9PSB1bmRlZmluZWQgJiYgc3RhdGUudXBkYXRlKSBzdGF0ZS51cGRhdGUocmV0KTtcbiAgICAgICAgXG4gICAgICAgIGlmIChtb2RpZmllcnMuYmVmb3JlKSBtb2RpZmllcnMuYmVmb3JlLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgaWYgKCFrZWVwR29pbmcpIHJldHVybiBzdGF0ZTtcbiAgICAgICAgXG4gICAgICAgIGlmICh0eXBlb2Ygc3RhdGUubm9kZSA9PSAnb2JqZWN0J1xuICAgICAgICAmJiBzdGF0ZS5ub2RlICE9PSBudWxsICYmICFzdGF0ZS5jaXJjdWxhcikge1xuICAgICAgICAgICAgcGFyZW50cy5wdXNoKHN0YXRlKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgdXBkYXRlU3RhdGUoKTtcbiAgICAgICAgICAgIFxuICAgICAgICAgICAgZm9yRWFjaChzdGF0ZS5rZXlzLCBmdW5jdGlvbiAoa2V5LCBpKSB7XG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKGtleSk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wcmUpIG1vZGlmaWVycy5wcmUuY2FsbChzdGF0ZSwgc3RhdGUubm9kZVtrZXldLCBrZXkpO1xuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIHZhciBjaGlsZCA9IHdhbGtlcihzdGF0ZS5ub2RlW2tleV0pO1xuICAgICAgICAgICAgICAgIGlmIChpbW11dGFibGUgJiYgaGFzT3duUHJvcGVydHkuY2FsbChzdGF0ZS5ub2RlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRlLm5vZGVba2V5XSA9IGNoaWxkLm5vZGU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgIGNoaWxkLmlzTGFzdCA9IGkgPT0gc3RhdGUua2V5cy5sZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIGNoaWxkLmlzRmlyc3QgPSBpID09IDA7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgaWYgKG1vZGlmaWVycy5wb3N0KSBtb2RpZmllcnMucG9zdC5jYWxsKHN0YXRlLCBjaGlsZCk7XG4gICAgICAgICAgICAgICAgXG4gICAgICAgICAgICAgICAgcGF0aC5wb3AoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcGFyZW50cy5wb3AoKTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgaWYgKG1vZGlmaWVycy5hZnRlcikgbW9kaWZpZXJzLmFmdGVyLmNhbGwoc3RhdGUsIHN0YXRlLm5vZGUpO1xuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHN0YXRlO1xuICAgIH0pKHJvb3QpLm5vZGU7XG59XG5cbmZ1bmN0aW9uIGNvcHkgKHNyYykge1xuICAgIGlmICh0eXBlb2Ygc3JjID09PSAnb2JqZWN0JyAmJiBzcmMgIT09IG51bGwpIHtcbiAgICAgICAgdmFyIGRzdDtcbiAgICAgICAgXG4gICAgICAgIGlmIChpc0FycmF5KHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzRGF0ZShzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgRGF0ZShzcmMuZ2V0VGltZSA/IHNyYy5nZXRUaW1lKCkgOiBzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzUmVnRXhwKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IG5ldyBSZWdFeHAoc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Vycm9yKHNyYykpIHtcbiAgICAgICAgICAgIGRzdCA9IHsgbWVzc2FnZTogc3JjLm1lc3NhZ2UgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0Jvb2xlYW4oc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IEJvb2xlYW4oc3JjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc051bWJlcihzcmMpKSB7XG4gICAgICAgICAgICBkc3QgPSBuZXcgTnVtYmVyKHNyYyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNTdHJpbmcoc3JjKSkge1xuICAgICAgICAgICAgZHN0ID0gbmV3IFN0cmluZyhzcmMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKE9iamVjdC5jcmVhdGUgJiYgT2JqZWN0LmdldFByb3RvdHlwZU9mKSB7XG4gICAgICAgICAgICBkc3QgPSBPYmplY3QuY3JlYXRlKE9iamVjdC5nZXRQcm90b3R5cGVPZihzcmMpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzcmMuY29uc3RydWN0b3IgPT09IE9iamVjdCkge1xuICAgICAgICAgICAgZHN0ID0ge307XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgcHJvdG8gPVxuICAgICAgICAgICAgICAgIChzcmMuY29uc3RydWN0b3IgJiYgc3JjLmNvbnN0cnVjdG9yLnByb3RvdHlwZSlcbiAgICAgICAgICAgICAgICB8fCBzcmMuX19wcm90b19fXG4gICAgICAgICAgICAgICAgfHwge31cbiAgICAgICAgICAgIDtcbiAgICAgICAgICAgIHZhciBUID0gZnVuY3Rpb24gKCkge307XG4gICAgICAgICAgICBULnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICAgICAgZHN0ID0gbmV3IFQ7XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGZvckVhY2gob2JqZWN0S2V5cyhzcmMpLCBmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBkc3Rba2V5XSA9IHNyY1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGRzdDtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gc3JjO1xufVxuXG52YXIgb2JqZWN0S2V5cyA9IE9iamVjdC5rZXlzIHx8IGZ1bmN0aW9uIGtleXMgKG9iaikge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSByZXMucHVzaChrZXkpXG4gICAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIHRvUyAob2JqKSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSB9XG5mdW5jdGlvbiBpc0RhdGUgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IERhdGVdJyB9XG5mdW5jdGlvbiBpc1JlZ0V4cCAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgUmVnRXhwXScgfVxuZnVuY3Rpb24gaXNFcnJvciAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB9XG5mdW5jdGlvbiBpc0Jvb2xlYW4gKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJyB9XG5mdW5jdGlvbiBpc051bWJlciAob2JqKSB7IHJldHVybiB0b1Mob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgfVxuZnVuY3Rpb24gaXNTdHJpbmcgKG9iaikgeyByZXR1cm4gdG9TKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nIH1cblxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkgKHhzKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh4cykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG52YXIgZm9yRWFjaCA9IGZ1bmN0aW9uICh4cywgZm4pIHtcbiAgICBpZiAoeHMuZm9yRWFjaCkgcmV0dXJuIHhzLmZvckVhY2goZm4pXG4gICAgZWxzZSBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZuKHhzW2ldLCBpLCB4cyk7XG4gICAgfVxufTtcblxuZm9yRWFjaChvYmplY3RLZXlzKFRyYXZlcnNlLnByb3RvdHlwZSksIGZ1bmN0aW9uIChrZXkpIHtcbiAgICB0cmF2ZXJzZVtrZXldID0gZnVuY3Rpb24gKG9iaikge1xuICAgICAgICB2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICAgICAgdmFyIHQgPSBuZXcgVHJhdmVyc2Uob2JqKTtcbiAgICAgICAgcmV0dXJuIHRba2V5XS5hcHBseSh0LCBhcmdzKTtcbiAgICB9O1xufSk7XG5cbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5oYXNPd25Qcm9wZXJ0eSB8fCBmdW5jdGlvbiAob2JqLCBrZXkpIHtcbiAgICByZXR1cm4ga2V5IGluIG9iajtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgcHVueWNvZGUgPSByZXF1aXJlKCdwdW55Y29kZScpO1xudmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxuZXhwb3J0cy5wYXJzZSA9IHVybFBhcnNlO1xuZXhwb3J0cy5yZXNvbHZlID0gdXJsUmVzb2x2ZTtcbmV4cG9ydHMucmVzb2x2ZU9iamVjdCA9IHVybFJlc29sdmVPYmplY3Q7XG5leHBvcnRzLmZvcm1hdCA9IHVybEZvcm1hdDtcblxuZXhwb3J0cy5VcmwgPSBVcmw7XG5cbmZ1bmN0aW9uIFVybCgpIHtcbiAgdGhpcy5wcm90b2NvbCA9IG51bGw7XG4gIHRoaXMuc2xhc2hlcyA9IG51bGw7XG4gIHRoaXMuYXV0aCA9IG51bGw7XG4gIHRoaXMuaG9zdCA9IG51bGw7XG4gIHRoaXMucG9ydCA9IG51bGw7XG4gIHRoaXMuaG9zdG5hbWUgPSBudWxsO1xuICB0aGlzLmhhc2ggPSBudWxsO1xuICB0aGlzLnNlYXJjaCA9IG51bGw7XG4gIHRoaXMucXVlcnkgPSBudWxsO1xuICB0aGlzLnBhdGhuYW1lID0gbnVsbDtcbiAgdGhpcy5wYXRoID0gbnVsbDtcbiAgdGhpcy5ocmVmID0gbnVsbDtcbn1cblxuLy8gUmVmZXJlbmNlOiBSRkMgMzk4NiwgUkZDIDE4MDgsIFJGQyAyMzk2XG5cbi8vIGRlZmluZSB0aGVzZSBoZXJlIHNvIGF0IGxlYXN0IHRoZXkgb25seSBoYXZlIHRvIGJlXG4vLyBjb21waWxlZCBvbmNlIG9uIHRoZSBmaXJzdCBtb2R1bGUgbG9hZC5cbnZhciBwcm90b2NvbFBhdHRlcm4gPSAvXihbYS16MC05ListXSs6KS9pLFxuICAgIHBvcnRQYXR0ZXJuID0gLzpbMC05XSokLyxcblxuICAgIC8vIFNwZWNpYWwgY2FzZSBmb3IgYSBzaW1wbGUgcGF0aCBVUkxcbiAgICBzaW1wbGVQYXRoUGF0dGVybiA9IC9eKFxcL1xcLz8oPyFcXC8pW15cXD9cXHNdKikoXFw/W15cXHNdKik/JC8sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyByZXNlcnZlZCBmb3IgZGVsaW1pdGluZyBVUkxzLlxuICAgIC8vIFdlIGFjdHVhbGx5IGp1c3QgYXV0by1lc2NhcGUgdGhlc2UuXG4gICAgZGVsaW1zID0gWyc8JywgJz4nLCAnXCInLCAnYCcsICcgJywgJ1xccicsICdcXG4nLCAnXFx0J10sXG5cbiAgICAvLyBSRkMgMjM5NjogY2hhcmFjdGVycyBub3QgYWxsb3dlZCBmb3IgdmFyaW91cyByZWFzb25zLlxuICAgIHVud2lzZSA9IFsneycsICd9JywgJ3wnLCAnXFxcXCcsICdeJywgJ2AnXS5jb25jYXQoZGVsaW1zKSxcblxuICAgIC8vIEFsbG93ZWQgYnkgUkZDcywgYnV0IGNhdXNlIG9mIFhTUyBhdHRhY2tzLiAgQWx3YXlzIGVzY2FwZSB0aGVzZS5cbiAgICBhdXRvRXNjYXBlID0gWydcXCcnXS5jb25jYXQodW53aXNlKSxcbiAgICAvLyBDaGFyYWN0ZXJzIHRoYXQgYXJlIG5ldmVyIGV2ZXIgYWxsb3dlZCBpbiBhIGhvc3RuYW1lLlxuICAgIC8vIE5vdGUgdGhhdCBhbnkgaW52YWxpZCBjaGFycyBhcmUgYWxzbyBoYW5kbGVkLCBidXQgdGhlc2VcbiAgICAvLyBhcmUgdGhlIG9uZXMgdGhhdCBhcmUgKmV4cGVjdGVkKiB0byBiZSBzZWVuLCBzbyB3ZSBmYXN0LXBhdGhcbiAgICAvLyB0aGVtLlxuICAgIG5vbkhvc3RDaGFycyA9IFsnJScsICcvJywgJz8nLCAnOycsICcjJ10uY29uY2F0KGF1dG9Fc2NhcGUpLFxuICAgIGhvc3RFbmRpbmdDaGFycyA9IFsnLycsICc/JywgJyMnXSxcbiAgICBob3N0bmFtZU1heExlbiA9IDI1NSxcbiAgICBob3N0bmFtZVBhcnRQYXR0ZXJuID0gL15bK2EtejAtOUEtWl8tXXswLDYzfSQvLFxuICAgIGhvc3RuYW1lUGFydFN0YXJ0ID0gL14oWythLXowLTlBLVpfLV17MCw2M30pKC4qKSQvLFxuICAgIC8vIHByb3RvY29scyB0aGF0IGNhbiBhbGxvdyBcInVuc2FmZVwiIGFuZCBcInVud2lzZVwiIGNoYXJzLlxuICAgIHVuc2FmZVByb3RvY29sID0ge1xuICAgICAgJ2phdmFzY3JpcHQnOiB0cnVlLFxuICAgICAgJ2phdmFzY3JpcHQ6JzogdHJ1ZVxuICAgIH0sXG4gICAgLy8gcHJvdG9jb2xzIHRoYXQgbmV2ZXIgaGF2ZSBhIGhvc3RuYW1lLlxuICAgIGhvc3RsZXNzUHJvdG9jb2wgPSB7XG4gICAgICAnamF2YXNjcmlwdCc6IHRydWUsXG4gICAgICAnamF2YXNjcmlwdDonOiB0cnVlXG4gICAgfSxcbiAgICAvLyBwcm90b2NvbHMgdGhhdCBhbHdheXMgY29udGFpbiBhIC8vIGJpdC5cbiAgICBzbGFzaGVkUHJvdG9jb2wgPSB7XG4gICAgICAnaHR0cCc6IHRydWUsXG4gICAgICAnaHR0cHMnOiB0cnVlLFxuICAgICAgJ2Z0cCc6IHRydWUsXG4gICAgICAnZ29waGVyJzogdHJ1ZSxcbiAgICAgICdmaWxlJzogdHJ1ZSxcbiAgICAgICdodHRwOic6IHRydWUsXG4gICAgICAnaHR0cHM6JzogdHJ1ZSxcbiAgICAgICdmdHA6JzogdHJ1ZSxcbiAgICAgICdnb3BoZXI6JzogdHJ1ZSxcbiAgICAgICdmaWxlOic6IHRydWVcbiAgICB9LFxuICAgIHF1ZXJ5c3RyaW5nID0gcmVxdWlyZSgncXVlcnlzdHJpbmcnKTtcblxuZnVuY3Rpb24gdXJsUGFyc2UodXJsLCBwYXJzZVF1ZXJ5U3RyaW5nLCBzbGFzaGVzRGVub3RlSG9zdCkge1xuICBpZiAodXJsICYmIHV0aWwuaXNPYmplY3QodXJsKSAmJiB1cmwgaW5zdGFuY2VvZiBVcmwpIHJldHVybiB1cmw7XG5cbiAgdmFyIHUgPSBuZXcgVXJsO1xuICB1LnBhcnNlKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpO1xuICByZXR1cm4gdTtcbn1cblxuVXJsLnByb3RvdHlwZS5wYXJzZSA9IGZ1bmN0aW9uKHVybCwgcGFyc2VRdWVyeVN0cmluZywgc2xhc2hlc0Rlbm90ZUhvc3QpIHtcbiAgaWYgKCF1dGlsLmlzU3RyaW5nKHVybCkpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUGFyYW1ldGVyICd1cmwnIG11c3QgYmUgYSBzdHJpbmcsIG5vdCBcIiArIHR5cGVvZiB1cmwpO1xuICB9XG5cbiAgLy8gQ29weSBjaHJvbWUsIElFLCBvcGVyYSBiYWNrc2xhc2gtaGFuZGxpbmcgYmVoYXZpb3IuXG4gIC8vIEJhY2sgc2xhc2hlcyBiZWZvcmUgdGhlIHF1ZXJ5IHN0cmluZyBnZXQgY29udmVydGVkIHRvIGZvcndhcmQgc2xhc2hlc1xuICAvLyBTZWU6IGh0dHBzOi8vY29kZS5nb29nbGUuY29tL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD0yNTkxNlxuICB2YXIgcXVlcnlJbmRleCA9IHVybC5pbmRleE9mKCc/JyksXG4gICAgICBzcGxpdHRlciA9XG4gICAgICAgICAgKHF1ZXJ5SW5kZXggIT09IC0xICYmIHF1ZXJ5SW5kZXggPCB1cmwuaW5kZXhPZignIycpKSA/ICc/JyA6ICcjJyxcbiAgICAgIHVTcGxpdCA9IHVybC5zcGxpdChzcGxpdHRlciksXG4gICAgICBzbGFzaFJlZ2V4ID0gL1xcXFwvZztcbiAgdVNwbGl0WzBdID0gdVNwbGl0WzBdLnJlcGxhY2Uoc2xhc2hSZWdleCwgJy8nKTtcbiAgdXJsID0gdVNwbGl0LmpvaW4oc3BsaXR0ZXIpO1xuXG4gIHZhciByZXN0ID0gdXJsO1xuXG4gIC8vIHRyaW0gYmVmb3JlIHByb2NlZWRpbmcuXG4gIC8vIFRoaXMgaXMgdG8gc3VwcG9ydCBwYXJzZSBzdHVmZiBsaWtlIFwiICBodHRwOi8vZm9vLmNvbSAgXFxuXCJcbiAgcmVzdCA9IHJlc3QudHJpbSgpO1xuXG4gIGlmICghc2xhc2hlc0Rlbm90ZUhvc3QgJiYgdXJsLnNwbGl0KCcjJykubGVuZ3RoID09PSAxKSB7XG4gICAgLy8gVHJ5IGZhc3QgcGF0aCByZWdleHBcbiAgICB2YXIgc2ltcGxlUGF0aCA9IHNpbXBsZVBhdGhQYXR0ZXJuLmV4ZWMocmVzdCk7XG4gICAgaWYgKHNpbXBsZVBhdGgpIHtcbiAgICAgIHRoaXMucGF0aCA9IHJlc3Q7XG4gICAgICB0aGlzLmhyZWYgPSByZXN0O1xuICAgICAgdGhpcy5wYXRobmFtZSA9IHNpbXBsZVBhdGhbMV07XG4gICAgICBpZiAoc2ltcGxlUGF0aFsyXSkge1xuICAgICAgICB0aGlzLnNlYXJjaCA9IHNpbXBsZVBhdGhbMl07XG4gICAgICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHF1ZXJ5c3RyaW5nLnBhcnNlKHRoaXMuc2VhcmNoLnN1YnN0cigxKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5xdWVyeSA9IHRoaXMuc2VhcmNoLnN1YnN0cigxKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICAgIHRoaXMuc2VhcmNoID0gJyc7XG4gICAgICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfVxuXG4gIHZhciBwcm90byA9IHByb3RvY29sUGF0dGVybi5leGVjKHJlc3QpO1xuICBpZiAocHJvdG8pIHtcbiAgICBwcm90byA9IHByb3RvWzBdO1xuICAgIHZhciBsb3dlclByb3RvID0gcHJvdG8udG9Mb3dlckNhc2UoKTtcbiAgICB0aGlzLnByb3RvY29sID0gbG93ZXJQcm90bztcbiAgICByZXN0ID0gcmVzdC5zdWJzdHIocHJvdG8ubGVuZ3RoKTtcbiAgfVxuXG4gIC8vIGZpZ3VyZSBvdXQgaWYgaXQncyBnb3QgYSBob3N0XG4gIC8vIHVzZXJAc2VydmVyIGlzICphbHdheXMqIGludGVycHJldGVkIGFzIGEgaG9zdG5hbWUsIGFuZCB1cmxcbiAgLy8gcmVzb2x1dGlvbiB3aWxsIHRyZWF0IC8vZm9vL2JhciBhcyBob3N0PWZvbyxwYXRoPWJhciBiZWNhdXNlIHRoYXQnc1xuICAvLyBob3cgdGhlIGJyb3dzZXIgcmVzb2x2ZXMgcmVsYXRpdmUgVVJMcy5cbiAgaWYgKHNsYXNoZXNEZW5vdGVIb3N0IHx8IHByb3RvIHx8IHJlc3QubWF0Y2goL15cXC9cXC9bXkBcXC9dK0BbXkBcXC9dKy8pKSB7XG4gICAgdmFyIHNsYXNoZXMgPSByZXN0LnN1YnN0cigwLCAyKSA9PT0gJy8vJztcbiAgICBpZiAoc2xhc2hlcyAmJiAhKHByb3RvICYmIGhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dKSkge1xuICAgICAgcmVzdCA9IHJlc3Quc3Vic3RyKDIpO1xuICAgICAgdGhpcy5zbGFzaGVzID0gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICBpZiAoIWhvc3RsZXNzUHJvdG9jb2xbcHJvdG9dICYmXG4gICAgICAoc2xhc2hlcyB8fCAocHJvdG8gJiYgIXNsYXNoZWRQcm90b2NvbFtwcm90b10pKSkge1xuXG4gICAgLy8gdGhlcmUncyBhIGhvc3RuYW1lLlxuICAgIC8vIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiAvLCA/LCA7LCBvciAjIGVuZHMgdGhlIGhvc3QuXG4gICAgLy9cbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBAIGluIHRoZSBob3N0bmFtZSwgdGhlbiBub24taG9zdCBjaGFycyAqYXJlKiBhbGxvd2VkXG4gICAgLy8gdG8gdGhlIGxlZnQgb2YgdGhlIGxhc3QgQCBzaWduLCB1bmxlc3Mgc29tZSBob3N0LWVuZGluZyBjaGFyYWN0ZXJcbiAgICAvLyBjb21lcyAqYmVmb3JlKiB0aGUgQC1zaWduLlxuICAgIC8vIFVSTHMgYXJlIG9ibm94aW91cy5cbiAgICAvL1xuICAgIC8vIGV4OlxuICAgIC8vIGh0dHA6Ly9hQGJAYy8gPT4gdXNlcjphQGIgaG9zdDpjXG4gICAgLy8gaHR0cDovL2FAYj9AYyA9PiB1c2VyOmEgaG9zdDpjIHBhdGg6Lz9AY1xuXG4gICAgLy8gdjAuMTIgVE9ETyhpc2FhY3MpOiBUaGlzIGlzIG5vdCBxdWl0ZSBob3cgQ2hyb21lIGRvZXMgdGhpbmdzLlxuICAgIC8vIFJldmlldyBvdXIgdGVzdCBjYXNlIGFnYWluc3QgYnJvd3NlcnMgbW9yZSBjb21wcmVoZW5zaXZlbHkuXG5cbiAgICAvLyBmaW5kIHRoZSBmaXJzdCBpbnN0YW5jZSBvZiBhbnkgaG9zdEVuZGluZ0NoYXJzXG4gICAgdmFyIGhvc3RFbmQgPSAtMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhvc3RFbmRpbmdDaGFycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGhlYyA9IHJlc3QuaW5kZXhPZihob3N0RW5kaW5nQ2hhcnNbaV0pO1xuICAgICAgaWYgKGhlYyAhPT0gLTEgJiYgKGhvc3RFbmQgPT09IC0xIHx8IGhlYyA8IGhvc3RFbmQpKVxuICAgICAgICBob3N0RW5kID0gaGVjO1xuICAgIH1cblxuICAgIC8vIGF0IHRoaXMgcG9pbnQsIGVpdGhlciB3ZSBoYXZlIGFuIGV4cGxpY2l0IHBvaW50IHdoZXJlIHRoZVxuICAgIC8vIGF1dGggcG9ydGlvbiBjYW5ub3QgZ28gcGFzdCwgb3IgdGhlIGxhc3QgQCBjaGFyIGlzIHRoZSBkZWNpZGVyLlxuICAgIHZhciBhdXRoLCBhdFNpZ247XG4gICAgaWYgKGhvc3RFbmQgPT09IC0xKSB7XG4gICAgICAvLyBhdFNpZ24gY2FuIGJlIGFueXdoZXJlLlxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBhdFNpZ24gbXVzdCBiZSBpbiBhdXRoIHBvcnRpb24uXG4gICAgICAvLyBodHRwOi8vYUBiL2NAZCA9PiBob3N0OmIgYXV0aDphIHBhdGg6L2NAZFxuICAgICAgYXRTaWduID0gcmVzdC5sYXN0SW5kZXhPZignQCcsIGhvc3RFbmQpO1xuICAgIH1cblxuICAgIC8vIE5vdyB3ZSBoYXZlIGEgcG9ydGlvbiB3aGljaCBpcyBkZWZpbml0ZWx5IHRoZSBhdXRoLlxuICAgIC8vIFB1bGwgdGhhdCBvZmYuXG4gICAgaWYgKGF0U2lnbiAhPT0gLTEpIHtcbiAgICAgIGF1dGggPSByZXN0LnNsaWNlKDAsIGF0U2lnbik7XG4gICAgICByZXN0ID0gcmVzdC5zbGljZShhdFNpZ24gKyAxKTtcbiAgICAgIHRoaXMuYXV0aCA9IGRlY29kZVVSSUNvbXBvbmVudChhdXRoKTtcbiAgICB9XG5cbiAgICAvLyB0aGUgaG9zdCBpcyB0aGUgcmVtYWluaW5nIHRvIHRoZSBsZWZ0IG9mIHRoZSBmaXJzdCBub24taG9zdCBjaGFyXG4gICAgaG9zdEVuZCA9IC0xO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9uSG9zdENoYXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgaGVjID0gcmVzdC5pbmRleE9mKG5vbkhvc3RDaGFyc1tpXSk7XG4gICAgICBpZiAoaGVjICE9PSAtMSAmJiAoaG9zdEVuZCA9PT0gLTEgfHwgaGVjIDwgaG9zdEVuZCkpXG4gICAgICAgIGhvc3RFbmQgPSBoZWM7XG4gICAgfVxuICAgIC8vIGlmIHdlIHN0aWxsIGhhdmUgbm90IGhpdCBpdCwgdGhlbiB0aGUgZW50aXJlIHRoaW5nIGlzIGEgaG9zdC5cbiAgICBpZiAoaG9zdEVuZCA9PT0gLTEpXG4gICAgICBob3N0RW5kID0gcmVzdC5sZW5ndGg7XG5cbiAgICB0aGlzLmhvc3QgPSByZXN0LnNsaWNlKDAsIGhvc3RFbmQpO1xuICAgIHJlc3QgPSByZXN0LnNsaWNlKGhvc3RFbmQpO1xuXG4gICAgLy8gcHVsbCBvdXQgcG9ydC5cbiAgICB0aGlzLnBhcnNlSG9zdCgpO1xuXG4gICAgLy8gd2UndmUgaW5kaWNhdGVkIHRoYXQgdGhlcmUgaXMgYSBob3N0bmFtZSxcbiAgICAvLyBzbyBldmVuIGlmIGl0J3MgZW1wdHksIGl0IGhhcyB0byBiZSBwcmVzZW50LlxuICAgIHRoaXMuaG9zdG5hbWUgPSB0aGlzLmhvc3RuYW1lIHx8ICcnO1xuXG4gICAgLy8gaWYgaG9zdG5hbWUgYmVnaW5zIHdpdGggWyBhbmQgZW5kcyB3aXRoIF1cbiAgICAvLyBhc3N1bWUgdGhhdCBpdCdzIGFuIElQdjYgYWRkcmVzcy5cbiAgICB2YXIgaXB2Nkhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZVswXSA9PT0gJ1snICYmXG4gICAgICAgIHRoaXMuaG9zdG5hbWVbdGhpcy5ob3N0bmFtZS5sZW5ndGggLSAxXSA9PT0gJ10nO1xuXG4gICAgLy8gdmFsaWRhdGUgYSBsaXR0bGUuXG4gICAgaWYgKCFpcHY2SG9zdG5hbWUpIHtcbiAgICAgIHZhciBob3N0cGFydHMgPSB0aGlzLmhvc3RuYW1lLnNwbGl0KC9cXC4vKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gaG9zdHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgcGFydCA9IGhvc3RwYXJ0c1tpXTtcbiAgICAgICAgaWYgKCFwYXJ0KSBjb250aW51ZTtcbiAgICAgICAgaWYgKCFwYXJ0Lm1hdGNoKGhvc3RuYW1lUGFydFBhdHRlcm4pKSB7XG4gICAgICAgICAgdmFyIG5ld3BhcnQgPSAnJztcbiAgICAgICAgICBmb3IgKHZhciBqID0gMCwgayA9IHBhcnQubGVuZ3RoOyBqIDwgazsgaisrKSB7XG4gICAgICAgICAgICBpZiAocGFydC5jaGFyQ29kZUF0KGopID4gMTI3KSB7XG4gICAgICAgICAgICAgIC8vIHdlIHJlcGxhY2Ugbm9uLUFTQ0lJIGNoYXIgd2l0aCBhIHRlbXBvcmFyeSBwbGFjZWhvbGRlclxuICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRoaXMgdG8gbWFrZSBzdXJlIHNpemUgb2YgaG9zdG5hbWUgaXMgbm90XG4gICAgICAgICAgICAgIC8vIGJyb2tlbiBieSByZXBsYWNpbmcgbm9uLUFTQ0lJIGJ5IG5vdGhpbmdcbiAgICAgICAgICAgICAgbmV3cGFydCArPSAneCc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBuZXdwYXJ0ICs9IHBhcnRbal07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIC8vIHdlIHRlc3QgYWdhaW4gd2l0aCBBU0NJSSBjaGFyIG9ubHlcbiAgICAgICAgICBpZiAoIW5ld3BhcnQubWF0Y2goaG9zdG5hbWVQYXJ0UGF0dGVybikpIHtcbiAgICAgICAgICAgIHZhciB2YWxpZFBhcnRzID0gaG9zdHBhcnRzLnNsaWNlKDAsIGkpO1xuICAgICAgICAgICAgdmFyIG5vdEhvc3QgPSBob3N0cGFydHMuc2xpY2UoaSArIDEpO1xuICAgICAgICAgICAgdmFyIGJpdCA9IHBhcnQubWF0Y2goaG9zdG5hbWVQYXJ0U3RhcnQpO1xuICAgICAgICAgICAgaWYgKGJpdCkge1xuICAgICAgICAgICAgICB2YWxpZFBhcnRzLnB1c2goYml0WzFdKTtcbiAgICAgICAgICAgICAgbm90SG9zdC51bnNoaWZ0KGJpdFsyXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobm90SG9zdC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgcmVzdCA9ICcvJyArIG5vdEhvc3Quam9pbignLicpICsgcmVzdDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuaG9zdG5hbWUgPSB2YWxpZFBhcnRzLmpvaW4oJy4nKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0aGlzLmhvc3RuYW1lLmxlbmd0aCA+IGhvc3RuYW1lTWF4TGVuKSB7XG4gICAgICB0aGlzLmhvc3RuYW1lID0gJyc7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGhvc3RuYW1lcyBhcmUgYWx3YXlzIGxvd2VyIGNhc2UuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gdGhpcy5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIGlmICghaXB2Nkhvc3RuYW1lKSB7XG4gICAgICAvLyBJRE5BIFN1cHBvcnQ6IFJldHVybnMgYSBwdW55Y29kZWQgcmVwcmVzZW50YXRpb24gb2YgXCJkb21haW5cIi5cbiAgICAgIC8vIEl0IG9ubHkgY29udmVydHMgcGFydHMgb2YgdGhlIGRvbWFpbiBuYW1lIHRoYXRcbiAgICAgIC8vIGhhdmUgbm9uLUFTQ0lJIGNoYXJhY3RlcnMsIGkuZS4gaXQgZG9lc24ndCBtYXR0ZXIgaWZcbiAgICAgIC8vIHlvdSBjYWxsIGl0IHdpdGggYSBkb21haW4gdGhhdCBhbHJlYWR5IGlzIEFTQ0lJLW9ubHkuXG4gICAgICB0aGlzLmhvc3RuYW1lID0gcHVueWNvZGUudG9BU0NJSSh0aGlzLmhvc3RuYW1lKTtcbiAgICB9XG5cbiAgICB2YXIgcCA9IHRoaXMucG9ydCA/ICc6JyArIHRoaXMucG9ydCA6ICcnO1xuICAgIHZhciBoID0gdGhpcy5ob3N0bmFtZSB8fCAnJztcbiAgICB0aGlzLmhvc3QgPSBoICsgcDtcbiAgICB0aGlzLmhyZWYgKz0gdGhpcy5ob3N0O1xuXG4gICAgLy8gc3RyaXAgWyBhbmQgXSBmcm9tIHRoZSBob3N0bmFtZVxuICAgIC8vIHRoZSBob3N0IGZpZWxkIHN0aWxsIHJldGFpbnMgdGhlbSwgdGhvdWdoXG4gICAgaWYgKGlwdjZIb3N0bmFtZSkge1xuICAgICAgdGhpcy5ob3N0bmFtZSA9IHRoaXMuaG9zdG5hbWUuc3Vic3RyKDEsIHRoaXMuaG9zdG5hbWUubGVuZ3RoIC0gMik7XG4gICAgICBpZiAocmVzdFswXSAhPT0gJy8nKSB7XG4gICAgICAgIHJlc3QgPSAnLycgKyByZXN0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIG5vdyByZXN0IGlzIHNldCB0byB0aGUgcG9zdC1ob3N0IHN0dWZmLlxuICAvLyBjaG9wIG9mZiBhbnkgZGVsaW0gY2hhcnMuXG4gIGlmICghdW5zYWZlUHJvdG9jb2xbbG93ZXJQcm90b10pIHtcblxuICAgIC8vIEZpcnN0LCBtYWtlIDEwMCUgc3VyZSB0aGF0IGFueSBcImF1dG9Fc2NhcGVcIiBjaGFycyBnZXRcbiAgICAvLyBlc2NhcGVkLCBldmVuIGlmIGVuY29kZVVSSUNvbXBvbmVudCBkb2Vzbid0IHRoaW5rIHRoZXlcbiAgICAvLyBuZWVkIHRvIGJlLlxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gYXV0b0VzY2FwZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhZSA9IGF1dG9Fc2NhcGVbaV07XG4gICAgICBpZiAocmVzdC5pbmRleE9mKGFlKSA9PT0gLTEpXG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgdmFyIGVzYyA9IGVuY29kZVVSSUNvbXBvbmVudChhZSk7XG4gICAgICBpZiAoZXNjID09PSBhZSkge1xuICAgICAgICBlc2MgPSBlc2NhcGUoYWUpO1xuICAgICAgfVxuICAgICAgcmVzdCA9IHJlc3Quc3BsaXQoYWUpLmpvaW4oZXNjKTtcbiAgICB9XG4gIH1cblxuXG4gIC8vIGNob3Agb2ZmIGZyb20gdGhlIHRhaWwgZmlyc3QuXG4gIHZhciBoYXNoID0gcmVzdC5pbmRleE9mKCcjJyk7XG4gIGlmIChoYXNoICE9PSAtMSkge1xuICAgIC8vIGdvdCBhIGZyYWdtZW50IHN0cmluZy5cbiAgICB0aGlzLmhhc2ggPSByZXN0LnN1YnN0cihoYXNoKTtcbiAgICByZXN0ID0gcmVzdC5zbGljZSgwLCBoYXNoKTtcbiAgfVxuICB2YXIgcW0gPSByZXN0LmluZGV4T2YoJz8nKTtcbiAgaWYgKHFtICE9PSAtMSkge1xuICAgIHRoaXMuc2VhcmNoID0gcmVzdC5zdWJzdHIocW0pO1xuICAgIHRoaXMucXVlcnkgPSByZXN0LnN1YnN0cihxbSArIDEpO1xuICAgIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgICB0aGlzLnF1ZXJ5ID0gcXVlcnlzdHJpbmcucGFyc2UodGhpcy5xdWVyeSk7XG4gICAgfVxuICAgIHJlc3QgPSByZXN0LnNsaWNlKDAsIHFtKTtcbiAgfSBlbHNlIGlmIChwYXJzZVF1ZXJ5U3RyaW5nKSB7XG4gICAgLy8gbm8gcXVlcnkgc3RyaW5nLCBidXQgcGFyc2VRdWVyeVN0cmluZyBzdGlsbCByZXF1ZXN0ZWRcbiAgICB0aGlzLnNlYXJjaCA9ICcnO1xuICAgIHRoaXMucXVlcnkgPSB7fTtcbiAgfVxuICBpZiAocmVzdCkgdGhpcy5wYXRobmFtZSA9IHJlc3Q7XG4gIGlmIChzbGFzaGVkUHJvdG9jb2xbbG93ZXJQcm90b10gJiZcbiAgICAgIHRoaXMuaG9zdG5hbWUgJiYgIXRoaXMucGF0aG5hbWUpIHtcbiAgICB0aGlzLnBhdGhuYW1lID0gJy8nO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICBpZiAodGhpcy5wYXRobmFtZSB8fCB0aGlzLnNlYXJjaCkge1xuICAgIHZhciBwID0gdGhpcy5wYXRobmFtZSB8fCAnJztcbiAgICB2YXIgcyA9IHRoaXMuc2VhcmNoIHx8ICcnO1xuICAgIHRoaXMucGF0aCA9IHAgKyBzO1xuICB9XG5cbiAgLy8gZmluYWxseSwgcmVjb25zdHJ1Y3QgdGhlIGhyZWYgYmFzZWQgb24gd2hhdCBoYXMgYmVlbiB2YWxpZGF0ZWQuXG4gIHRoaXMuaHJlZiA9IHRoaXMuZm9ybWF0KCk7XG4gIHJldHVybiB0aGlzO1xufTtcblxuLy8gZm9ybWF0IGEgcGFyc2VkIG9iamVjdCBpbnRvIGEgdXJsIHN0cmluZ1xuZnVuY3Rpb24gdXJsRm9ybWF0KG9iaikge1xuICAvLyBlbnN1cmUgaXQncyBhbiBvYmplY3QsIGFuZCBub3QgYSBzdHJpbmcgdXJsLlxuICAvLyBJZiBpdCdzIGFuIG9iaiwgdGhpcyBpcyBhIG5vLW9wLlxuICAvLyB0aGlzIHdheSwgeW91IGNhbiBjYWxsIHVybF9mb3JtYXQoKSBvbiBzdHJpbmdzXG4gIC8vIHRvIGNsZWFuIHVwIHBvdGVudGlhbGx5IHdvbmt5IHVybHMuXG4gIGlmICh1dGlsLmlzU3RyaW5nKG9iaikpIG9iaiA9IHVybFBhcnNlKG9iaik7XG4gIGlmICghKG9iaiBpbnN0YW5jZW9mIFVybCkpIHJldHVybiBVcmwucHJvdG90eXBlLmZvcm1hdC5jYWxsKG9iaik7XG4gIHJldHVybiBvYmouZm9ybWF0KCk7XG59XG5cblVybC5wcm90b3R5cGUuZm9ybWF0ID0gZnVuY3Rpb24oKSB7XG4gIHZhciBhdXRoID0gdGhpcy5hdXRoIHx8ICcnO1xuICBpZiAoYXV0aCkge1xuICAgIGF1dGggPSBlbmNvZGVVUklDb21wb25lbnQoYXV0aCk7XG4gICAgYXV0aCA9IGF1dGgucmVwbGFjZSgvJTNBL2ksICc6Jyk7XG4gICAgYXV0aCArPSAnQCc7XG4gIH1cblxuICB2YXIgcHJvdG9jb2wgPSB0aGlzLnByb3RvY29sIHx8ICcnLFxuICAgICAgcGF0aG5hbWUgPSB0aGlzLnBhdGhuYW1lIHx8ICcnLFxuICAgICAgaGFzaCA9IHRoaXMuaGFzaCB8fCAnJyxcbiAgICAgIGhvc3QgPSBmYWxzZSxcbiAgICAgIHF1ZXJ5ID0gJyc7XG5cbiAgaWYgKHRoaXMuaG9zdCkge1xuICAgIGhvc3QgPSBhdXRoICsgdGhpcy5ob3N0O1xuICB9IGVsc2UgaWYgKHRoaXMuaG9zdG5hbWUpIHtcbiAgICBob3N0ID0gYXV0aCArICh0aGlzLmhvc3RuYW1lLmluZGV4T2YoJzonKSA9PT0gLTEgP1xuICAgICAgICB0aGlzLmhvc3RuYW1lIDpcbiAgICAgICAgJ1snICsgdGhpcy5ob3N0bmFtZSArICddJyk7XG4gICAgaWYgKHRoaXMucG9ydCkge1xuICAgICAgaG9zdCArPSAnOicgKyB0aGlzLnBvcnQ7XG4gICAgfVxuICB9XG5cbiAgaWYgKHRoaXMucXVlcnkgJiZcbiAgICAgIHV0aWwuaXNPYmplY3QodGhpcy5xdWVyeSkgJiZcbiAgICAgIE9iamVjdC5rZXlzKHRoaXMucXVlcnkpLmxlbmd0aCkge1xuICAgIHF1ZXJ5ID0gcXVlcnlzdHJpbmcuc3RyaW5naWZ5KHRoaXMucXVlcnkpO1xuICB9XG5cbiAgdmFyIHNlYXJjaCA9IHRoaXMuc2VhcmNoIHx8IChxdWVyeSAmJiAoJz8nICsgcXVlcnkpKSB8fCAnJztcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuc3Vic3RyKC0xKSAhPT0gJzonKSBwcm90b2NvbCArPSAnOic7XG5cbiAgLy8gb25seSB0aGUgc2xhc2hlZFByb3RvY29scyBnZXQgdGhlIC8vLiAgTm90IG1haWx0bzosIHhtcHA6LCBldGMuXG4gIC8vIHVubGVzcyB0aGV5IGhhZCB0aGVtIHRvIGJlZ2luIHdpdGguXG4gIGlmICh0aGlzLnNsYXNoZXMgfHxcbiAgICAgICghcHJvdG9jb2wgfHwgc2xhc2hlZFByb3RvY29sW3Byb3RvY29sXSkgJiYgaG9zdCAhPT0gZmFsc2UpIHtcbiAgICBob3N0ID0gJy8vJyArIChob3N0IHx8ICcnKTtcbiAgICBpZiAocGF0aG5hbWUgJiYgcGF0aG5hbWUuY2hhckF0KDApICE9PSAnLycpIHBhdGhuYW1lID0gJy8nICsgcGF0aG5hbWU7XG4gIH0gZWxzZSBpZiAoIWhvc3QpIHtcbiAgICBob3N0ID0gJyc7XG4gIH1cblxuICBpZiAoaGFzaCAmJiBoYXNoLmNoYXJBdCgwKSAhPT0gJyMnKSBoYXNoID0gJyMnICsgaGFzaDtcbiAgaWYgKHNlYXJjaCAmJiBzZWFyY2guY2hhckF0KDApICE9PSAnPycpIHNlYXJjaCA9ICc/JyArIHNlYXJjaDtcblxuICBwYXRobmFtZSA9IHBhdGhuYW1lLnJlcGxhY2UoL1s/I10vZywgZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gZW5jb2RlVVJJQ29tcG9uZW50KG1hdGNoKTtcbiAgfSk7XG4gIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKCcjJywgJyUyMycpO1xuXG4gIHJldHVybiBwcm90b2NvbCArIGhvc3QgKyBwYXRobmFtZSArIHNlYXJjaCArIGhhc2g7XG59O1xuXG5mdW5jdGlvbiB1cmxSZXNvbHZlKHNvdXJjZSwgcmVsYXRpdmUpIHtcbiAgcmV0dXJuIHVybFBhcnNlKHNvdXJjZSwgZmFsc2UsIHRydWUpLnJlc29sdmUocmVsYXRpdmUpO1xufVxuXG5VcmwucHJvdG90eXBlLnJlc29sdmUgPSBmdW5jdGlvbihyZWxhdGl2ZSkge1xuICByZXR1cm4gdGhpcy5yZXNvbHZlT2JqZWN0KHVybFBhcnNlKHJlbGF0aXZlLCBmYWxzZSwgdHJ1ZSkpLmZvcm1hdCgpO1xufTtcblxuZnVuY3Rpb24gdXJsUmVzb2x2ZU9iamVjdChzb3VyY2UsIHJlbGF0aXZlKSB7XG4gIGlmICghc291cmNlKSByZXR1cm4gcmVsYXRpdmU7XG4gIHJldHVybiB1cmxQYXJzZShzb3VyY2UsIGZhbHNlLCB0cnVlKS5yZXNvbHZlT2JqZWN0KHJlbGF0aXZlKTtcbn1cblxuVXJsLnByb3RvdHlwZS5yZXNvbHZlT2JqZWN0ID0gZnVuY3Rpb24ocmVsYXRpdmUpIHtcbiAgaWYgKHV0aWwuaXNTdHJpbmcocmVsYXRpdmUpKSB7XG4gICAgdmFyIHJlbCA9IG5ldyBVcmwoKTtcbiAgICByZWwucGFyc2UocmVsYXRpdmUsIGZhbHNlLCB0cnVlKTtcbiAgICByZWxhdGl2ZSA9IHJlbDtcbiAgfVxuXG4gIHZhciByZXN1bHQgPSBuZXcgVXJsKCk7XG4gIHZhciB0a2V5cyA9IE9iamVjdC5rZXlzKHRoaXMpO1xuICBmb3IgKHZhciB0ayA9IDA7IHRrIDwgdGtleXMubGVuZ3RoOyB0aysrKSB7XG4gICAgdmFyIHRrZXkgPSB0a2V5c1t0a107XG4gICAgcmVzdWx0W3RrZXldID0gdGhpc1t0a2V5XTtcbiAgfVxuXG4gIC8vIGhhc2ggaXMgYWx3YXlzIG92ZXJyaWRkZW4sIG5vIG1hdHRlciB3aGF0LlxuICAvLyBldmVuIGhyZWY9XCJcIiB3aWxsIHJlbW92ZSBpdC5cbiAgcmVzdWx0Lmhhc2ggPSByZWxhdGl2ZS5oYXNoO1xuXG4gIC8vIGlmIHRoZSByZWxhdGl2ZSB1cmwgaXMgZW1wdHksIHRoZW4gdGhlcmUncyBub3RoaW5nIGxlZnQgdG8gZG8gaGVyZS5cbiAgaWYgKHJlbGF0aXZlLmhyZWYgPT09ICcnKSB7XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8vIGhyZWZzIGxpa2UgLy9mb28vYmFyIGFsd2F5cyBjdXQgdG8gdGhlIHByb3RvY29sLlxuICBpZiAocmVsYXRpdmUuc2xhc2hlcyAmJiAhcmVsYXRpdmUucHJvdG9jb2wpIHtcbiAgICAvLyB0YWtlIGV2ZXJ5dGhpbmcgZXhjZXB0IHRoZSBwcm90b2NvbCBmcm9tIHJlbGF0aXZlXG4gICAgdmFyIHJrZXlzID0gT2JqZWN0LmtleXMocmVsYXRpdmUpO1xuICAgIGZvciAodmFyIHJrID0gMDsgcmsgPCBya2V5cy5sZW5ndGg7IHJrKyspIHtcbiAgICAgIHZhciBya2V5ID0gcmtleXNbcmtdO1xuICAgICAgaWYgKHJrZXkgIT09ICdwcm90b2NvbCcpXG4gICAgICAgIHJlc3VsdFtya2V5XSA9IHJlbGF0aXZlW3JrZXldO1xuICAgIH1cblxuICAgIC8vdXJsUGFyc2UgYXBwZW5kcyB0cmFpbGluZyAvIHRvIHVybHMgbGlrZSBodHRwOi8vd3d3LmV4YW1wbGUuY29tXG4gICAgaWYgKHNsYXNoZWRQcm90b2NvbFtyZXN1bHQucHJvdG9jb2xdICYmXG4gICAgICAgIHJlc3VsdC5ob3N0bmFtZSAmJiAhcmVzdWx0LnBhdGhuYW1lKSB7XG4gICAgICByZXN1bHQucGF0aCA9IHJlc3VsdC5wYXRobmFtZSA9ICcvJztcbiAgICB9XG5cbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgaWYgKHJlbGF0aXZlLnByb3RvY29sICYmIHJlbGF0aXZlLnByb3RvY29sICE9PSByZXN1bHQucHJvdG9jb2wpIHtcbiAgICAvLyBpZiBpdCdzIGEga25vd24gdXJsIHByb3RvY29sLCB0aGVuIGNoYW5naW5nXG4gICAgLy8gdGhlIHByb3RvY29sIGRvZXMgd2VpcmQgdGhpbmdzXG4gICAgLy8gZmlyc3QsIGlmIGl0J3Mgbm90IGZpbGU6LCB0aGVuIHdlIE1VU1QgaGF2ZSBhIGhvc3QsXG4gICAgLy8gYW5kIGlmIHRoZXJlIHdhcyBhIHBhdGhcbiAgICAvLyB0byBiZWdpbiB3aXRoLCB0aGVuIHdlIE1VU1QgaGF2ZSBhIHBhdGguXG4gICAgLy8gaWYgaXQgaXMgZmlsZTosIHRoZW4gdGhlIGhvc3QgaXMgZHJvcHBlZCxcbiAgICAvLyBiZWNhdXNlIHRoYXQncyBrbm93biB0byBiZSBob3N0bGVzcy5cbiAgICAvLyBhbnl0aGluZyBlbHNlIGlzIGFzc3VtZWQgdG8gYmUgYWJzb2x1dGUuXG4gICAgaWYgKCFzbGFzaGVkUHJvdG9jb2xbcmVsYXRpdmUucHJvdG9jb2xdKSB7XG4gICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKHJlbGF0aXZlKTtcbiAgICAgIGZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xuICAgICAgICB2YXIgayA9IGtleXNbdl07XG4gICAgICAgIHJlc3VsdFtrXSA9IHJlbGF0aXZlW2tdO1xuICAgICAgfVxuICAgICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHJlc3VsdC5wcm90b2NvbCA9IHJlbGF0aXZlLnByb3RvY29sO1xuICAgIGlmICghcmVsYXRpdmUuaG9zdCAmJiAhaG9zdGxlc3NQcm90b2NvbFtyZWxhdGl2ZS5wcm90b2NvbF0pIHtcbiAgICAgIHZhciByZWxQYXRoID0gKHJlbGF0aXZlLnBhdGhuYW1lIHx8ICcnKS5zcGxpdCgnLycpO1xuICAgICAgd2hpbGUgKHJlbFBhdGgubGVuZ3RoICYmICEocmVsYXRpdmUuaG9zdCA9IHJlbFBhdGguc2hpZnQoKSkpO1xuICAgICAgaWYgKCFyZWxhdGl2ZS5ob3N0KSByZWxhdGl2ZS5ob3N0ID0gJyc7XG4gICAgICBpZiAoIXJlbGF0aXZlLmhvc3RuYW1lKSByZWxhdGl2ZS5ob3N0bmFtZSA9ICcnO1xuICAgICAgaWYgKHJlbFBhdGhbMF0gIT09ICcnKSByZWxQYXRoLnVuc2hpZnQoJycpO1xuICAgICAgaWYgKHJlbFBhdGgubGVuZ3RoIDwgMikgcmVsUGF0aC51bnNoaWZ0KCcnKTtcbiAgICAgIHJlc3VsdC5wYXRobmFtZSA9IHJlbFBhdGguam9pbignLycpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aG5hbWUgPSByZWxhdGl2ZS5wYXRobmFtZTtcbiAgICB9XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgICByZXN1bHQuaG9zdCA9IHJlbGF0aXZlLmhvc3QgfHwgJyc7XG4gICAgcmVzdWx0LmF1dGggPSByZWxhdGl2ZS5hdXRoO1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9IHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3Q7XG4gICAgcmVzdWx0LnBvcnQgPSByZWxhdGl2ZS5wb3J0O1xuICAgIC8vIHRvIHN1cHBvcnQgaHR0cC5yZXF1ZXN0XG4gICAgaWYgKHJlc3VsdC5wYXRobmFtZSB8fCByZXN1bHQuc2VhcmNoKSB7XG4gICAgICB2YXIgcCA9IHJlc3VsdC5wYXRobmFtZSB8fCAnJztcbiAgICAgIHZhciBzID0gcmVzdWx0LnNlYXJjaCB8fCAnJztcbiAgICAgIHJlc3VsdC5wYXRoID0gcCArIHM7XG4gICAgfVxuICAgIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgICByZXN1bHQuaHJlZiA9IHJlc3VsdC5mb3JtYXQoKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgdmFyIGlzU291cmNlQWJzID0gKHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuY2hhckF0KDApID09PSAnLycpLFxuICAgICAgaXNSZWxBYnMgPSAoXG4gICAgICAgICAgcmVsYXRpdmUuaG9zdCB8fFxuICAgICAgICAgIHJlbGF0aXZlLnBhdGhuYW1lICYmIHJlbGF0aXZlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nXG4gICAgICApLFxuICAgICAgbXVzdEVuZEFicyA9IChpc1JlbEFicyB8fCBpc1NvdXJjZUFicyB8fFxuICAgICAgICAgICAgICAgICAgICAocmVzdWx0Lmhvc3QgJiYgcmVsYXRpdmUucGF0aG5hbWUpKSxcbiAgICAgIHJlbW92ZUFsbERvdHMgPSBtdXN0RW5kQWJzLFxuICAgICAgc3JjUGF0aCA9IHJlc3VsdC5wYXRobmFtZSAmJiByZXN1bHQucGF0aG5hbWUuc3BsaXQoJy8nKSB8fCBbXSxcbiAgICAgIHJlbFBhdGggPSByZWxhdGl2ZS5wYXRobmFtZSAmJiByZWxhdGl2ZS5wYXRobmFtZS5zcGxpdCgnLycpIHx8IFtdLFxuICAgICAgcHN5Y2hvdGljID0gcmVzdWx0LnByb3RvY29sICYmICFzbGFzaGVkUHJvdG9jb2xbcmVzdWx0LnByb3RvY29sXTtcblxuICAvLyBpZiB0aGUgdXJsIGlzIGEgbm9uLXNsYXNoZWQgdXJsLCB0aGVuIHJlbGF0aXZlXG4gIC8vIGxpbmtzIGxpa2UgLi4vLi4gc2hvdWxkIGJlIGFibGVcbiAgLy8gdG8gY3Jhd2wgdXAgdG8gdGhlIGhvc3RuYW1lLCBhcyB3ZWxsLiAgVGhpcyBpcyBzdHJhbmdlLlxuICAvLyByZXN1bHQucHJvdG9jb2wgaGFzIGFscmVhZHkgYmVlbiBzZXQgYnkgbm93LlxuICAvLyBMYXRlciBvbiwgcHV0IHRoZSBmaXJzdCBwYXRoIHBhcnQgaW50byB0aGUgaG9zdCBmaWVsZC5cbiAgaWYgKHBzeWNob3RpYykge1xuICAgIHJlc3VsdC5ob3N0bmFtZSA9ICcnO1xuICAgIHJlc3VsdC5wb3J0ID0gbnVsbDtcbiAgICBpZiAocmVzdWx0Lmhvc3QpIHtcbiAgICAgIGlmIChzcmNQYXRoWzBdID09PSAnJykgc3JjUGF0aFswXSA9IHJlc3VsdC5ob3N0O1xuICAgICAgZWxzZSBzcmNQYXRoLnVuc2hpZnQocmVzdWx0Lmhvc3QpO1xuICAgIH1cbiAgICByZXN1bHQuaG9zdCA9ICcnO1xuICAgIGlmIChyZWxhdGl2ZS5wcm90b2NvbCkge1xuICAgICAgcmVsYXRpdmUuaG9zdG5hbWUgPSBudWxsO1xuICAgICAgcmVsYXRpdmUucG9ydCA9IG51bGw7XG4gICAgICBpZiAocmVsYXRpdmUuaG9zdCkge1xuICAgICAgICBpZiAocmVsUGF0aFswXSA9PT0gJycpIHJlbFBhdGhbMF0gPSByZWxhdGl2ZS5ob3N0O1xuICAgICAgICBlbHNlIHJlbFBhdGgudW5zaGlmdChyZWxhdGl2ZS5ob3N0KTtcbiAgICAgIH1cbiAgICAgIHJlbGF0aXZlLmhvc3QgPSBudWxsO1xuICAgIH1cbiAgICBtdXN0RW5kQWJzID0gbXVzdEVuZEFicyAmJiAocmVsUGF0aFswXSA9PT0gJycgfHwgc3JjUGF0aFswXSA9PT0gJycpO1xuICB9XG5cbiAgaWYgKGlzUmVsQWJzKSB7XG4gICAgLy8gaXQncyBhYnNvbHV0ZS5cbiAgICByZXN1bHQuaG9zdCA9IChyZWxhdGl2ZS5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgPT09ICcnKSA/XG4gICAgICAgICAgICAgICAgICByZWxhdGl2ZS5ob3N0IDogcmVzdWx0Lmhvc3Q7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gKHJlbGF0aXZlLmhvc3RuYW1lIHx8IHJlbGF0aXZlLmhvc3RuYW1lID09PSAnJykgP1xuICAgICAgICAgICAgICAgICAgICAgIHJlbGF0aXZlLmhvc3RuYW1lIDogcmVzdWx0Lmhvc3RuYW1lO1xuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgc3JjUGF0aCA9IHJlbFBhdGg7XG4gICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRoZSBkb3QtaGFuZGxpbmcgYmVsb3cuXG4gIH0gZWxzZSBpZiAocmVsUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBpdCdzIHJlbGF0aXZlXG4gICAgLy8gdGhyb3cgYXdheSB0aGUgZXhpc3RpbmcgZmlsZSwgYW5kIHRha2UgdGhlIG5ldyBwYXRoIGluc3RlYWQuXG4gICAgaWYgKCFzcmNQYXRoKSBzcmNQYXRoID0gW107XG4gICAgc3JjUGF0aC5wb3AoKTtcbiAgICBzcmNQYXRoID0gc3JjUGF0aC5jb25jYXQocmVsUGF0aCk7XG4gICAgcmVzdWx0LnNlYXJjaCA9IHJlbGF0aXZlLnNlYXJjaDtcbiAgICByZXN1bHQucXVlcnkgPSByZWxhdGl2ZS5xdWVyeTtcbiAgfSBlbHNlIGlmICghdXRpbC5pc051bGxPclVuZGVmaW5lZChyZWxhdGl2ZS5zZWFyY2gpKSB7XG4gICAgLy8ganVzdCBwdWxsIG91dCB0aGUgc2VhcmNoLlxuICAgIC8vIGxpa2UgaHJlZj0nP2ZvbycuXG4gICAgLy8gUHV0IHRoaXMgYWZ0ZXIgdGhlIG90aGVyIHR3byBjYXNlcyBiZWNhdXNlIGl0IHNpbXBsaWZpZXMgdGhlIGJvb2xlYW5zXG4gICAgaWYgKHBzeWNob3RpYykge1xuICAgICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBzcmNQYXRoLnNoaWZ0KCk7XG4gICAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgICAvL3RoaXMgZXNwZWNpYWxseSBoYXBwZW5zIGluIGNhc2VzIGxpa2VcbiAgICAgIC8vdXJsLnJlc29sdmVPYmplY3QoJ21haWx0bzpsb2NhbDFAZG9tYWluMScsICdsb2NhbDJAZG9tYWluMicpXG4gICAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQuaG9zdC5zcGxpdCgnQCcpIDogZmFsc2U7XG4gICAgICBpZiAoYXV0aEluSG9zdCkge1xuICAgICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgICAgcmVzdWx0Lmhvc3QgPSByZXN1bHQuaG9zdG5hbWUgPSBhdXRoSW5Ib3N0LnNoaWZ0KCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlc3VsdC5zZWFyY2ggPSByZWxhdGl2ZS5zZWFyY2g7XG4gICAgcmVzdWx0LnF1ZXJ5ID0gcmVsYXRpdmUucXVlcnk7XG4gICAgLy90byBzdXBwb3J0IGh0dHAucmVxdWVzdFxuICAgIGlmICghdXRpbC5pc051bGwocmVzdWx0LnBhdGhuYW1lKSB8fCAhdXRpbC5pc051bGwocmVzdWx0LnNlYXJjaCkpIHtcbiAgICAgIHJlc3VsdC5wYXRoID0gKHJlc3VsdC5wYXRobmFtZSA/IHJlc3VsdC5wYXRobmFtZSA6ICcnKSArXG4gICAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgICB9XG4gICAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIGlmICghc3JjUGF0aC5sZW5ndGgpIHtcbiAgICAvLyBubyBwYXRoIGF0IGFsbC4gIGVhc3kuXG4gICAgLy8gd2UndmUgYWxyZWFkeSBoYW5kbGVkIHRoZSBvdGhlciBzdHVmZiBhYm92ZS5cbiAgICByZXN1bHQucGF0aG5hbWUgPSBudWxsO1xuICAgIC8vdG8gc3VwcG9ydCBodHRwLnJlcXVlc3RcbiAgICBpZiAocmVzdWx0LnNlYXJjaCkge1xuICAgICAgcmVzdWx0LnBhdGggPSAnLycgKyByZXN1bHQuc2VhcmNoO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHQucGF0aCA9IG51bGw7XG4gICAgfVxuICAgIHJlc3VsdC5ocmVmID0gcmVzdWx0LmZvcm1hdCgpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvLyBpZiBhIHVybCBFTkRzIGluIC4gb3IgLi4sIHRoZW4gaXQgbXVzdCBnZXQgYSB0cmFpbGluZyBzbGFzaC5cbiAgLy8gaG93ZXZlciwgaWYgaXQgZW5kcyBpbiBhbnl0aGluZyBlbHNlIG5vbi1zbGFzaHksXG4gIC8vIHRoZW4gaXQgbXVzdCBOT1QgZ2V0IGEgdHJhaWxpbmcgc2xhc2guXG4gIHZhciBsYXN0ID0gc3JjUGF0aC5zbGljZSgtMSlbMF07XG4gIHZhciBoYXNUcmFpbGluZ1NsYXNoID0gKFxuICAgICAgKHJlc3VsdC5ob3N0IHx8IHJlbGF0aXZlLmhvc3QgfHwgc3JjUGF0aC5sZW5ndGggPiAxKSAmJlxuICAgICAgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSB8fCBsYXN0ID09PSAnJyk7XG5cbiAgLy8gc3RyaXAgc2luZ2xlIGRvdHMsIHJlc29sdmUgZG91YmxlIGRvdHMgdG8gcGFyZW50IGRpclxuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gc3JjUGF0aC5sZW5ndGg7IGkgPj0gMDsgaS0tKSB7XG4gICAgbGFzdCA9IHNyY1BhdGhbaV07XG4gICAgaWYgKGxhc3QgPT09ICcuJykge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBzcmNQYXRoLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgc3JjUGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cC0tO1xuICAgIH1cbiAgfVxuXG4gIC8vIGlmIHRoZSBwYXRoIGlzIGFsbG93ZWQgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIHJlc3RvcmUgbGVhZGluZyAuLnNcbiAgaWYgKCFtdXN0RW5kQWJzICYmICFyZW1vdmVBbGxEb3RzKSB7XG4gICAgZm9yICg7IHVwLS07IHVwKSB7XG4gICAgICBzcmNQYXRoLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgc3JjUGF0aFswXSAhPT0gJycgJiZcbiAgICAgICghc3JjUGF0aFswXSB8fCBzcmNQYXRoWzBdLmNoYXJBdCgwKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgudW5zaGlmdCgnJyk7XG4gIH1cblxuICBpZiAoaGFzVHJhaWxpbmdTbGFzaCAmJiAoc3JjUGF0aC5qb2luKCcvJykuc3Vic3RyKC0xKSAhPT0gJy8nKSkge1xuICAgIHNyY1BhdGgucHVzaCgnJyk7XG4gIH1cblxuICB2YXIgaXNBYnNvbHV0ZSA9IHNyY1BhdGhbMF0gPT09ICcnIHx8XG4gICAgICAoc3JjUGF0aFswXSAmJiBzcmNQYXRoWzBdLmNoYXJBdCgwKSA9PT0gJy8nKTtcblxuICAvLyBwdXQgdGhlIGhvc3QgYmFja1xuICBpZiAocHN5Y2hvdGljKSB7XG4gICAgcmVzdWx0Lmhvc3RuYW1lID0gcmVzdWx0Lmhvc3QgPSBpc0Fic29sdXRlID8gJycgOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc3JjUGF0aC5sZW5ndGggPyBzcmNQYXRoLnNoaWZ0KCkgOiAnJztcbiAgICAvL29jY2F0aW9uYWx5IHRoZSBhdXRoIGNhbiBnZXQgc3R1Y2sgb25seSBpbiBob3N0XG4gICAgLy90aGlzIGVzcGVjaWFsbHkgaGFwcGVucyBpbiBjYXNlcyBsaWtlXG4gICAgLy91cmwucmVzb2x2ZU9iamVjdCgnbWFpbHRvOmxvY2FsMUBkb21haW4xJywgJ2xvY2FsMkBkb21haW4yJylcbiAgICB2YXIgYXV0aEluSG9zdCA9IHJlc3VsdC5ob3N0ICYmIHJlc3VsdC5ob3N0LmluZGV4T2YoJ0AnKSA+IDAgP1xuICAgICAgICAgICAgICAgICAgICAgcmVzdWx0Lmhvc3Quc3BsaXQoJ0AnKSA6IGZhbHNlO1xuICAgIGlmIChhdXRoSW5Ib3N0KSB7XG4gICAgICByZXN1bHQuYXV0aCA9IGF1dGhJbkhvc3Quc2hpZnQoKTtcbiAgICAgIHJlc3VsdC5ob3N0ID0gcmVzdWx0Lmhvc3RuYW1lID0gYXV0aEluSG9zdC5zaGlmdCgpO1xuICAgIH1cbiAgfVxuXG4gIG11c3RFbmRBYnMgPSBtdXN0RW5kQWJzIHx8IChyZXN1bHQuaG9zdCAmJiBzcmNQYXRoLmxlbmd0aCk7XG5cbiAgaWYgKG11c3RFbmRBYnMgJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBzcmNQYXRoLnVuc2hpZnQoJycpO1xuICB9XG5cbiAgaWYgKCFzcmNQYXRoLmxlbmd0aCkge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IG51bGw7XG4gICAgcmVzdWx0LnBhdGggPSBudWxsO1xuICB9IGVsc2Uge1xuICAgIHJlc3VsdC5wYXRobmFtZSA9IHNyY1BhdGguam9pbignLycpO1xuICB9XG5cbiAgLy90byBzdXBwb3J0IHJlcXVlc3QuaHR0cFxuICBpZiAoIXV0aWwuaXNOdWxsKHJlc3VsdC5wYXRobmFtZSkgfHwgIXV0aWwuaXNOdWxsKHJlc3VsdC5zZWFyY2gpKSB7XG4gICAgcmVzdWx0LnBhdGggPSAocmVzdWx0LnBhdGhuYW1lID8gcmVzdWx0LnBhdGhuYW1lIDogJycpICtcbiAgICAgICAgICAgICAgICAgIChyZXN1bHQuc2VhcmNoID8gcmVzdWx0LnNlYXJjaCA6ICcnKTtcbiAgfVxuICByZXN1bHQuYXV0aCA9IHJlbGF0aXZlLmF1dGggfHwgcmVzdWx0LmF1dGg7XG4gIHJlc3VsdC5zbGFzaGVzID0gcmVzdWx0LnNsYXNoZXMgfHwgcmVsYXRpdmUuc2xhc2hlcztcbiAgcmVzdWx0LmhyZWYgPSByZXN1bHQuZm9ybWF0KCk7XG4gIHJldHVybiByZXN1bHQ7XG59O1xuXG5VcmwucHJvdG90eXBlLnBhcnNlSG9zdCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgaG9zdCA9IHRoaXMuaG9zdDtcbiAgdmFyIHBvcnQgPSBwb3J0UGF0dGVybi5leGVjKGhvc3QpO1xuICBpZiAocG9ydCkge1xuICAgIHBvcnQgPSBwb3J0WzBdO1xuICAgIGlmIChwb3J0ICE9PSAnOicpIHtcbiAgICAgIHRoaXMucG9ydCA9IHBvcnQuc3Vic3RyKDEpO1xuICAgIH1cbiAgICBob3N0ID0gaG9zdC5zdWJzdHIoMCwgaG9zdC5sZW5ndGggLSBwb3J0Lmxlbmd0aCk7XG4gIH1cbiAgaWYgKGhvc3QpIHRoaXMuaG9zdG5hbWUgPSBob3N0O1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIGlzU3RyaW5nOiBmdW5jdGlvbihhcmcpIHtcbiAgICByZXR1cm4gdHlwZW9mKGFyZykgPT09ICdzdHJpbmcnO1xuICB9LFxuICBpc09iamVjdDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIHR5cGVvZihhcmcpID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XG4gIH0sXG4gIGlzTnVsbDogZnVuY3Rpb24oYXJnKSB7XG4gICAgcmV0dXJuIGFyZyA9PT0gbnVsbDtcbiAgfSxcbiAgaXNOdWxsT3JVbmRlZmluZWQ6IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiBhcmcgPT0gbnVsbDtcbiAgfVxufTtcbiIsIlxuLyoqXG4gKiBNb2R1bGUgZXhwb3J0cy5cbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGRlcHJlY2F0ZTtcblxuLyoqXG4gKiBNYXJrIHRoYXQgYSBtZXRob2Qgc2hvdWxkIG5vdCBiZSB1c2VkLlxuICogUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLm5vRGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gaXQgaXMgYSBuby1vcC5cbiAqXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcbiAqIHdpbGwgdGhyb3cgYW4gRXJyb3Igd2hlbiBpbnZva2VkLlxuICpcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xuICogd2lsbCBpbnZva2UgYGNvbnNvbGUudHJhY2UoKWAgaW5zdGVhZCBvZiBgY29uc29sZS5lcnJvcigpYC5cbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcbiAqIEBwYXJhbSB7U3RyaW5nfSBtc2cgLSB0aGUgc3RyaW5nIHRvIHByaW50IHRvIHRoZSBjb25zb2xlIHdoZW4gYGZuYCBpcyBpbnZva2VkXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259IGEgbmV3IFwiZGVwcmVjYXRlZFwiIHZlcnNpb24gb2YgYGZuYFxuICogQGFwaSBwdWJsaWNcbiAqL1xuXG5mdW5jdGlvbiBkZXByZWNhdGUgKGZuLCBtc2cpIHtcbiAgaWYgKGNvbmZpZygnbm9EZXByZWNhdGlvbicpKSB7XG4gICAgcmV0dXJuIGZuO1xuICB9XG5cbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xuICAgIGlmICghd2FybmVkKSB7XG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICB9IGVsc2UgaWYgKGNvbmZpZygndHJhY2VEZXByZWNhdGlvbicpKSB7XG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnNvbGUud2Fybihtc2cpO1xuICAgICAgfVxuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH1cblxuICByZXR1cm4gZGVwcmVjYXRlZDtcbn1cblxuLyoqXG4gKiBDaGVja3MgYGxvY2FsU3RvcmFnZWAgZm9yIGJvb2xlYW4gdmFsdWVzIGZvciB0aGUgZ2l2ZW4gYG5hbWVgLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGNvbmZpZyAobmFtZSkge1xuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xuICB0cnkge1xuICAgIGlmICghZ2xvYmFsLmxvY2FsU3RvcmFnZSkgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xuICBpZiAobnVsbCA9PSB2YWwpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIFN0cmluZyh2YWwpLnRvTG93ZXJDYXNlKCkgPT09ICd0cnVlJztcbn1cbiJdfQ==
